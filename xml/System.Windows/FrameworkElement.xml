<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6f367ce94e6ad246e96bdd6eeaf93ae159acc517" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52609002" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Satz von Eigenschaften, Ereignissen und Methoden für Elemente auf WPF-Frameworkebene (Windows Presentation Foundation) bereit. Diese Klasse stellt die bereitgestellte Implementierung auf WPF-Frameworkebene dar, die auf den WPF-Kernebenen-APIs basiert, die durch <see cref="T:System.Windows.UIElement" /> definiert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> der verbundene Punkt zwischen WPF-Frameworkebene-Element-Klassen und der WPF-Kernebenen-Satz ist <xref:System.Windows.UIElement> Präsentationsdiensten. Weitere Informationen zu diesen Konzepten finden Sie unter [WPF-Architektur](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> Erweitert <xref:System.Windows.UIElement> und fügt die folgenden Funktionen:  
  
-   **Layout Systemdefinition**: <xref:System.Windows.FrameworkElement> WPF-Frameworkebene Implementierungen für bestimmte stellt Methoden bereit, die als virtuelle Member in definiert wurden <xref:System.Windows.UIElement>. Insbesondere <xref:System.Windows.FrameworkElement> versiegelt bestimmte WPF-Kernebenen-Layout-Außerkraftsetzungen, und stattdessen bieten Sie eine WPF-Frameworkebene-Entsprechung, die abgeleitete Klassen sollten stattdessen überschreiben. Z. B. <xref:System.Windows.FrameworkElement> Siegel <xref:System.Windows.UIElement.ArrangeCore%2A> bietet jedoch <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Diese Änderungen widerzuspiegeln, die Tatsache, dass auf die WPF-Frameworkebene besteht ein vollständiges Layout-System, das alle rendern kann <xref:System.Windows.FrameworkElement> abgeleitete Klasse. Auf der WPF-core-Ebene, bestimmte Elemente, die eine allgemeine Struktur werden [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] basierend Layout-Lösung vorhanden sind, aber die tatsächlichen-Engine des Layoutsystems ist nicht definiert. Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Die logische Struktur:** den allgemeinen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Programmiermodell wird häufig eine Struktur von Elementen ausgedrückt. Unterstützung für die Struktur von Elementen als logische Struktur Ausdrücken und zugehörige Unterstützung für die Definition der Struktur im Markup implementiert ist die <xref:System.Windows.FrameworkElement> Ebene. Beachten Sie jedoch, dass <xref:System.Windows.FrameworkElement> absichtlich ein Inhaltsmodell nicht definieren, und verlässt diese Verantwortung für abgeleitete Klassen. Weitere Informationen finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Objektlebensdauer-Ereignisse:** häufig ist es hilfreich zu wissen, wann ein Element initialisiert wird (der Konstruktor aufgerufen wird) oder wenn das Element zuerst in einer logischen Struktur geladen wird. <xref:System.Windows.FrameworkElement> definiert mehrere Ereignisse im Zusammenhang mit der Objektlebensdauer, die nützliche Hooks für Code-Behind-Vorgänge, die Elemente bereitstellen, z. B. das Hinzufügen von untergeordneten Elementen enthalten. Weitere Informationen finden Sie unter [Objektlebensdauer-Ereignisse](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Unterstützung für Datenbindung und dynamische Ressourcenverweise:** wird die auf Eigenschaftenebene-Unterstützung für die Datenbindung und Ressourcen von implementiert die <xref:System.Windows.DependencyProperty> Klasse und das Eigenschaftensystem, aber die Möglichkeit, einen Mitgliedswert aufzulösen, die vorliegen gespeichert als eine <xref:System.Windows.Expression> (die Programmierungskonstrukt, die sowohl die Datenbindung und dynamische Ressourcen zugrunde liegen) wird implementiert, indem <xref:System.Windows.FrameworkElement>. Weitere Informationen finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md) und [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Stile:** <xref:System.Windows.FrameworkElement> definiert die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Allerdings <xref:System.Windows.FrameworkElement> noch nicht definieren, Unterstützung für Vorlagen oder Decorator-Elemente zu unterstützen. Diese Features werden von Steuerelementklassen eingeführt, z. B. <xref:System.Windows.Controls.Control> und <xref:System.Windows.Controls.ContentControl>.  
  
-   **Weitere Unterstützung für Animationen:** Unterstützung für Animationen wurde bereits definiert, unter der WPF-Kernebene, aber <xref:System.Windows.FrameworkElement> erweitert diese durch die Implementierung <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> und verwandte Elemente.  
  
 Wie aus der Hierarchie von Klassen, angezeigt werden viele [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Klassen leiten sich von <xref:System.Windows.FrameworkElement>, entweder direkt oder über fortgeschrittene Basisklassen wie z. B. <xref:System.Windows.Controls.Panel> oder <xref:System.Windows.Controls.Control>.  
  
 Wenn Sie beabsichtigen, verwenden Sie <xref:System.Windows.FrameworkElement> als Basisklasse verwendet, Sie möchten zunächst die vorhandenen abgeleiteten Klassen zu untersuchen. <xref:System.Windows.FrameworkElement> bietet Unterstützung für eine Reihe von grundlegenden Szenarien, entbehrt aber auch eine Reihe von Funktionen, die für ein "Element" im Sinne eines Bausteins, die Sie zum Erstellen von wünschenswert sind [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Z. B. eine <xref:System.Windows.FrameworkElement> Inhaltsmodell; nicht definiert <xref:System.Windows.FrameworkElement> eine Basisklasse nicht erstellen kann eine Eigenschaft definieren [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] untergeordnete Elemente. Insbesondere sollten Sie betrachten <xref:System.Windows.Controls.Control> und <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElement" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gerenderte Höhe dieses Elements ab.</summary>
        <value>Die Höhe des Elements als Wert in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein berechneter Wert, der auf anderen größeneingaben und dem Layoutsystem basiert. Der Wert wird vom Layoutsystem selbst, basierend auf einem tatsächlichen Renderingdurchlauf, festgelegt und kann aus diesem Grund lag etwas hinter den festgelegten Wert der Eigenschaften, z. B. <xref:System.Windows.FrameworkElement.Height%2A> , die die Grundlage der eingabeänderung sind.  
  
 Da <xref:System.Windows.FrameworkElement.ActualHeight%2A> wird ein berechneter Wert sollten Sie bedenken, dass möglicherweise mehrere oder inkrementelle gemeldete Änderungen an es aufgrund verschiedener Vorgänge des Layoutsystems. Das Layoutsystem berechnet möglicherweise den Bereich für untergeordnete Elemente, Einschränkungen durch übergeordnete Elemente usw.  
  
 Obwohl Sie diese Eigenschaft festlegen, können nicht [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], Grundlage können Sie eine <xref:System.Windows.Trigger> auf dessen Wert in einem Stil.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt verschiedene Height-Eigenschaften.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ActualHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gerenderte Breite dieses Elements ab.</summary>
        <value>Die Breite des Elements als Wert in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein berechneter Wert, der auf der Grundlage anderer Breiteneingaben und das Layoutsystem. Der Wert wird vom Layoutsystem selbst, basierend auf einem tatsächlichen Renderingdurchlauf, festgelegt und kann aus diesem Grund lag etwas hinter den festgelegten Wert der Eigenschaften, z. B. <xref:System.Windows.FrameworkElement.Width%2A> , die die Grundlage der eingabeänderung sind.  
  
 Da <xref:System.Windows.FrameworkElement.ActualWidth%2A> wird ein berechneter Wert sollten Sie bedenken, dass möglicherweise mehrere oder inkrementelle gemeldete Änderungen an es aufgrund verschiedener Vorgänge des Layoutsystems. Das Layoutsystem berechnet möglicherweise den Bereich für untergeordnete Elemente, Einschränkungen durch übergeordnete Elemente usw.  
  
 Obwohl Sie diese Eigenschaft festlegen, können nicht [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], Grundlage können Sie eine <xref:System.Windows.Trigger> auf dessen Wert in einem Stil.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt verschiedene Width-Eigenschaften.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ActualWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das hinzuzufügende untergeordnete Element.</param>
        <summary>Fügt der logischen Struktur dieses Elements das bereitgestellte Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode für die Implementierung von Sammlungen für Objekte, die logischen untergeordneten Elemente eines Elements darstellen. Sammlung von Wartungstasks für die Auflistungen von untergeordneten Element kann in der Eigenschaftengetter oder Setter, Klassenbehandlung Changed-Ereignisse, Konstruktoren, oder in den Auflistungstypen selbst durchgeführt werden.  
  
 Für Autoren von Steuerelementen bearbeiten die logische Struktur auf dieser Ebene nicht die empfohlene Vorgehensweise besteht, sofern keiner der Inhaltsmodelle für verfügbare basissteuerklassen für Ihr Steuerelementszenario geeignet ist. Betrachten Sie Unterklassen auf der Ebene der <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, und <xref:System.Windows.Controls.HeaderedItemsControl>. Diese Klassen bieten ein Inhaltsmodell mit bestimmten Erzwingung der untergeordneten Elemente der logischen Struktur über dedizierte [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], sowie Unterstützung für andere Funktionen, die in der Regel erwünscht, in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelement wie die Formatierung mithilfe von Vorlagen. Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkElement.LogicalChildren%2A> und <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> eine Ausnahme kann ausgelöst werden, wenn zu einem Zeitpunkt erfolgt, wenn die logische Struktur von einem anderen Prozess durchlaufen wird.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert eine `Child` Eigenschaft in einem benutzerdefinierten <xref:System.Windows.FrameworkElement> , die eine eigene Implementierung der visuellen Ebene ist. Der Eigenschaftensetter ist so konzipiert, dass der alte Wert aus der logischen Struktur als auch eine visuelle Sammlung von mandantenklassen geltenden schemaanpassungen, wenn der Wert ändert entfernt wird. Der Eigenschaftswert wird zwischengespeichert, und der neue Wert wird dann sowohl die logische Struktur und die benutzerdefinierte visuelle Sammlung hinzugefügt.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt bei Bedarf die visuelle Struktur der aktuellen Vorlage und gibt einen Wert zurück, der angibt, ob die visuelle Struktur durch diesen Aufruf neu erstellt wurde.</summary>
        <returns>
          <see langword="true" />, wenn der Struktur visuelle Elemente hinzugefügt wurden, andernfalls wird <see langword="false" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen können diese Methode, um sicherzustellen, dass die visuelle Struktur eines Elements abgeschlossen ist, aufrufen. Dieser Schritt ist möglicherweise erforderlich, wenn der Code überprüft werden, die untergeordneten Elemente in der Struktur wird. Für typische Element Logik in Anwendungen, Aufrufen von <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> ist nicht erforderlich, da die Vorlagen für Elemente an einer geeigneten Stelle in ihrer Lebensdauer automatisch angewendet werden.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> wird aufgerufen, für jedes Measure durch das Layoutsystem von WPF-Frameworkebene übergeben.  
  
 <xref:System.Windows.FrameworkElement> abgeleitete Klassen können die <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> Klassenhandler der Fälle, in diese Methode explizit aufgerufen wurde, oder durch das Layoutsystem benachrichtigt werden. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> wird aufgerufen, nachdem die Vorlage vollständig generiert und an der logischen Struktur angefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Implementiert <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (in <see cref="T:System.Windows.UIElement" /> als virtuell definiert) und versiegelt die Implementierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist versiegelt. Um die Logik in benutzerdefinierten Element für die Anordnungsübergabe des Elementlayouts, außer Kraft setzen Ihre <xref:System.Windows.FrameworkElement> abgeleiteten Klasse außer Kraft setzen muss <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Positioniert beim Überschreiben in einer abgeleiteten Klasse die untergeordneten Elemente und bestimmt eine Größe für eine von <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse.</summary>
        <returns>Die tatsächlich verwendete Größe.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Autoren von Steuerelementen, die auf die Anordnungsübergabe des Layouts Verarbeitung anpassen möchten, sollten diese Methode überschreiben. Das Implementierungsmuster sollte Aufrufen <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> auf jede sichtbare untergeordnete Element, und übergeben Sie die endgültige gewünschte Größe für jedes untergeordnete Element als das <paramref name="finalRect" /> Parameter. Übergeordnete Elemente rufen sollten <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> für jedes untergeordnete Element ist, andernfalls die untergeordneten Elemente nicht gerendert werden.  
  
Viele abgeleitete Klassen bieten Implementierungen dieser Methode. Dazu zählen: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> und <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Initialisierungsprozess für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode für einzelne Elemente aufrufen, wenn Sie diese auf Weise anpassen, die noch nicht verfügbar zu machen oder verbinden das Element mit einer Elementstruktur. Beispielsweise Sie möglicherweise haben erstellt ein neues <xref:System.Windows.FrameworkElement>, haben, dürfen Sie es noch nicht an eine logische Struktur angefügt haben. Oder die logische Struktur, in dem das Element ein untergeordnetes Element darin ist, möglicherweise nicht in einem Fenster oder einer Seite der Anwendung verbunden werden.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Implementieren Sie diese Methode, um eine sonderverarbeitung bereitzustellen, die erfolgen soll, bevor das Element bei der das Element mit dem Prozess des Ladens initialisiert wird.  
  
Die Implementierung sollte die basisimplementierung wird aufrufen, weil die Basis (Standard)-Implementierung einige interne Kennzeichen zum Nachverfolgen Initialisierung festgelegt werden. Eine mögliche Implementierung ist die Verwendung dieser Methode als Hook in Ihren eigenen Initialisierungsroutinen private Klasse, die noch nicht von Konstruktoren aktiviert sind.  
  
Die grundlegende Implementierung wird eine Ausnahme ausgelöst, wenn <see cref="M:System.Windows.FrameworkElement.BeginInit" /> wird aufgerufen, mehr als einmal auf dem selben Element vor dem <see cref="M:System.Windows.FrameworkElement.EndInit" /> aufgerufen wird.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufigste Animations-Szenarios verwenden Sie diese Methode nicht. Normalerweise erstellen Sie die <xref:System.Windows.Media.Animation.Storyboard> oder <xref:System.Windows.Media.Animation.BeginStoryboard> platzieren Sie diese als Element im Markup, und klicken Sie dann Sie die <xref:System.Windows.EventTrigger> Inhalt für ein Element. Wenn das Ereignis ausgelöst wird, wird die Animation dann ausgeführt. Die meisten der die Kontrolle einiger Aspekte einer <xref:System.Windows.Media.Animation.Storyboard> gelöst werden, indem die Eigenschaften, die im Markup verfügbar gemacht werden.  
  
 Für die Signaturen, die keine verwenden die `isControllable`, Parameter, oder wenn dieser Parameter angegeben wird `false`, Uhren auf der Zeitachse, die die Animation zugeordnet sind werden entfernt, sobald die Animation den "Fill"-Zeitraum erreicht. Aus diesem Grund kann nicht die Animation neu gestartet werden, nachdem Sie einmal ausgeführt. Steuern einer Animation erfordert auch, dass das Storyboard haben eine [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) oder darauf verweisen im Code zugreifen können.  
  
   
  
## Examples  
 Das folgende Beispiel ruft eine <xref:System.Windows.Media.Animation.Storyboard> aus Ressourcen, und klicken Sie dann ausgeführt wird, <xref:System.Windows.Media.Animation.Storyboard> Wenn ist ein internes Ereignis Klasse behandelt.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <param name="handoffBehavior">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist. Dabei sind Optionen angegeben, welche Aktion ausgeführt werden soll, wenn die Eigenschaft bereits animiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufigste Animations-Szenarios verwenden Sie diese Methode nicht. Normalerweise erstellen Sie die <xref:System.Windows.Media.Animation.Storyboard> oder <xref:System.Windows.Media.Animation.BeginStoryboard> platzieren Sie diese als Element im Markup, und klicken Sie dann Sie die <xref:System.Windows.EventTrigger> Inhalt für ein Element. Wenn das Ereignis ausgelöst wird, wird die Animation dann ausgeführt. Die meisten der die Kontrolle einiger Aspekte einer <xref:System.Windows.Media.Animation.Storyboard> gelöst werden, indem die Eigenschaften, die im Markup verfügbar gemacht werden.  
  
 Für die Signaturen, die keine verwenden die `isControllable`, Parameter, oder wenn dieser Parameter angegeben wird `false`, Uhren auf der Zeitachse, die die Animation zugeordnet sind werden entfernt, sobald die Animation den "Fill"-Zeitraum erreicht. Aus diesem Grund kann nicht die Animation neu gestartet werden, nachdem Sie einmal ausgeführt. Steuern einer Animation erfordert auch, dass das Storyboard haben eine [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) oder darauf verweisen im Code zugreifen können.  
  
 Übergabeverhalten kann angegeben werden, als ein Attribut des <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, ist das Zeitsteuerungssystem die Uhren nicht automatisch entfernt werden.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht ausgelöst, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel ruft eine <xref:System.Windows.Media.Animation.Storyboard> aus Ressourcen, und klicken Sie dann ausgeführt wird, <xref:System.Windows.Media.Animation.Storyboard> Wenn ist ein internes Ereignis Klasse behandelt.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <param name="handoffBehavior">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (angehalten werden kann), nachdem sie gestartet wurde.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist, im angegebenen Zustand für das Steuerelement der Animation nach deren Start.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufigste Animations-Szenarios verwenden Sie diese Methode nicht. Normalerweise erstellen Sie die <xref:System.Windows.Media.Animation.Storyboard> oder <xref:System.Windows.Media.Animation.BeginStoryboard> platzieren Sie diese als Element im Markup, und klicken Sie dann Sie die <xref:System.Windows.EventTrigger> Inhalt für ein Element. Wenn das Ereignis ausgelöst wird, wird die Animation dann ausgeführt. Die meisten der die Kontrolle einiger Aspekte einer <xref:System.Windows.Media.Animation.Storyboard> gelöst werden, indem die Eigenschaften, die im Markup verfügbar gemacht werden.  
  
 Für die Signaturen, die keine verwenden die `isControllable`, Parameter, oder wenn dieser Parameter angegeben wird `false`, Uhren auf der Zeitachse, die die Animation zugeordnet sind werden entfernt, sobald die Animation den "Fill"-Zeitraum erreicht. Aus diesem Grund kann nicht die Animation neu gestartet werden, nachdem Sie einmal ausgeführt. Steuern einer Animation erfordert auch, dass das Storyboard haben eine [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) oder darauf verweisen im Code zugreifen können.  
  
 Übergabeverhalten kann angegeben werden, als ein Attribut des <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, ist das Zeitsteuerungssystem die Uhren nicht automatisch entfernt werden.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht ausgelöst, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" /> ab oder legt diese fest.</summary>
        <value>Die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Data.BindingGroup> zum Überprüfen der Werte aus mehreren Eigenschaften eines Objekts verwendet werden können. Nehmen wir beispielsweise an, dass eine Anwendung den Benutzer fordert auf eine Adresse eingeben, und dann ein Objekt des Typs füllt `Address`, die über Eigenschaften verfügt `Street`, `City`, `ZipCode`, und `Country`, mit den Werten, die der Benutzer bereitgestellt. Die Anwendung verfügt über einen Bereich, das vier <xref:System.Windows.Controls.TextBox> Steuerelemente, von denen jede auf eine der Eigenschaften des Objekts gebunden ist. Können Sie eine <xref:System.Windows.Controls.ValidationRule> in einem <xref:System.Windows.Data.BindingGroup> zum Überprüfen der `Address` Objekt. Z. B. die <xref:System.Windows.Controls.ValidationRule> können sicherstellen, dass die Postleitzahl für das Land der Adresse gültig ist.  
  
 Untergeordnete Elemente erben die <xref:System.Windows.Data.BindingGroup> von ihren übergeordneten Elementen, genauso wie bei jedem anderen vererbbare Eigenschaft.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Metadaten-Eigenschaften festgelegt, um **"true"**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Die folgenden Beispiele sind Teil einer Anwendung, die überprüft, ob der Benutzer die Eigenschaften von zwei Objekten, auf die gleichen Werte festgelegt hat. Im erste Beispiel erstellt zwei <xref:System.Windows.Controls.TextBox> Steuerelemente, von denen jeder die an eine andere Datenquelle gebunden ist. Die <xref:System.Windows.Controls.StackPanel> verfügt über eine <xref:System.Windows.Data.BindingGroup> , enthält eine <xref:System.Windows.Controls.ValidationRule> , die überprüft, dass die beiden Zeichenfolgen gleich sind.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 Das folgende Beispiel zeigt die <xref:System.Windows.Controls.ValidationRule> , die im vorherigen Beispiel verwendet.  In der <xref:System.Windows.Controls.ValidationRule.Validate%2A> methodenüberschreibung, im Beispiel wird jede Quellobjekts, aus der <xref:System.Windows.Data.BindingGroup> und überprüft, ob die Eigenschaften der Objekte gleich sind.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Zum Aufrufen der <xref:System.Windows.Controls.ValidationRule>, rufen Sie die <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> Methode.  Im folgenden Beispiel wird <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> tritt das Click-Ereignis der Schaltfläche.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.BindingGroup" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Aufrufen dieser Methode, die Sie Heraufstufen einer <xref:System.Windows.FrameworkElement.RequestBringIntoView> -Ereignis, das aus dem aktuellen Element stammt. Dieses Ereignis wird ausgelöst, damit sie vom verarbeitet werden, kann eine <xref:System.Windows.Controls.ScrollViewer>, oder einen abgeleiteten oder ähnlichen-Klasse. Das erwartete Verhalten ist, dass das Ereignis wird vom übergeordneten Element, als in den Ereignisdaten behandelt markiert wurden verarbeitet, und die Quelle des Ereignisses in der Ansicht, über die Logik in eingebetteten geschaltet ist die <xref:System.Windows.Controls.ScrollViewer> Steuerelement. Weder die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis noch die <xref:System.Windows.FrameworkElement.BringIntoView%2A> Methode übertragen Informationen über Erfolg oder Fehler, außer, die sich das Ereignis in der Regel ist gekennzeichnet auf behandelt Success. Grund für Fehler bei die Element-Einstellungen, wie enthalten das <xref:System.Windows.UIElement.Visibility%2A> wird von einem Wert außer <xref:System.Windows.Visibility.Visible>.  
  
 Wenn Sie die Signatur verwenden, der keiner `targetRectangle`, klicken Sie dann die gesamte Elementgröße (die <xref:System.Windows.UIElement.RenderSize%2A>) sichtbar gemacht.  
  
 Durch diese Methode aufrufen, rufen Sie möglicherweise <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für alle übergeordneten bildlauffähigen Bereiche, die das Element enthält. Wenn dieses Element nicht in einem bildlauffähigen Bereich enthalten ist das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis trotzdem ausgelöst, aber es sind davon nicht betroffen, da keine Ereignislistener vorhanden sind.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler für ein Ereignis zu Anwendungsfehler Navigation, die reagiert, wenn die [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] ein Fragment enthält, zu dem navigiert. Das Fragment ist mit dem Namen in der [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] nach dem Nummernzeichen (#), und das implementierte Verhalten bewirkt, dass das Element, das innerhalb des Rahmens Bildlauf. <xref:System.Windows.FrameworkElement.BringIntoView%2A> und <xref:System.Windows.FrameworkElement.RequestBringIntoView> anfordern, Scrollverhalten im Beispiel.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Die angegebene Größe des anzuzeigenden Elements.</param>
        <summary>Versucht, die bereitgestellte Bereichsgröße dieses Elements in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Aufrufen dieser Methode, die Sie Heraufstufen einer <xref:System.Windows.FrameworkElement.RequestBringIntoView> -Ereignis, das aus dem aktuellen Element stammt. Dieses Ereignis wird ausgelöst, damit sie vom verarbeitet werden, kann eine <xref:System.Windows.Controls.ScrollViewer>, oder einen abgeleiteten oder ähnlichen-Klasse. Das erwartete Verhalten ist, dass das Ereignis wird vom übergeordneten Element, als in den Ereignisdaten behandelt markiert wurden verarbeitet, und die Quelle des Ereignisses in der Ansicht, über die Logik in eingebetteten geschaltet ist die <xref:System.Windows.Controls.ScrollViewer> Steuerelement. Weder die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis noch die <xref:System.Windows.FrameworkElement.BringIntoView%2A> Methode übertragen Informationen über Erfolg oder Fehler, außer, die sich das Ereignis in der Regel ist gekennzeichnet auf behandelt Success. Grund für Fehler bei die Element-Einstellungen, wie enthalten das <xref:System.Windows.UIElement.Visibility%2A> wird von einem Wert außer <xref:System.Windows.Visibility.Visible>.  
  
 Wenn Sie die Signatur verwenden, der keiner `targetRectangle`, klicken Sie dann die gesamte Elementgröße (die <xref:System.Windows.UIElement.RenderSize%2A>) sichtbar gemacht.  
  
 Durch diese Methode aufrufen, rufen Sie möglicherweise <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für alle übergeordneten bildlauffähigen Bereiche, die das Element enthält. Wenn dieses Element nicht in einem bildlauffähigen Bereich enthalten ist das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis trotzdem ausgelöst, aber es sind davon nicht betroffen, da keine Ereignislistener vorhanden sind.  
  
   
  
## Examples  
 Das folgende Beispiel enthält eine große Grafik in einem eingeschränkten Bildlaufbereich. Eine Schaltfläche auf der Seite verfügt über einen Handler, der die Ansicht auf einen bestimmten Bereich der große Grafik verschiebt.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Kontextmenüelement ab bzw. legt das Kontextmenüelement fest, das angezeigt wird, wenn das Kontextmenü über die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aus diesem Element angefordert wird.</summary>
        <value>Das Kontextmenü, das diesem Element zugewiesen ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> selbst ist ein <xref:System.Windows.FrameworkElement> abgeleitete Klasse, und es ist technisch möglich, dass <xref:System.Windows.Controls.ContextMenu> selbst haben ein <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft. Allerdings ein verwirrendes Kontextmenü für den Benutzer erstellt, und dies wird nicht empfohlen.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar vor dem Schließen eines Kontextmenüs für ein Element auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um schließende unterdrücken sollte Kontextmenüs, Handler des Ereignisses es als behandelt markieren.  
  
 Verwenden Sie dieses Ereignis als ein <xref:System.Windows.EventTrigger> in einem Stil, müssen Sie auf den zugrunde liegenden Dienst Definition des Ereignisses verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Diese Verwendung ist erforderlich, da die Implementierung von Ereignissen auf <xref:System.Windows.FrameworkElement> , macht das zugrunde liegende Dienstereignis keine Zuordnung für ist die <xref:System.Windows.FrameworkElement.ContextMenuClosing> Bezeichner so, dass Sie es als Trigger verwenden können).  
  
 <xref:System.Windows.Controls.ContextMenu> selbst ist ein <xref:System.Windows.FrameworkElement> abgeleitete Klasse sein, aber die <xref:System.Windows.FrameworkElement.ContextMenuClosing> Ereignis wird nicht direkt durch ein Kontextmenü ausgelöst. Stattdessen wird das Ereignis aus dem Element ausgelöst, die "besitzt" das Kontextmenü als eine Eigenschaft und wird nur ausgelöst, wenn ein Benutzer versucht, um ein Kontextmenü in der Benutzeroberfläche zu schließen. Jedoch ist es möglich, dass <xref:System.Windows.Controls.ContextMenu> selbst haben ein <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft (ein geschachteltes Kontextmenü). In diesem Fall die <xref:System.Windows.Controls.ContextMenu> wirklich besitzt der geschachtelten <xref:System.Windows.Controls.ContextMenu> und kann das Ereignis, mit der Quelle des Ereignisses wird das Kontextmenü für die geschachtelte auslösen.  
  
 Die <xref:System.Windows.Controls.ContextMenu> Klasse selbst verfügt auch über ein ähnliches Ereignis (<xref:System.Windows.Controls.ContextMenu.Closed>) jedoch <xref:System.Windows.Controls.ContextMenu.Closed> Ereignis zeigt Ihnen die Möglichkeit zum Abbruch der Benutzeraktion.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Außer Kraft setzen <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Kontextmenü des Elements geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum manuellen Öffnen des Kontextmenüs sollte die Handler für die Ereignisse das relevante Ereignis als behandelt markieren. Andernfalls den vorhandenen Wert von der <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft wird verwendet, um automatisch ein Kontextmenü geöffnet. Das Ereignis als behandelt markiert wird effektiv die Default-Aktion abgebrochen, und könnte eine Möglichkeit, den Wert eines Zurücksetzen der <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft und öffnen Sie dann auf die neue <xref:System.Windows.Controls.ContextMenu>. Es ist jedoch ein Problem der zeitlichen Steuerung, die Sie kennen müssen. Um vollständig ersetzen Sie im Kontextmenü über eine <xref:System.Windows.FrameworkElement.ContextMenuOpening> Handler auf, das Kontextmenü für die erste darf nicht null oder leer sein. Alternativ müssen Sie das Ereignis zu behandeln, und klicken Sie dann manuell ein neues Kontextmenü geöffnet. Weitere Informationen finden Sie unter [wie: Behandeln des ContextMenuOpening-Ereignisses](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Verwenden Sie dieses Ereignis als ein <xref:System.Windows.EventTrigger> in einem Stil, müssen Sie auf das zugrunde liegende angefügte Ereignis verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Diese Verwendung ist erforderlich, da die Implementierung von Ereignissen auf <xref:System.Windows.FrameworkElement> , macht das zugrunde liegende Dienstereignis keine Zuordnung für ist die <xref:System.Windows.FrameworkElement.ContextMenuOpening> Bezeichner so, dass Sie ihn in Triggern verwenden können).  
  
 <xref:System.Windows.Controls.ContextMenu> selbst ist ein <xref:System.Windows.FrameworkElement> abgeleitete Klasse, aber dieses Ereignis wird nicht aus dem Kontextmenü geöffnet wird, als Quelle ausgelöst werden. Das Ereignis wird vom Element ausgelöst, die "besitzt" das Kontextmenü als eine Eigenschaft und wird nur ausgelöst, wenn ein Benutzer versucht, ein Kontextmenü geöffnet, in der Benutzeroberfläche. Es ist möglich, dass <xref:System.Windows.Controls.ContextMenu> selbst haben ein <xref:System.Windows.FrameworkElement.ContextMenu%2A> -Eigenschaft, aber Sie sollten dieses Szenario vermeiden (Weitere Informationen finden Sie unter <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 Die <xref:System.Windows.Controls.ContextMenu> Klasse selbst verfügt auch über ein ähnliches Ereignis (<xref:System.Windows.Controls.ContextMenu.Opened>) jedoch <xref:System.Windows.Controls.ContextMenu.Opened> zeigt Ihnen die Möglichkeit zum Abbruch der Benutzeraktion.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Außer Kraft setzen <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ContextMenu" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab bzw. legt den Cursor fest, der angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet.</summary>
        <value>Der anzuzeigende Cursor. Der Standardwert ist gemäß dieser Abhängigkeitseigenschaft als <see langword="null" /> definiert. Der zur Laufzeit angewendete Standardwert resultiert jedoch aus einer Vielzahl von Faktoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft festlegen, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], wird die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor abhängig typkonvertierung für die <xref:System.Windows.Input.Cursor> Klasse zum Auswerten der Zeichenfolge. Die bereitgestellte Zeichenfolge ergeben sollten eine <xref:System.Windows.Input.CursorType> Wert. Ausführliche Informationen finden Sie unter <xref:System.Windows.Input.Cursor>.  
  
 Ob der von dieser Eigenschaft festgelegte Cursor werden oder wird nicht angezeigt wird, wenn der Mauszeiger über diesem Element befindet ist auch abhängig von den Wert des der <xref:System.Windows.FrameworkElement.ForceCursor%2A> Eigenschaft. Darüber hinaus wirkt ereignisbezogene Faktoren wie z. B. ein aktives ziehen, die Erfassung von Mauseingaben, Textbearbeitung-Modi Steuerelemente und So weiter, den Cursor mit höherer Priorität als der Wert sich auch, die Sie in dieser Eigenschaft angeben.  
  
 Um das Verhalten der Einstellung dieser Eigenschaft auf den tatsächlichen Standardwert wiederherzustellen, legen Sie ihn auf `null` erneut aus.  
  
 Die `null` Standard wirklich bedeutet, dass Bestimmung der Wert der praktischen Cursor, hier verzögert wird und von einer anderen Stelle abgerufen werden sollen. Programmgesteuerte Werte aus beliebigen Quellen angezeigt, den Standardcursor, der ist visuell über eine [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Anwendung wird ein Pfeil. Ändert sich der vorübergehende Cursor sind jedoch nicht festgelegt, um die <xref:System.Windows.FrameworkElement.Cursor%2A> Werte der Elemente, wenn sie über übergeben werden. Die <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft wird nur Null-Werte in Fällen, in dem sie tatsächlich, z. B. durch Code oder einem Stil festgelegt wurde. Jede Bewegung der Maus über ein [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendung löst eine <xref:System.Windows.UIElement.QueryCursor> Ereignis. Das Ereignis weitergeleitet, und jedes Element entlang der Route hat die Möglichkeit zum Behandeln des Ereignisses und zum Festlegen des Werts, der den Cursor über die Argumente des Ereignisses. Dies ist der Mechanismus, der den sichtbaren Cursor in den meisten Fällen erzeugt. Wenn eine <xref:System.Windows.UIElement.QueryCursor> Handler gibt eine Cursorergebnis zurück, und klicken Sie dann die Tatsache, dass das Ereignis behandelt wird, und verfügt über einen geänderten Wert in den Argumenten hat Vorrang vor den Wert des der <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft auf jeder Ebene, es sei denn, <xref:System.Windows.FrameworkElement.ForceCursor%2A> festgelegt ist.  
  
 Wenn Sie keinen benutzerdefinierten Cursor erstellen, Sie in der Regel legen Sie diese Eigenschaft auf einen statischen Eigenschaft-Wert, der die <xref:System.Windows.Input.Cursors> Klasse. Festlegen von <xref:System.Windows.FrameworkElement.Cursor%2A> im Code erfordert eine der folgenden:  
  
-   Rufen Sie die <xref:System.Windows.Input.Cursor> Konstruktor zum Abrufen einer <xref:System.Windows.Input.Cursor> Instanz. Beide Signaturen der <xref:System.Windows.Input.Cursor> Konstruktor verwenden, Streams oder Dateien, in der Erwartung, die Sie erstellen die <xref:System.Windows.Input.Cursor> -Objekt für einen benutzerdefinierten Cursor.  
  
-   Verwenden der <xref:System.Windows.Input.CursorConverter> Klasse und die zugehörige <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> Methode, um einen Cursor durch angeben <xref:System.Windows.Input.CursorType>, oder eine Zeichenfolge, die zum Auswerten können eine <xref:System.Windows.Input.CursorType>, und die Rückgabe in <xref:System.Windows.Input.Cursor>.  
  
 Festlegen der <xref:System.Windows.Input.Cursor> auf einen benutzerdefinierten Wert ist bei teilweiser Vertrauenswürdigkeit nicht aktiviert. Weitere Informationen zu benutzerdefinierten Cursor finden Sie unter [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die Grafik Cursor absichtlich festgelegt wird.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Cursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Datenkontexts für ein Element fest, wenn das Element an Datenbindungen beteiligt ist.</summary>
        <value>Das Objekt, das als Datenkontext verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Datenkontext* ist ein Konzept, das kann Elemente Informationen von ihren übergeordneten Elementen zur Datenquelle erben, die für die Bindung sowie andere Merkmale der Bindung, z. B. den Pfad verwendet wird.  
  
 Datenkontext kann direkt an ein .NET-Objekt, mit den Bindungen, die als Eigenschaften dieses Objekts bewertet festgelegt werden. Alternativ können Sie den Datenkontext festlegen, um eine <xref:System.Windows.Data.DataSourceProvider> Objekt.  
  
 Diese Abhängigkeitseigenschaft erbt die Eigenschaftswerte. Wenn es untergeordnete Elemente ohne andere Werte für <xref:System.Windows.FrameworkElement.DataContext%2A> durch lokale Werte oder Stile, erstellt wurden, und klicken Sie dann das Eigenschaftensystem den Wert festgelegt wird die <xref:System.Windows.FrameworkElement.DataContext%2A> Wert des nächsten übergeordneten Element mit diesem Wert zugewiesen.  
  
 Alternativ können Sie eine der folgenden Eigenschaften von den <xref:System.Windows.Data.Binding> Klasse, um die Bindungsquelle explizit anzugeben:
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Weitere Informationen finden Sie unter [Vorgehensweise: Angeben der Bindungsquelle](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 In XAML <xref:System.Windows.FrameworkElement.DataContext%2A> i. d. r. festgelegt ist, als eine <xref:System.Windows.Data.Binding> Deklaration. Sie können entweder Eigenschaftenelement-Syntax oder Attributsyntax verwenden. Attributsyntax wird im Beispiel auf dieser Seite angezeigt. Sie können auch Code verwenden, um festzulegen <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> ist eine bindbare Eigenschaft in Szenarien nützlich, in denen ein Kontext in einen anderen gebunden werden kann. Jedoch wenn Sie zum Binden <xref:System.Windows.FrameworkElement.DataContext%2A>, achten Sie darauf, dass Sie keine zirkulären Bindungsverweise erstellen (Binden keine <xref:System.Windows.FrameworkElement.DataContext%2A> auf sich selbst, die es möglich ist, führen Sie aufgrund der Eigenschaft Wert Vererbung der <xref:System.Windows.FrameworkElement.DataContext%2A> Eigenschaft).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *dataContextObject*  
 Ein direkt embedded-Objekt, das als Datenkontext für alle Bindungen im übergeordneten Element dient. Dieses Objekt in der Regel ist eine <xref:System.Windows.Data.Binding> oder einem anderen <xref:System.Windows.Data.BindingBase> abgeleitete Klasse. Alternativ können die unformatierte Daten eines jeden Objekttyp, für die Bindung bestimmt hier mit den tatsächlichen Bindungen, die später definierte platziert werden.  
  
 *bindingUsage*  
 Eine Bindungsverwendung, die mit einem entsprechenden-Kontext ausgewertet wird. Weitere Informationen finden Sie unter [Binding als Markuperweiterung](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Eine der folgenden: [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) oder [ `DynamicResource` ](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). Diese Verwendung wird verwendet, in Bezug auf die unformatierten Daten als ein Objekt in den Ressourcen definiert. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Der Schlüsselbezeichner für das Objekt, das angefordert wird, innerhalb einer <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Datenkontext für eine Bindung fungiert und enthält die Informationen, die die spezifischen Werte der gebundenen Eigenschaften definiert.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Datenkontext für dieses Element geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Erläuterung der Datenkontexten und Datenbindung, finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Wenn die <xref:System.Windows.FrameworkElement.DataContext%2A> für ein Element ändert, der alle datengebundenen Eigenschaften dieses Elements sind möglicherweise betroffen. Dies gilt für alle Elemente, die untergeordneten Elemente des aktuellen Elements in der logischen Struktur, die den Datenkontext zu erben, und auch für das aktuelle Element selbst. Alle diese vorhandenen Bindungen müssen erneut den neuen interpretieren <xref:System.Windows.FrameworkElement.DataContext%2A> und Systemwerten die Bindungsergebnisse. Der Datenbindungs-Engine ist nicht deterministisch, über die Reihenfolge der erneuten Auswertung relativ zu das Auslösen von der <xref:System.Windows.FrameworkElement.DataContextChanged> Ereignis. Der erneuten Auswertung können vor dem Ereignis, nach dem Ereignis oder in einer beliebigen Kombination auftreten.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.DataContext" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Schlüssel ab, der zum Referenzieren der Formatvorlage für dieses Steuerelement verwendet werden soll, wenn Designformatvorlagen verwendet werden oder definiert sind.</summary>
        <value>Der Formatvorlagenschlüssel. Damit er als Teil der Designformatvorlagen-Suche ordnungsgemäß funktioniert, wird erwartet, dass dieser Wert der <see cref="T:System.Type" /> des Steuerelements ist, das formatiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird in der Regel nicht über einen beliebigen ihrer direkten Eigenschaftenaccessoren festgelegt. Stattdessen überschreiben Sie die typspezifische Metadaten dieser Abhängigkeitseigenschaft jedes Mal, wenn Sie ein neues erstellen <xref:System.Windows.FrameworkElement> abgeleitete Klasse. Wenn Sie ein Steuerelement abgeleitet werden, rufen Sie die <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> -Methode für die <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> Bezeichner im statischen Konstruktor des Steuerelements abgeleitete Klasse (oder entsprechende klasseninitialisierung).  
  
 Ein Steuerelement in der Regel überschreibt den Standardwert dieser Eigenschaft auf einen eigenen Typ sein, aber in einigen Fällen kann auch verwenden einen Basistyp für den ein Stil in die Designwörterbücher vorhanden ist. Dies ist nur praktisch, wenn die Vorlagen des Basissteuerelements vollständig die visuelle Darstellung des abgeleiteten Steuerelements definieren und beliebige zusätzliche Member, die die abgeleiteten Typen verfügbar machen keine zusätzlichen Elemente als Teil der Steuerelementvorlage erforderlich ist.  
  
 Wenn Sie ein Element oder Steuerelement Designstile absichtlich nicht verwenden möchten, legen Sie die <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> Eigenschaft `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der Abhängigkeitseigenschaft-Metadaten außer Kraft setzen in den Hinweisen beschrieben. Dieser Code definiert eine benutzerdefinierte Steuerelementklasse `NumericUpDown` aus einer dedizierten Bibliothek Steuerelementassembly verwendet werden soll. Die dargestellten statische Konstruktor verweist auf einige private Initialisierungsfunktion, registriert einen Klassenhandler (ein weiteres gängiges Szenario zum Erstellen von Unterklassen; Siehe [Markieren von Routingereignissen als behandelt und Klassenbehandlung](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) und schließlich überschreibt die <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Metadaten für Abhängigkeitseigenschaften auf die `NumericUpDown` Klasse. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Gibt Sie immer einen eigenen Typ zurück, als beabsichtigten Schlüssel, der der Konvention, die das System der Design-Stil verwendet ist, um den Stil für ein beliebiges ansonsten nicht formatiertes Steuerelement zu suchen. Das vollständige Beispiel definiert auch das tatsächliche Steuerelement Designstil, die durch diesen Schlüssel verwiesen wird. finden Sie unter [NumericUpDown Custom Control with Theme "und" UI Automation Support Sample](https://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Der vollständigen Quellcode für dieses Beispiel ist auf GitHub verfügbar, für beide [ C# ](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) und [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary).

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">NumericUpDown Custom Control with Theme and UI Automation Support Sample</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, dass der Initialisierungsprozess für das Element abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.BeginInit%2A> wurde bereits aufgerufen, die Base Implementierung löst die <xref:System.Windows.FrameworkElement.Initialized> Ereignis. Andernfalls gilt: Wenn <xref:System.Windows.FrameworkElement.BeginInit%2A> wurde nicht aufgerufen oder konnte nicht bestimmt, ob <xref:System.Windows.FrameworkElement.BeginInit%2A> aufgerufen wurde, <xref:System.Windows.FrameworkElement.Initialized> wird nicht ausgelöst, und es wird stattdessen eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.FrameworkElement.EndInit" /> wurde aufgerufen, ohne dass zuvor <see cref="M:System.Windows.FrameworkElement.BeginInit" /> für das Element aufgerufen wurde.</exception>
        <block subset="none" type="overrides">
          <para>Implementieren Sie diese Methode, um eine sonderverarbeitung bereitzustellen, die erfolgen soll, wenn das Element bei der das Element mit dem Prozess des Ladens initialisiert wird.  
  
Die Implementierung sollte die basisimplementierung wird aufrufen, weil die Basis (Standard)-Implementierung einige interne Kennzeichen zum Nachverfolgen Initialisierung festgelegt werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des angeforderten Elements.</param>
        <summary>Sucht ein Element mit dem Namen des bereitgestellten Bezeichners.</summary>
        <returns>Das angeforderte Element. Dies kann <see langword="null" /> sein, wenn kein übereinstimmendes Element gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Element untergeordnete Elemente verfügt, werden diese untergeordneten Elemente rekursiv durchsucht für die angeforderte benanntes Element.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> innerhalb des aktuellen Elements Namescope operiert. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">X: Name-Attribut</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner für die angeforderte Ressource.</param>
        <summary>Sucht eine Ressource mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird.</summary>
        <returns>Die angeforderte Ressource. Wenn keine Ressource mit dem angegebenen Schlüssel gefunden wurde, wird eine Ausnahme ausgelöst. Bei einer Ausnahme kann auch ein <see cref="F:System.Windows.DependencyProperty.UnsetValue" />-Wert zurückgegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Wenn Sie diese Methode für einen Schlüssel, die nicht gefunden werden kann aufrufen, wird eine Ausnahme ausgelöst. Wenn Sie nicht möchten, um Ausnahmen zu behandeln, die aus aufrufen <xref:System.Windows.FrameworkElement.FindResource%2A>, rufen Sie <xref:System.Windows.FrameworkElement.TryFindResource%2A> stattdessen. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Gibt `null` Wenn eine angeforderte Ressource nicht gefunden werden kann, und löst keine Ausnahme.  
  
 Wenn die Ressource für das aufrufende Element nicht gefunden wird, ist das übergeordnete Element in der logischen Struktur gesuchten weiter, und klicken Sie dann Anwendung, und klicken Sie dann Designs und schließlich Systemressourcen. Diese Methodik für die Suche ist identisch mit wie die Struktur durchsucht wird, wenn eine Ressource von einem dynamischen Ressourcenverweis in Markup angefordert wurden. Weitere Informationen zu der Ressourcensuche, finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 In der Regel Sie sofort Umwandeln einer <xref:System.Windows.FrameworkElement.FindResource%2A> Rückgabewert in den Typ der Eigenschaft, die Sie mit der zurückgegebenen Wert festlegen.  
  
 Ressourcenschlüssel sind nicht unbedingt Zeichenfolgen. Z. B. Stile für Steuerelemente auf der Designebene absichtlich, um abgestimmt sind die <xref:System.Type> des Steuerelements, und die Anwendung oder Seite Stile für Steuerelemente in der Regel dadurch verwenden dasselbe Schlüssel Konvention. Weitere Informationen finden Sie unter [Stile und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md) oder [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine benannte Ressource abgerufen, und wandelt ihn in einen geeigneten Typ eine Eigenschaft ausgefüllt werden.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <paramref name="resourceKey" /> wurde nicht gefunden, und ein Ereignishandler ist für das <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />-Ereignis nicht vorhanden.  
  
- oder -  
 <paramref name="resourceKey" /> wurde nicht gefunden und die <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" />-Eigenschaft lautet <see langword="false" /> im <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />-Ereignis.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Richtung ab, in die Text und andere [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]-Elemente innerhalb von übergeordneten Elementen fließen, die ihr Layout steuern, oder legt diese Richtung fest.</summary>
        <value>Die Richtung, in die Text und andere [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]-Elemente in ihrem übergeordneten Element fließen, als ein Wert der Enumeration. Der Standardwert ist <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Dependency-Eigenschaftensätze Nutzung der <xref:System.Windows.FrameworkElement.FlowDirection%2A> für dieses Element. Aufgrund der Vererbung von Eigenschaftswerten, Festlegen von <xref:System.Windows.FrameworkElement.FlowDirection%2A> für ein Element kann potenziell festgelegt <xref:System.Windows.FrameworkElement.FlowDirection%2A> für alle untergeordneten Elemente, die nicht festgelegt <xref:System.Windows.FrameworkElement.FlowDirection%2A> lokal oder über andere Methoden wie z. B. Stile.  
  
 Diese Eigenschaft wird nicht automatisch als Teil jeder Anwendungsinformationen zur Kultur, festgelegt, da ein Element Inhalt enthalten kann, die nicht unbedingt vorgesehen ist, befolgen die allgemeine flussrichtung impliziert durch die die kulturinformationen. Weitere Informationen zu Überlegungen zur Globalisierung, finden Sie unter [Globalisierung für WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Diese Eigenschaft verfügt über ein definiertes [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor der Eigenschaft, damit er als Abhängigkeitseigenschaft funktioniert. Allerdings ist es auch als registriert angefügt, sodass es auch als eine angefügte Eigenschaft fungieren kann. Die angefügten Registrierung ist vor allem, damit die Vererbung von Eigenschaftswerten wird unterstützt, aber die Eigenschaft auch als "true" angefügten Eigenschaft verwendet werden kann. Die Verwendung der angefügten Eigenschaft ist nur relevant, wenn das Objekt, das Sie für die flussrichtung festlegen möchten hat eine <xref:System.Windows.FrameworkElement> übergeordneten Elements, das Layout auf, führt selbst keine ist eine <xref:System.Windows.FrameworkElement>, und verfügt noch nicht über ein definiertes direkt `FlowDirection` Diese Eigenschaft. (Einige des Datenflusses dokumentieren Klassen wie z. B. <xref:System.Windows.Documents.Block> und <xref:System.Windows.Documents.Inline> definieren ihre eigenen `FlowDirection`, und diese Eigenschaft kann auch die flussrichtung festgelegt. Der Eigenschaftswert wird dann durch den Inhaltshost gelesen ohne Verwendung der angefügten Eigenschaft.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 \<*Objekt* **FlowDirection**= "<xref:System.Windows.FlowDirection>" / >  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Diese Eigenschaft kann auch für Klassen, die nicht festgelegt werden <xref:System.Windows.FrameworkElement> abgeleitete Klassen, indem Sie die folgenden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Verwendung für angefügte Eigenschaft:  
  
 `<` *Objekt* `FrameworkElement.` **FlowDirection**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Diese Eigenschaft ist sowohl eine angefügte Eigenschaft als auch eine Abhängigkeitseigenschaft. finden Sie unter "Hinweise".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen einer Eigenschaft, die die Anpassung von Darstellung, Effekten oder anderen Formateigenschaften ermöglicht, die auf dieses Element angewendet werden, wenn es den Tastaturfokus erhält.</summary>
        <value>Die gewünschte Formatvorlage, die angewendet wird, wenn das Element den Fokus erhält. Der in der Abhängigkeitseigenschaft deklarierte Standardwert ist eine leere statische <see cref="T:System.Windows.Style" />. Der tatsächliche Wert zur Laufzeit ist jedoch häufig (aber nicht immer) eine Formatvorlage, die von der Designunterstützung für Steuerelemente bereitgestellt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wirkt sich auf die visuelle Darstellung werden jedoch keine <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> in Metadaten. Dies ist, da die Änderung der visuellen Darstellung ereignisgesteuert ist und möglicherweise nicht immer gilt und aus diesem Grund sollten nicht in der Regel keine Informationen zur Visual oder Layout, in den Metadaten.  
  
 Grundsätzlich sollte das visuelle Verhalten des Fokus auf ein Steuerelement angewendet kohärente von Steuerelement zu Steuerelement sein. Die sinnvollste zum Erzwingen der Kohärenz besteht darin, nur der visuelle Fokusstil ändern, wenn Sie ein vollständiges Design erstellen. Diese Einstellung für einzelne Steuerelementstile und nicht als Teil eines Designs ist nicht die beabsichtigte Verwendung dieser Eigenschaft, da dies zu einer verwirrenden nutzererfahrung hinsichtlich des Tastaturfokus führen kann. Wenn Sie steuerelementspezifische Verhalten, die designübergreifend bewusst nicht kohärent ist festlegen möchten, ist viel besser in Stilen für einzelne Eingabezustandseigenschaften wie z. B. Verwenden von Triggern <xref:System.Windows.UIElement.IsFocused%2A> oder <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, und klicken Sie auf eine Weise dazu, die nicht der Fall ist alle vorhandenen visuellen Fokusstil beeinträchtigen Sie visuell. Weitere Informationen über den Entwurf von <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> und Alternative Fokuseigenschaften finden Sie unter [Fokusstile in Steuerelementen und FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceExtension*  
 Eine der folgenden:, oder. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Der Schlüssel, der das angeforderte Format identifiziert. Der Schlüssel verweist auf eine vorhandene Ressource in einem <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Eigenschaftenelement-Syntax ist es technisch möglich ist, aber nicht empfehlenswert. Finden Sie unter [Inlinestile und-Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ein Bindung mit oder <xref:System.Windows.Data.Binding> ist auch möglich, jedoch nicht empfohlen.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses <see cref="T:System.Windows.FrameworkElement" /> das Rendern des Cursors in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] gemäß der Deklaration in der <see cref="P:System.Windows.FrameworkElement.Cursor" />-Eigenschaft erzwingen soll, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn für die Darstellung des Cursors bei Positionierung über diesem Element die aktuellen <see cref="P:System.Windows.FrameworkElement.Cursor" />-Einstellungen (einschließlich aller untergeordneten Elemente) erzwungen werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft auf `true` überschreiben Sie die Cursor Einstellungen hergestellt, indem die untergeordneten Elemente. Dies ist also im Allgemeinen Anwendung [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] sind möglicherweise für den Benutzer verwirrend, insbesondere, wenn untergeordnete Elemente Cursor angeben möchten. Festlegen von <xref:System.Windows.FrameworkElement.ForceCursor%2A> Unterklassen oder Zusammensetzung von Szenarios besser geeignet ist.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Cursorwert.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ForceCursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die Ziel-<see cref="T:System.Windows.DependencyProperty" />, von der die Bindung abgerufen wird.</param>
        <summary>Gibt den <see cref="T:System.Windows.Data.BindingExpression" /> zurück, der die Bindung für die angegebene Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Windows.Data.BindingExpression" />, wenn die Zieleigenschaft über eine aktive Bindung verfügt, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überprüfen des Rückgabewerts für `null` ist eine Technik, können Sie bestimmen, ob eine Eigenschaft über eine aktive Bindung verfügt.  
  
 Diese Methode ist einfach nur einen Hilfswrapper rund um die <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> Methode. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> Gibt die aktuelle Instanz und die `dp` Parameter <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, für das eine <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> zurückgegeben werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Eigenschaft für das angegebene <see cref="T:System.Windows.DependencyObject" /> ab.</summary>
        <returns>Die angeforderte Flussrichtung als Wert der Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hauptzweck dieser Methode wird zur Unterstützung der Syntax für angefügte Eigenschaften der <xref:System.Windows.FrameworkElement.FlowDirection%2A> -Eigenschaft untergeordnete Elemente eines bereitgestellten <xref:System.Windows.FrameworkElement> Richtung des Inhaltsflusses für die Anordnung in ihrem übergeordneten Element an. Um den Wert abzurufen, auf dem aktuellen <xref:System.Windows.FrameworkElement>, verwenden Sie die direkte [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Die Größe des Teils des Elements für die visuelle Darstellung.</param>
        <summary>Gibt eine Geometrie für eine Clippingmaske zurück. Die Maske wird verwendet, wenn das Layoutsystem versucht, ein Element anzuordnen, das breiter als der verfügbare Anzeigeraum ist.</summary>
        <returns>Die Clippinggeometrie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ränder subtrahiert der `layoutSlotSize` als Teil des Layout-System-Verhalten.  
  
 Ein zurückgegebener null-Verweis gibt an, dass kein Abschneiden erfolgt. Die standardmäßige Implementierung gibt immer `null` beim <xref:System.Windows.UIElement.ClipToBounds%2A> ist `false`. Diese Methode überschreibt <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. Die <xref:System.Windows.FrameworkElement> Implementierung verwendet <xref:System.Windows.FrameworkElement.MaxHeight%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A> bei seinen Berechnungen. Mehrere Unterklassen von <xref:System.Windows.FrameworkElement> überschreiben diese Methode erneut. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, außer Kraft gesetzt werden immer Rückgabe `null` da Adorner häufig absichtlich außerhalb der üblichen Grenzen sind. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> und <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> zurückgeben `null` Wenn <xref:System.Windows.UIElement.ClipToBounds%2A> ist `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die standardmäßige Implementierung gibt immer <see langword="null" /> beim <see cref="P:System.Windows.UIElement.ClipToBounds" /> ist <see langword="false" />. Außerkraftsetzungen werden in der Regel beibehalten dieses Verhalten erwartet, es gibt jedoch Ausnahmen, abhängig von der Beziehung und den Zweck der abgeleiteten Klasse und die Layoutlogik statt der Basisklasse.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Name des gesuchten untergeordneten Elements.</param>
        <summary>Gibt das benannte Element in der visuellen Struktur der instanziierten <see cref="T:System.Windows.Controls.ControlTemplate" /> ab.</summary>
        <returns>Das angeforderte Element. Es kann <see langword="null" /> sein, wenn kein Element mit dem angeforderten Namen vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorlagen in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] haben Sie einen eigenständigen Namescope. Dies ist die Vorlagen erneut verwendet werden und in einer Vorlage definierte Namen nicht eindeutig bleiben, wenn mehrere Instanzen eines Steuerelements, seiner Vorlage instanziieren. Rufen Sie die <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Methode, um Verweise auf Objekte zurückzugeben, die aus der Vorlage enthalten sind, nachdem er instanziiert wird. Können keine der <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> Methode, um Elemente aus Vorlagen zu finden, da <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> dient im Allgemeinen ein Bereich, und es besteht keine Verbindung zwischen der <xref:System.Windows.Controls.ControlTemplate> Klasse selbst und der instanziierten Vorlage, sobald er angewendet wird.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> Stellt die gleiche Funktion wie diese Methode bereit. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> Öffentliche anstelle von geschützt ist und er verwendet die richtigen Namen Bereichsdefinition Überlegungen, mit denen sie Zugriff auf die Vorlage in einem Element und die benannten Elemente darin suchen können. Verwendung <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> Wenn benötigen Sie ein Element außerhalb seines übergeordneten Steuerelements.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein alternatives logisches übergeordnetes Element für dieses Element zurück, wenn kein visuelles übergeordnetes Element vorhanden ist.</summary>
        <returns>Gibt immer dann einen Wert ungleich <see langword="null" /> zurück, wenn eine auf WPF-Frameworkebene vorgenommene Implementierung dieser Methode eine nicht visuelle übergeordnete Verbindung hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Der Standardwert <xref:System.Windows.FrameworkElement> Implementierung gibt zurück, der erwarteten einzelne visuelle übergeordneten Element, wird das gleiche Ergebnis wie das Abrufen der <xref:System.Windows.FrameworkElement.Parent%2A> Wert. Alternative übergeordnete Beziehungen können von abgeleiteten Implementierungen zurückgegeben werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des angeforderten untergeordneten Elements in der Auflistung.</param>
        <summary>Überschreibt <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> und gibt aus einer Auflistung untergeordneter Elemente ein untergeordnetes Element an der angegebenen Indexposition zurück.</summary>
        <returns>Das angeforderte untergeordnete Element. Es sollte nicht <see langword="null" /> zurückgeben; wenn der angegebene Index außerhalb des Bereichs liegt, wird eine Ausnahme ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der <xref:System.Windows.FrameworkElement> Implementierung der einzige gültige Index ist 0 (null). Das Inhaltsmodell für <xref:System.Windows.FrameworkElement.GetVisualChild%2A> unterstützt entweder NULL oder ein untergeordnetes Element, aber keine Auflistung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein benutzerdefinierter Adorner wird verwendet, die Werte, der deklariert, indem eine <xref:System.Windows.Media.VisualCollection> , die er verwaltet, für die mehreren visuellen untergeordneten Elemente. Diese Werte werden durch Außerkraftsetzungen von gemeldet <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> und <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Diese Implementierung gilt nur für Elemente, die jede aussagekräftigeren Auflistung der sichtbaren untergeordneten Elemente nicht beibehalten. Alle Elemente, die eine solche Auflistung verfügt, muss diese Methode überschreiben und ordnen den Index in einen entsprechenden Index in der Auflistung der untergeordneten Elemente, die durch dieses Element unterstützt wird. Ein Index im Bereich von 0 (null), um <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (minus eins) sollte ein gültiges Element; zurückgeben anderer Indizes sollten Ausnahme außerhalb des gültigen Bereichs. Ein Beispiel für einen Elementtyp aus, die eine untergeordnete Auflistung unterstützt, und überschreibt <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> auf mehr als eine mögliche untergeordnete Elemente zurückgegeben werden <see cref="T:System.Windows.Controls.Panel" />.  
  
Die standardmäßige Implementierung in <see cref="T:System.Windows.FrameworkElement" /> setzt voraus, dass nur ein visuellen untergeordneter. Jeder Wert für die <paramref name="index" /> als NULL festgelegt, wird eine Ausnahme ausgelöst wird. Mehrere allgemeine Elemente, wie Decorator-Elemente, Adorner oder Elemente mit spezialisierten Renderern, überschreiben die <see cref="T:System.Windows.FrameworkElement" /> Implementierung (von der Implementierung von intermediate Basisklassen). Einige Implementierungen erzwingen immer noch eine visuelle untergeordnete, während andere eine Sammlung können.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vorgeschlagene Höhe des Elements ab oder legt sie fest.</summary>
        <value>Die Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.NaN" />. Dieser Wert muss größer oder gleich 0,0 sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> ist eine der drei schreibbaren Eigenschaften von <xref:System.Windows.FrameworkElement> anzugeben, dass Informationen über die Zeilenhöhe. Die anderen zwei sind <xref:System.Windows.FrameworkElement.MinHeight%2A> und <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Liegt ein Konflikt zwischen dem diese Werte, die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Höhe ist, die erste <xref:System.Windows.FrameworkElement.MinHeight%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxHeight%2A>, und schließlich ist dies in den angegebenen Begrenzungen, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Wenn dieses Element ein untergeordnetes Element in einem anderen Element ist, ist das Festlegen dieser Eigenschaft auf einen Wert eigentlich nur jeweils einen vorgeschlagenen Wert. Das Layoutsystem als auch die bestimmten Layoutlogik des übergeordneten Elements wird den Wert als nicht-bindungsparamater Eingabe während des Prozesses Layout verwenden. Praktisch eine <xref:System.Windows.FrameworkElement> ist fast immer das untergeordnete Element eines anderen; selbst wenn Sie festlegen, die <xref:System.Windows.FrameworkElement.Height%2A> auf <xref:System.Windows.Window>. (Für <xref:System.Windows.Window>, dieser Wert verwendet, wenn das zugrunde liegende Anwendungsmodell stellt die grundlegende Rendering-Annahmen her, die das Hwnd zu, die erstellen die Anwendung gehostet.)  
  
 Zusätzlich zu den akzeptablen <xref:System.Double> Werte, die diese Eigenschaft kann auch sein <xref:System.Double.NaN?displayProperty=nameWithType>. Dies ist, wie Sie die automatische Größenanpassungsverhalten im Code angeben. In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sie legen Sie den Wert der Zeichenfolge "Auto" (Groß-/Kleinschreibung) um das automatische Größenanpassungsverhalten zu aktivieren. Das automatische Größenanpassungsverhalten bedeutet, dass das Element die verfügbare Höhe ausfüllt. Beachten Sie jedoch, dass bestimmte Steuerelemente häufig Standardwerte durch ihren Standardwert Designstilen, die deaktiviert wird, das automatische Größenanpassungsverhalten bereitstellen, es sei denn, sie explizit wieder aktiviert wird.  
  
 Der Rückgabewert dieser Eigenschaft ist immer mit dem jeder Wert, der festgelegt wurde. Im Gegensatz dazu ist der Wert des der <xref:System.Windows.FrameworkElement.ActualHeight%2A> abweichen. Dies kann vorkommen entweder statisch, da das Layout die vorgeschlagene Größe aus irgendeinem Grund abgelehnt oder vorübergehend. Das Layoutsystem selbst asynchron ausgeführt, relativ zu das Eigenschaftensystem Satz von <xref:System.Windows.FrameworkElement.Height%2A> und kann nicht verarbeitet, bestimmte Eigenschaftenänderung noch größenanpassung.  
  
 Die Einschränkungen der Wert für die <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
 Neben der Überprüfung, es gibt eine nicht deterministische obere Grenze für den Wert <xref:System.Windows.FrameworkElement.Height%2A> , die durch das Layoutsystem erzwungen wird (Dies ist eine sehr große Zahl größer als <xref:System.Single.MaxValue?displayProperty=nameWithType> jedoch kleiner als <xref:System.Double.MaxValue?displayProperty=nameWithType>). Wenn Sie diese Grenze überschreiten, wird das Element wird nicht gerendert, und wird keine Ausnahme ausgelöst. Stellen Sie keine <xref:System.Windows.FrameworkElement.Height%2A> auf einen Wert an, die erheblich größer als die maximale Größe jeder mögliche visuelle Darstellung, oder wenn Sie dieses nicht deterministische Obergrenze überschreiten kann.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Informationen zur Obergrenze finden Sie unter „Hinweise“. Dieser Wert wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Zum Beispiel den Wert `1` akzeptabel ist.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einer der folgenden Deklaration Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1 In == 96 px  
  
 `cm` ist Zentimeter. 1cm==(96/2.54) px  
  
 `pt` ist die Punkte. 1pt==(96/72) px  
  
 **Auto**  
 Aktiviert das Verhalten für automatisches Anpassen der Größe. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Height" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die horizontalen Ausrichtungsmerkmale ab bzw. legt diese fest. Sie werden auf dieses Element angewendet, wenn es Teil von einem übergeordneten Element ist, z. B. von einem Panel-Steuerelement oder von einem ItemsControl-Element.</summary>
        <value>Eine Einstellung für horizontale Ausrichtung als Wert der Enumeration. Der Standardwert ist <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.Width%2A> Eigenschaften werden für ein Element explizit festgelegt wird, diese Messungen werden Sie während des Layouts stets Vorrang und bricht die typischen Auswirkungen der Einstellung <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> zu <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> ist die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaftenaccessor für das was in Wirklichkeit eine Abhängigkeitseigenschaft ist. Diese bestimmte Abhängigkeitseigenschaft hat oft einen offensichtlichen "Default"-Wert, der als Unterklasse Elementen führen, insbesondere Steuerelemente festgelegt. Dieser Vorgang erfolgt normalerweise auf zwei Arten: die Abhängigkeitseigenschaft wird erneut registriert werden, auf eine bestimmte Unterklasse, aber unterschiedliche Metadaten für die Standardeinstellungen werden; oder es ist ein Standardformat angewendet wird, der Wert dieser Abhängigkeitseigenschaft unterschiedlich festlegt. Z. B. die scheinbare "Default" der <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> für eine <xref:System.Windows.Controls.Label> -Steuerelement <xref:System.Windows.HorizontalAlignment.Left>, auch wenn <xref:System.Windows.Controls.Label> erbt <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> direkt von <xref:System.Windows.FrameworkElement>. Dies ist, da dieser Wert, in den Standardstil der zurückgesetzt wurde <xref:System.Windows.Controls.Label>, in der Vorlage für den Stil des Steuerelements.  
  
 <xref:System.Windows.Controls.Canvas> verwendet keine <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> beim Erstellen des Layouts, da <xref:System.Windows.Controls.Canvas> basiert auf der absoluten Positionierung.  
  
 Wenn von geerbt <xref:System.Windows.Controls.Label> oder abgeleiteten Klassen, <xref:System.Windows.Controls.Label> ändert den Standardwert dieser Abhängigkeitseigenschaft sein <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bereichsgrenzen für die Vererbung von Eigenschaftswerten, die Suche nach Ressourcenschlüsseln und die RelativeSource-FindAncestor-Suche ab oder legt diese Grenzen fest.</summary>
        <value>Ein Wert aus der Enumeration. Der Standardwert ist <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmte Grenzen in der Struktur Satz <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> absichtlich den Bereich der von Vererbungsverhalten in eine Ressourcensuche erzwingen, um die Anwendungsressourcen zu überprüfen oder um zu verhindern, dass die RelativeSource FindAncestor-Suche Abfragen das aktuelle Element beschränken oder Weiter. RelativeSource FindAncestor-Suche tritt auf, wenn eine Bindung verwendet ein <xref:System.Windows.Data.RelativeSource> , bei dem die <xref:System.Windows.Data.RelativeSource.Mode%2A> Eigenschaft festgelegt wird, um die <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> Wert.  
  
 Wenn Sie die abgeleitete Klasse diese Eigenschaft festlegen möchten, sollten Sie diesen im statischen Konstruktor oder in anderen Initialisierungsroutinen ausführen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn dieses <see cref="T:System.Windows.FrameworkElement" /> initialisiert wird. Dieses Ereignis geht mit Fällen einher, in denen sich der Wert der <see cref="P:System.Windows.FrameworkElement.IsInitialized" />-Eigenschaft von <see langword="false" /> (oder nicht definiert) in <see langword="true" /> ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.FrameworkElement.EndInit%2A> oder <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> Methoden aufgerufen werden. Aufrufe an eine Methode können stammen haben, aus dem Anwendungscode oder über die [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] -Prozessorverhaltens bei einem [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite verarbeitet wird.  
  
 Gibt an, ob Sie verarbeiten möchten <xref:System.Windows.FrameworkElement.Loaded> oder <xref:System.Windows.FrameworkElement.Initialized> hängt von Ihren Anforderungen. Wenn Sie nicht benötigen, um Elementeigenschaften lesen, Eigenschaften zurücksetzen möchten, und brauchen keine Informationen zum Standardlayout, <xref:System.Windows.FrameworkElement.Initialized> möglicherweise die bessere-Ereignis zu reagieren. Wenn alle des Elements Eigenschaften, das zur Verfügung, und Sie Eigenschaften, die wahrscheinlich das Layout zurücksetzen festlegen <xref:System.Windows.FrameworkElement.Loaded> möglicherweise die bessere-Ereignis zu reagieren. Achten Sie darauf, von Eintrittsinvarianz, wenn der Handler setzt alle Eigenschaften, die interpretiert werden, durch das Layoutsystem zurück bedeutet, dass ein neuen Layoutdurchlauf erforderlich ist. (Sie müssen möglicherweise überprüfen die <xref:System.Windows.FrameworkPropertyMetadata> Werte für die Eigenschaft, wenn Sie nicht genau wissen, welche Eigenschaften ein neues Layout erforderlich sind zu übergeben, wenn diese geändert werden.)  
  
 Weitere Informationen zur Reihenfolge der Ereignisse für Objekt eine <xref:System.Windows.FrameworkElement>, und auch mehrere Anwendungs- und Element-Klassen beziehen, finden Sie unter [Objektlebensdauer-Ereignisse](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Kontext für die Eingabe ab oder legt ihn fest, der von diesem <see cref="T:System.Windows.FrameworkElement" /> verwendet wird.</summary>
        <value>Der Eingabebereich, der bestimmt, wie Eingaben von alternativen Eingabemethoden interpretiert werden. Der Standardwert ist <see langword="null" /> (führt zu einer Standardbehandlung von Befehlen).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Abhängigkeitseigenschaft erbt die Eigenschaftswerte. Wenn es untergeordnete Elemente ohne andere Werte für <xref:System.Windows.FrameworkElement.InputScope%2A> durch lokale Werte oder Stile, erstellt wurden, und klicken Sie dann das Eigenschaftensystem den Wert festgelegt wird die <xref:System.Windows.FrameworkElement.InputScope%2A> Wert, der das nächste übergeordnete Element mit diesem Wert zugewiesen.  
  
 Obwohl eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax Nutzung aufgeführt und syntaktisch zulässig ist, wird durch Festlegen dieser Eigenschaft [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ist nicht üblich.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.InputScope" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob dieses Element entweder während der Verarbeitung durch einen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Prozessor oder durch explizites Aufrufen seiner <see cref="M:System.Windows.FrameworkElement.EndInit" />-Methode initialisiert wurde.</summary>
        <value>
          <see langword="true" />, wenn das Element über die oben genannte [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Verarbeitung oder Methodenaufrufe initialisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann auch sein `true` , wenn dieses Element innerhalb der logischen Struktur verschoben wurde, dass sie ein neues übergeordnetes Element aufweist, und daher neu geladen werden muss.  
  
 Diese Eigenschaft ist nützlich, wenn Sie auch verwenden <xref:System.Windows.FrameworkElement.BeginInit%2A> und <xref:System.Windows.FrameworkElement.EndInit%2A>. Elemente in der logischen Struktur, die geladen wird, indem eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor werden sicher initialisiert werden. Elemente, die nicht in der logischen Struktur werden initialisiert, wenn <xref:System.Windows.FrameworkElement.EndInit%2A> aufgerufen wird. Bei einem Nichtvorhandensein von jeder spezifische Verarbeitung von <xref:System.Windows.FrameworkElement.BeginInit%2A> und <xref:System.Windows.FrameworkElement.EndInit%2A>, dies erfolgt, sobald der Konstruktor das initialisierte Ergebnis zurückgibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element für die Darstellung geladen wurde.</summary>
        <value>
          <see langword="true" />, wenn das aktuelle Element an eine Elementstruktur angefügt ist, <see langword="false" />, wenn das Element noch nie an eine geladene Elementstruktur angefügt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einem neu erstellten <xref:System.Windows.FrameworkElement>, diese Eigenschaft Anfangs `false`, und bleibt `true` Nachdem sie, um festgelegt wurde `true`, auch wenn das Element anschließend aus einer verbundenen logischen Struktur von Code entfernt wird. `true` Zustand wird von der allgemeinen Präsentationslogik festgelegt, wenn Elemente in der Präsentation-Engine geladen werden.  
  
 In der Regel werden von geladener Elemente gerendert, aber nicht alle <xref:System.Windows.FrameworkElement> abgeleitete Klassen haben, eine Präsentation und andere Eigenschaften wie z. B. <xref:System.Windows.UIElement.Visibility%2A> können Präsentation beeinflussen.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Handler implementiert: eine ist der Umgang mit den <xref:System.Windows.FrameworkElement.Loaded> Ereignis des Stammelements, damit sichergestellt ist, dass das Stammelement der Seite geladen wird, da dies die Bedeutung des Ereignisses ist. Die andere Handler ist verknüpft, auf ein Benutzersteuerelement und der Aufrufe <xref:System.Windows.FrameworkElement.IsLoaded%2A> sicherzustellen, dass das Stammelement geladen wird vollständig. Beide Handler aufrufen, die gleiche Funktion (nicht gezeigt), mit die untergeordnete Elemente mit neuen Daten aufgefüllt wird.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Lokalisierungs-/Globalisierungs-Sprachinformationen für das Element angibt, oder legt diesen Wert fest.</summary>
        <value>Die Sprachinformationen für dieses Element. Der Standardwert ist eine <see cref="T:System.Windows.Markup.XmlLanguage" />, deren <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />-Wert auf die Zeichenfolge „en-US“ festgelegt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Formate befolgen Sie die RFC 3066-Standard. Z. B. USA Englisch ist "En-US". Weitere Informationen zu den Werten und Format finden Sie unter <xref:System.Windows.Markup.XmlLanguage>.  
  
 Diese Abhängigkeitseigenschaft erbt die Eigenschaftswerte. Wenn es untergeordnete Elemente ohne andere Werte für <xref:System.Windows.FrameworkElement.Language%2A> hergestellt, über lokale Werte oder Stile, das Eigenschaftensystem setze den Wert der <xref:System.Windows.FrameworkElement.Language%2A> Wert, der das nächste übergeordnete Element mit diesem Wert zugewiesen.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] definiert die allgemeinen Bedeutung des das `xml:lang` Attribut. <xref:System.Windows.FrameworkElement.Language%2A> im Wesentlichen stellt die Bedeutung dieses Attributs als Abhängigkeitseigenschaft. <xref:System.Windows.FrameworkElement.Language%2A> programmgesteuert angepasst werden kann, und profitiert von System die Vererbung von Eigenschaftswerten in einer Weise, die parallel wie die `xml:lang` Attribut kann auf den Bereich der untergeordneten Elemente in erben [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Setzen Sie <xref:System.Windows.FrameworkElement.Language%2A>, dieser Wert wird die `xml:lang` und überschreibt alle vorherigen Werte. Weitere Informationen finden Sie unter [XML: lang Handling in XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Language" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Grafiktransformation ab, die auf dieses Element angewendet werden soll, wenn Layout ausgeführt wird, oder legt diese fest.</summary>
        <value>Die Transformation, die dieses Element verwenden soll. Der Standardwert ist <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> Einfluss auf die Ergebnisse des Layouts.  
  
 Festlegen einer Transformation stellt leistungsfähige Funktionen skalieren und rotieren. Allerdings <xref:System.Windows.FrameworkElement.LayoutTransform%2A> ignoriert <xref:System.Windows.Media.TranslateTransform> Vorgänge. Grund hierfür ist das Verhalten des Layouts für untergeordnete Elemente des eine <xref:System.Windows.FrameworkElement> alle Offsets, die die Position eines Elements skaliert oder gedreht, in das Layout und der Koordinatensystem des übergeordneten Elements automatisch korrigiert.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> kann zu schlechter Anwendungsleistung führen, wenn Sie es in einem Szenario aufrufen, die nicht über einen vollständigen Durchlauf des Layoutsystems erfordert. Beim Anwenden einer <xref:System.Windows.FrameworkElement.LayoutTransform%2A> auf die <xref:System.Windows.Controls.Panel.Children%2A> Auflistung von der <xref:System.Windows.Controls.Panel>, einen neuen Durchlauf des Layoutsystems auslöst werden soll, und erzwingt, dass alle Objekte auf dem Bildschirm dieses erneut berechnet und neu angeordnet werden. Wenn Sie die vollständige Anwendung aktualisieren [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], diese Funktionalität kann sein, genau die benötigten. Wenn Sie nicht über eine vollständige Layoutphase benötigen, allerdings verwenden der <xref:System.Windows.UIElement.RenderTransform%2A> -Eigenschaft, die das Layoutsystem nicht aufruft, und aus diesem Grund ist in der Regel eine bessere Wahl für dieses Szenario.  
  
 Beispielszenarien, in denen <xref:System.Windows.FrameworkElement.LayoutTransform%2A> wäre nützlich sind: Drehen von Elementen wie z. B. Menükomponenten, von der horizontalen, vertikalen oder umgekehrt, skalieren (vergrößern) Elemente von fokussierten, bereitstellen usw. Bearbeitungsverhalten.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie Anwenden einer <xref:System.Windows.FrameworkElement.LayoutTransform%2A> auf ein Element. Das Beispiel erstellt eine Instanz des <xref:System.Windows.Controls.Button> an und hostet es in einem übergeordneten <xref:System.Windows.Controls.Grid>. Darüber hinaus verwendet er die <xref:System.Windows.FrameworkElement.LayoutTransform%2A> Eigenschaft anwenden einer <xref:System.Windows.Media.RotateTransform> auf die <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">Beispiel für 2D-Transformationen</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Element ausgerichtet und gerendert sowie zur Interaktion vorbereitet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> das letzte Ereignis wird in der Regel in einer Sequenz der verbindungsinitialisierung Element ausgelöst werden. Es wird immer ausgelöst, nach dem <xref:System.Windows.FrameworkElement.Initialized>. Gibt an, ob Sie verarbeiten möchten <xref:System.Windows.FrameworkElement.Loaded> oder <xref:System.Windows.FrameworkElement.Initialized> hängt von Ihren Anforderungen. Wenn Sie nicht benötigen, um Elementeigenschaften lesen, Eigenschaften zurücksetzen möchten, und brauchen keine Informationen zum Standardlayout, <xref:System.Windows.FrameworkElement.Initialized> möglicherweise die bessere-Ereignis zu reagieren. Wenn alle des Elements Eigenschaften, das zur Verfügung, und Sie Eigenschaften, die wahrscheinlich das Layout zurücksetzen festlegen <xref:System.Windows.FrameworkElement.Loaded> möglicherweise die bessere-Ereignis zu reagieren. Achten Sie darauf, von Eintrittsinvarianz, wenn der Handler setzt alle Eigenschaften, die interpretiert werden, durch das Layoutsystem zurück bedeutet, dass ein neuen Layoutdurchlauf erforderlich ist. (Sie müssen möglicherweise überprüfen die <xref:System.Windows.FrameworkPropertyMetadata> Werte für die Eigenschaft, wenn Sie nicht genau wissen, welche Eigenschaften ein neues Layout erforderlich sind zu übergeben, wenn diese geändert werden.)  
  
 Weitere Informationen zur Reihenfolge der Ereignisse für Objekt eine <xref:System.Windows.FrameworkElement>, und auch mehrere Anwendungs- und Element-Klassen beziehen, finden Sie unter [Objektlebensdauer-Ereignisse](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Direkte Routingereignisse führen Sie eine Route nicht, sondern werden nur innerhalb des gleichen Elements, auf dem sie ausgelöst werden, behandelt. Unterstützen direkte Routingereignisse andere Routingereignisverhaltens: sie unterstützen eine Auflistung der Handler der zugegriffen werden kann, und können verwendet werden, als ein <xref:System.Windows.EventTrigger> in einem Stil.  
  
 <xref:System.Windows.FrameworkElement.Loaded> und <xref:System.Windows.FrameworkElement.Unloaded> können sowohl für Steuerelemente, die als Ergebnis der vom Benutzer initiierte Systemdesigns ausgelöst werden. Eine Design Änderung führt zu einer invalidierung von der Steuerelementvorlage und der enthaltenen visuellen Struktur, die wiederum führt dazu, dass das gesamte Steuerelement nicht entladen und neu laden. Aus diesem Grund <xref:System.Windows.FrameworkElement.Loaded> kann nicht angenommen werden, dass auftreten, nur wenn eine Seite zuerst durch Navigation zur Seite geladen wird.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Routing-Strategie|Direkt|  
|delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.Loaded" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente dieses Elements ab.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> können Sie untergeordnete Elemente durchlaufen. Dies ist nützlich für Elemente, die möglicherweise keine Auflistung definierte, dedizierte aber immer noch mehrere untergeordnete Elemente enthält, vor allem <xref:System.Windows.FrameworkContentElement> untergeordnete Elemente.  
  
 Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkElement.LogicalChildren%2A> und <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array-Markuperweiterung</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den äußeren Rand eines Elements ab oder legt ihn fest.</summary>
        <value>Stellt Randwerte für das Element bereit. Der Standardwert ist eine <see cref="T:System.Windows.Thickness" />, bei der alle Eigenschaften gleich 0 (null) sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rand ist der Abstand zwischen diesem Element und anderen Elementen, die nach dem Layout der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Gemeinsame Elemente möglicherweise Peer-Elemente (z. B. von anderen Elementen in der Auflistung von einem gemeinsamen übergeordneten Steuerelement) oder übergeordnetes Element vorhanden ist, wird dieses Element können auch sein.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> wird festgelegt, wie eine <xref:System.Windows.Thickness> Struktur und nicht als eine Zahl, damit der Rand asymmetrisch festgelegt werden kann. Die <xref:System.Windows.Thickness> Struktur selbst unterstützt die Konvertierung, damit Sie einen asymmetrischen angeben können <xref:System.Windows.FrameworkElement.Margin%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Attributsyntax auch.  
  
 Ein Rand ungleich 0 betrifft jeden Bereich außerhalb des Elementlayouts <xref:System.Windows.FrameworkElement.ActualWidth%2A> und <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Ränder sind additiv für nebengeordnete Elemente in einem Layout; Beispielsweise müssten zwei benachbarte Elemente, die mit einem Rand von 30 für den benachbarten Rand festgelegt 60 Einheiten von Leerzeichen dazwischen.  
  
 Elemente mit Ränder festgelegt werden nicht in der Regel beschränken die Größe des angegebenen <xref:System.Windows.FrameworkElement.Margin%2A> ist der zugewiesenen Rechteck Speicherplatz nicht groß genug ist, für den Rand und der Inhaltsbereich des Elements. Inhaltsbereich des Elements wird stattdessen eingeschränkt werden, wenn das Layout berechnet wird. Der einzige Fall, in denen Ränder beschränkt werden, ist auch auf, wenn der Inhalt bereits bis hin zu 0 (null) beschränkt ist.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *Links, oben, rechts, unten*  
 Anzahl von Werten zwischen 0 und <xref:System.Double.PositiveInfinity> anzugeben, dass der vier möglichen Dimensionseigenschaften eine <xref:System.Windows.Thickness> Struktur.  
  
 Die Verwendung von Attributen akzeptiert auch abgekürzte Werte, die in der Reihenfolge angegeben, symmetrisch und logisch gelten. Z. B. `Margin="20"` interpretiert wird, dass eine <xref:System.Windows.Thickness> mit allen Eigenschaften, die auf 20 festgelegt. `Margin="20,50"` wird so interpretiert, dass eine <xref:System.Windows.Thickness> mit <xref:System.Windows.Thickness.Left%2A> und <xref:System.Windows.Thickness.Right%2A> auf 20 festgelegt und <xref:System.Windows.Thickness.Top%2A> und <xref:System.Windows.Thickness.Bottom%2A> auf 50 festgelegt.  
  
 Die Standardeinheit für eine <xref:System.Windows.Thickness> Measure [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Sie können auch andere Zeiteinheiten angeben, durch die Unit-Typ-Zeichenfolgen anhängen `cm`, `in`, oder `pt` auf ein Measure.  
  
 Anzahl der Werte, die als [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Attribute müssen keine Dezimaltrennzeichen angeben (0 akzeptabel ist, muss nicht als 0,0 bereitgestellt werden). Weitere Informationen zu [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Nutzung finden Sie unter <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Ein Objektverweis auf eine vorhandene <xref:System.Windows.Thickness>. Dies ist möglicherweise eine `}`, a oder `}` Verweis. Weitere Informationen zu [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Nutzung finden Sie unter <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Margin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die maximale Höhe ab bzw. legt diese fest.</summary>
        <value>Die maximale Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.PositiveInfinity" />. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. <see cref="F:System.Double.PositiveInfinity" /> ist ebenfalls gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> anzugeben, dass Informationen über die Zeilenhöhe. Die anderen zwei sind <xref:System.Windows.FrameworkElement.MinHeight%2A> und <xref:System.Windows.FrameworkElement.Height%2A>.  Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Höhe zuerst <xref:System.Windows.FrameworkElement.MinHeight%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxHeight%2A>, und wenn all dies innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Die Einschränkungen der Wert für die <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Eine Laufzeitausnahme wird ausgelöst, wenn Sie versuchen, einen ungültigen Wert festzulegen.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Zum Beispiel den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> bereichseinschränkungen wie im Abschnitt Eigenschaftswert anwenden, mit dem Unterschied, dass Sie verwenden, müssen [X: statische Markuperweiterung](~/docs/framework/xaml-services/x-static-markup-extension.md) , wenn Sie den Wert explizit festlegen müssen <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einer der folgenden Deklaration Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1 In == 96 px  
  
 `cm` ist Zentimeter. 1cm==(96/2.54) px  
  
 `pt` ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MaxHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die maximale Breite ab bzw. legt diese fest.</summary>
        <value>Die maximale Breite des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.PositiveInfinity" />. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. <see cref="F:System.Double.PositiveInfinity" /> ist ebenfalls gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> anzugeben, dass die Breiteninformationen. Die anderen zwei sind <xref:System.Windows.FrameworkElement.MinWidth%2A> und <xref:System.Windows.FrameworkElement.Width%2A>. Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Breite zuerst <xref:System.Windows.FrameworkElement.MinWidth%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxWidth%2A>, und wenn all dies innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Die Einschränkungen der Wert für die <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Zum Beispiel den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> bereichseinschränkungen wie im Abschnitt Eigenschaftswert anwenden, mit dem Unterschied, dass Sie verwenden müssen [X: statische Markuperweiterung](~/docs/framework/xaml-services/x-static-markup-extension.md) zum Festlegen des Werts sein <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einer der folgenden Deklaration Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1 In == 96 px  
  
 `cm` ist Zentimeter. 1cm==(96/2.54) px  
  
 `pt` ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MaxWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die das übergeordnete Element an die untergeordneten Elemente übergeben kann.</param>
        <summary>Implementiert das grundlegende Systemverhalten für das Layout zur Measureübergabe für <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Die gewünschte Größe dieses Elements im Layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> zum Verbinden der WPF-Kernebenen und WPF-Frameworkebene-Layout-Measure-Implementierungen. Die <xref:System.Windows.FrameworkElement> Implementierung versiegelt die Methode. Zum Anpassen der Measure-Pass-Layout-Verhalten eines Elements, das auf die WPF-Frameworkebene aufbaut überschreiben <xref:System.Windows.FrameworkElement.MeasureOverride%2A> stattdessen. Anpassen, auf die Maßübergabe Layoutverhalten für ein Element, das absichtlich nicht auf die WPF-Frameworkebene erstellen oder <xref:System.Windows.FrameworkElement>, außer Kraft setzen <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die dieses Element untergeordneten Elementen bereitstellen kann. „Unendlich“ kann als Wert angegeben werden, um festzulegen, dass das Element an die Größe des jeweiligen Inhalts angepasst wird.</param>
        <summary>Misst beim Überschreiben in einer abgeleiteten Klasse die für untergeordnete Elemente im Layout benötigte Größe und bestimmt eine Größe für die von <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse.</summary>
        <returns>Die für dieses Element beim Layout benötigte Größe, basierend auf der Berechnung der Größen der untergeordneten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Außer Kraft setzen <xref:System.Windows.FrameworkElement.MeasureOverride%2A> benutzerdefiniertes Layout Größenanpassungsverhalten für das Element zu implementieren, wie sie ein Teil ist die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Layoutsystem. Ihre Implementierung sollten die folgenden Schritte ausführen:  
  
1.  Durchlaufen des Elements bestimmte Auflistung untergeordneter Elemente, die Teil des Layouts, Aufruf <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element.  
  
2.  Sofort <xref:System.Windows.UIElement.DesiredSize%2A> auf dem untergeordneten Element (Dies wird als eine Eigenschaft nach festgelegt <xref:System.Windows.UIElement.Measure%2A> aufgerufen wird).  
  
3.  Berechnen Sie die net gewünschte Größe des übergeordneten Elements auf Grundlage der Messung der untergeordneten Elemente.  
  
 Der Rückgabewert von <xref:System.Windows.FrameworkElement.MeasureOverride%2A> muss die Größe des Elements gewünscht, die dann das Measure, geben Sie für das übergeordnete Element des aktuellen Elements wird. Dieser Prozess wird durch das Layoutsystem fortgesetzt, bis das Stammelement der Seite erreicht ist.  
  
 Während dieses Vorgangs können untergeordnete Elemente eines größeren zurückgeben <xref:System.Windows.UIElement.DesiredSize%2A> als die anfängliche Größe `availableSize` um anzugeben, dass das untergeordnete Element mehr Speicherplatz benötigt. Dies könnte in Ihren eigenen Implementierungen verarbeitet werden, durch die Einführung eines bildlauffähigen Bereichs, von dem übergeordneten Steuerelement, Größenänderung, durch die Einrichtung schnellstmöglich gestapelte Bestellung oder eine beliebige Anzahl von Lösungen für messen oder Anordnen von Inhalt.  
  
> [!IMPORTANT]
>  Elemente müssen Aufrufen <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element, während dieses Vorgangs werden soll, andernfalls die untergeordneten Elemente nicht ordnungsgemäß dimensioniert oder angeordnet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Im folgenden nicht kompilieren sehen dieses Implementierungsmuster.  <c>VisualChildren</c> stellt eine aufzählbare Auflistung-Eigenschaft der untergeordneten Elemente, die Ihre eigenen Element definieren, sollten dar. Die Eigenschaft kann beliebig benannt werden. <c>VisualChildren</c> ist ein Platzhaltername für dieses Beispiel, <c>VisualChildren</c> ist keiner [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] gemäß [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] oder einen Teil ein Namensmuster...  
  
[! Code-Csharp[CorePseudocode #FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [! Code – Vb[CorePseudocode #FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die minimale Höhe ab bzw. legt diese fest.</summary>
        <value>Die minimale Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0,0. Dieser Wert kann ein beliebiger Wert größer gleich 0,0 sein. Allerdings ist <see cref="F:System.Double.PositiveInfinity" /> NICHT gültig, noch <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> anzugeben, dass Informationen über die Zeilenhöhe.  Die anderen zwei sind <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Höhe zuerst <xref:System.Windows.FrameworkElement.MinHeight%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxHeight%2A>, und wenn all dies innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Die Einschränkungen der Wert für die <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Zum Beispiel den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> Bereich in der Eigenschaft Value-Abschnitt genannten Einschränkungen.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einer der folgenden Deklaration Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1 In == 96 px  
  
 `cm` ist Zentimeter. 1cm==(96/2.54) px  
  
 `pt` ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MinHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die minimale Breite ab bzw. legt diese fest.</summary>
        <value>Die Mindestbreite des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0,0. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. Allerdings ist weder <see cref="F:System.Double.PositiveInfinity" /> noch <see cref="F:System.Double.NaN" /> gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> anzugeben, dass die Breiteninformationen.  Die anderen zwei sind <xref:System.Windows.FrameworkElement.Width%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Breite zuerst <xref:System.Windows.FrameworkElement.MinWidth%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxWidth%2A>, und wenn all dies innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Die Einschränkungen der Wert für die <xref:System.Double> Wert werden erzwungen, indem eine <xref:System.Windows.ValidateValueCallback> Mechanismus. Wenn Sie versuchen, einen ungültigen Wert festgelegt, wird eine Laufzeitausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Dies wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Zum Beispiel den Wert `1` akzeptabel ist.  
  
 Die gleiche <xref:System.Double> Bereich in der Eigenschaft Value-Abschnitt genannten Einschränkungen.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einer der folgenden Deklaration Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1 In == 96 px  
  
 `cm` ist Zentimeter. 1cm==(96/2.54) px  
  
 `pt` ist die Punkte. 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MinWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Die Richtung, in die der Fokus verschoben werden soll, als Wert der Enumeration.</param>
        <summary>Verschiebt den Tastaturfokus von diesem Element in einer angegebenen Durchlaufrichtung zu einem anderen Element.</summary>
        <returns>Gibt <see langword="true" /> zurück, wenn der Fokus erfolgreich verschoben wurde. <see langword="false" /> wird zurückgegeben, wenn das Zielelement in der angegebenen Richtung nicht vorhanden ist oder den Tastaturfokus nicht erhalten kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung überschreibt <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> und versiegelt die Methode.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der mehrere mögliche Schaltflächeneingaben behandelt. Jede Schaltfläche stellt eine mögliche <xref:System.Windows.Input.FocusNavigationDirection>. Der Handler verfolgt das Element mit dem aktuellen Tastaturfokus und ruft <xref:System.Windows.FrameworkElement.MoveFocus%2A> auf diesem Element durch Angabe der entsprechenden <xref:System.Windows.Input.FocusNavigationDirection> als Initialisierung für die <xref:System.Windows.Input.TraversalRequest> Typparameter angegeben.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Elementnamens. Der Name stellt einen Verweis bereit, damit CodeBehind, wie etwa Ereignishandlercode, auf ein Markupelement verweisen kann, nachdem es während der Verarbeitung durch einen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Prozessor konstruiert wurde.</summary>
        <value>Der Name des Elements. Der Standardwert ist eine leere Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Verwendung dieser Eigenschaft wird an eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Elementname als ein Attribut im Markup.  
  
 Diese Eigenschaft bietet im Wesentlichen eine WPF-Frameworkebene Hilfseigenschaft Festlegen der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Namen müssen innerhalb eines Namescope eindeutig sein. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Abrufen einer <xref:System.Windows.FrameworkElement.Name%2A> bei der Erstellung der Elemente im Code wird nicht empfohlen. Wenn Sie den entsprechenden Verweis bereits im Code haben, rufen Sie einfach Methoden und Eigenschaften für das Element verweisen und nicht der Fall ist im Allgemeinen müssen die <xref:System.Windows.FrameworkElement.Name%2A>. Eine Ausnahme wird Wenn das <xref:System.Windows.FrameworkElement.Name%2A> Zeichenfolge verfügt über eine überladene Bedeutung, z. B. ist dies nützlich, um diese Anzeigenamen in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Festlegen eine <xref:System.Windows.FrameworkElement.Name%2A> vom Code-Behind-Wenn die ursprüngliche <xref:System.Windows.FrameworkElement.Name%2A> wurde aus dem Markup festgelegt wird ebenfalls nicht empfohlen, und Ändern der Eigenschaft nach dem Laden der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ändert sich nicht auf den ursprünglichen Objektverweis. Die Objektverweise werden nur erstellt, wenn die zugrunde liegenden Namescopes explizit während der Analyse erstellt werden. Müssen Sie ausdrücklich Aufrufen <xref:System.Windows.FrameworkElement.RegisterName%2A> auf eine effektiv zu ändern, die <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft des bereits geladenen Elements.  
  
 Beachten Sie einen Fall, in dem das Festlegen <xref:System.Windows.FrameworkElement.Name%2A> von Code ist wichtig ist, beim Registrieren von Namen für Elemente, für die storyboards ausgeführt, damit sie bei der Ausführung verwiesen werden kann. Bevor Sie einen Namen registrieren können, möglicherweise müssen Sie auch instanziieren und Zuweisen einer <xref:System.Windows.NameScope> Instanz. Finden Sie im Beispielabschnitt oder [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Festlegen von <xref:System.Windows.FrameworkElement.Name%2A> über Code verfügt über eingeschränkten, Anwendungen, aber ein Element abrufen <xref:System.Windows.FrameworkElement.Name%2A> wird häufiger verwendet. Ein bestimmtes Szenario ist, wenn Ihre Anwendung ein Navigationsmodell unterstützt, in dem Seiten erneut laden, bei der Anwendung, und der Code zur Laufzeit ist nicht notwendigerweise Code-Behind für diese Seite definiert. Die Hilfsmethode <xref:System.Windows.FrameworkElement.FindName%2A>, steht aus allen <xref:System.Windows.FrameworkElement>, finde, dass jedes Element von <xref:System.Windows.FrameworkElement.Name%2A> suchen Sie in der logischen Struktur für dieses Element, die rekursiv nach Bedarf. Oder Sie können die <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statische Methode der <xref:System.Windows.LogicalTreeHelper>, der auch akzeptiert eine <xref:System.Windows.FrameworkElement.Name%2A> Zeichenfolge als Argument.  
  
 In der Regel verwendet Stammelemente (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> z. B.) implementieren die Schnittstelle <xref:System.Windows.Markup.INameScope>. Implementierungen dieser Schnittstelle sollten erzwingen, dass Namen innerhalb ihres Bereichs eindeutig sein. Die Stammelemente, die diese Schnittstelle definieren, definieren die Grenzen des Namescope auch für alle verknüpften [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 Die <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft dient auch als Bezeichner für andere Prozesse. Z. B. die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Automatisierungsmodell verwendet <xref:System.Windows.FrameworkElement.Name%2A> als AutomationId für Clients und Anbietern.  
  
 Die Zeichenfolgenwerte, die zum <xref:System.Windows.FrameworkElement.Name%2A> haben Sie einige Einschränkungen, wie vom zugrunde liegenden auferlegt [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) von definiert die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Spezifikation. Insbesondere eine <xref:System.Windows.FrameworkElement.Name%2A> muss mit einem Buchstaben oder ein Unterstrich (_) beginnen und darf nur Buchstaben, Ziffern oder Unterstriche enthalten. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> ist eine sehr wenige Abhängigkeitseigenschaften, die nicht animiert werden können (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> ist `true` in den Metadaten), da der Name selbst wichtig für das Festlegen einer Animation ist. Datenbindung einer <xref:System.Windows.FrameworkElement.Name%2A> ist es technisch möglich ist, jedoch ist ein äußerst ungewöhnliches Szenario, da ein datengebundenes <xref:System.Windows.FrameworkElement.Name%2A> den wichtigsten Zweck die Eigenschaft kann nicht verarbeitet werden: um ein ID-Verbindungspunkt für Code-Behind bereitzustellen.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft im Code, und klicken Sie dann den Namen in die neu erstellte registriert <xref:System.Windows.NameScope> durch Aufrufen von <xref:System.Windows.FrameworkElement.RegisterName%2A>. Das hier beschriebene Verfahren ist eine Voraussetzung für das Animieren mit Storyboards, aus, da Storyboards erfordern Zielgruppenadressierung der <xref:System.Windows.FrameworkElement.Name%2A>, und kann nicht als Objektverweis angewendet werden.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Name" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird beim Überschreiben in einer abgeleiteten Klasse immer dann aufgerufen, wenn Anwendungscode oder interne Prozesse <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> aufrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode besitzt keine Standardimplementierung.  
  
 Vorlagen sind der Teil eines Elements abgeschlossenen visuelle Struktur, die die Template-Eigenschaft des stammt eine <xref:System.Windows.Style> , die für das Element angewendet wird. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Abgeleitete Klassen von <see cref="T:System.Windows.FrameworkElement" /> können diese Methode als eine Benachrichtigung für eine Vielzahl von möglichen Szenarien verwenden: 
– Sie können Ihre eigene Implementierung des Codes aufrufen, die den Rest der visuellen Struktur eines Elements erstellt.  
  
– Sie können Code ausführen, der auf der visuellen Struktur aus der angewendeten Vorlagen, wie das Abrufen von Verweisen auf benannte Elemente aus einer Vorlage basiert.  
  
– Sie können Dienste einführen, die nur sinnvoll, vorhanden sind, nach Abschluss die visuelle Struktur aus Vorlagen.  
  
– Sie können festlegen, Status und Eigenschaften der Elemente in der Vorlage, die von anderen Faktoren abhängig sind. Beispielsweise können Eigenschaftswerte nur erkannt werden, zu wissen, das übergeordnete Element, oder wenn eine bestimmte abgeleitete Klasse eine gemeinsame Vorlage verwendet.  
  
Implementierungen sollten immer die basisimplementierung vor eigene Implementierung aufrufen. <see cref="T:System.Windows.FrameworkElement" /> selbst besitzt keinen Standard-Implementierung, aber Beteiligte Klassen können.  
  
 <see cref="T:System.Windows.Controls.Control" /> bietet eine ähnliche Überschreibung <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode besitzt keine Standardimplementierung. Sie sollten dennoch die basisimplementierung aufrufen, für den Fall, dass eine Zwischenklasse in die Vererbung dieser Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt ein wenig [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignismuster auf * Methoden: Es bietet die Möglichkeit, die von abgeleiteten Klassen mit einem Klassenhandler anstelle einer Instanzhandler das übereinstimmende Ereignis zu behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis durch ein untergeordnetes Element, nicht unbedingt das Element sein kann, die Handler aufruft ausgelöst worden, damit Ihre Implementierung den Ereignisargumenten Quelle geschaltet werden müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, die das Ereignis in den meisten Fällen erneut auslösen). Unterklassen von <xref:System.Windows.FrameworkElement> können Handlermethoden für private Klasse aufrufen, wenn das Ereignis entlang der Route empfangen wird. Einem möglichen Szenario werden die Argumente des Ereignisses und absichtlich das Ereignis als behandelt markiert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode besitzt keine Standardimplementierung. Sie sollten dennoch die basisimplementierung aufrufen, für den Fall, dass eine Zwischenklasse in die Vererbung dieser Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt ein wenig [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignismuster auf * Methoden: Es bietet die Möglichkeit, die von abgeleiteten Klassen mit einem Klassenhandler anstelle einer Instanzhandler das übereinstimmende Ereignis zu behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis durch ein untergeordnetes Element, nicht unbedingt das Element sein kann, die Handler aufruft ausgelöst worden, damit Ihre Implementierung den Ereignisargumenten Quelle geschaltet werden müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, die das Ereignis in den meisten Fällen erneut auslösen). Unterklassen von <xref:System.Windows.FrameworkElement> können Handlermethoden für private Klasse aufrufen, wenn das Ereignis entlang der Route empfangen wird. Einem möglichen Szenario werden die Argumente des Ereignisses und absichtlich das Ereignis als behandelt markiert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.GotFocus" />-Ereignis dieses Element auf der Route erreicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu einigen anderen auf * von Basiselementen, verfügbar gemachte Methoden <xref:System.Windows.FrameworkElement.OnGotFocus%2A> verfügt über eine Standardimplementierung. Insbesondere ist eine Implementierung, die die null-Implementierung in der nächsten Ebene des Basiselements, überschreibt <xref:System.Windows.UIElement.OnGotFocus%2A>. Wenn aufgerufen, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> legt entsprechende Fokusverhaltensweise für dieses Element in Fällen, in dem das Ereignis ausgelöst, aus dem aktuellen Element aufgrund der über den Tastaturfokus hat. Die <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Handler kennzeichnet nicht die Ereignisargumente als behandelt, selbst wenn der Fokus auf das aktuelle Element festgelegt ist. Wenn die Quelle des Ereignisses ein anderes Element in der Struktur (nicht das aktuelle Element) war, führt der Handler mit "nothing".  
  
 Sie können angeben, überschreiben diese Methode, um das Standardverhalten der Fokus auf das Element ändern, aber Bedenken Sie, dass die Änderung den Fokus auf diese Weise besser erfüllt werden möglicherweise von lässt nicht zu. das Element, das überhaupt Fokus festgelegt werden (siehe <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie beabsichtigen, die das Ereignis als behandelt, die in den Argumenten zu markieren, sollten Sie folgen für die Ereignisbehandlung in anderen übergeordneten Elemente in der Elementstruktur bekannt sein. Da dieser Handler auf ein Ereignis mit einem bubbling-routing fungiert, Festlegen des Fokus, mit dem aktuellen <paramref name="sender" /> pro Ereignis Argumente eventuell nicht möglich. Fokus müssen möglicherweise zu entweder einer zusammengesetzten untergeordnete Element oder ein übergeordnetes Element, abhängig von der Zusammensetzung bestimmter Steuerelemente führen. Aus diesem Grund das Kennzeichnen eines als behandelt, wird nur empfohlen, wenn während des gesamten Entwicklungsprozesses der visuellen Struktur, der durch das Ereignisrouting ist Teil einer Zusammensetzung eines Steuerelements ist, die Sie erstellt.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.FrameworkElement.Initialized" />-Ereignis aus. Diese Methode wird immer aufgerufen, wenn <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> intern auf <see langword="true" /> festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf diese besondere *-Methode ist nicht als ein Klasse-Handler-Hook. Noch ist es genau folgen Sie den gesamten [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] auf *-Methode-Konvention, dass das übereinstimmende Ereignis durch diese Methode überschreiben und nicht Aufrufen der basisimplementierung unterdrückt werden kann.  
  
 Beachten Sie, dass die <xref:System.Windows.FrameworkElement.IsInitialized%2A> Eigenschaft ist schreibgeschützt, sodass Sie nicht festlegen können <xref:System.Windows.FrameworkElement.IsInitialized%2A> Initialisierungsverhalten zu erzwingen. Anfangsstatus festlegen soll nur von erfolgen die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung dieser virtuellen Methode löst das Ereignis wie oben beschrieben aus. Bei Überschreibungen sollte die Basisimplementierung aufgerufen werden, um dieses Verhalten beizubehalten. Wenn Sie nicht die basisimplementierung aufrufen, nicht nur Sie löst keine der <see cref="E:System.Windows.FrameworkElement.Initialized" /> Ereignisses wie in der Regel von erwartet wird ein <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse, aber Sie werden auch zwei wichtige Stil und das Design Stil Initialisierungsvorgänge, die unterdrücken Durch diese basisimplementierung implementiert.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten, die die geänderte Eigenschaft beschreibt, sowie die alten und neuen Werte.</param>
        <summary>Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.FrameworkElement" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet. Überschreibt <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht vorgesehen, um eigenschaftsänderungen oder invalidierungen in der Regel zu erkennen. Es dient stattdessen für Änderungen an der allgemeinen invalidierung-Muster, wenn bestimmte Informationen über wide Klassifizierungen der Eigenschaften, die bekannt ist.  
  
 Diese Methode wird möglicherweise mehrmals während der Lebensdauer eines Objekts aufgerufen. Aus diesem Grund können Sie eine bessere Leistung erzielen, wenn Sie die Metadaten der bestimmte Eigenschaften überschreiben, und Sie dann fügen <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen für die einzelnen Eigenschaften. Allerdings würden Sie diese Methode verwenden, wenn eine <xref:System.Windows.FrameworkElement> umfasst eine Vielzahl von Wert in wechselseitiger Beziehung Abhängigkeitseigenschaften, oder wenn sie die Logik enthält, wie z. B. Renderingverhalten, die erneut ausgeführt werden, muss einige Fälle von eigenschafteninvalidierungen beziehen.  
  
 Beachten Sie, dass es eine gleichnamige `OnPropertyChanged` Methode mit einer anderen Signatur (der Parametertyp ist <xref:System.ComponentModel.PropertyChangedEventArgs>), die auf eine Reihe von Klassen angezeigt werden können. Dass `OnPropertyChanged` wird für Benachrichtigungen für Daten-Objekt verwendet und ist Teil des Vertrags für <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Rufen Sie die basisimplementierung wird immer als erster Vorgang in Ihrer Implementierung. Geschieht dies nicht die gesamte erheblich deaktiviert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem, wodurch falsche Werte gemeldet werden. Die spezifischen <see cref="T:System.Windows.FrameworkElement" /> Implementierung ist auch zuständig für die Verwaltung der richtigen Zustand für eine Vielzahl von Eigenschaften, die die sichtbare Benutzeroberfläche betreffen. Dazu gehören die visuelle Struktur, die basierend auf Änderungen an Stil zur richtigen Zeit jeweils für ungültig zu erklären.</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Details zu den an der Änderung beteiligten alten und neuen Größen.</param>
        <summary>Löst das <see cref="E:System.Windows.FrameworkElement.SizeChanged" />-Ereignis unter Verwendung der angegebenen Informationen als Teil der möglichen Ereignisdaten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Wenn Sie diese Methode aufrufen, setzen Sie die <xref:System.Windows.FrameworkElement.ActualWidth%2A> -Eigenschaft, die <xref:System.Windows.FrameworkElement.ActualHeight%2A> Eigenschaft oder beide, je nachdem, was als angegeben wird, die in die angegebenen Argumente geändert und das Ereignis wird immer ausgelöst.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode für typische Layoutszenarien nicht. Das Layoutsystem gibt es in einem absichtlich asynchrone Methode, um sicherzustellen, dass alle möglichen Layout anordnen und Measure Fälle berücksichtigt werden. Das Layoutsystem Methoden außer Kraft setzen <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> und <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> sind für eine Anpassung erforderlich Layout in der Regel ausreichend. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> als virtuelle wird verfügbar gemacht werden. Sie können außer Kraft setzen <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> bei Ausnahmefälle zu beheben, bei denen eine verhaltensänderung Laufzeit verknüpfte Ereignisse, die in Kombination mit dem Steuerelement eingeben, kann Neuerstellung Reaktion geben Sie ungenaue Layoutinformationen.  
  
Sie können diese Methode in abgeleiteten Klassen immer noch überschreiben, (es wird geschützt, aber nicht versiegelt). Rufen Sie immer die basisimplementierung bereit, die oben genannte Verhalten beibehalten, es sei denn, Sie sehr spezifische Gründe für das Deaktivieren der WPF-Frameworkebene Standardrenderingverhalten haben. Fehler beim Auslösen der <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> Ereignis nicht standardmäßige Layout-Verhalten verursacht, wenn die WPF-Frameworkebene Layout System Standardimplementierung verwenden.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Der alte Stil.</param>
        <param name="newStyle">Der neue Stil.</param>
        <summary>Wird aufgerufen, wenn sich der verwendete Stil für dieses Element ändert und dadurch das Layout ungültig wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat eine Standardimplementierung, die ein internes Flag festlegt, die die Bedingung geändert Stil angibt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie sollten in der Regel keine diese Methode überschreiben. Ändern Sie in ein Format, das umfasst ein Measure oder ordnen Sie die Änderung ausgelöst würde bereits eine andere Rendering-Zyklus, vorausgesetzt eine typische Implementierung der <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, oder die Standardwerte. Überschreibungen der <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> kann sinnvoll sein, wenn Ihre <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> Implementierungen wurden absichtlich optimieren oder teilweise Updates unterstützen jedoch weiterhin Änderungen direkt an den Stilen zu übernehmen möchten. (Die teilupdates wäre ein Versuch, mehrere inkrementelle Aufrufe zu vermeiden <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> und <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> auf seine untergeordneten Elemente).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode besitzt keine Standardimplementierung. Sie sollten dennoch die basisimplementierung aufrufen, für den Fall, dass eine Zwischenklasse in die Vererbung dieser Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt ein wenig [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignismuster auf * Methoden: Es bietet die Möglichkeit, die von abgeleiteten Klassen mit einem Klassenhandler anstelle einer Instanzhandler das übereinstimmende Ereignis zu behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis durch ein untergeordnetes Element, nicht unbedingt das Element sein kann, die Handler aufruft ausgelöst worden, damit Ihre Implementierung den Ereignisargumenten Quelle geschaltet werden müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, die das Ereignis in den meisten Fällen erneut auslösen). Unterklassen von <xref:System.Windows.FrameworkElement> können Handlermethoden für private Klasse aufrufen, wenn das Ereignis entlang der Route empfangen wird. Einem möglichen Szenario werden die Argumente des Ereignisses und absichtlich das Ereignis als behandelt markiert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode besitzt keine Standardimplementierung. Sie sollten dennoch die basisimplementierung aufrufen, für den Fall, dass eine Zwischenklasse in die Vererbung dieser Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt ein wenig [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignismuster auf * Methoden: Es bietet die Möglichkeit, die von abgeleiteten Klassen mit einem Klassenhandler anstelle einer Instanzhandler das übereinstimmende Ereignis zu behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis durch ein untergeordnetes Element, nicht unbedingt das Element sein kann, die Handler aufruft ausgelöst worden, damit Ihre Implementierung den Ereignisargumenten Quelle geschaltet werden müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, die das Ereignis in den meisten Fällen erneut auslösen). Unterklassen von <xref:System.Windows.FrameworkElement> können Handlermethoden für private Klasse aufrufen, wenn das Ereignis entlang der Route empfangen wird. Einem möglichen Szenario ist die Argumente des Ereignisses und absichtlich markieren Sie das Ereignis als behandelt, um die Route zu kürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das alte übergeordnete Element. Kann <see langword="null" /> sein, um anzugeben, dass das Element zuvor über kein visuelles übergeordnetes Element verfügt hat.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element dieses Elements in der visuellen Struktur geändert wird. Überschreibt <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die visuelle Struktur unterscheidet sich möglicherweise von der logischen Struktur da Elemente weggelassen wird, die nicht visuell, z. B. Sammlungen, rendern und einige Elemente auf der Grundlage ihrer Zusammensetzung-Design- und erweitert. Weitere Informationen finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung dieser virtuellen Methode fragt das neue übergeordnete Element löst Initialisierungsereignisse aus verschiedenen und internen Flags zum Status der Initialisierung des legt die <see cref="T:System.Windows.FrameworkElement" /> je nach Bedarf. Schließlich ruft es gemäß der Deklaration durch aufeinander folgende basisimplementierungen <see cref="T:System.Windows.UIElement" />, wiederum ruft die Basis in <see cref="T:System.Windows.Media.Visual" />. Rufen Sie immer die basisimplementierung bereit, dieses Verhalten beizubehalten, andernfalls das Verhalten für die Struktur von Elementen für dieses Element wird als ein untergeordnetes Element eines anderen Elements deklariert möglicherweise nicht wie erwartet.  
  
Einige vorhandene [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Klassen überschreiben diese Methode, z. B.: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Das häufigste Szenario ist, um zu erzwingen, dass das neue übergeordnete Element eines bestimmten Typs sein muss. Dabei wird z. B. eine Ausnahme auszulösen, wenn das neue übergeordnete Element einige Typtest fehlgeschlagen ist. Eine spezielle Version dieses Szenarios, die in den Implementierungen für Listenelemente und Menüelemente, die keine außerhalb einer übergeordneten visuellen sinnvoll sind, die zum Speichern in eine entsprechende Sammlung besitzt vorhanden ist. Beachten Sie, dass es sich bei diesen Fällen nicht unbedingt Ausnahmen ausgelöst, da möglicherweise gibt es Szenarien, die für die neuzuordnung des übergeordneten Elements der Elemente, die vorübergehend ohne "regular" ihren übergeordneten Elementen basieren.  
  
Diese Methode wird auch in bestimmte Elemente, die in der Regel das Stammelement, wie z. B. überschrieben <see cref="T:System.Windows.Window" />. Ein weiterer Fall ist, Elemente, die das Stammelement in Markup, aber der automatischen Generierung eine größere Infrastruktur in einer kompilierten logischen Struktur (z. B. <see cref="T:System.Windows.Controls.Page" />). Die <see cref="T:System.Windows.Window" /> und <see cref="T:System.Windows.Controls.Page" /> Implementierungen absichtlich versiegeln Sie die Methode.</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt einen Wert fest, der angibt, ob dieses Element die Formatvorlageneigenschaften aus Designformatvorlagen enthalten soll.</summary>
        <value>
          <see langword="true" />, wenn dieses Element keine Designstileigenschaften verwendet, alle auf Stile zurückgehenden Eigenschaften aus den Stilen lokaler Anwendungen stammen und die Designstileigenschaften nicht angewendet werden. <see langword="false" />, wenn Anwendungsstile vor Designstilen auf Eigenschaften angewendet werden, die in Anwendungsstilen nicht explizit festgelegt wurden. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Verwendung dieser Eigenschaft ist eine indirekte Verwendung innerhalb der Setter eines Formats, der einen Designstil bereitstellt.  
  
> [!IMPORTANT]
>  Setzen Sie <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> zu `true` auf ein Steuerelement, Sie werden unterdrückt die standardmäßige Steuerelementvorlage, die vom Design-Stilen. Diese Steuerelementvorlage enthält in der Regel die ContentPresenter und andere zusammengesetzte Elemente, die grundlegende bereitstellen [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Funktionalität und die Visualisierung für das Steuerelement. Wenn Sie das Steuerelement, das weiterhin die gleichen Features wie den Standardwert Designstilen unterstützen möchten, müssen Sie ein anderes Format mit einer Steuerelementvorlage angeben, die die gleiche Struktur repliziert. Weitere Informationen finden Sie unter [Übersicht über das Erstellen von Steuerelementen](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das logische übergeordnete Element dieses Elements ab.</summary>
        <value>Das logische übergeordnete Element dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> möglicherweise `null` in Fällen, in dem ein Element instanziiert wurde, aber nicht an eine logische Struktur, die schließlich mit dem Stammelement auf Seitenebene oder dem Anwendungsobjekt verbindet angefügt ist.  
  
 Beachten Sie, dass das logische übergeordnete Element eines Elements abhängig von Ihrer Anwendung Funktionen ändern kann, und halten den Wert dieser Eigenschaft sich nicht auf diese Änderung spiegeln. Sie sollten den Wert in der Regel erhalten, unmittelbar bevor Sie sie benötigen.  
  
 Finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) für Weitere Informationen zum Durchlaufen der logischen Struktur und die Szenarios, das bei Verwendung <xref:System.Windows.FrameworkElement.Parent%2A> als Verfahren des übergeordneten Elements Ermittlung geeignet ist.  
  
 Die Eigenschaften-Engine wird möglicherweise neu berechnen aller Eigenschaftswerte eines Elements, wenn sie erneut, übergeordnet ist, da einige Eigenschaften Werte durch die logische Struktur erben. Die <xref:System.Windows.FrameworkElement.DataContext%2A> , die für gilt für Bindungen können auch ändern, wenn Elemente neu zugeordnet werden.  
  
 Ändern die übergeordnete Element eines Elements in der Regel erfolgt nur über die Bearbeitung von Auflistungen können mithilfe von dedizierten hinzufügen oder entfernen-Methoden oder durch Festlegen der Content-Eigenschaften von Elementen.  
  
 Das häufigste Szenario für die Verwendung der <xref:System.Windows.FrameworkElement.Parent%2A> Eigenschaft ist, rufen Sie einen Verweis, und rufen Sie anschließend auf verschiedene <xref:System.Windows.FrameworkElement> Eigenschaftswerte aus dem übergeordneten Element. Für Vorlagen die <xref:System.Windows.FrameworkElement.Parent%2A> der Vorlage schließlich werden `null`. Um über diesen Punkt hinaus zu erhalten, und erweitern in der logischen Struktur, in dem tatsächlich die Vorlage angewendet wird, verwenden Sie <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Beachten Sie, dass diese Eigenschaft keine übergeordneten Elemente einer visuellen Struktur meldet, wenn diese von der übergeordneten Struktur abweichen. Visuelle Struktur übergeordnete Elemente sind nicht für allgemeine Fälle in der Regel wichtig, aber möglicherweise die gewünschte übergeordnete Elemente für bestimmte visuelle Ebene Fälle. Siehe <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt Code, der für das übergeordnete Element eines Elements überprüft und verwendet dann die Eigenschaftswerte aus dem übergeordneten, um die Eigenschaften für das untergeordnete Element entsprechend festlegen. In diesem Fall sind dies die Eigenschaften, die Renderinggröße für die auswirken.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Das untergeordnete Element, das die Änderung meldet.</param>
        <summary>Unterstützt inkrementelle Layoutimplementierungen in spezielle Unterklassen des <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> wird aufgerufen, wenn ein untergeordnetes Element eine Eigenschaft für ungültig erklärt hat, die in den Metadaten entsprechend markiert ist, dass sie das Measure oder die Anordnungsdurchläufe des übergeordneten Elements während des Layouts beeinflusst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element ein untergeordnetes Element verfügt, auf dem eine Eigenschaft für ungültig erklärt und die Eigenschaft wurde als markiert <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> oder <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> in den Metadaten während der Registrierung, der diese Methode wird aufgerufen. Der Methodenaufruf benachrichtigt das übergeordnete Element der jeweilige untergeordnete Element erneut gemessen sein muss, wenn dieses Element (inkrementell) Teilupdate Layout unterstützt.  
  
 In der Standardeinstellung <xref:System.Windows.FrameworkElement> inkrementelles Layout wird nicht unterstützt und in der <xref:System.Windows.FrameworkElement> Klasse diese Methode keine Standardimplementierung besitzt. Das Szenario, in dem diese Methode überschreiben erforderlich wäre, ist selten, da Sie so ändern Sie das Standardverhalten des Layout erforderlich ist.  
  
 Ein Beispielszenario für die Implementierung möglicherweise bei eine Klasse Typ-Einschränkungen für mögliche untergeordnete Elemente, die wesentlich restriktiver ist als das Layoutsystem von WPF-Frameworkebene sind. Aufgrund der Natur dieser benutzerdefinierte Elemente können die eigenschaftsänderungen absichtlich zurückgestellt werden, wenn Sie ein benutzerdefiniertes Layout-Verhalten implementieren. Measure/anordnen methodenüberschreibungen, die versuchen, das untergeordnete Element optimieren Renderings, können z. B. für bestimmte Arten von Änderungen zurückgestellt werden, die normalerweise eine weitere Layoutphase führen würde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Die Richtung, für die eine mögliche Fokusänderung bestimmt werden soll.</param>
        <summary>Bestimmt das nächste Element, das relativ zu diesem Element den Fokus in einer angegebenen Fokusverschiebungsrichtung erhalten würde, verschiebt den Fokus jedoch nicht.</summary>
        <returns>Das nächste Element, auf das der Fokus verschoben würde, wenn der Fokus tatsächlich durchlaufen würde. Kann <see langword="null" /> zurückgeben, wenn der Fokus für die bereitgestellte Richtung nicht relativ zu diesem Element verschoben werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> ist die entsprechende Methode, die tatsächlich den Fokus verschiebt.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der mehrere mögliche Schaltflächeneingaben, jede Schaltfläche, die eine mögliche darstellt behandelt <xref:System.Windows.Input.FocusNavigationDirection>. Der Handler verfolgt das Element mit dem aktuellen Tastaturfokus und ruft <xref:System.Windows.FrameworkElement.PredictFocus%2A> auf diesem Element und gibt die entsprechende <xref:System.Windows.Input.FocusNavigationDirection> als Initialisierung für die <xref:System.Windows.Input.TraversalRequest> Typparameter angegeben. Anstatt auf das betreffende Element als <xref:System.Windows.FrameworkElement.MoveFocus%2A> dazu, der Handler ändert sich die physischen Abmessungen des Ziels vorhergesagten Fokus für Zwecke der Visualisierung.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Gibt eine der folgenden Richtungen im <see cref="T:System.Windows.Input.TraversalRequest" /> an: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Diese Richtungen sind für <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> unzulässig (aber für <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> zulässig).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Name für die angegebene Namensobjektzuordnung.</param>
        <param name="scopedElement">Objekt für die Zuordnung.</param>
        <summary>Stellt einen Accessor bereit, der Zugriff auf die <see cref="T:System.Windows.NameScope" />-Registrierungsmethode vereinfacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen <xref:System.Windows.NameScope.RegisterName%2A>. Die Implementierung überprüft aufeinanderfolgenden, übergeordneten Elementen, bis die entsprechende <xref:System.Windows.NameScope> -Implementierung, die gefunden wird, suchen Sie ein Element, das implementiert <xref:System.Windows.Markup.INameScope>. Weitere Informationen zu Namescopes finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Aufrufen von <xref:System.Windows.FrameworkElement.RegisterName%2A> ist erforderlich, um ordnungsgemäß einbinden Animationsstoryboards für Anwendungen, wenn im Code erstellt. Dies ist, da einer der Schlüsselwerte storyboard-Eigenschaften, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, eine Laufzeit-Suche verwendet, statt einen Verweis auf ein Target-Element zu nutzen. Dies gilt auch, wenn dieses Element durch einen Verweis aus dem Code zugegriffen werden. Weitere Informationen darüber, warum zum Registrieren von Namen für die Storyboard-Zielen müssen finden Sie unter [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das zu entfernende Element.</param>
        <summary>Entfernt das angegebene Objekt aus der logischen Struktur dieses Elements. <see cref="T:System.Windows.FrameworkElement" /> aktualisiert die übergeordneten Zeiger des betroffenen logischen Baums, um ihn mit der Löschung synchron zu halten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode für die Implementierung von Sammlungen für Objekte, die logischen untergeordneten Elemente eines Elements darstellen. Dies kann erfolgen, in der Eigenschaftengetter oder Setter, Klassenhandler von `Changed` Ereignisse, Konstruktoren, oder in der Auflistung selbst.  
  
 Für Autoren von Steuerelementen bearbeiten die logische Struktur auf dieser Ebene nicht die empfohlene Vorgehensweise besteht, wenn keines der Klasse bereitgestellten Basissteuerelement Inhaltsmodelle geeignet sind. Betrachten Sie Unterklassen auf der Ebene der <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, und <xref:System.Windows.Controls.HeaderedItemsControl>. Diese Klassen bieten ein Inhaltsmodell mit bestimmten Durchsetzung von logischen untergeordneten Elemente über dedizierte [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], sowie Unterstützung für andere Funktionen, die in der Regel erwünscht, in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelement wie die Formatierung mithilfe von Vorlagen.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert eine `Child` Eigenschaft in einem benutzerdefinierten <xref:System.Windows.FrameworkElement> , die eine eigene Implementierung der visuellen Ebene ist. Den Setter der Eigenschaft ist so konzipiert, dass wenn der Wert ändert, der alte Wert aus der logischen Struktur als auch eine visuelle Sammlung von mandantenklassen geltenden schemaanpassungen entfernt wird. Die Werte werden zwischengespeichert, und der neue Wert wird dann sowohl die standardmäßigen WPF-Framework auf logische Struktur und der Sammlung von benutzerdefinierten visual hinzugefügt.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> für dieses Element aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis gibt an, an ein übergeordnetes Element <xref:System.Windows.Controls.ScrollViewer> (oder abgeleitete Klasse), wenn das Element, das auslöst, die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis sichtbar gemacht werden soll den bildlauffähigen Bereich. Die <xref:System.Windows.Controls.ScrollViewer> dann markiert die <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis als behandelt, durch das Klasse behandeln des Ereignisses,. Im allgemeinen <xref:System.Windows.FrameworkElement.RequestBringIntoView> Daten sollten nicht werden als behandelt markiert wurden durch alle Klassen, die einen Bildlaufbereich durchführt oder von einem Ereignis Instanz Handler auf, da dies das beabsichtigte Ziel des Elements beeinträchtigen würde, die aufgerufen <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das lokal definierte Ressourcenwörterbuch ab oder legt es fest.</summary>
        <value>Das derzeit lokal definierte Ressourcenwörterbuch, in dem mit einem Schlüssel auf jede Ressource zugegriffen werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ressourcenverzeichnisse, die vollständig oder teilweise in definiert werden können [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] werden in der Regel als ein Property-Element erstellt und sind in der Regel für das Stammelement für die einzelnen Seiten oder für die Anwendung. Platzieren das Ressourcenverzeichnis auf dieser Ebene erleichtert die von einzelnen untergeordneten Elemente auf der Seite (oder von einer beliebigen Seite, bei der Anwendung) zu suchen. In den meisten Anwendungsszenarien, wird empfohlen, Stile, die als Object-Elemente in einem Ressourcenverzeichnis definiert werden oder als externe Ressourcen definiert werden, damit die gesamte Stilressource eigenständig sein kann (Dadurch werden separate-Designer Zuständigkeiten von Entwickleraufgaben durch die Trennung der physischen Dateien, die bearbeitet werden müssen).  
  
 Beachten Sie, dass diese Eigenschaft gibt nur das Ressourcenverzeichnis direkt innerhalb dieses Elements deklariert. Dies ist anders als die eigentliche Ressource Lookup-Prozess, in dem ein untergeordnetes Element eines in jedem übergeordneten Element, die Suche rekursiv aufwärts definierten Ressourcen zugreifen können.  
  
 Ressourcen können auch Code aus der Auflistung verwiesen werden, aber beachten Sie, dass Ressourcen in erstellt [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wird definitiv nicht zugegriffen werden erst nach dem <xref:System.Windows.FrameworkElement.Loaded> wird ausgelöst, durch das Element, das das Wörterbuch deklariert. Ressourcen werden in der Tat analysiert, asynchron und nicht selbst die <xref:System.Windows.FrameworkElement.Loaded> Ereignis ist eine Zusicherung, die Sie verweisen können eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Ressource definiert. Aus diesem Grund sollten Sie in der Regel nur auf zugreifen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sich systemdefinierte Ressourcen als Teil der Laufzeitcode oder über andere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Techniken wie z. B. Stile oder ressourcenerweiterungsparameter für Attributwerte. Zugriff auf Ressourcen über Code entspricht im Wesentlichen um einen Verweis, die von [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Die zugrunde liegende <xref:System.Windows.ResourceDictionary> unterstützt die Methoden zum Hinzufügen, entfernen oder Abfragen von Ressourcen in der Auflistung mithilfe von Code erforderlich. Die <xref:System.Windows.FrameworkElement.Resources%2A> Eigenschaft kann festgelegt werden, um die Unterstützung des Szenarios vollständig ersetzen die ressourcenauflistung der Elemente in ein neues oder anderes sein <xref:System.Windows.ResourceDictionary>.  
  
 Beachten Sie, dass die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] gezeigte Syntax enthält kein Element für die <xref:System.Windows.ResourceDictionary>. Dies ist ein Beispiel für die implizite Auflistungssyntax; Ein Tag, das das Auflistungselement darstellt, kann ausgelassen werden. Die Elemente, die als Elemente der Auflistung hinzugefügt werden, werden stattdessen angegeben. Weitere Informationen zu impliziten Sammlungen und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], finden Sie unter [XAML-Syntax im Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Ein Fall, in denen eine <xref:System.Windows.ResourceDictionary> wird immer noch explizit angegeben, wie ein Element ist, wenn Sie ein zusammengeführtes Wörterbuch vorgestellt werden, in diesem Fall stehen in der Regel keine untergeordneten Elemente für diesen <xref:System.Windows.ResourceDictionary>. Weitere Informationen finden Sie unter [zusammengeführte Ressourcenverzeichnisse](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreResourceElements*  
 Eine oder mehrere Object-Elemente, die jeweils eine Ressource definieren. Jede Ressource Property-Element innerhalb der einzelnen <xref:System.Windows.ResourceDictionary> müssen einen eindeutigen Wert für die [X: Key Directive](~/docs/framework/xaml-services/x-key-directive.md), der dient als eindeutige Schlüssel beim Abrufen von Werten aus der <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">X: Key-Attribut</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordnet eine Bindung zu diesem Element für die angegebene Abhängigkeitseigenschaft zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Gibt die Zieleigenschaft an, für die die Bindung eingerichtet werden soll.</param>
        <param name="path">Der Name der Quelleigenschaft oder der Pfad zu der für die Bindung verwendeten Eigenschaft.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Namens der Quelleigenschaft als Pfadangabe zur Datenquelle eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, der die aktuelle Instanz als übergibt die <xref:System.Windows.DependencyObject>, und erstellt einen neuen <xref:System.Windows.Data.Binding> auf Basis der bereitgestellten `path` Parameter. Diese Signatur ist Benutzerfreundlicher, wenn Sie eine einfachen Bindung hergestellt werden. Wenn Sie müssen alle Bindungseigenschaften auf nicht standardmäßige Bedingungen anzugeben, oder verwenden möchten eine <xref:System.Windows.Data.MultiBinding> oder <xref:System.Windows.Data.PriorityBinding>, verwenden Sie die <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> Signatur.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Bindung mit einem bestimmten Pfad.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Gibt die Eigenschaft an, für die die Bindung eingerichtet werden soll.</param>
        <param name="binding">Stellt die Merkmale der Datenbindung dar.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Bindungsobjekts eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, der die aktuelle Instanz als übergibt die <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, das eine Flussrichtung angibt.</param>
        <param name="value">Ein Wert der Enumeration, der die Richtung angibt.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Eigenschaft für das angegebene Element fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Syntax für angefügte Eigenschaften der <xref:System.Windows.FrameworkElement.FlowDirection%2A> -Eigenschaft untergeordnete Elemente eines bereitgestellten <xref:System.Windows.FrameworkElement> Richtung des Inhaltsflusses für die Anordnung in ihrem übergeordneten Element an. Zum Festlegen des Werts für die aktuelle <xref:System.Windows.FrameworkElement>, verwenden Sie die direkte [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Die Eigenschaft, an die die Ressource gebunden ist.</param>
        <param name="name">Der Name der Ressource.</param>
        <summary>Sucht eine Ressource mit dem angegebenen Namen und richtet einen entsprechenden Ressourcenverweis für die angegebene Eigenschaft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Verweis auf die Ressource ist vergleichbar mit der Verwendung von einem [DynamicResource-Markuperweiterung](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) im Markup. Verweis auf die Ressource erstellt einen internen Ausdruck, der den Wert der angegebenen Eigenschaft im zurückgestellten Laufzeit bereitstellt. Der Ausdruck wird erneut ausgewertet werden, wenn das Ressourcenverzeichnis einen geänderten Wert durch interne Ereignisse angibt oder wenn das aktuelle Element erneut übergeordnet ist (eine übergeordnetes Element die Änderung wird den Wörterbuch-Lookup-Pfad ändern).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der <see cref="P:System.Windows.FrameworkElement.Resources" />-Eigenschaft serialisieren sollen.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Resources" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Als Ergebnis erhalten `true` so lange, wie mindestens eine Ressource mit Schlüssel in der lokalen <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der <see cref="P:System.Windows.FrameworkElement.Style" />-Eigenschaft serialisieren sollen.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Style" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Als Ergebnis erhalten `true` Wenn die <xref:System.Windows.Style> lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der <see cref="P:System.Windows.FrameworkElement.Triggers" />-Eigenschaft serialisieren sollen.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Triggers" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `true` Wenn die <xref:System.Windows.FrameworkElement.Triggers%2A> Eigenschaft lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Wert der <see cref="P:System.Windows.FrameworkElement.ActualHeight" />-Eigenschaft oder der <see cref="P:System.Windows.FrameworkElement.ActualWidth" />-Eigenschaft für dieses Element ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routingereignisse führen Sie eine Route nicht, sondern werden nur innerhalb des gleichen Elements, auf dem sie ausgelöst werden, behandelt. Unterstützen direkte Routingereignisse andere Routingereignisverhaltens: sie unterstützen eine Auflistung der Handler der zugegriffen werden kann, und können verwendet werden, als ein <xref:System.Windows.EventTrigger> in einem Stil.  
  
 Das Layoutsystem liest Eigenschaften innerhalb der <xref:System.Windows.SizeChangedEventArgs> argumentklasse für dieses Ereignis, um festzustellen, ob die größenveränderung der gemeldeten als signifikant angesehen werden soll. Dadurch kann das Layoutsystem oder Ihre steuerelementspezifische layoutimplementierungen vermieden, dass eine layoutänderung aufgrund der visuell nicht wahrnehmbar Unterschiede zwischen alten und neuen Höhe oder Breitenwerte. Die nicht wahrnehmbar Unterschiede möglicherweise aufgrund von Rundung oder dasselbe Ergebnis von Berechnungen von deren ein Gleitkomma-Datentypen.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Routing-Strategie|Direkt|  
|delegate|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.SizeChanged" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Quellwert für eine vorhandene Eigenschaft ändert, die an dieses Element gebunden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Data.Binding.SourceUpdated> -Ereignis, das ausgelöst wird, von einem <xref:System.Windows.Data.Binding> mit diesem Element verknüpft sind.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von diesem Element beim Rendern verwendeten Stil ab oder legt ihn fest.</summary>
        <value>Der übernommene und nicht dem Standardstil entsprechende Stil für das Element, wenn ein Stil vorhanden ist. Andernfalls <see langword="null" />. Der Standardwert für ein mit den Standardwerten konstruiertes <see cref="T:System.Windows.FrameworkElement" /> ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Steuerelemente ist der aktuelle Stil häufig von einer Standardformatvorlage aus den Steuerelementdesigns bereitgestellt oder von Stilen in der Regel auf Steuerelemente angewendet werden von diesem Typ von Ressourcen auf Seiten- oder Anwendungsebene (ein impliziter Stil). Diese Eigenschaft ist nicht festgelegt oder return-Standard Designstile, aber es gibt entweder eine implizite oder explizite Stil, der für das Element fungiert zurück. Im Fall von impliziten oder expliziten Stilen spielt es keine Rolle, ob der Stil als eine Ressource angegeben oder lokal definiert ist.  
  
 Festlegen der Stile weist einige Einschränkungen. Sie können die gesamte zurücksetzen <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft, um ein neues <xref:System.Windows.Style> erzwingt die zu jedem Zeitpunkt eine Neuerstellung Layout. Allerdings so schnell wie Stil verwendet verwendet wird, von einem geladenen Element, das <xref:System.Windows.Style> angesehen werden versiegelt. Eine einzelne Eigenschaft eines Stils verwendet eine Änderung vornehmen möchten (z. B. ein Element innerhalb der Auflistung von <xref:System.Windows.Style.Setters%2A>) löst eine Ausnahme ausgelöst wird. Ein Format, das im Markup definierte gilt, sobald es, aus einem Ressourcenverzeichnis (für Ressourcen geladen wird), oder der Seite, die, der es enthalten ist (für Inlineformatvorlagen laden) verwendet werden.  
  
 <xref:System.Windows.FrameworkElement.Style%2A> ist eine Abhängigkeitseigenschaft mit besonderer Rangfolge. Die lokal festgelegte Format, die in der Regel mit der höchsten Priorität im Eigenschaftensystem verarbeitet werden. Wenn die <xref:System.Windows.FrameworkElement.Style%2A> null ist an diesem Punkt während des Ladens, die Eigenschaft wird überprüft, ob implizite Stile in die lokale oder eine Anwendung Ressourcen, die diesen Typ angeben. Wenn nach diesem Schritt das Format noch null ist wird der verwendete Stil für die Darstellung in der Regel aus den Standardstil (Design), aber das Standardformat nicht, in zurückgegeben wird der <xref:System.Windows.FrameworkElement.Style%2A> -Eigenschaftswert. Finden Sie unter [Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) oder [Stile und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceExtension*  
 Eine der folgenden:, oder. Finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Der Schlüssel, der das angeforderte Format identifiziert. Der Schlüssel verweist auf eine vorhandene Ressource in einem <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Eigenschaftenelement-Syntax ist technisch möglich, aber nicht empfohlen, für die meisten Style-Szenarien. Finden Sie unter [Inlinestile und-Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ein Bindung mit oder <xref:System.Windows.Data.Binding> ist auch möglich, jedoch nicht empfohlen.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Stil in einem Ressourcenverzeichnis definiert.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Style" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter der <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />-Methode.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="propertyName" /> verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.FrameworkElement>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen beliebigen Objektwert ab, der zum Speichern von benutzerdefinierten Informationen zu diesem Element verwendet werden kann, bzw. legt diesen fest.</summary>
        <value>Der vorgesehene Wert. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist analog zu den Tag-Eigenschaften in anderen Microsoft-Programmiermodellen, wie Visual Basic für Applikationen oder Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> richtet sich an einen bereits vorhandenen Eigenschaft-Standort angeben, können Sie sich für eine grundlegende benutzerdefinierte Informationen speichern <xref:System.Windows.FrameworkElement> ohne dass Sie ein Element um eine Unterklasse.  
  
 Da diese Eigenschaft auf ein Objekt akzeptiert, müssen Sie die Verwendung des Elements verwenden, um einzurichten der <xref:System.Windows.FrameworkElement.Tag%2A> Eigenschaft in XAML auf etwas anderes als ein Objekt mit einem bekannten und integrierten Typkonverter, z. B. eine Zeichenfolge. Objekte, die auf diese Weise verwendet befinden sich in der Regel nicht in der standard-WPF-Namespaces und daher möglicherweise Namespacezuordnung zu der externe Namespace um als XAML-Elemente eingeführt werden. Weitere Informationen finden Sie unter [XAML-Namespaces und Namespace-Zuordnung für WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) und [XAML und benutzerdefinierte Klassen für WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Tag" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Zielwert für eine Eigenschaftenbindung bei diesem Element ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Data.Binding.TargetUpdated> -Ereignis, das ausgelöst wird, von einem <xref:System.Windows.Data.Binding> mit diesem Element verknüpft sind. Dies bedeutet normalerweise, dass die betreffende Bindung eine bidirektionale Bindung ist, und dass die gebundenen Abhängigkeitseigenschaft, die bestätigt der vorherige Eigenschaftswert jetzt gemäß keine Validierung oder die Zwischenspeicherung Schema, das die Eigenschaft oder der Datenquelle nicht ungültig.  
  
 Verwenden Sie die Daten von der <xref:System.Windows.FrameworkElement.TargetUpdated> Ereignis, um die spezifischen Eigenschaften zu ermitteln, für die Aktualisierung des Zielwerts gemeldet wird.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die übergeordnete Vorlage dieses Elements ab. Diese Eigenschaft ist nicht relevant, wenn das Element nicht durch eine Vorlage erstellt wurde.</summary>
        <value>Das Element, dessen <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> erstellt werden, dieses Elements verursacht hat. Dieser Wert ist häufig <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Häufig ist `null` für Objekte, die in Ihrer Anwendungsmarkup oder Code erstellt werden. Dies ist, da Sie diese Objekte nicht direkt, nicht über eine Vorlage erstellen. Objektverweise abgerufen, indem Sie die logische Struktur durchlaufen, ausgehend vom Stamm oder typische Namensverweise, die nicht von einer Vorlage stammen.  
  
 Fälle, in denen <xref:System.Windows.FrameworkElement.TemplatedParent%2A> möglicherweise nicht `null` gehören Vorgänge wie das Treffertests, Behandlung von Ereignissen für bestimmte Low-Level Eingabeereignisse, das Durchlaufen der visuellen Struktur mit <xref:System.Windows.Media.VisualTreeHelper>, oder Arbeiten mit Enumeratoren können die Elemente zurückgegeben werden können, die bereitgestellt wurde aus den Vorlagen. Ein weiterer Fall ist, wenn Sie ausdrücklich Aufrufen <xref:System.Windows.FrameworkTemplate.FindName%2A> für eine vorhandene <xref:System.Windows.FrameworkTemplate> und das zurückgegebene Objekt.  
  
 Vorlagen sind eigentlich freigegebene Objekte, in dem der Inhalt der Vorlage nur einmal erstellt werden. Aus diesem Grund, wenn Sie einen Objektverweis auf ein Element, die aus einer Vorlage stammen abrufen, können Sie feststellen, dass die offensichtliche logische Struktur nicht bis zum Seitenstamm erreicht. Um solche eines vorlagenverweises zum logischen Struktur der Seite verbinden, erhalten Sie die <xref:System.Windows.FrameworkElement.TemplatedParent%2A> Wert ein, und fahren Sie mit der Navigation durch die Elementstruktur wie gewünscht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das QuickInfo-Objekt ab, das für dieses Element in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] angezeigt wird, oder legt dieses Objekt fest.</summary>
        <value>Das QuickInfo-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert dieser Eigenschaft vom Typ <xref:System.Windows.Controls.ToolTip>, lautet dieser Wert die QuickInfo, die in verwendet werden die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Wenn der Wert eines anderen Typs, wird dieser Wert wird als verwendet die *Inhalt* für eine <xref:System.Windows.Controls.ToolTip> bereitgestellt (erstellt), vom System. Weitere Informationen finden Sie unter <xref:System.Windows.Controls.ToolTipService>. Die Dienstklasse stellt angefügte Eigenschaften, die verwendet werden können, um weiter anpassen, einem <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *toolTipContent*  
 Eine Zeichenfolge, der Anzeigetext für wird, den <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Ein Objekt, das bereitgestellt wird, in Form eines Objektelements, die als Inhalt für verwendet werden soll die <xref:System.Windows.FrameworkElement> . In der Regel wäre dies eine <xref:System.Windows.FrameworkElement> oder ein anderes Element, das Layout für die Zusammensetzung von Steuerelementen der <xref:System.Windows.FrameworkElement.ToolTip%2A>, schließlich mit Textinhalt in der Zusammensetzung. In diesem Kontext die <xref:System.Windows.Controls.ToolTip> Element erstellt implizit aus dem analysierten [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], und die *ToolTipObjectContent* Inhalt festgelegt ist, als die <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> Eigenschaft.  
  
 <`ToolTip` … / >  
 Siehe <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Controls.ToolTip> in Code und legt dann die <xref:System.Windows.FrameworkElement.ToolTip%2A> Eigenschaft für eine <xref:System.Windows.Controls.Primitives.StatusBar> Steuerelement.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar vor dem Schließen einer QuickInfo über dem Element ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Markiert die <xref:System.Windows.FrameworkElement.ToolTipClosing> Ereignis als behandelt nicht schließen der QuickInfo ab. Wenn die QuickInfo angezeigt wird, erfolgt nur als Reaktion auf Benutzerinteraktion mit der Benutzeroberfläche schließen der QuickInfo.  
  
 Dieses Ereignis kein <xref:System.Windows.EventTrigger> in einem Stil. Dies ist, da das Bezeichnerfeld für dieses Ereignis eine Implementierung von einem Dienst erneut verwendet, die nicht hinzufügen oder Entfernen von Ereignismethoden für das Service Level-Ereignis verfügbar macht.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Routing-Strategie|Direkt|  
|delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Außer Kraft setzen <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Öffnen einer QuickInfo im Element auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass eine QuickInfo angezeigt werden, in der Benutzeroberfläche der Handler für <xref:System.Windows.FrameworkElement.ToolTipOpening> markieren die <xref:System.Windows.Controls.ToolTipEventArgs> Ereignisdaten behandelt. Andernfalls wird die QuickInfo angezeigt, mit dem Wert des der <xref:System.Windows.FrameworkElement.ToolTip%2A> den QuickInfo-Inhalt-Eigenschaft. Ein anderes mögliches Szenario ist, dass Sie einen Handler schreiben, die den Wert der setzt die <xref:System.Windows.FrameworkElement.ToolTip%2A> -Eigenschaft für das Element, das die Ereignisquelle ist, kurz bevor die QuickInfo angezeigt wird.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> wird nicht ausgelöst werden, wenn der Wert des <xref:System.Windows.FrameworkElement.ToolTip%2A> ist `null` oder auf andere Weise nicht festgelegt. Legen Sie nicht <xref:System.Windows.FrameworkElement.ToolTip%2A> zu `null` während eine QuickInfo geöffnet ist, oder öffnen; Dies hat keine der Auswirkungen der Schließung der QuickInfos und wird stattdessen ein unerwünschten visual-Element in der Benutzeroberfläche erstellen.  
  
 Die <xref:System.Windows.FrameworkElement.ToolTipOpening> Ereignis darf nicht sein. ein <xref:System.Windows.EventTrigger> in einem Stil. Dies ist, da das Bezeichnerfeld für dieses Ereignis eine Implementierung von einem Dienst erneut verwendet, die nicht hinzufügen oder Entfernen von Ereignismethoden für das Service Level-Ereignis verfügbar macht.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Routing-Strategie|Direkt|  
|delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Außer Kraft setzen <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ToolTip" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der direkt für dieses Element oder in untergeordneten Elementen eingerichteten Trigger ab.</summary>
        <value>Eine stark typisierte Auflistung von <see cref="T:System.Windows.Trigger" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Eigenschaft kann nur festgelegt werden, [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] über die Auflistungssyntax angezeigt oder den Zugriff auf das Objekt und dessen verschiedene Methoden wie z. B. hinzufügen. Die Eigenschaft auf das Auflistungsobjekt selbst ist schreibgeschützt, die Sammlung selbst ist Lese-/ Schreibzugriff. Die Eigenschaft ist nur auf Stammelemente vorhanden. Es wird versucht, finden sie ein, oder legen Sie sie an anderer Stelle bewirkt, dass eine Ausnahme ausgelöst werden.  
  
 Diese Eigenschaft ermöglicht nicht das Auslöser zu untersuchen, die als Teil der Formate in der für dieses Element vorhanden sind. Es werden nur die Auflistung von Triggern, die der Auflistung, die entweder im Markup oder Code buchstäblich hinzugefügt werden, gemeldet. Elemente in der Regel keine solche Elemente, die standardmäßig vorhandene (über eine Vorlage für die Instanz); Es ist üblicher für Trigger, die von Steuerelement zusammensetzt in Stilen eingerichtet werden, stattdessen stammen.  
  
 Im Hinblick auf Verhalten (und beim Ermitteln der Auswirkungen aus dem Element deklariert die <xref:System.Windows.FrameworkElement.Triggers%2A> Auflistung), sowohl die auslösende Bedingung und die Auswirkung der Trigger für dieses Element möglicherweise oder möglicherweise auf die untergeordneten Elemente in der logischen Struktur. Beachten Sie, dass Sie Objektlebensdauer-Ereignisse verwenden, z. B. <xref:System.Windows.FrameworkElement.Loaded> rufen Sie diese Auflistung des untergeordneten Elements Trigger möglicherweise noch nicht vollständig geladen, und die Auflistung wird nicht kleiner als der zur Laufzeit sein wird.  
  
 Beachten Sie, das die Auflistung der Auslöser für ein Element wird nur unterstützt <xref:System.Windows.EventTrigger>, nicht Eigenschaftstrigger (<xref:System.Windows.Trigger>). Wenn Sie Eigenschaftstrigger benötigen, Sie müssen diese in Stilen oder Vorlagen platzieren und dann zuweisen Stil oder die Vorlage auf das Element entweder direkt über die <xref:System.Windows.FrameworkElement.Style%2A> -Eigenschaft oder indirekt über eine implizite formatreferenz.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreTriggers*  
 Eine oder mehrere der definierten <xref:System.Windows.EventTrigger> Elemente. Jeder dieser Auslöser wird erwartet, gültige Storyboard-Aktionen und Verweise enthalten. Beachten Sie, dass dieser Auflistung nur für das Stammelement einer Seite hergestellt werden kann. Weitere Informationen finden Sie unter [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner der gesuchten Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Schlüssel und gibt diese Ressource zurück, sofern sie gefunden wurde.</summary>
        <returns>Die gefundene Ressource oder <see langword="null" />, wenn keine Ressource mit dem angegebenen <paramref name="key" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ressource für das aufrufende Element nicht gefunden wird, wird die übergeordnete Ressourcenstruktur nach oben durch die logische Struktur durchsucht, auf die gleiche Weise, die die Struktur gesuchten Wenn eine Ressource nach Schlüssel bei der Ausführung angefordert wurden. Gibt die Methode zurück `null` nur dann, wenn keine Ressource mit diesem Schlüssel eine beliebige Stelle in der Ressourcenstruktur pro der Struktur zum Zeitpunkt der vorhandenen Bedingungen vorhanden waren, <xref:System.Windows.FrameworkElement.TryFindResource%2A> aufgerufen wird.  
  
 In der Regel würden Sie sofort den Rückgabewert in den Typ der Eigenschaft umwandeln, die Sie mit dem Wert für die zurückgegebene Ressource festlegen möchten.  
  
 Die <xref:System.Windows.FrameworkElement.FindResource%2A> Methode verhält sich ähnlich, außer dass es eine Ausnahme auslöst, wenn keine Ressource mit dem angegebenen Schlüssel zurückgegeben wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird als einem Schaltflächenhandler, das die Schaltfläche legt geklickt wird, bei dem der Hintergrund auf eine Ressource definiert Pinsel durch Aufrufen von abgerufen implementiert <xref:System.Windows.FrameworkElement.TryFindResource%2A> für sich selbst. Dies führt die Elementstruktur und sucht nach der Ressource (die Ressource selbst ist in definiert [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] und wird nicht angezeigt).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Element aus einer Elementstruktur geladener Elemente entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routingereignisse führen Sie eine Route nicht, sondern werden nur innerhalb des gleichen Elements, auf dem sie ausgelöst werden, behandelt. Unterstützen direkte Routingereignisse andere Routingereignisverhaltens: sie unterstützen eine Auflistung der Handler der zugegriffen werden kann, und können verwendet werden, als ein <xref:System.Windows.EventTrigger> in einem Stil.  
  
 <xref:System.Windows.FrameworkElement.Loaded> und <xref:System.Windows.FrameworkElement.Unloaded> können sowohl für Steuerelemente, die als Ergebnis der vom Benutzer initiierte Systemdesigns ausgelöst werden. Eine Design Änderung führt zu einer invalidierung von der Steuerelementvorlage und der enthaltenen visuellen Struktur, die wiederum führt dazu, dass das gesamte Steuerelement nicht entladen und neu laden. Aus diesem Grund <xref:System.Windows.FrameworkElement.Unloaded> kann nicht angenommen werden, dass nur auf die Seite verlassen auftreten.  
  
 Beachten Sie, dass die <xref:System.Windows.FrameworkElement.Unloaded> Ereignis wird nicht ausgelöst, nachdem das Herunterfahren eine Anwendung startet. Anwendung wird heruntergefahren, wenn die Bedingung definiert die <xref:System.Windows.Application.ShutdownMode%2A> wird. Setzen Sie Bereinigungscode in einen Handler für die <xref:System.Windows.FrameworkElement.Unloaded> Ereignisses, z.B. für eine <xref:System.Windows.Window> oder <xref:System.Windows.Controls.UserControl>, es kann nicht aufgerufen werden, wie erwartet.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Routing-Strategie|Direkt|  
|delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.Unloaded" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Name/Objekt-Paars, der aus dem aktuellen Bereich entfernt werden soll.</param>
        <summary>Vereinfacht den Zugriff auf die <see cref="T:System.Windows.NameScope" />-Methode zum Aufheben der Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen nur zum Aufheben der Registrierung von Namen, wenn Sie beabsichtigen, ein anderes Element mit diesem Namen erneut zu registrieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet erneut den Standardstil auf den aktuellen <see cref="T:System.Windows.FrameworkElement" /> an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob die Layoutglättung auf die Größe und Position dieses Elements während des Layouts angewendet werden.</summary>
        <value>
          <see langword="true" />, wenn die Layoutglättung angewendet wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> -Eigenschaft für ein Element ist `true`, alle nicht-integrale Pixelwerte, die während der berechnet werden die <xref:System.Windows.UIElement.Measure%2A> und <xref:System.Windows.UIElement.Arrange%2A> übergibt auf ganze Pixelwerte gerundet werden.  
  
 Diese Eigenschaft wird von untergeordneten Elementen geerbt.  
  
> [!NOTE]
>  Sie sollten festlegen <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> zu `true` für das Stammelement. Das Layoutsystem hinzugefügt die übergeordneten Koordinaten untergeordneten Koordinaten; aus diesem Grund, wenn die übergeordneten Koordinaten nicht an einer Pixelgrenze sind, sind die untergeordneten Koordinaten auch nicht auf einer Pixelgrenze. Wenn <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> kann nicht auf der Stammebene festlegen, legen <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> für das untergeordnete Element, um die Auswirkungen zu erhalten, die Sie möchten.  
  
 Zeichnen von Objekten auf Pixelgrenzen entfällt die teilweise transparenten Kanten, die von Antialiasing verwendet wird, erstellt werden, in der Mitte eines Gerätepixels fällt eine Kante. Die folgende Abbildung zeigt die Ausgabe einer einzelnen Pixel Breite-Zeile, die in der Mitte eines Gerätepixels liegt. Die Linie auf der linken Seite verwendet nicht die layoutglättung und Antialiasing wird. Die Zeile auf der rechten Seite wird die layoutglättung verwendet.  
  
 ![Anti&#45;Alias-Zeile, die im Vergleich mit. ] (~/add/media/pixelsnaplinecompare.PNG "Im Vergleich mit Antialiasing-Zeile.")  
  
 Bei Verwendung von layoutglättung und <xref:System.Windows.GridUnitType.Star> Festlegen der Größe des Layoutsystems erstellt kleine abweichungen in der Spalte oder Zeile Messungen werden an die Subpixelrendering zu vermeiden. Beispielsweise wenn ein Raster eine Gesamtbreite von mit 3 Spalten von der Größe 100 <xref:System.Windows.GridUnitType.Star>haben, statt drei Spalten, die gleiche Breite von 33,3, erstellt das Layoutsystem 2 Spalten, die eine Breite von 33 und eine, die eine von 34 Breite.  
  
> [!NOTE]
>  In .NET 4.6 wurden Änderungen an der layoutglättung um Instanzen von Clipping in Steuerelementen mit Begrenzungen zu reduzieren. Dieses Feature ist standardmäßig aktiviert, wenn Ihr Zielframework .NET Framework 4.6 oder höher ist. Anwendungen, die auf frühere Versionen des Frameworks abzielen können in das neue Verhalten entscheiden, indem Sie die folgende Einstellung in einer Datei "App.config" hinzufügen: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` die Einstellung wird nur wirksam, wenn die Anwendung auf .NET Framework 4.6 ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Auswirkungen, die die <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> Eigenschaft, die in einer Zeile für die einzelnen Pixel Breite verfügt. Die Zeile, auf der linken Seite verwendet nicht die layoutglättung und der Zeile auf der rechten Seite wird verwendet, die layoutglättung. Wenn langsam der Fenstergröße ändern, können Sie sich, dem Unterschied, layoutglättung ist sehen.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vertikalen Ausrichtungsmerkmale ab bzw. legt diese fest. Sie werden auf dieses Element angewendet, wenn es Teil von einem übergeordneten Element ist, z. B. von einem Panel-Steuerelement oder von einem ItemsControl-Element.</summary>
        <value>Eine vertikale Ausrichtungseinstellung. Der Standardwert ist <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.Width%2A> Eigenschaften werden für ein Element explizit festgelegt wird, diese Messungen haben Vorrang von Layout und die reguläre Auswirkungen der Einstellung dieser Eigenschaft zum abzubrechen <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> ist die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaftenaccessor für das was in Wirklichkeit eine Abhängigkeitseigenschaft ist. Diese bestimmte Abhängigkeitseigenschaft hat oft einen offensichtlichen "Default"-Wert, der in abgeleitete Elementklassen, insbesondere Steuerelemente festgelegt. Dieser Vorgang erfolgt normalerweise auf zwei Arten: die Abhängigkeitseigenschaft wird zu einer bestimmten abgeleiteten Klasse, aber mit unterschiedlichen Metadaten für das Festlegen seiner Standardeinstellungen; erneut registriert. oder es ist ein Standardformat angewendet wird, der Wert dieser Abhängigkeitseigenschaft unterschiedlich festlegt. Z. B. die scheinbare "Default" der <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> für eine <xref:System.Windows.Controls.ComboBoxItem> -Steuerelement <xref:System.Windows.VerticalAlignment.Center>, auch wenn <xref:System.Windows.Controls.ComboBoxItem> erbt <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> direkt von <xref:System.Windows.FrameworkElement>. Dies ist, da dieser Wert, in den Standardstil der zurückgesetzt wurde <xref:System.Windows.Controls.ComboBoxItem>, in der Vorlage für den Stil des Steuerelements.  
  
 <xref:System.Windows.Controls.Canvas> verwendet keine <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> beim Erstellen des Layouts, da <xref:System.Windows.Controls.Canvas> basiert auf der absoluten Positionierung.  
  
 Wenn von geerbt <xref:System.Windows.Controls.ComboBoxItem> oder abgeleiteten Klassen, <xref:System.Windows.Controls.ComboBoxItem> ändert den Standardwert dieser Eigenschaft sein <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der sichtbaren untergeordneten Elemente innerhalb dieses Elements ab.</summary>
        <value>Die Anzahl der sichtbaren untergeordneten Elemente für dieses Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.FrameworkElement> Implementierung <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> gibt immer entweder NULL oder eins zurück. Klassen, die eine Auflistung der untergeordneten visuellen zu verwalten, die mehr als müssen sowohl diese Eigenschaft überschreiben und <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Diese Eigenschaft wird in der Regel verwendet, um zu bestimmen, der die obere Grenze der aktuellen untergeordneten Auflistung zum Zweck der Implementierung der Layout-Außerkraftsetzungen (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein benutzerdefinierter Adorner wird verwendet, die Werte, der deklariert, indem eine <xref:System.Windows.Media.VisualCollection> verwaltet für die mehreren visuellen untergeordneten Elemente und Berichte diese Werte durch Außerkraftsetzungen der <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> und <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Ihre Klasse mehrere visuelle untergeordnete Elemente in eine Auflistung untergeordneter Elemente unterstützt, überschreiben Sie diese Eigenschaft, um die Anzahl der Elemente in der Auflistung zurück. Dies ist erforderlich, selbst wenn das Auflistungsobjekt selbst zurückgibt. Elementlayoutlogik auf der WPF-Frameworkebene wird davon ausgegangen, dass alle Elemente über eine gültige Anzahl zurückgibt, deren <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> Eigenschaft.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Elements ab bzw. legt diese fest.</summary>
        <value>Ruft die Breite des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] ab. Der Standardwert ist <see cref="F:System.Double.NaN" />. Dieser Wert muss größer oder gleich 0,0 sein. Informationen zur Obergrenze finden Sie unter „Hinweise“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine der drei Eigenschaften auf <xref:System.Windows.FrameworkElement> anzugeben, dass die Breiteninformationen.  Die anderen zwei sind <xref:System.Windows.FrameworkElement.MinWidth%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Ist ein Konflikt zwischen diesen Werten vorliegt, wird die Reihenfolge der Anwendung für die Bestimmung der tatsächlichen Breite zuerst <xref:System.Windows.FrameworkElement.MinWidth%2A> muss dann berücksichtigt, <xref:System.Windows.FrameworkElement.MaxWidth%2A>, und wenn all dies innerhalb der Grenzen, sind <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Der Rückgabewert dieser Eigenschaft ist immer mit dem jeder Wert, der festgelegt wurde. Im Gegensatz dazu ist der Wert des der <xref:System.Windows.FrameworkElement.ActualWidth%2A> abweichen. Das Layout kann die vorgeschlagene Größe aus irgendeinem Grund abgelehnt haben. Das Layoutsystem selbst funktioniert ebenfalls asynchron relativ zu den System-Eigenschaftensatz der <xref:System.Windows.FrameworkElement.Width%2A> und kann nicht verarbeitet, bestimmte Eigenschaftenänderung noch größenanpassung.  
  
 Zusätzlich zu den akzeptablen <xref:System.Double> Werte, die diese Eigenschaft kann auch sein <xref:System.Double.NaN?displayProperty=nameWithType>. Dies ist, wie Sie die automatische Größenanpassungsverhalten angeben. In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sie legen Sie den Wert der Zeichenfolge "Auto" (Groß-/Kleinschreibung) um das automatische Größenanpassungsverhalten zu aktivieren. Das automatische Größenanpassungsverhalten bedeutet, dass das Element die verfügbare Breite ausfüllt. Beachten Sie jedoch, dass bestimmte Steuerelemente häufig Standardwerte in den Standardstilen, die deaktiviert wird, das automatische Größenanpassungsverhalten bereitstellen, es sei denn, sie explizit wieder aktiviert wird.  
  
 Neben der Überprüfung, es gibt eine nicht deterministische obere Grenze für den Wert <xref:System.Windows.FrameworkElement.Width%2A> , die durch das Layoutsystem erzwungen wird (Dies ist eine sehr große Zahl größer als <xref:System.Single.MaxValue?displayProperty=nameWithType> jedoch kleiner als <xref:System.Double.MaxValue?displayProperty=nameWithType>). Wenn Sie diese Grenze überschreiten, wird das Element wird nicht gerendert, und wird keine Ausnahme ausgelöst. Stellen Sie keine <xref:System.Windows.FrameworkElement.Width%2A> auf einen Wert an, die erheblich größer als die maximale Größe jeder mögliche visuelle Darstellung, oder wenn Sie dieses nicht deterministische Obergrenze überschreiten kann.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Die Zeichenfolgendarstellung einer <xref:System.Double> Wert gleich oder größer als 0,0. Informationen zur Obergrenze finden Sie unter „Hinweise“. Dieser Wert wird als interpretiert eine [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Messung. Zeichenfolgen müssen nicht explizit Dezimaltrennzeichen enthalten. Zum Beispiel den Wert `1` akzeptabel ist.  
  
 *qualifiedDouble*  
 Ein *doppelte* Wert, wie oben beschrieben, gefolgt von einer der folgenden Deklaration Zeichenfolgen: `px`, `in`, `cm`, `pt`.  
  
 `px` (Standard) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll. 1 In == 96 px  
  
 `cm` ist Zentimeter. 1cm==(96/2.54) px  
  
 `pt` ist die Punkte. 1pt==(96/72) px  
  
 `Auto`  
 Aktiviert das Verhalten für automatisches Anpassen der Größe. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Width" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>