<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="85905bc2206a3c47a965b60cd236dd544728be4f" /><Meta Name="ms.sourcegitcommit" Value="33529b5cc32683b91d3422992fb4dc422f85782b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/17/2020" /><Meta Name="ms.locfileid" Value="88266130" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface ISupportInitialize&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.RuntimeNameProperty("Name")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.RuntimeNameProperty("Name")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.UsableDuringInitialization(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.UsableDuringInitialization(true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.XmlLangProperty("Language")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.XmlLangProperty("Language")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Satz von Eigenschaften, Ereignissen und Methoden für Elemente auf WPF-Frameworkebene (Windows Presentation Foundation) bereit. Diese Klasse stellt die bereitgestellte Implementierung auf WPF-Frameworkebene dar, die auf den WPF-Kernebenen-APIs basiert, die durch <see cref="T:System.Windows.UIElement" /> definiert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> der Verbindungspunkt zwischen den Element Klassen auf WPF-Frameworkebene und dem WPF-Kernsatz von <xref:System.Windows.UIElement> Präsentations Diensten. Weitere Informationen zu diesen Konzepten finden Sie unter [WPF-Architektur](/dotnet/framework/wpf/advanced/wpf-architecture).  
  
 <xref:System.Windows.FrameworkElement> erweitert <xref:System.Windows.UIElement> und erweitert die folgenden Funktionen:  
  
-   **Layout-Systemdefinition**: <xref:System.Windows.FrameworkElement> stellt bestimmte Implementierungen auf WPF-Frameworkebene für bestimmte Methoden bereit, die als virtuelle Member in definiert wurden  <xref:System.Windows.UIElement> . In den meisten Fällen werden von <xref:System.Windows.FrameworkElement> bestimmte Layout-über Schreibungen für WPF-Kernebenen durchgesetzt, und stattdessen wird eine auf WPF-Frameworkebene äquivalente bereitstellt, die von abgeleiteten Beispielsweise wird von <xref:System.Windows.FrameworkElement> versiegelt, <xref:System.Windows.UIElement.ArrangeCore%2A> aber bereitstellt <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> . Diese Änderungen spiegeln die Tatsache wider, dass auf der WPF-Frameworkebene ein vollständiges Layoutsystem vorhanden ist, das jede <xref:System.Windows.FrameworkElement> abgeleitete Klasse erzeugen kann. Auf der WPF-kernstufe werden bestimmte Member, die eine allgemeine [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] layoutlösung strukturieren, vorhanden sein, aber die tatsächliche Engine des Layoutsystems ist nicht definiert. Weitere Informationen finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
-   **Die logische Struktur:** Das allgemeine [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Programmiermodell wird häufig als eine Struktur von Elementen ausgedrückt. Unterstützung für das Ausdrücken der Struktur von Elementen als logische Struktur und die zugehörige Unterstützung zum Definieren dieser Struktur in Markup wird auf der <xref:System.Windows.FrameworkElement> Ebene implementiert. Beachten Sie jedoch, dass <xref:System.Windows.FrameworkElement> absichtlich kein Inhalts Modell definiert und diese Verantwortung für abgeleitete Klassen verlässt. Weitere Informationen finden Sie unter [Strukturen in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).  
  
-   **Objekt Lebensdauer-Ereignisse:** Häufig ist es hilfreich zu wissen, wann ein Element initialisiert wird (der Konstruktor wird aufgerufen) oder wann das Element zum ersten Mal in eine logische Struktur geladen wird. <xref:System.Windows.FrameworkElement> definiert mehrere Ereignisse im Zusammenhang mit der Objekt Lebensdauer, die nützliche Hooks für Code Behind-Vorgänge bereitstellen, die Elemente einschließen, wie z. b. das Hinzufügen von Weitere Informationen finden Sie unter [Objekt Lebensdauer-Ereignisse](/dotnet/framework/wpf/advanced/object-lifetime-events).  
  
-   **Unterstützung für die Datenbindung und dynamische Ressourcen Verweise:** Die Unterstützung auf Eigenschafts Ebene für Datenbindung und Ressourcen wird von der <xref:System.Windows.DependencyProperty> -Klasse implementiert und im-Eigenschaften System enthalten, aber die Möglichkeit, einen Elementwert aufzulösen, der als <xref:System.Windows.Expression> (das Programmierkonstrukt, das sowohl der Datenbindung als auch der dynamischen Ressourcen zugrunde liegt), wird von implementiert <xref:System.Windows.FrameworkElement> . Weitere Informationen finden Sie unter [Übersicht über Daten Bindungen](/dotnet/framework/wpf/data/data-binding-overview) und [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
-   **Stile:** <xref:System.Windows.FrameworkElement> definiert die- <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Definiert jedoch <xref:System.Windows.FrameworkElement> noch keine Unterstützung für Vorlagen oder unterstützt Decorators. Diese Features werden von Steuerelement Klassen wie <xref:System.Windows.Controls.Control> und eingeführt <xref:System.Windows.Controls.ContentControl> .  
  
-   **Weitere Animations Unterstützung:** Einige Animations Unterstützung wurde bereits auf der WPF-kernstufe definiert, <xref:System.Windows.FrameworkElement> erweitert dies jedoch durch Implementieren von <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> und zugehörigen Membern.  
  
 Wie aus der Klassenhierarchie ersichtlich ist, werden viele [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Klassen von <xref:System.Windows.FrameworkElement> entweder direkt oder über zwischengeschaltete Basisklassen wie <xref:System.Windows.Controls.Panel> oder abgeleitet <xref:System.Windows.Controls.Control> .  
  
 Wenn Sie beabsichtigen <xref:System.Windows.FrameworkElement> , als Basisklasse zu verwenden, sollten Sie zunächst die vorhandenen abgeleiteten Klassen untersuchen. <xref:System.Windows.FrameworkElement> bietet Unterstützung für eine Reihe von grundlegenden Szenarios, verfügt aber auch über eine Reihe von Features, die für ein "-Element" in dem Sinne eines Bausteine, den Sie zum Erstellen von in verwenden, wünschenswert sind [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] . Beispiels <xref:System.Windows.FrameworkElement> Weise definiert ein kein echtes Inhalts Modell, <xref:System.Windows.FrameworkElement> da eine Basisklasse keine Eigenschaft definiert, die untergeordnete Elemente erstellen kann [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] . Insbesondere sollten Sie sich mit <xref:System.Windows.Controls.Control> und befassen <xref:System.Windows.Controls.ContentControl> .  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElement" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gerenderte Höhe dieses Elements ab.</summary>
        <value>Die Höhe des Elements als Wert in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein berechneter Wert, der auf anderen Höhen Eingaben und dem Layoutsystem basiert. Der Wert wird vom Layoutsystem selbst festgelegt, basierend auf einem tatsächlichen Renderingdurchlauf, und kann daher etwas hinter dem festgelegten Wert von Eigenschaften, z <xref:System.Windows.FrameworkElement.Height%2A> . b. der Grundlage der Eingabe Änderung, liegen.  
  
 Da <xref:System.Windows.FrameworkElement.ActualHeight%2A> ein berechneter Wert ist, sollten Sie beachten, dass es möglicherweise mehrere oder inkrementell gemeldete Änderungen an ihm aufgrund von verschiedenen Vorgängen durch das Layoutsystem gibt. Das Layoutsystem berechnet möglicherweise den Bereich für untergeordnete Elemente, Einschränkungen durch übergeordnete Elemente usw.  
  
 Obwohl Sie diese Eigenschaft nicht von festlegen können [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , können Sie <xref:System.Windows.Trigger> auf ihren Wert in einem Stil basieren.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel werden verschiedene Height-Eigenschaften angezeigt.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ActualHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gerenderte Breite dieses Elements ab.</summary>
        <value>Die Breite des Elements als Wert in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein berechneter Wert, der auf anderen breiten Eingaben und dem Layoutsystem basiert. Der Wert wird vom Layoutsystem selbst festgelegt, basierend auf einem tatsächlichen Renderingdurchlauf, und kann daher etwas hinter dem festgelegten Wert von Eigenschaften, z <xref:System.Windows.FrameworkElement.Width%2A> . b. der Grundlage der Eingabe Änderung, liegen.  
  
 Da <xref:System.Windows.FrameworkElement.ActualWidth%2A> ein berechneter Wert ist, sollten Sie beachten, dass es möglicherweise mehrere oder inkrementell gemeldete Änderungen an ihm aufgrund von verschiedenen Vorgängen durch das Layoutsystem gibt. Das Layoutsystem berechnet möglicherweise den Bereich für untergeordnete Elemente, Einschränkungen durch übergeordnete Elemente usw.  
  
 Obwohl Sie diese Eigenschaft nicht von festlegen können [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , können Sie <xref:System.Windows.Trigger> auf ihren Wert in einem Stil basieren.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel werden verschiedene Width-Eigenschaften angezeigt.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ActualWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das hinzuzufügende untergeordnete Element.</param>
        <summary>Fügt der logischen Struktur dieses Elements das bereitgestellte Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode für die Implementierung von Auflistungen für Objekte, die logische untergeordnete Elemente eines Elements darstellen. Die Auflistungs Wartung für untergeordnete Element Auflistungen kann in Eigenschaften Getter oder-Setter, Klassen Behandlung von geänderten Ereignissen, Konstruktoren oder innerhalb der Sammlungs Typen selbst durchgeführt werden.  
  
 Für Steuerelement Autoren ist das Bearbeiten der logischen Struktur auf dieser Ebene nicht die empfohlene Vorgehensweise, es sei denn, keines der Inhalts Modelle für die verfügbaren Basis Steuerelement Klassen eignet sich für Ihr Steuerungs Szenario. Betrachten Sie die Unterklassen auf der Ebene von <xref:System.Windows.Controls.ContentControl> , <xref:System.Windows.Controls.ItemsControl> und <xref:System.Windows.Controls.HeaderedItemsControl> . Diese Klassen bieten ein Inhalts Modell mit spezieller Erzwingung von untergeordneten Elementen der logischen Struktur durch dedizierte APIs sowie Unterstützung für andere Funktionen, die in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelement wie z. b Weitere Informationen zur Verwendung von und finden Sie Unterstrukturen <xref:System.Windows.FrameworkElement.LogicalChildren%2A> <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> [in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> löst möglicherweise eine Ausnahme aus, wenn Sie zu einem Zeitpunkt aufgerufen wird, an dem die logische Struktur von einem anderen Prozess durchlaufen wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine- `Child` Eigenschaft für ein benutzerdefiniertes implementiert <xref:System.Windows.FrameworkElement> , das eine eigene Implementierung der visuellen Schicht implementiert. Der Eigenschaften Setter ist so konzipiert, dass, wenn sich der Wert ändert, der alte Wert aus der logischen Struktur sowie eine klassenspezifische visuelle Auflistung entfernt wird. Der Eigenschafts Wert wird zwischengespeichert, und dann wird der neue Wert sowohl der logischen Struktur als auch der benutzerdefinierten visuellen Auflistung hinzugefügt.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt bei Bedarf die visuelle Struktur der aktuellen Vorlage und gibt einen Wert zurück, der angibt, ob die visuelle Struktur durch diesen Aufruf neu erstellt wurde.</summary>
        <returns><see langword="true" />, wenn der Struktur visuelle Elemente hinzugefügt wurden, andernfalls wird <see langword="false" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen können diese Methode aufzurufen, um sicherzustellen, dass die visuelle Struktur eines Elements fertiggestellt ist. Dieser Garantie Schritt ist möglicherweise erforderlich, wenn der Code die untergeordneten Elemente in der Struktur prüft. Für eine typische Element Logik innerhalb von Anwendungen ist das Aufrufen von <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> nicht erforderlich, da Vorlagen auf Elemente an einem geeigneten Punkt in ihrer Lebensdauer automatisch angewendet werden.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> wird für jedes Measure aufgerufen, das vom Layout-System auf WPF-Frameworkebene übergeben wird.  
  
 <xref:System.Windows.FrameworkElement> abgeleitete Klassen können den <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> Klassen Handler verwenden, um über Fälle benachrichtigt zu werden, in denen diese Methode explizit oder vom Layoutsystem aufgerufen wurde. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> wird aufgerufen, nachdem die Vorlage vollständig generiert und an die logische Struktur angefügt wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Implementiert <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (in <see cref="T:System.Windows.UIElement" /> als virtuell definiert) und versiegelt die Implementierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist versiegelt. Um die Logik in Ihrem benutzerdefinierten Element speziell für die Anordnungs Übergabe des Element Layouts zu überschreiben, <xref:System.Windows.FrameworkElement> muss die abgeleitete Klasse überschreiben <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Der letzte Bereich im übergeordneten Element, den dieses Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Positioniert beim Überschreiben in einer abgeleiteten Klasse die untergeordneten Elemente und bestimmt eine Größe für eine von <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse.</summary>
        <returns>Die tatsächlich verwendete Größe.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Steuerelement Autoren, die die Anordnungs Übergabe der Layoutverarbeitung anpassen möchten, sollten diese Methode überschreiben. Das Implementierungs Muster sollte <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> für jedes sichtbare untergeordnete Element aufrufen und die endgültige gewünschte Größe für jedes untergeordnete Element als <paramref name="finalRect" /> Parameter übergeben. Übergeordnete Elemente sollten <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> für jedes untergeordnete Element aufgerufen werden, andernfalls werden die untergeordneten Elemente nicht gerendert.  
  
Viele abgeleitete Klassen bieten Implementierungen dieser Methode. Zu den wichtigsten zählen: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" /> , <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> und <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" /> .</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Initialisierungsprozess für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode für einzelne Elemente aufrufen, wenn Sie Sie so anpassen, dass das Element noch nicht verfügbar gemacht oder mit einer beliebigen Elementstruktur verbunden ist. Beispielsweise haben Sie möglicherweise einen neuen erstellt <xref:System.Windows.FrameworkElement> , ihn aber noch nicht an eine logische Struktur angefügt. Oder die logische Struktur, in der das Element ein untergeordnetes Element darin ist, ist möglicherweise nicht mit einem Fenster oder einer Seite der Anwendung verbunden.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementieren Sie diese Methode, um eine spezielle Verarbeitung bereitzustellen, die vor dem Initialisieren des Elements während des Ladevorgangs des Elements erfolgen sollte.  
  
Ihre Implementierung sollte die Basis Implementierung aufzurufen, da die Basis Implementierung (Standard) einige interne Flags festlegt, um die Initialisierung nachzuverfolgen. Eine mögliche Implementierung besteht darin, diese Methode als Hook in ihren eigenen Initialisierungs Routinen für die private Klasse zu verwenden, die noch nicht von Konstruktoren aktiviert wurden.  
  
Die Basis Implementierung löst eine Ausnahme aus, wenn <see cref="M:System.Windows.FrameworkElement.BeginInit" /> mehr als einmal für das gleiche Element vor dem Aufruf von aufgerufen wird <see cref="M:System.Windows.FrameworkElement.EndInit" /> .</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den meisten gängigen Animations Szenarien wird diese Methode nicht verwendet. In der Regel erstellen Sie <xref:System.Windows.Media.Animation.Storyboard> das <xref:System.Windows.Media.Animation.BeginStoryboard> -Element oder das-Element im Markup und platzieren diese dann als <xref:System.Windows.EventTrigger> Inhalt in einem Element. Wenn die Animation durch das-Ereignis ausgelöst wird, wird Sie ausgeführt. Die meisten Steuerungs Aspekte von <xref:System.Windows.Media.Animation.Storyboard> können von Eigenschaften adressiert werden, die im Markup verfügbar gemacht werden.  
  
 Bei den Signaturen, die den-Parameter, den-Parameter oder den-Parameter nicht verwenden, `isControllable` `false` werden die Zeitachse, die der Animation zugeordnet sind, entfernt, sobald die Animation den "Fill"-Zeitraum erreicht. Daher kann die Animation nach einer einmaligen Ausführung nicht neu gestartet werden. Das Steuern einer Animation erfordert auch, dass das Storyboard eine [x:Name-Direktive](/dotnet/framework/xaml-services/x-name-directive) hat oder über einen Verweis im Code darauf zugegriffen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel <xref:System.Windows.Media.Animation.Storyboard> wird ein aus Ressourcen abgerufen und dann ausgeführt, <xref:System.Windows.Media.Animation.Storyboard> Wenn ein internes Ereignis eine Klasse behandelt wird.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <param name="handoffBehavior">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist. Dabei sind Optionen angegeben, welche Aktion ausgeführt werden soll, wenn die Eigenschaft bereits animiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den meisten gängigen Animations Szenarien wird diese Methode nicht verwendet. In der Regel erstellen Sie <xref:System.Windows.Media.Animation.Storyboard> das <xref:System.Windows.Media.Animation.BeginStoryboard> -Element oder das-Element im Markup und platzieren diese dann als <xref:System.Windows.EventTrigger> Inhalt in einem Element. Wenn die Animation durch das-Ereignis ausgelöst wird, wird Sie ausgeführt. Die meisten Steuerungs Aspekte von <xref:System.Windows.Media.Animation.Storyboard> können von Eigenschaften adressiert werden, die im Markup verfügbar gemacht werden.  
  
 Bei den Signaturen, die den-Parameter, den-Parameter oder den-Parameter nicht verwenden, `isControllable` `false` werden die Zeitachse, die der Animation zugeordnet sind, entfernt, sobald die Animation den "Fill"-Zeitraum erreicht. Daher kann die Animation nach einer einmaligen Ausführung nicht neu gestartet werden. Das Steuern einer Animation erfordert auch, dass das Storyboard eine [x:Name-Direktive](/dotnet/framework/xaml-services/x-name-directive) hat oder über einen Verweis im Code darauf zugegriffen werden kann.  
  
 Das Übergabe Verhalten kann als Attribut von angegeben werden <xref:System.Windows.Media.Animation.BeginStoryboard> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt die Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht ausgelöst wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
   
  
## Examples  
 Im folgenden Beispiel <xref:System.Windows.Media.Animation.Storyboard> wird ein aus Ressourcen abgerufen und dann ausgeführt, <xref:System.Windows.Media.Animation.Storyboard> Wenn ein internes Ereignis eine Klasse behandelt wird.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <param name="handoffBehavior">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (angehalten werden kann), nachdem sie gestartet wurde.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist, im angegebenen Zustand für das Steuerelement der Animation nach deren Start.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den meisten gängigen Animations Szenarien wird diese Methode nicht verwendet. In der Regel erstellen Sie <xref:System.Windows.Media.Animation.Storyboard> das <xref:System.Windows.Media.Animation.BeginStoryboard> -Element oder das-Element im Markup und platzieren diese dann als <xref:System.Windows.EventTrigger> Inhalt in einem Element. Wenn die Animation durch das-Ereignis ausgelöst wird, wird Sie ausgeführt. Die meisten Steuerungs Aspekte von <xref:System.Windows.Media.Animation.Storyboard> können von Eigenschaften adressiert werden, die im Markup verfügbar gemacht werden.  
  
 Bei den Signaturen, die den-Parameter, den-Parameter oder den-Parameter nicht verwenden, `isControllable` `false` werden die Zeitachse, die der Animation zugeordnet sind, entfernt, sobald die Animation den "Fill"-Zeitraum erreicht. Daher kann die Animation nach einer einmaligen Ausführung nicht neu gestartet werden. Das Steuern einer Animation erfordert auch, dass das Storyboard eine [x:Name-Direktive](/dotnet/framework/xaml-services/x-name-directive) hat oder über einen Verweis im Code darauf zugegriffen werden kann.  
  
 Das Übergabe Verhalten kann als Attribut von angegeben werden <xref:System.Windows.Media.Animation.BeginStoryboard> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt die Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht ausgelöst wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" /> ab oder legt diese fest.</summary>
        <value>Die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup>Kann verwendet werden, um die Werte mehrerer Eigenschaften eines Objekts zu überprüfen. Angenommen, eine Anwendung fordert den Benutzer auf, eine Adresse einzugeben, und füllt dann ein Objekt vom Typ `Address` mit den Eigenschaften `Street` , `City` , `ZipCode` und `Country` mit den vom Benutzer bereitgestellten Werten. Die Anwendung verfügt über einen Bereich, der vier Steuer <xref:System.Windows.Controls.TextBox> Elemente enthält, von denen jede an eine der Eigenschaften des Objekts gebunden ist. Sie können einen <xref:System.Windows.Controls.ValidationRule> in einem verwenden <xref:System.Windows.Data.BindingGroup> , um das Objekt zu validieren `Address` . So kann beispielsweise <xref:System.Windows.Controls.ValidationRule> sichergestellt werden, dass die Postleitzahl für das Land/die Region der Adresse gültig ist.  
  
 Untergeordnete Elemente erben die <xref:System.Windows.Data.BindingGroup> von ihren übergeordneten Elementen, ebenso wie jede andere vererbbare Eigenschaft.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Die folgenden Beispiele sind Teil einer Anwendung, die überprüft, ob der Benutzer die Eigenschaften von zwei-Objekten auf die gleichen Werte festgelegt hat. Im ersten Beispiel werden zwei-Steuer <xref:System.Windows.Controls.TextBox> Elemente erstellt, die jeweils an eine andere Datenquelle gebunden sind. Der <xref:System.Windows.Controls.StackPanel> verfügt über einen <xref:System.Windows.Data.BindingGroup> , der einen enthält <xref:System.Windows.Controls.ValidationRule> , der überprüft, ob die beiden Zeichen folgen gleich sind.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 Das folgende Beispiel zeigt das <xref:System.Windows.Controls.ValidationRule> , das im vorherigen Beispiel verwendet wurde.  In der- <xref:System.Windows.Controls.ValidationRule.Validate%2A> Methoden Überschreibung ruft das Beispiel jedes Quell Objekt aus ab <xref:System.Windows.Data.BindingGroup> und überprüft, ob die Eigenschaften der-Objekte gleich sind.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Rufen Sie zum Aufrufen von <xref:System.Windows.Controls.ValidationRule> die- <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> Methode auf.  Im folgenden Beispiel wird aufgerufen, <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> Wenn das Click-Ereignis der Schaltfläche auftritt.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.BindingGroup" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufrufen dieser Methode wird ein-Ereignis aufgerufen, <xref:System.Windows.FrameworkElement.RequestBringIntoView> das aus dem aktuellen Element stammt. Dieses Ereignis wird ausgelöst, damit es von einer <xref:System.Windows.Controls.ScrollViewer> oder einer abgeleiteten oder ähnlichen Klasse behandelt werden kann. Das erwartete Verhalten ist, dass das Ereignis durch das übergeordnete Element behandelt wird, das in den Ereignisdaten als behandelt markiert ist, und die Quelle des Ereignisses durch die im Steuerelement eingebettete Logik in die Ansicht aufgenommen wird <xref:System.Windows.Controls.ScrollViewer> . Weder das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis noch die <xref:System.Windows.FrameworkElement.BringIntoView%2A> Methode übertragen Informationen über Erfolg oder Fehler, außer dass das Ereignis in der Regel bei Erfolg als behandelt markiert ist. Fehlerursachen können die Element Einstellungen einschließen, z. b <xref:System.Windows.UIElement.Visibility%2A> . einen anderen Wert als <xref:System.Windows.Visibility.Visible> .  
  
 Wenn Sie die Signatur verwenden, die keine angibt `targetRectangle` , wird die gesamte Elementgröße (Ihre <xref:System.Windows.UIElement.RenderSize%2A> ) sichtbar gemacht.  
  
 Durch Aufrufen dieser Methode wird möglicherweise <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für jeden übergeordneten scrollbaren Bereich aufgerufen, der das Element enthält. Wenn dieses Element nicht in einem Bild lauffähigen Bereich enthalten ist, wird das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis immer noch ausgelöst, aber es gibt keine Auswirkung, da keine Ereignislistener vorhanden sind.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Handler für ein Anwendungs Navigations Ereignis implementiert, das antwortet, wenn der URI (Uniform Resource Identifier), zu dem navigiert wird, ein Fragment einschließt. Das Fragment wird im URI nach dem Hash Zeichen (#) benannt, und das implementierte Verhalten bewirkt, dass das Element in der Sicht innerhalb des Frames einen Bildlauf durchführen kann. <xref:System.Windows.FrameworkElement.BringIntoView%2A> und <xref:System.Windows.FrameworkElement.RequestBringIntoView> fordern dieses Scrollverhalten im Beispiel an.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Die angegebene Größe des anzuzeigenden Elements.</param>
        <summary>Versucht, die bereitgestellte Bereichsgröße dieses Elements in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufrufen dieser Methode wird ein-Ereignis aufgerufen, <xref:System.Windows.FrameworkElement.RequestBringIntoView> das aus dem aktuellen Element stammt. Dieses Ereignis wird ausgelöst, damit es von einer <xref:System.Windows.Controls.ScrollViewer> oder einer abgeleiteten oder ähnlichen Klasse behandelt werden kann. Das erwartete Verhalten ist, dass das Ereignis durch das übergeordnete Element behandelt wird, das in den Ereignisdaten als behandelt markiert ist, und die Quelle des Ereignisses durch die im Steuerelement eingebettete Logik in die Ansicht aufgenommen wird <xref:System.Windows.Controls.ScrollViewer> . Weder das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis noch die <xref:System.Windows.FrameworkElement.BringIntoView%2A> Methode übertragen Informationen über Erfolg oder Fehler, außer dass das Ereignis in der Regel bei Erfolg als behandelt markiert ist. Fehlerursachen können die Element Einstellungen einschließen, z. b <xref:System.Windows.UIElement.Visibility%2A> . einen anderen Wert als <xref:System.Windows.Visibility.Visible> .  
  
 Wenn Sie die Signatur verwenden, die keine angibt `targetRectangle` , wird die gesamte Elementgröße (Ihre <xref:System.Windows.UIElement.RenderSize%2A> ) sichtbar gemacht.  
  
 Durch Aufrufen dieser Methode wird möglicherweise <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für jeden übergeordneten scrollbaren Bereich aufgerufen, der das Element enthält. Wenn dieses Element nicht in einem Bild lauffähigen Bereich enthalten ist, wird das <xref:System.Windows.FrameworkElement.RequestBringIntoView> Ereignis immer noch ausgelöst, aber es gibt keine Auswirkung, da keine Ereignislistener vorhanden sind.  
  
   
  
## Examples  
 Das folgende Beispiel enthält eine große Grafik in einem eingeschränkten scrollbereich. Eine Schaltfläche auf der Seite verfügt über einen Handler, der in der Ansicht einen Bildlauf zu einem bestimmten Bereich der großen Grafik durchführt.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Kontextmenüelement ab bzw. legt das Kontextmenüelement fest, das angezeigt wird, wenn das Kontextmenü über die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aus diesem Element angefordert wird.</summary>
        <value>Das Kontextmenü, das diesem Element zugewiesen ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> selbst ist eine <xref:System.Windows.FrameworkElement> abgeleitete Klasse, und es ist technisch möglich, <xref:System.Windows.Controls.ContextMenu> eine Eigenschaft zu haben <xref:System.Windows.FrameworkElement.ContextMenu%2A> . Dies führt jedoch zu einer verwirrenden Kontextmenü Erfahrung für den Benutzer, und diese Vorgehensweise wird nicht empfohlen.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar vor dem Schließen eines Kontextmenüs für ein Element auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Schließen von Kontextmenüs zu unterdrücken, sollten Handler des Ereignisses ihn als behandelt markieren.  
  
 Um dieses Ereignis als <xref:System.Windows.EventTrigger> in einem Stil zu verwenden, müssen Sie auf die Definition des Ereignisses des zugrunde liegenden dienstanweises verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Diese Verwendung ist erforderlich, da die Ereignis Implementierung von <xref:System.Windows.FrameworkElement> , die das zugrunde liegende Dienst Ereignis verfügbar macht, den <xref:System.Windows.FrameworkElement.ContextMenuClosing> Bezeichner nicht so zuordnet, dass Sie ihn als einen-Auslösers verwenden können.)  
  
 <xref:System.Windows.Controls.ContextMenu> selbst ist eine <xref:System.Windows.FrameworkElement> abgeleitete Klasse, aber das <xref:System.Windows.FrameworkElement.ContextMenuClosing> Ereignis wird nicht direkt von einem Kontextmenü ausgelöst. Stattdessen wird das-Ereignis aus dem-Element ausgelöst, das das Kontextmenü als Eigenschaft besitzt und nur ausgelöst wird, wenn ein Benutzer versucht, ein Kontextmenü in der Benutzeroberfläche zu schließen. Es ist jedoch möglich <xref:System.Windows.Controls.ContextMenu> , dass eine <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft (ein Kontextmenü mit einem Kontext) vorhanden ist. In diesem Fall ist der Besitzer der <xref:System.Windows.Controls.ContextMenu> <xref:System.Windows.Controls.ContextMenu> -Tabelle und kann das-Ereignis, wobei die Quelle des Ereignisses das Kontextmenü des-Ereignisses ist, hervorrufen.  
  
 Die- <xref:System.Windows.Controls.ContextMenu> Klasse selbst verfügt auch über ein ähnliches Ereignis ( <xref:System.Windows.Controls.ContextMenu.Closed> ), aber das- <xref:System.Windows.Controls.ContextMenu.Closed> Ereignis bietet Ihnen nicht die Möglichkeit, die Benutzeraktion abzubrechen.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>Überschreiben, um die Klassen Behandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Kontextmenü des Elements geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Kontextmenüs manuell zu öffnen, sollten die Handler der Ereignisse das relevante Ereignis als behandelt markieren. Andernfalls wird der vorhandene Wert der- <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft verwendet, um automatisch ein Kontextmenü zu öffnen. Wenn das Ereignis behandelt wird, wird die Standardaktion effektiv abgebrochen, und es kann eine Gelegenheit sein, den Wert der Eigenschaft zurückzusetzen <xref:System.Windows.FrameworkElement.ContextMenu%2A> und dann die neue zu öffnen <xref:System.Windows.Controls.ContextMenu> . Es gibt jedoch ein Problem mit der zeitlichen Steuerung, das Sie kennen sollten. Um das Kontextmenü durch einen Handler vollständig zu ersetzen <xref:System.Windows.FrameworkElement.ContextMenuOpening> , darf das anfängliche Kontextmenü nicht NULL/leer sein. Alternativ dazu müssen Sie möglicherweise das-Ereignis behandeln und dann manuell ein neues Kontextmenü öffnen. Weitere Informationen finden Sie unter Gewusst [wie: Behandeln des ContextMenuOpening-Ereignisses](/dotnet/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event).  
  
 Um dieses Ereignis als <xref:System.Windows.EventTrigger> in einem Stil zu verwenden, müssen Sie auf das zugrunde liegende angefügte Ereignis verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Diese Verwendung ist erforderlich, da die Ereignis Implementierung von <xref:System.Windows.FrameworkElement> , die das zugrunde liegende Dienst Ereignis verfügbar macht, den Bezeichner nicht zuordnet <xref:System.Windows.FrameworkElement.ContextMenuOpening> , sodass Sie ihn in Triggern verwenden können.)  
  
 <xref:System.Windows.Controls.ContextMenu> selbst ist eine <xref:System.Windows.FrameworkElement> abgeleitete Klasse, aber dieses Ereignis wird nicht aus dem als Quelle geöffneten Kontextmenü ausgelöst. Das-Ereignis wird von dem-Element ausgelöst, das das Kontextmenü als Eigenschaft besitzt und nur ausgelöst wird, wenn ein Benutzer versucht, ein Kontextmenü in der Benutzeroberfläche zu öffnen. Es ist möglich, dass Sie <xref:System.Windows.Controls.ContextMenu> über eine <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft verfügen, aber Sie sollten dieses Szenario vermeiden (Weitere Informationen finden Sie unter <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> ).  
  
 Die- <xref:System.Windows.Controls.ContextMenu> Klasse selbst verfügt auch über ein ähnliches Ereignis ( <xref:System.Windows.Controls.ContextMenu.Opened> ) <xref:System.Windows.Controls.ContextMenu.Opened> , bietet Ihnen jedoch nicht die Möglichkeit, die Benutzeraktion abzubrechen.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>Überschreiben, um die Klassen Behandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ContextMenu" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab bzw. legt den Cursor fest, der angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet.</summary>
        <value>Der anzuzeigende Cursor. Der Standardwert ist gemäß dieser Abhängigkeitseigenschaft als <see langword="null" /> definiert. Der zur Laufzeit angewendete Standardwert resultiert jedoch aus einer Vielzahl von Faktoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft in festlegen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] stützt der Prozessor die Typkonvertierung für die- <xref:System.Windows.Input.Cursor> Klasse, um die Zeichenfolge auszuwerten. Die bereitgestellte Zeichenfolge sollte zu einem Wert ausgewertet werden <xref:System.Windows.Input.CursorType> . Einzelheiten dazu finden Sie unter <xref:System.Windows.Input.Cursor>.  
  
 Ob der Cursor, wie durch diese Eigenschaft festgelegt, angezeigt wird oder nicht angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet, hängt auch vom Wert der- <xref:System.Windows.FrameworkElement.ForceCursor%2A> Eigenschaft ab. Außerdem wirken sich ereignisbezogene Überlegungen, wie z. b. eine aktive Drag-, Maus-und Text Bearbeitungsmodi innerhalb von Steuerelementen, auch auf den Cursor mit höherer Priorität als dem Wert aus, den Sie in dieser Eigenschaft angeben.  
  
 Um das Verhalten für das Festlegen dieser Eigenschaft auf den Standardwert zurückzusetzen, legen Sie ihn `null` erneut fest.  
  
 Der `null` Standardwert bedeutet, dass die Bestimmung des praktischen Cursor Werts hier verzögert wird und von anderen Orten abgerufen werden sollte. Wenn eine Darstellung ohne programmgesteuerte Werte aus einer beliebigen Quelle vorhanden ist, wird der Standard Cursor, der über eine-Anwendung visuell ist, [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] ein Pfeil. Die vorübergehenden Cursor Änderungen werden jedoch nicht auf die <xref:System.Windows.FrameworkElement.Cursor%2A> Werte der Elemente festgelegt, wenn Sie übergeben werden. Die- <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft meldet nur Werte ungleich NULL in Fällen, in denen Sie tatsächlich festgelegt wurde, beispielsweise durch Code oder einen Stil. Jede Bewegung des Mauszeigers über eine- [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendung löst ein- <xref:System.Windows.UIElement.QueryCursor> Ereignis aus. Die Ereignis Blasen, und jedes Element entlang der Route hat die Möglichkeit, das Ereignis zu behandeln und den Wert des Cursors durch die Argumente dieses Ereignisses festzulegen. Dies ist der Mechanismus, der in den meisten Fällen den visuell sichtbaren Cursor erzeugt. Wenn ein <xref:System.Windows.UIElement.QueryCursor> Handler ein Cursor Ergebnis zurückgibt, hat die Tatsache, dass das Ereignis behandelt wird und einen geänderten Wert in den Argumenten hat, Vorrang vor dem Wert der <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft auf jeder Ebene, es sei denn, <xref:System.Windows.FrameworkElement.ForceCursor%2A> wird festgelegt.  
  
 Wenn kein benutzerdefinierter Cursor erstellt wird, legen Sie diese Eigenschaft in der Regel auf einen statischen Eigenschafts Wert der- <xref:System.Windows.Input.Cursors> Klasse fest. Für <xref:System.Windows.FrameworkElement.Cursor%2A> das Festlegen von im Code ist Folgendes erforderlich:  
  
-   Ruft den <xref:System.Windows.Input.Cursor> Konstruktor auf, um eine- <xref:System.Windows.Input.Cursor> Instanz abzurufen. Beide Signaturen des <xref:System.Windows.Input.Cursor> Konstruktors verwenden Streams oder Dateien, in der Erwartung, dass Sie das- <xref:System.Windows.Input.Cursor> Objekt für einen benutzerdefinierten Cursor erstellen.  
  
-   Verwenden <xref:System.Windows.Input.CursorConverter> Sie die-Klasse und die zugehörige-Methode, <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> um einen Cursor anzugeben <xref:System.Windows.Input.CursorType> , oder eine Zeichenfolge, die als ausgewertet <xref:System.Windows.Input.CursorType> werden kann, und umwandeln Sie die Rückgabe in <xref:System.Windows.Input.Cursor> .  
  
 Das Festlegen <xref:System.Windows.Input.Cursor> von auf einen benutzerdefinierten Wert ist in teilweiser Vertrauenswürdigkeit nicht aktiviert. Weitere Informationen zu benutzerdefinierten Cursorn finden Sie unter Übersicht über die [Eingabe](/dotnet/framework/wpf/advanced/input-overview).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Cursor Grafik absichtlich festgelegt wird.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Cursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Datenkontexts für ein Element fest, wenn das Element an Datenbindungen beteiligt ist.</summary>
        <value>Das Objekt, das als Datenkontext verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der *Datenkontext* ist ein Konzept, mit dem Elemente Informationen von ihren übergeordneten Elementen über die Datenquelle, die für die Bindung verwendet wird, und andere Eigenschaften der Bindung, z. b. den Pfad, erben können.  
  
 Der Datenkontext kann direkt auf ein .NET-Objekt festgelegt werden, wobei die Bindungen die Eigenschaften dieses Objekts auswerten. Alternativ können Sie den Datenkontext auf ein- <xref:System.Windows.Data.DataSourceProvider> Objekt festlegen.  
  
 Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte. Wenn untergeordnete Elemente vorhanden sind, für die keine anderen Werte <xref:System.Windows.FrameworkElement.DataContext%2A> durch lokale Werte oder Stile festgelegt wurden, wird der Wert vom-Eigenschaften System auf den <xref:System.Windows.FrameworkElement.DataContext%2A> Wert des nächsten übergeordneten Elements festgelegt, dem dieser Wert zugewiesen ist.  
  
 Alternativ können Sie eine der folgenden Eigenschaften der- <xref:System.Windows.Data.Binding> Klasse verwenden, um die Bindungs Quelle explizit anzugeben:
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Weitere Informationen finden Sie unter Gewusst [wie: Angeben der Bindungs Quelle](/dotnet/framework/wpf/data/how-to-specify-the-binding-source).  
  
 In XAML <xref:System.Windows.FrameworkElement.DataContext%2A> wird in der Regel als <xref:System.Windows.Data.Binding> Deklaration festgelegt. Sie können entweder die Syntax des Eigenschafts Elements oder die Attribut Syntax verwenden. Die Attribut Syntax wird im Beispiel auf dieser Seite angezeigt. Sie können auch Code verwenden, um festzulegen <xref:System.Windows.FrameworkElement.DataContext%2A> .  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> ist eine bindbare Eigenschaft zum Vereinfachen von Szenarien, in denen ein Kontext möglicherweise an einen anderen gebunden ist. Wenn Sie jedoch eine Bindung an vornehmen, achten Sie darauf, <xref:System.Windows.FrameworkElement.DataContext%2A> keine Zirkel Bindungs Verweise zu erstellen (binden <xref:System.Windows.FrameworkElement.DataContext%2A> Sie nicht an sich selbst, was aufgrund der Vererbung des Eigenschafts Werts der- <xref:System.Windows.FrameworkElement.DataContext%2A> Eigenschaft möglich ist).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml  
<object DataContext="bindingUsage"/>  
```

- oder -

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *datacontextobject*  
 Ein direkt eingebettetes Objekt, das als Datenkontext für alle Bindungen innerhalb des übergeordneten Elements fungiert. In der Regel ist dieses Objekt eine <xref:System.Windows.Data.Binding> oder eine andere <xref:System.Windows.Data.BindingBase> abgeleitete Klasse. Alternativ können Rohdaten eines beliebigen Objekttyps, der für die Bindung bestimmt ist, hier platziert werden, wobei die eigentlichen Bindungen später definiert werden.  
  
 *bindingusage*  
 Eine Bindungs Verwendung, die zu einem geeigneten Datenkontext ausgewertet wird. Weitere Informationen finden Sie unter [Binding als Markuperweiterung](/dotnet/framework/wpf/advanced/binding-markup-extension).  
  
 *resourceextension*  
 Eines der folgenden: [`StaticResource`](/dotnet/framework/wpf/advanced/staticresource-markup-extension) oder [`DynamicResource`](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) . Diese Verwendung wird verwendet, wenn auf Rohdaten verwiesen wird, die als Objekt in Ressourcen definiert sind. Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
 *contextresourcekey*  
 Der Schlüssel Bezeichner für das Objekt, das in einem angefordert wird <xref:System.Windows.ResourceDictionary> .  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Datenkontext für eine Bindung agiert und die Informationen bereitstellt, die die spezifischen Werte gebundener Eigenschaften definieren.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Datenkontext für dieses Element geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Erläuterung der Daten Kontexte und der Datenbindung finden Sie unter [Übersicht über die Datenbindung](/dotnet/framework/wpf/data/data-binding-overview).  
  
> [!IMPORTANT]
>  Wenn <xref:System.Windows.FrameworkElement.DataContext%2A> sich der für ein Element ändert, werden möglicherweise alle Daten gebundenen Eigenschaften für dieses Element beeinträchtigt. Dies gilt für alle Elemente, die untergeordnete Elemente des aktuellen Elements in der logischen Struktur sind, die den Datenkontext erben, und auch das aktuelle Element selbst. Alle vorhandenen Bindungen müssen neu interpretiert <xref:System.Windows.FrameworkElement.DataContext%2A> werden und die Bindungs Ergebnisse neu auswerten. Die Daten Bindungs-Engine ist nicht deterministisch in Bezug auf die Reihenfolge dieser neuauswertungen, relativ zur Erhöhung des <xref:System.Windows.FrameworkElement.DataContextChanged> Ereignisses. Die neuauswertungen können vor dem Ereignis, nach dem Ereignis oder in einer beliebigen Mischung erfolgen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.DataContext" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Schlüssel ab, der zum Referenzieren der Formatvorlage für dieses Steuerelement verwendet werden soll, wenn Designformatvorlagen verwendet werden oder definiert sind.</summary>
        <value>Der Formatvorlagenschlüssel. Damit er als Teil der Designformatvorlagen-Suche ordnungsgemäß funktioniert, wird erwartet, dass dieser Wert der <see cref="T:System.Type" /> des Steuerelements ist, das formatiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird in der Regel nicht über einen ihrer direkten Eigenschaftenaccessoren festgelegt. Stattdessen überschreiben Sie jedes Mal, wenn Sie eine neue abgeleitete Klasse erstellen, die typspezifischen Metadaten dieser Abhängigkeits Eigenschaft <xref:System.Windows.FrameworkElement> . Wenn Sie ein Steuerelement ableiten, müssen Sie die- <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> für den Bezeichner innerhalb des statischen Konstruktors der abgeleiteten Steuerelement Klasse (oder der entsprechenden Klassen Initialisierung) aufzurufen.  
  
 Ein Steuerelement überschreibt den Standardwert dieser Eigenschaft in der Regel als seinen eigenen Typ, aber in manchen Fällen könnte auch ein Basistyp verwendet werden, für den ein Stil in den Design Wörterbüchern vorhanden ist. Dies ist nur praktisch, wenn die Steuerelement Vorlagen des Basis Steuer Elements die visuelle Darstellung dieses abgeleiteten Steuer Elements vollständig definieren und wenn die von den abgeleiteten Typen bereitgestellten zusätzlichen Member keine zusätzlichen Elemente als Teil der Steuerelement Vorlage erfordern.  
  
 Wenn Sie möchten, dass das Element oder Steuerelement absichtlich keine Designstile verwendet, legen Sie die- <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> Eigenschaft auf fest `true` .  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der Metadaten für Abhängigkeits Eigenschaften, die unter Hinweise erläutert werden. Mit diesem Code wird eine benutzerdefinierte Steuerelement Klasse definiert `NumericUpDown` , die von einer dedizierten Steuerelement Bibliotheks Assembly verwendet werden soll. Der dargestellte statische Konstruktor verweist auf eine private Initialisierungsfunktion, registriert einen Klassen Handler (ein anderes häufiges Steuerungs Unterklassen Szenario; Siehe Markieren von Routing [Ereignissen als behandelt und Klassen Behandlung](/dotnet/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling)) und überschreibt schließlich die <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Metadaten der Abhängigkeits Eigenschaft für die- `NumericUpDown` Klasse. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> gibt immer seinen eigenen Typ als beabsichtigten Schlüssel zurück. Hierbei handelt es sich um die Konvention, die das Design System verwendet, um den Stil für ein beliebiges anderes, anderweitig nicht formatiertes Steuerelement zu suchen. Das Complete-Beispiel definiert auch das Design Format des eigentlichen Steuer Elements, auf das von diesem Schlüssel verwiesen wird. Weitere Informationen finden [Sie unter benutzerdefiniertes NumericUpDown-Steuerelement mit Design und UI Automation Support Sample](https://go.microsoft.com/fwlink/?LinkID=160025)  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Der gesamte Quellcode für dieses Beispiel ist auf GitHub sowohl für [c#](https://github.com/dotnet/dotnet-api-docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) als auch für [Visual Basic](https://github.com/dotnet/dotnet-api-docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary)verfügbar.

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">NumericUpDown Custom Control with Theme and UI Automation Support Sample(Benutzerdefiniertes NumericUpDown-Steuerelement mit Unterstützung von Design und Automatisierung)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, dass der Initialisierungsprozess für das Element abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.BeginInit%2A> zuvor aufgerufen wurde, wird das-Ereignis von der Basis Implementierung aufgerufen <xref:System.Windows.FrameworkElement.Initialized> . Andernfalls wird, wenn <xref:System.Windows.FrameworkElement.BeginInit%2A> nicht aufgerufen wurde oder nicht bestimmt werden konnte <xref:System.Windows.FrameworkElement.BeginInit%2A> , ob aufgerufen wurde, <xref:System.Windows.FrameworkElement.Initialized> nicht ausgelöst, und stattdessen wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.FrameworkElement.EndInit" /> wurde aufgerufen, ohne dass zuvor <see cref="M:System.Windows.FrameworkElement.BeginInit" /> für das Element aufgerufen wurde.</exception>
        <block subset="none" type="overrides"><para>Implementieren Sie diese Methode, um eine spezielle Verarbeitung bereitzustellen, die auftreten sollte, wenn das Element während des Ladevorgangs des Elements initialisiert wird.  
  
 Ihre Implementierung sollte die Basis Implementierung aufzurufen, da die Basis Implementierung (Standard) einige interne Flags festlegt, um die Initialisierung nachzuverfolgen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des angeforderten Elements.</param>
        <summary>Sucht ein Element mit dem Namen des bereitgestellten Bezeichners.</summary>
        <returns>Das angeforderte Element. Dies kann <see langword="null" /> sein, wenn kein übereinstimmendes Element gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Element über untergeordnete Elemente verfügt, werden diese untergeordneten Elemente für das angeforderte benannte Element rekursiv durchsucht.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> wird innerhalb des Namescope des aktuellen Elements angewendet. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="/dotnet/desktop-wpf/xaml-services/xname-directive">x:Name-Attribut</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner für die angeforderte Ressource.</param>
        <summary>Sucht eine Ressource mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird.</summary>
        <returns>Die angeforderte Ressource. Wenn keine Ressource mit dem angegebenen Schlüssel gefunden wurde, wird eine Ausnahme ausgelöst. Bei einer Ausnahme kann auch ein <see cref="F:System.Windows.DependencyProperty.UnsetValue" />-Wert zurückgegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Wenn Sie diese Methode für einen Schlüssel aufgerufen haben, der nicht gefunden werden kann, wird eine Ausnahme ausgelöst. Wenn Sie keine Ausnahmen behandeln möchten, die sich aus dem Aufruf von ergeben <xref:System.Windows.FrameworkElement.FindResource%2A> , rufen Sie <xref:System.Windows.FrameworkElement.TryFindResource%2A> stattdessen auf. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Gibt zurück `null` , wenn eine angeforderte Ressource nicht gefunden werden kann und keine Ausnahme auslöst.  
  
 Wenn die Ressource im aufrufenden Element nicht gefunden wird, wird als nächstes das übergeordnete Element in der logischen Struktur durchsucht, dann die Anwendung, dann die Themen und schließlich die Systemressourcen. Diese Nachschlage Methode ist identisch mit der Art und Weise, in der die Struktur durchsucht wird, wenn eine Ressource von einem dynamischen Ressourcen Verweis im Markup angefordert wurde. Weitere Informationen zur Ressourcen Suche finden Sie unter [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
 In der Regel wandeln Sie sofort einen <xref:System.Windows.FrameworkElement.FindResource%2A> Rückgabewert in den Typ der Eigenschaft um, die Sie mit dem zurückgegebenen Ressourcen Wert festlegen.  
  
 Ressourcen Schlüssel sind nicht notwendigerweise Zeichen folgen. Beispielsweise werden Stile für Steuerelemente auf der Design Ebene absichtlich an die <xref:System.Type> des Steuer Elements gebunden, und Anwendungs-oder Seiten Stile für Steuerelemente verwenden normalerweise dieselbe Schlüssel Konvention. Weitere Informationen finden Sie unter Erstellen von Formaten [und](/dotnet/framework/wpf/controls/styling-and-templating) Vorlagen oder [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine benannte Ressource abgerufen und in einen geeigneten Typ umgewandelt, um eine Eigenschaft zu füllen.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" /> wurde nicht gefunden, und ein Ereignishandler ist für das <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />-Ereignis nicht vorhanden.  
  
- oder - 
 <paramref name="resourceKey" /> wurde nicht gefunden und die <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" />-Eigenschaft lautet <see langword="false" /> im <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />-Ereignis.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Richtung ab, in die Text und andere [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]-Elemente innerhalb von übergeordneten Elementen fließen, die ihr Layout steuern, oder legt diese Richtung fest.</summary>
        <value>Die Richtung, in die Text und andere [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]-Elemente in ihrem übergeordneten Element fließen, als ein Wert der Enumeration. Der Standardwert ist <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung der Abhängigkeits Eigenschaft legt den <xref:System.Windows.FrameworkElement.FlowDirection%2A> für dieses Element fest. Aufgrund der Vererbung von Eigenschafts Werten <xref:System.Windows.FrameworkElement.FlowDirection%2A> kann die Einstellung für ein Element <xref:System.Windows.FrameworkElement.FlowDirection%2A> für alle untergeordneten Elemente festgelegt werden, die nicht lokal festgelegt wurden, <xref:System.Windows.FrameworkElement.FlowDirection%2A> oder andere Mittel wie Stile.  
  
 Diese Eigenschaft wird nicht automatisch als Teil von Anwendungs Kultur Informationen festgelegt, da ein Element möglicherweise Inhalt enthält, der nicht notwendigerweise der allgemeinen Fluss Richtung, die von den Kultur Informationen impliziert, entsprechen soll. Weitere Informationen zu Globalisierungs Überlegungen finden Sie unter [Globalisierung für WPF](/dotnet/framework/wpf/advanced/globalization-for-wpf).  
  
 Diese Eigenschaft verfügt über einen definierten [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Eigenschafts Accessor, sodass Sie als Abhängigkeits Eigenschaft fungiert. Sie wird jedoch auch als angefügt registriert, sodass Sie auch als angefügte Eigenschaft fungieren kann. Die angefügte Registrierung besteht hauptsächlich darin, dass die Vererbung von Eigenschafts Werten unterstützt wird, die-Eigenschaft jedoch auch als echte angefügte Eigenschaft verwendet werden kann. Die Verwendung der angefügten Eigenschaft ist nur relevant, wenn das Objekt, für das Sie die Fluss Richtung festlegen möchten, über ein über <xref:System.Windows.FrameworkElement> geordnetes Element verfügt, das Layout darauf ausführt, selbst kein ist <xref:System.Windows.FrameworkElement> und nicht bereits über eine direkt definierte `FlowDirection` Eigenschaft verfügt. (Einige der Fluss Dokument Klassen wie <xref:System.Windows.Documents.Block> und <xref:System.Windows.Documents.Inline> definieren eigene `FlowDirection` , und diese Eigenschaft kann auch die Fluss Richtung festlegen. Der Eigenschafts Wert wird dann vom Inhalt des Inhalts Hosts gelesen, ohne dass eine angefügte Eigenschaften Verwendung erforderlich ist.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Diese Eigenschaft kann auch für Klassen festgelegt werden, die keine <xref:System.Windows.FrameworkElement> abgeleiteten Klassen sind, indem die folgende [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] angefügte Eigenschaften Verwendung verwendet wird:  
  
 `<`*Objekt* `FrameworkElement.` **FlowDirection**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Diese Eigenschaft ist eine Abhängigkeits Eigenschaft und eine angefügte Eigenschaft. siehe Hinweise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen einer Eigenschaft, die die Anpassung von Darstellung, Effekten oder anderen Formateigenschaften ermöglicht, die auf dieses Element angewendet werden, wenn es den Tastaturfokus erhält.</summary>
        <value>Die gewünschte Formatvorlage, die angewendet wird, wenn das Element den Fokus erhält. Der in der Abhängigkeitseigenschaft deklarierte Standardwert ist eine leere statische <see cref="T:System.Windows.Style" />. Der tatsächliche Wert zur Laufzeit ist jedoch häufig (aber nicht immer) eine Formatvorlage, die von der Designunterstützung für Steuerelemente bereitgestellt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wirkt sich auf die visuelle Darstellung aus, meldet aber nicht <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> in den Metadaten. Dies liegt daran, dass die visuelle Darstellung des Erscheinungs Bilds ereignisgesteuert ist und nicht immer angewendet werden kann. Daher sollten in der Regel keine visuellen Informationen und Layoutinformationen in den Metadaten angezeigt werden.  
  
 Konzeptionell sollte das visuelle Verhalten von Fokus, das auf ein Steuerelement angewendet wird, von Steuerelement zu Steuerelement kohärent sein. Die sinnvollste Methode zum Erzwingen von Kohärenz besteht darin, nur den visuellen Fokus Stil zu ändern, wenn Sie ein ganzes Design erstellen. Das Festlegen dieser Eigenschaft in einzelnen Steuerelement Formaten und nicht als Teil eines Designs ist nicht die beabsichtigte Verwendung dieser Eigenschaft, da dies möglicherweise zu einer verwirrenden Benutzer Darstellung in Bezug auf den Tastaturfokus führt. Wenn Sie ein Steuerelement spezifisches Verhalten haben, das in einem Design absichtlich nicht kohärent ist, ist es viel besser, Trigger in Stilen für einzelne Eingabe Zustands Eigenschaften wie oder zu verwenden, und dies auf <xref:System.Windows.UIElement.IsFocused%2A> <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> eine Weise zu tun, die keinen visuellen Fokus im visuellen Stil beeinträchtigt. Weitere Informationen zu den Entwurfs Absichten <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> und alternativen Fokus Eigenschaften finden Sie unter Formatieren [für den Fokus in Steuerelementen und liegt VisualStyle](/dotnet/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceextension*  
 Eines der folgenden:, oder. Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
 *styleresourcekey*  
 Der Schlüssel, der den angeforderten Stil bezeichnet. Der Schlüssel verweist auf eine vorhandene Ressource in einer <xref:System.Windows.ResourceDictionary> .  
  
> [!NOTE]
>  Die Syntax von Eigenschafts Elementen ist technisch möglich, wird jedoch nicht empfohlen. Weitere Informationen finden Sie unter [Inline Stile und Vorlagen](/dotnet/framework/wpf/advanced/inline-styles-and-templates). Ein Bindungs Verweis mit [TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension) oder <xref:System.Windows.Data.Binding> ist ebenfalls möglich, aber nicht üblich.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses <see cref="T:System.Windows.FrameworkElement" /> das Rendern des Cursors in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] gemäß der Deklaration in der <see cref="P:System.Windows.FrameworkElement.Cursor" />-Eigenschaft erzwingen soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn für die Darstellung des Cursors bei Positionierung über diesem Element die aktuellen <see cref="P:System.Windows.FrameworkElement.Cursor" />-Einstellungen (einschließlich aller untergeordneten Elemente) erzwungen werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft auf festlegen, `true` werden die von untergeordneten Elementen eingerichteten Cursor Einstellungen überschrieben. Dies [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] kann für den Benutzer verwirrend sein, insbesondere dann, wenn untergeordnete Elemente versuchen, Cursor anzugeben. Die Einstellung <xref:System.Windows.FrameworkElement.ForceCursor%2A> eignet sich besser für die Steuerung von Unterklassen-oder Kompositions Szenarien.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Cursor Wert erzwungen.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ForceCursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die Ziel-<see cref="T:System.Windows.DependencyProperty" />, von der die Bindung abgerufen wird.</param>
        <summary>Gibt den <see cref="T:System.Windows.Data.BindingExpression" /> zurück, der die Bindung für die angegebene Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Windows.Data.BindingExpression" />, wenn die Zieleigenschaft über eine aktive Bindung verfügt, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Überprüfen des Rückgabewerts für `null` ist eine Technik, mit der Sie bestimmen können, ob eine Eigenschaft über eine aktive Bindung verfügt.  
  
 Bei dieser Methode handelt es sich um einen einfachen Wrapper um die <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> Methode. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> übergibt die aktuelle-Instanz und den- `dp` Parameter an <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, für das eine <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> zurückgegeben werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Eigenschaft für das angegebene <see cref="T:System.Windows.DependencyObject" /> ab.</summary>
        <returns>Die angeforderte Flussrichtung als Wert der Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hauptzweck dieser Methode besteht darin, die Syntax der angefügten Eigenschaft für die-Eigenschaft zu unterstützen <xref:System.Windows.FrameworkElement.FlowDirection%2A> . Daher können untergeordnete Elemente einer bereitgestellten die <xref:System.Windows.FrameworkElement> Fluss Richtung für die Anordnung innerhalb ihres übergeordneten Elements angeben. Um den Wert für die aktuelle-Methode zu erhalten <xref:System.Windows.FrameworkElement> , verwenden Sie den Direct- [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor <xref:System.Windows.FrameworkElement.FlowDirection%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Die Größe des Teils des Elements für die visuelle Darstellung.</param>
        <summary>Gibt eine Geometrie für eine Clippingmaske zurück. Die Maske wird verwendet, wenn das Layoutsystem versucht, ein Element anzuordnen, das breiter als der verfügbare Anzeigeraum ist.</summary>
        <returns>Die Clippinggeometrie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ränder werden `layoutSlotSize` als Teil des layoutsystemverhaltens von subtrahiert.  
  
 Ein zurückgegebener NULL-Verweis gibt an, dass kein Clipping erfolgt. Die Standard Implementierung gibt immer zurück, wenn den Wert hat `null` <xref:System.Windows.UIElement.ClipToBounds%2A> `false` . Diese Methode überschreibt <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. Die <xref:System.Windows.FrameworkElement> -Implementierung verwendet <xref:System.Windows.FrameworkElement.MaxHeight%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A> in ihren Berechnungen. Mehrere Unterklassen von über <xref:System.Windows.FrameworkElement> schreiben diese Methode erneut. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, überschreibt, sodass immer zurückgegeben wird, `null` da Adorner häufig absichtlich außerhalb der normalen Grenzen liegen. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> und <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> geben zurück, `null` Wenn <xref:System.Windows.UIElement.ClipToBounds%2A> ist `false` .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die Standard Implementierung gibt immer zurück, wenn den Wert hat <see langword="null" /> <see cref="P:System.Windows.UIElement.ClipToBounds" /> <see langword="false" /> . In der Regel wird dieses Verhalten durch außer Kraft setzungen beibehalten. es gibt jedoch Ausnahmen, abhängig von der Beziehung und dem Zweck der abgeleiteten Klasse und ihrer Layoutlogik im Gegensatz zur Basisklasse.</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Name des gesuchten untergeordneten Elements.</param>
        <summary>Gibt das benannte Element in der visuellen Struktur der instanziierten <see cref="T:System.Windows.Controls.ControlTemplate" /> ab.</summary>
        <returns>Das angeforderte Element. Es kann <see langword="null" /> sein, wenn kein Element mit dem angeforderten Namen vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorlagen in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] verfügen über einen eigenständigen Namescope. Dies liegt daran, dass Vorlagen erneut verwendet werden, und jeder in einer Vorlage definierte Name kann nicht eindeutig bleiben, wenn mehrere Instanzen eines Steuer Elements jeweils seine Vorlage instanziieren. Ruft die- <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Methode auf, um Verweise auf Objekte zurückzugeben, die aus der Vorlage stammen, nachdem Sie instanziiert wurde. Sie können die- <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> Methode nicht verwenden, um Elemente aus Vorlagen zu finden <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> , da in einem allgemeineren Bereich agiert und keine Verbindung zwischen der <xref:System.Windows.Controls.ControlTemplate> Klasse selbst und der instanziierten Vorlage besteht, nachdem Sie angewendet wurde.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> stellt dieselbe Funktion bereit wie diese Methode. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> ist nicht geschützt, sondern verwendet korrekte namens Bereichs Überlegungen, die den Zugriff auf die Vorlage innerhalb eines Elements und das Auffinden benannter Elemente innerhalb des Elements ermöglichen. Verwenden <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> Sie, wenn Sie ein Element außerhalb des übergeordneten Steuer Elements erhalten müssen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein alternatives logisches übergeordnetes Element für dieses Element zurück, wenn kein visuelles übergeordnetes Element vorhanden ist.</summary>
        <returns>Gibt immer dann einen Wert ungleich <see langword="null" /> zurück, wenn eine auf WPF-Frameworkebene vorgenommene Implementierung dieser Methode eine nicht visuelle übergeordnete Verbindung hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Die Standard <xref:System.Windows.FrameworkElement> Implementierung gibt das erwartete visuelle übergeordnete Element zurück, das das gleiche Ergebnis wie das erzielen des <xref:System.Windows.FrameworkElement.Parent%2A> Werts ist. Abgeleitete Klassen Implementierungen können alternative übergeordnete Beziehungen zurückgeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des angeforderten untergeordneten Elements in der Auflistung.</param>
        <summary>Überschreibt <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> und gibt aus einer Auflistung untergeordneter Elemente ein untergeordnetes Element an der angegebenen Indexposition zurück.</summary>
        <returns>Das angeforderte untergeordnete Element. Es sollte nicht <see langword="null" /> zurückgeben; wenn der angegebene Index außerhalb des Bereichs liegt, wird eine Ausnahme ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der- <xref:System.Windows.FrameworkElement> Implementierung ist der einzige gültige Index 0 (null). Das Inhalts Modell für <xref:System.Windows.FrameworkElement.GetVisualChild%2A> unterstützt entweder NULL oder ein untergeordnetes Element, keine Auflistung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein benutzerdefinierter Funktions Indikator die von einem deklarierten Werte verwendet <xref:System.Windows.Media.VisualCollection> , die er für seine verschiedenen visuellen untergeordneten Elemente beibehält. Diese Werte werden durch über schreibungen von <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> und gemeldet <xref:System.Windows.FrameworkElement.GetVisualChild%2A> .  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Implementierung ist nur für Elemente gültig, die keine beschreibende Auflistung von visuellen untergeordneten Elementen beibehalten. Alle Elemente, die über eine solche Auflistung verfügen, müssen diese Methode überschreiben und den Index einem entsprechenden Index in der Auflistung der untergeordneten Elemente zuordnen, die von diesem Element unterstützt wird. Ein Index im Bereich von 0 (NULL <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> ) bis (minus 1) sollte ein gültiges Element zurückgeben. jeder andere Index sollte eine Ausnahme außerhalb des gültigen Bereichs auslösen. Ein Beispiel für einen Elementtyp, der eine untergeordnete Auflistung unterstützt, und außer Kraft setzungen <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> , um mehr als ein mögliches untergeordnetes Element zurückzugeben, ist <see cref="T:System.Windows.Controls.Panel" /> .  
  
Die Standard Implementierung in nimmt nur ein visuelles untergeordnetes Element an <see cref="T:System.Windows.FrameworkElement" /> . Jeder Wert, der für einen <paramref name="index" /> anderen Wert als 0 (null) überschritten wird, bewirkt eine Ausnahme Mehrere allgemeine Elemente, wie z. b. decoratoren, Adorner oder Elemente mit speziellem Rendering, überschreiben die- <see cref="T:System.Windows.FrameworkElement" /> Implementierung (der Implementierung von zwischen Basisklassen). Einige Implementierungen erzwingen weiterhin ein visuelles untergeordnetes Element, während andere eine Auflistung erlauben.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vorgeschlagene Höhe des Elements ab oder legt sie fest.</summary>
        <value>Die Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.NaN" />. Dieser Wert muss größer oder gleich 0,0 sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> ist eine von drei beschreibbaren Eigenschaften <xref:System.Windows.FrameworkElement> , die Höheninformationen angeben. Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinHeight%2A> und <xref:System.Windows.FrameworkElement.MaxHeight%2A> . Wenn ein Konflikt zwischen diesen Werten vorliegt, ist die Reihenfolge der Anwendung für die tatsächliche Höhenbestimmung, dass zuerst berücksichtigt <xref:System.Windows.FrameworkElement.MinHeight%2A> werden muss, <xref:System.Windows.FrameworkElement.MaxHeight%2A> und schließlich, wenn Sie sich innerhalb der Grenzen befindet <xref:System.Windows.FrameworkElement.Height%2A> .  
  
 Wenn dieses Element ein untergeordnetes Element innerhalb eines anderen Elements ist, ist das Festlegen dieser Eigenschaft auf einen Wert wirklich nur ein empfohlener Wert. Das Layoutsystem und die jeweilige Layoutlogik des übergeordneten Elements verwenden den Wert während des Layoutprozesses als nicht-Bindungs Eingabe. Praktisch gesehen <xref:System.Windows.FrameworkElement> ist ein fast immer das untergeordnete Element von etwas anderem, auch wenn Sie das on festlegen <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.Window> . (Für <xref:System.Windows.Window> wird dieser Wert verwendet, wenn das zugrunde liegende Anwendungsmodell die grundlegenden Renderingannahmen festlegt, die das HWND erstellen, das die Anwendung hostet.)  
  
 Zusätzlich zu zulässigen <xref:System.Double> Werten kann diese Eigenschaft auch sein <xref:System.Double.NaN?displayProperty=nameWithType> . Auf diese Weise geben Sie das Verhalten für die automatische Größenanpassung im Code an. [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]Legen Sie den Wert in der Zeichenfolge "Auto" (ohne Beachtung der Groß-/Kleinschreibung) fest, um das Verhalten der automatischen Größenanpassung Das Verhalten der automatischen Größenanpassung impliziert, dass das Element die verfügbare Höhe ablegt. Beachten Sie jedoch, dass bestimmte Steuerelemente häufig Standardwerte über Ihre Standarddesign Stile bereitstellen, die das Verhalten der automatischen Größenänderung deaktivieren, es sei denn, es wird ausdrücklich erneut aktiviert.  
  
 Der Rückgabewert dieser Eigenschaft ist immer identisch mit dem Wert, der auf den Wert festgelegt wurde. Im Gegensatz dazu kann der Wert von <xref:System.Windows.FrameworkElement.ActualHeight%2A> variieren. Dies kann entweder statisch vorkommen, weil das Layout die vorgeschlagene Größe aus irgendeinem Grund zurückgewiesen hat oder vorübergehend. Das Layoutsystem selbst arbeitet asynchron in Relation zum Satz des Eigenschaften Systems <xref:System.Windows.FrameworkElement.Height%2A> und hat diese spezielle Änderung der Größenänderung möglicherweise noch nicht verarbeitet.  
  
 Die Wert Einschränkungen für den <xref:System.Double> Wert werden von einem <xref:System.Windows.ValidateValueCallback> Mechanismus erzwungen. Wenn Sie versuchen, einen ungültigen Wert festzulegen, wird eine Lauf Zeit Ausnahme ausgelöst.  
  
 Zusätzlich zur Überprüfungs Überprüfung gibt es einen nicht deterministischen oberen Wert, der <xref:System.Windows.FrameworkElement.Height%2A> vom Layoutsystem erzwungen wird (Dies ist eine sehr große Zahl, die größer als, <xref:System.Single.MaxValue?displayProperty=nameWithType> aber kleiner als ist <xref:System.Double.MaxValue?displayProperty=nameWithType> ). Wenn diese Grenze überschritten wird, wird das Element nicht mehr angezeigt, und es wird keine Ausnahme ausgelöst. Legen Sie keinen Wert fest, der <xref:System.Windows.FrameworkElement.Height%2A> deutlich größer als die maximale Größe einer möglichen visuellen Darstellung ist, oder diese nicht deterministische obere Grenze überschreiten.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml
<object Height="double"/>  
```

- oder -

```xaml
<object Height="qualifiedDouble"/>  
```

- oder -

```xaml
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts, der gleich oder größer als 0,0 ist. Informationen zur Obergrenze finden Sie unter „Hinweise“. Dieser Wert wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Maßeinheit interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px` , `in` , `cm` , `pt` .  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll; 1In = = 96px  
  
 `cm` ist Zentimeter; 1cm = = (96/2,54) px  
  
 `pt` ist Punkte 1pt = = (96/72) px  
  
 **Automatisch**  
 Aktiviert das Verhalten der automatische Größenanpassung. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Height" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die horizontalen Ausrichtungsmerkmale ab bzw. legt diese fest. Sie werden auf dieses Element angewendet, wenn es Teil von einem übergeordneten Element ist, z. B. von einem Panel-Steuerelement oder von einem ItemsControl-Element.</summary>
        <value>Eine Einstellung für horizontale Ausrichtung als Wert der Enumeration. Der Standardwert ist <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.Height%2A> die-Eigenschaft und die-Eigenschaft <xref:System.Windows.FrameworkElement.Width%2A> für ein Element explizit festgelegt sind, nehmen diese Messungen beim Layout einen höheren Präzedenz Wert an und brechen die typischen Auswirkungen der Einstellung <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> auf ab <xref:System.Windows.HorizontalAlignment.Stretch> .  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> der [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaften Accessor für das, was in Wirklichkeit eine Abhängigkeits Eigenschaft ist. Diese bestimmte Abhängigkeits Eigenschaft hat in untergeordneten Elementen, insbesondere-Steuerelementen, den offensichtlichen "Default"-Wert unterschiedlich festgelegt. Dies geschieht in der Regel auf zwei Arten: die Abhängigkeits Eigenschaft wird für eine bestimmte Unterklasse neu registriert, jedoch mit unterschiedlichen Metadaten zum Festlegen der Standardwerte. oder es wird ein Standardstil angewendet, der den Wert der Abhängigkeits Eigenschaft unterschiedlich festlegt. Beispielsweise ist der sichtbare "Standard" von <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> für ein <xref:System.Windows.Controls.Label> Steuerelement, obwohl er <xref:System.Windows.HorizontalAlignment.Left> <xref:System.Windows.Controls.Label> <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> direkt von erbt <xref:System.Windows.FrameworkElement> . Dies liegt daran, dass dieser Wert innerhalb des Standard Stils von <xref:System.Windows.Controls.Label> innerhalb der Steuerelement Vorlage des Stils zurückgesetzt wurde.  
  
 <xref:System.Windows.Controls.Canvas> verwendet beim Verfassen <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> des Layouts nicht, da <xref:System.Windows.Controls.Canvas> auf absoluter Positionierung basiert.  
  
 Wenn Sie von <xref:System.Windows.Controls.Label> oder abgeleiteten Klassen geerbt <xref:System.Windows.Controls.Label> werden, wird der Standardwert dieser Abhängigkeits Eigenschaft neu definiert als <xref:System.Windows.HorizontalAlignment.Left> .  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bereichsgrenzen für die Vererbung von Eigenschaftswerten, die Suche nach Ressourcenschlüsseln und die RelativeSource-FindAncestor-Suche ab oder legt diese Grenzen fest.</summary>
        <value>Ein Wert aus der Enumeration. Der Standardwert ist <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmte Begrenzungen in der-Elementstruktur legen fest, um <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> den Umfang des Vererbungs Verhaltens absichtlich einzuschränken, auf eine Ressourcen Suche erzwingen, um die Anwendungs Ressourcen zu überprüfen, oder um zu verhindern, dass eine RelativeSource-FindAncestor-Suche das aktuelle Element oder eine andere Abfrage abfragt. Die RelativeSource-FindAncestor-Suche tritt auf, wenn eine Bindung eine verwendet <xref:System.Windows.Data.RelativeSource> , deren- <xref:System.Windows.Data.RelativeSource.Mode%2A> Eigenschaft auf den Wert festgelegt ist <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> .  
  
 Wenn Sie möchten, dass von der abgeleiteten Klasse diese Eigenschaft festgelegt wird, sollten Sie dies innerhalb des statischen Konstruktors oder in anderen Initialisierungs Routinen tun.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn dieses <see cref="T:System.Windows.FrameworkElement" /> initialisiert wird. Dieses Ereignis geht mit Fällen einher, in denen sich der Wert der <see cref="P:System.Windows.FrameworkElement.IsInitialized" />-Eigenschaft von <see langword="false" /> (oder nicht definiert) in <see langword="true" /> ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird immer dann ausgelöst, wenn die- <xref:System.Windows.FrameworkElement.EndInit%2A> Methode oder die- <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> Methode aufgerufen wird. Aufrufe einer der beiden Methoden können aus Anwendungscode oder über das [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Prozessor Verhalten stammen, wenn eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite verarbeitet wird.  
  
 Ob Sie sich für <xref:System.Windows.FrameworkElement.Loaded> die Handhabung oder <xref:System.Windows.FrameworkElement.Initialized> die Abhängigkeit von Ihren Anforderungen entscheiden. Wenn Sie keine Element Eigenschaften lesen müssen, die Eigenschaften zurücksetzen möchten und keine Layoutinformationen benötigen, ist <xref:System.Windows.FrameworkElement.Initialized> möglicherweise das bessere Ereignis, auf das Sie reagieren müssen. Wenn alle Eigenschaften des-Elements verfügbar sein müssen und Sie Eigenschaften festlegen, die das Layout wahrscheinlich zurücksetzen, ist <xref:System.Windows.FrameworkElement.Loaded> möglicherweise das bessere Ereignis, auf das das Layout zurückgesetzt wird. Gehen Sie vorsichtig vor, wenn Ihr Handler alle vom Layoutsystem interpretierten Eigenschaften zurücksetzt, damit ein neuer Layoutdurchlauf erforderlich ist. (Möglicherweise müssen Sie die <xref:System.Windows.FrameworkPropertyMetadata> Werte für die-Eigenschaft überprüfen, wenn Sie nicht sicher sind, welche Eigenschaften einen neuen Layoutdurchlauf erfordern können, wenn Sie geändert werden.)  
  
 Weitere Informationen zur Sequenz von Objekt Ereignissen für eine <xref:System.Windows.FrameworkElement> und auch für mehrere verwandte Anwendungs-und Element Klassen finden Sie unter [Objekt Lebensdauer-Ereignisse](/dotnet/framework/wpf/advanced/object-lifetime-events).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Kontexts für die von diesem <see cref="T:System.Windows.FrameworkElement" /> verwendete Eingabe.</summary>
        <value>Der Eingabebereich, der bestimmt, wie Eingaben von alternativen Eingabemethoden interpretiert werden. Der Standardwert ist <see langword="null" /> (führt zu einer Standardbehandlung von Befehlen).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte. Wenn untergeordnete Elemente vorhanden sind, für die keine anderen Werte <xref:System.Windows.FrameworkElement.InputScope%2A> durch lokale Werte oder Stile festgelegt wurden, wird der Wert vom-Eigenschaften System auf den <xref:System.Windows.FrameworkElement.InputScope%2A> Wert des nächsten Vorgänger Elements festgelegt, dem dieser Wert zugewiesen ist.  
  
 Obwohl eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax Verwendung aufgelistet und syntaktisch zulässig ist, wird das Festlegen dieser Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nicht häufig verwendet.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.InputScope" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob dieses Element entweder während der Verarbeitung durch einen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Prozessor oder durch explizites Aufrufen seiner <see cref="M:System.Windows.FrameworkElement.EndInit" />-Methode initialisiert wurde.</summary>
        <value><see langword="true" />, wenn das Element über die oben genannte [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Verarbeitung oder Methodenaufrufe initialisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann auch sein `true` , wenn dieses Element in der logischen Struktur so verschoben wurde, dass es über ein neues übergeordnetes Element verfügt und daher erneut geladen wird.  
  
 Diese Eigenschaft ist nützlich, wenn Sie auch <xref:System.Windows.FrameworkElement.BeginInit%2A> und verwenden <xref:System.Windows.FrameworkElement.EndInit%2A> . Elemente in der logischen Struktur, die von einem [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor geladen werden, sind für die Initialisierung sicher. Elemente, die sich nicht in der logischen Struktur befinden, werden initialisiert, wenn <xref:System.Windows.FrameworkElement.EndInit%2A> aufgerufen wird. Wenn keine bestimmte Behandlung von <xref:System.Windows.FrameworkElement.BeginInit%2A> und <xref:System.Windows.FrameworkElement.EndInit%2A> erfolgt, erfolgt dies, sobald der Konstruktor das initialisierte Ergebnis zurückgibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element für die Darstellung geladen wurde.</summary>
        <value><see langword="true" />, wenn das aktuelle Element an eine Elementstruktur angefügt ist, <see langword="false" />, wenn das Element noch nie an eine geladene Elementstruktur angefügt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aus einer neu erstellten <xref:System.Windows.FrameworkElement> wird diese Eigenschaft gestartet `false` und bleibt, `true` nachdem Sie auf festgelegt `true` wurde, auch wenn das Element anschließend durch Code aus einer verbundenen logischen Struktur entfernt wird. `true` der Status wird von der allgemeinen Präsentationslogik festgelegt, wenn Elemente in die Präsentations-Engine geladen werden.  
  
 In der Regel werden geladene Elemente gerendert, aber nicht alle <xref:System.Windows.FrameworkElement> abgeleiteten Klassen verfügen über eine Präsentation, und andere Eigenschaften wie <xref:System.Windows.UIElement.Visibility%2A> können die Darstellung beeinflussen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Handler implementiert: eine verarbeitet das- <xref:System.Windows.FrameworkElement.Loaded> Ereignis des Root-Elements, daher ist es sicher, dass das Stamm Element der Seite geladen wird, da dies die Bedeutung des Ereignisses ist. Der andere Handler ist mit einem Benutzer Steuerelement verknüpft, und ruft <xref:System.Windows.FrameworkElement.IsLoaded%2A> auf, um sicherzustellen, dass das Stamm Element vollständig geladen wird. Beide Handler bezeichnen dieselbe Funktion (nicht angezeigt), die untergeordnete Elemente mit neuen Daten füllt.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Lokalisierungs-/Globalisierungs-Sprachinformationen für das Element angibt, oder legt diesen Wert fest.</summary>
        <value>Die Sprachinformationen für dieses Element. Der Standardwert ist eine <see cref="T:System.Windows.Markup.XmlLanguage" />, deren <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />-Wert auf die Zeichenfolge „en-US“ festgelegt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichen folgen Formate folgen dem Standard RFC 3066. US-Englisch lautet z. b. "en-US". Weitere Informationen zu den Werten und dem Format finden Sie unter <xref:System.Windows.Markup.XmlLanguage> .  
  
 Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte. Wenn untergeordnete Elemente vorhanden sind, für die keine anderen Werte <xref:System.Windows.FrameworkElement.Language%2A> durch lokale Werte oder Stile festgelegt wurden, wird der Wert vom-Eigenschaften System auf den <xref:System.Windows.FrameworkElement.Language%2A> Wert des nächsten Vorgänger Elements festgelegt, dem dieser Wert zugewiesen ist.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] definiert die allgemeine Bedeutung des `xml:lang` Attributs. <xref:System.Windows.FrameworkElement.Language%2A> macht im Wesentlichen die Bedeutung dieses Attributs als Abhängigkeits Eigenschaft verfügbar. <xref:System.Windows.FrameworkElement.Language%2A> kann Programm gesteuert angepasst werden und kann an der Vererbung von Eigenschafts System Werten beteiligt sein, und zwar so, dass das Attribut in den `xml:lang` Bereich eines untergeordneten Elements erben kann [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] . Wenn Sie festlegen <xref:System.Windows.FrameworkElement.Language%2A> , wird dieser Wert zum `xml:lang` und überschreibt alle vorherigen Werte. Weitere Informationen finden Sie unter [XML: lang-Behandlung in XAML](/dotnet/framework/xaml-services/xml-lang-handling-in-xaml).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Language" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Grafiktransformation ab, die auf dieses Element angewendet werden soll, wenn Layout ausgeführt wird, oder legt diese fest.</summary>
        <value>Die Transformation, die dieses Element verwenden soll. Der Standardwert ist <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Windows.UIElement.RenderTransform%2A> wirkt sich auf die <xref:System.Windows.FrameworkElement.LayoutTransform%2A> layoutergebnisse aus.  
  
 Das Festlegen einer Transformation bietet leistungsstarke Funktionen zum Skalieren und drehen. Ignoriert jedoch <xref:System.Windows.FrameworkElement.LayoutTransform%2A> <xref:System.Windows.Media.TranslateTransform> Vorgänge. Dies liegt daran, dass das layoutsystemverhalten für unter <xref:System.Windows.FrameworkElement> geordnete Elemente eines automatisch alle Offsets an die Position eines skalierten oder gedrehten Elements in das Layout-und Koordinatensystem des übergeordneten Elements korrigiert.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> kann zu schlechter Anwendungsleistung führen, wenn Sie Sie in einem Szenario aufrufen, für das kein vollständiger Pass durch das Layoutsystem erforderlich ist. Wenn Sie ein <xref:System.Windows.FrameworkElement.LayoutTransform%2A> auf die-Auflistung <xref:System.Windows.Controls.Panel.Children%2A> von anwenden <xref:System.Windows.Controls.Panel> , löst es einen neuen Durchlauf durch das Layoutsystem aus und erzwingt, dass alle Bildschirm Objekte neu gemessen und neu angeordnet werden. Wenn Sie die gesamte Anwendung aktualisieren [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] , ist diese Funktion möglicherweise genau das, was Sie benötigen. Wenn Sie jedoch keinen vollständigen Layoutdurchlauf benötigen, verwenden Sie die <xref:System.Windows.UIElement.RenderTransform%2A> -Eigenschaft, die das Layoutsystem nicht aufruft und daher in der Regel eine bessere Wahl für dieses Szenario ist.  
  
 Beispiele für Szenarien, in denen <xref:System.Windows.FrameworkElement.LayoutTransform%2A> nützlich wäre, sind z. b. das Drehen von Elementen, z. b. Menü Komponenten von horizontal zu vertikal oder umgekehrt, das Skalieren von Elementen (Zoomen) auf den Fokus, das Bereitstellen von Bearbeitungs Verhalten  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.FrameworkElement.LayoutTransform%2A> auf ein Element angewendet wird. Im Beispiel wird eine Instanz von erstellt <xref:System.Windows.Controls.Button> und in einem übergeordneten Element gehostet <xref:System.Windows.Controls.Grid> . Außerdem wird die- <xref:System.Windows.FrameworkElement.LayoutTransform%2A> Eigenschaft verwendet, um eine <xref:System.Windows.Media.RotateTransform> auf das anzuwenden <xref:System.Windows.Controls.Button> .  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">Beispiel für 2D-Transformationen</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Element ausgerichtet und gerendert sowie zur Interaktion vorbereitet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> ist in der Regel das letzte Ereignis, das in einer Element Initialisierungs Sequenz ausgelöst wird. Sie wird immer nach ausgelöst <xref:System.Windows.FrameworkElement.Initialized> . Ob Sie sich für <xref:System.Windows.FrameworkElement.Loaded> die Handhabung oder <xref:System.Windows.FrameworkElement.Initialized> die Abhängigkeit von Ihren Anforderungen entscheiden. Wenn Sie keine Element Eigenschaften lesen müssen, die Eigenschaften zurücksetzen möchten und keine Layoutinformationen benötigen, ist <xref:System.Windows.FrameworkElement.Initialized> möglicherweise das bessere Ereignis, auf das Sie reagieren müssen. Wenn alle Eigenschaften des-Elements verfügbar sein müssen und Sie Eigenschaften festlegen, die das Layout wahrscheinlich zurücksetzen, ist <xref:System.Windows.FrameworkElement.Loaded> möglicherweise das bessere Ereignis, auf das das Layout zurückgesetzt wird. Gehen Sie vorsichtig vor, wenn Ihr Handler alle vom Layoutsystem interpretierten Eigenschaften zurücksetzt, damit ein neuer Layoutdurchlauf erforderlich ist. (Möglicherweise müssen Sie die <xref:System.Windows.FrameworkPropertyMetadata> Werte für die-Eigenschaft überprüfen, wenn Sie nicht sicher sind, welche Eigenschaften einen neuen Layoutdurchlauf erfordern können, wenn Sie geändert werden.)  
  
 Weitere Informationen zur Sequenz von Objekt Ereignissen für eine <xref:System.Windows.FrameworkElement> und auch für mehrere verwandte Anwendungs-und Element Klassen finden Sie unter [Objekt Lebensdauer-Ereignisse](/dotnet/framework/wpf/advanced/object-lifetime-events).  
  
 Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden. Direkt geroutete Ereignisse unterstützen andere Routing Ereignis Verhalten: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.  
  
 <xref:System.Windows.FrameworkElement.Loaded> und <xref:System.Windows.FrameworkElement.Unloaded> können aufgrund von vom Benutzer initiierten Systemdesign Änderungen auch für Steuerelemente ausgelöst werden. Eine Designänderung bewirkt eine Invalidierung der Steuerelement Vorlage und der enthaltenen visuellen Struktur, die wiederum bewirkt, dass das gesamte Steuerelement entladen und neu geladen wird. Daher <xref:System.Windows.FrameworkElement.Loaded> kann nicht davon ausgegangen werden, dass Sie nur auftreten, wenn eine Seite zum ersten Mal durch Navigation zur Seite geladen wird.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.Loaded" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente dieses Elements ab.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> ermöglicht das Iterieren von untergeordneten Elementen. Dies ist nützlich für Elemente, die möglicherweise nicht über eine definierte, dedizierte Auflistung verfügen, aber immer noch mehr als ein untergeordnetes Element enthalten, insbesondere untergeordnete <xref:System.Windows.FrameworkContentElement> Elemente.  
  
 Weitere Informationen zur Verwendung von und finden Sie Unterstrukturen <xref:System.Windows.FrameworkElement.LogicalChildren%2A> <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> [in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/desktop-wpf/xaml-services/xarray-markup-extension">x:Array-Markuperweiterung</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den äußeren Rand eines Elements ab oder legt ihn fest.</summary>
        <value>Stellt Randwerte für das Element bereit. Der Standardwert ist eine <see cref="T:System.Windows.Thickness" />, bei der alle Eigenschaften gleich 0 (null) sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rand ist der Abstand zwischen diesem Element und anderen Elementen, die angrenzenden werden, wenn das Layout das-Element erstellt [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] . Freigegebene Elemente sind möglicherweise Peer Elemente (z. b. andere Elemente in der-Auflistung eines gemeinsamen übergeordneten Steuer Elements) oder auch das übergeordnete Element dieses Elements sein.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> wird als <xref:System.Windows.Thickness> Struktur anstatt als Zahl festgelegt, sodass der Rand asymmetrisch festgelegt werden kann. Die <xref:System.Windows.Thickness> Struktur selbst unterstützt die Konvertierung von Zeichen folgen Typen, sodass Sie auch eine asymmetrische <xref:System.Windows.FrameworkElement.Margin%2A> in der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Attribut Syntax angeben können.  
  
 Ein Rand ungleich NULL wendet den Bereich außerhalb des Elements und des Element Layouts an <xref:System.Windows.FrameworkElement.ActualWidth%2A> <xref:System.Windows.FrameworkElement.ActualHeight%2A> .  
  
 Ränder sind für gleich geordnete Elemente in einem Layout additiv. Beispielsweise haben zwei angrenzende Elemente, bei denen der Rand 30 auf dem angrenzenden Rand festgelegt ist, 60 Einheiten des Leerraums zwischen Ihnen.  
  
 Elemente, deren Ränder festgelegt sind, schränken in der Regel nicht die Größe der angegebenen ein, <xref:System.Windows.FrameworkElement.Margin%2A> Wenn der zugewiesene Rechteck Raum für den Rand und den Element Inhalts Bereich nicht groß genug ist. Der Element Inhalts Bereich wird stattdessen eingeschränkt, wenn das Layout berechnet wird. Der einzige Fall, in dem die Ränder eingeschränkt werden, ist auch, wenn der Inhalt bereits vollständig auf NULL beschränkt ist.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml  
<object Margin="left,top,right,bottom"/>  
```

- oder -

```xaml
<object Margin="left,top"/>  
```

- oder -  

```xaml
<object Margin="thicknessReference"/>  
```

<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *Links, oben, rechts, unten*  
 Zahlenwerte zwischen 0 und <xref:System.Double.PositiveInfinity> , die die vier möglichen Dimensions Eigenschaften einer <xref:System.Windows.Thickness> Struktur angeben.  
  
 Die Attribut Verwendung akzeptiert auch abgekürzte Werte, die in der angegebenen Reihenfolge (symmetrisch und logisch) angewendet werden. Beispiels `Margin="20"` Weise wird so interpretiert, dass eine bedeutet, dass <xref:System.Windows.Thickness> alle-Eigenschaften auf 20 festgelegt sind. `Margin="20,50"` wird so interpretiert, dass eine <xref:System.Windows.Thickness> mit <xref:System.Windows.Thickness.Left%2A> und <xref:System.Windows.Thickness.Right%2A> auf 20 und <xref:System.Windows.Thickness.Top%2A> und <xref:System.Windows.Thickness.Bottom%2A> auf 50 festgelegt wird.  
  
 Die Standardeinheit für ein <xref:System.Windows.Thickness> Measure ist [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] . Sie können auch andere Einheiten angeben, indem Sie die Unit Type Strings `cm` , `in` oder `pt` an ein beliebiges Measure anhängen.  
  
 Werte, die als Attribute bereitgestellt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , müssen keine Dezimalstellen angeben (0 ist akzeptabel, muss nicht als 0,0 angegeben werden). Weitere Informationen zur [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Verwendung finden Sie unter <xref:System.Windows.Thickness> .  
  
 *thicknessreference*  
 Ein Objekt Verweis auf einen vorhandenen <xref:System.Windows.Thickness> . Dies kann ein- `}` , ein-oder ein- `}` Verweis sein. Weitere Informationen zur [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Verwendung finden Sie unter <xref:System.Windows.Thickness> .  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Margin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die maximale Höhe ab bzw. legt diese fest.</summary>
        <value>Die maximale Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.PositiveInfinity" />. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. <see cref="F:System.Double.PositiveInfinity" /> ist ebenfalls gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um eine von drei Eigenschaften <xref:System.Windows.FrameworkElement> , die Höheninformationen angeben. Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinHeight%2A> und <xref:System.Windows.FrameworkElement.Height%2A> .  Wenn ein Konflikt zwischen diesen Werten vorliegt, muss zunächst die Reihenfolge der Anwendung für die tatsächliche Höhenbestimmung berücksichtigt <xref:System.Windows.FrameworkElement.MinHeight%2A> werden, dann <xref:System.Windows.FrameworkElement.MaxHeight%2A> und schließlich, wenn sich diese innerhalb der Grenzen befinden <xref:System.Windows.FrameworkElement.Height%2A> .  
  
 Die Wert Einschränkungen für den <xref:System.Double> Wert werden von einem <xref:System.Windows.ValidateValueCallback> Mechanismus erzwungen. Wenn Sie versuchen, einen ungültigen Wert festzulegen, wird eine Lauf Zeit Ausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml  
<object MaxHeight="double"/>  
```

- oder -

```xaml
<object MaxHeight ="qualifiedDouble"/>  
```

<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts, der gleich oder größer als 0,0 ist. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Maßeinheit interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 Die gleichen <xref:System.Double> Bereichs Einschränkungen wie im Abschnitt mit den Eigenschafts Werten werden angewendet, mit dem Unterschied, dass Sie die [x:statische Markup Erweiterung](/dotnet/framework/xaml-services/x-static-markup-extension) verwenden müssen, wenn Sie den Wert explizit auf festlegen müssen <xref:System.Double.PositiveInfinity> .  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px` , `in` , `cm` , `pt` .  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll; 1In = = 96px  
  
 `cm` ist Zentimeter; 1cm = = (96/2,54) px  
  
 `pt` ist Punkte 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MaxHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die maximale Breite ab bzw. legt diese fest.</summary>
        <value>Die maximale Breite des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist <see cref="F:System.Double.PositiveInfinity" />. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. <see cref="F:System.Double.PositiveInfinity" /> ist ebenfalls gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um eine von drei Eigenschaften <xref:System.Windows.FrameworkElement> , die Informationen zur Breite angeben. Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinWidth%2A> und <xref:System.Windows.FrameworkElement.Width%2A> . Wenn ein Konflikt zwischen diesen Werten vorliegt, muss zunächst die Reihenfolge der Anwendung für die tatsächliche breiten Bestimmung berücksichtigt <xref:System.Windows.FrameworkElement.MinWidth%2A> werden, dann <xref:System.Windows.FrameworkElement.MaxWidth%2A> und schließlich, wenn sich diese innerhalb der Grenzen befinden <xref:System.Windows.FrameworkElement.Width%2A> .  
  
 Die Wert Einschränkungen für den <xref:System.Double> Wert werden von einem <xref:System.Windows.ValidateValueCallback> Mechanismus erzwungen. Wenn Sie versuchen, einen ungültigen Wert festzulegen, wird eine Lauf Zeit Ausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml 
<object MaxWidth="double"/>  
```

- oder -

```xaml
<object MaxWidth="qualifiedDouble"/>  
```

<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts, der gleich oder größer als 0,0 ist. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Maßeinheit interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 Die gleichen <xref:System.Double> Bereichs Einschränkungen wie im Abschnitt mit den Eigenschafts Werten werden angewendet, mit dem Unterschied, dass Sie die [x:statische Markup Erweiterung](/dotnet/framework/xaml-services/x-static-markup-extension) verwenden müssen, um den Wert auf festzulegen <xref:System.Double.PositiveInfinity> .  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px` , `in` , `cm` , `pt` .  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll; 1In = = 96px  
  
 `cm` ist Zentimeter; 1cm = = (96/2,54) px  
  
 `pt` ist Punkte 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MaxWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die das übergeordnete Element an die untergeordneten Elemente übergeben kann.</param>
        <summary>Implementiert das grundlegende Systemverhalten für das Layout zur Measureübergabe für <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Die gewünschte Größe dieses Elements im Layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> , um die Implementierungen der layoutmeasures auf WPF-Kern-und WPF-Frameworkebene zu verbinden. Die- <xref:System.Windows.FrameworkElement> Implementierung versiegelt die-Methode. Um das Measure Pass Layout-Verhalten eines beliebigen Elements anzupassen, das auf der WPF-Frameworkebene aufbaut, überschreiben Sie <xref:System.Windows.FrameworkElement.MeasureOverride%2A> stattdessen. Um das Measure Pass Layout-Verhalten eines Elements anzupassen, das absichtlich nicht auf der WPF-Frameworkebene erstellt oder verwendet <xref:System.Windows.FrameworkElement> wird, überschreiben Sie <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die dieses Element untergeordneten Elementen bereitstellen kann. „Unendlich“ kann als Wert angegeben werden, um festzulegen, dass das Element an die Größe des jeweiligen Inhalts angepasst wird.</param>
        <summary>Misst beim Überschreiben in einer abgeleiteten Klasse die für untergeordnete Elemente im Layout benötigte Größe und bestimmt eine Größe für die von <see cref="T:System.Windows.FrameworkElement" /> abgeleitete Klasse.</summary>
        <returns>Die für dieses Element beim Layout benötigte Größe, basierend auf der Berechnung der Größen der untergeordneten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie <xref:System.Windows.FrameworkElement.MeasureOverride%2A> , um ein benutzerdefiniertes layoutgrößenverhalten für Ihr Element zu implementieren [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Ihre Implementierung sollte folgende Aktionen ausführen:  
  
1.  Iterieren Sie die jeweilige Auflistung von untergeordneten Elementen, die Teil des Layouts sind, und fordern Sie <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element an.  
  
2.  Sofort <xref:System.Windows.UIElement.DesiredSize%2A> auf das untergeordnete Element (Dies wird als Eigenschaft festgelegt, nachdem <xref:System.Windows.UIElement.Measure%2A> aufgerufen wurde).  
  
3.  Berechnet die gewünschte Netzwerkgröße des übergeordneten Elements basierend auf der Messung der untergeordneten Elemente.  
  
 Der Rückgabewert von <xref:System.Windows.FrameworkElement.MeasureOverride%2A> sollte die gewünschte Größe des Elements sein, die dann die Maßeinheit für das übergeordnete Element des aktuellen Elements wird. Derselbe Prozess wird über das Layoutsystem fortgesetzt, bis das Stamm Element der Seite erreicht ist.  
  
 Während dieses Vorgangs können untergeordnete Elemente eine größere <xref:System.Windows.UIElement.DesiredSize%2A> Größe als die anfängliche zurückgeben, `availableSize` um anzugeben, dass das untergeordnete Element mehr Platz benötigt. Dies kann in ihrer eigenen Implementierung erfolgen, indem ein Bild lauffähiger Bereich eingeführt wird, indem die Größe des übergeordneten Steuer Elements geändert wird, indem eine gestapelte Reihenfolge oder eine beliebige Anzahl von Lösungen zum Messen oder Anordnen von Inhalten festgelegt wird.  
  
> [!IMPORTANT]
>  Elemente sollten <xref:System.Windows.UIElement.Measure%2A> während dieses Vorgangs für jedes untergeordnete Element aufgerufen werden. andernfalls werden die untergeordneten Elemente nicht ordnungsgemäß formatiert oder angeordnet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Der folgende nicht Kompilier Bare Code zeigt dieses Implementierungs Muster.  <c>VisualChildren</c> stellt eine Aufzähl Bare Auflistungs Eigenschaft von untergeordneten Elementen dar, die von Ihrem eigenen Element definiert werden sollten. Die-Eigenschaft kann beliebig benannt werden. <c>VisualChildren</c> ist ein Platzhalter Name für dieses Beispiel. <c>VisualChildren</c> ist keine API, die von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] oder einem Teil eines Benennungs Musters bereitgestellt wird. 
  
[! Code-csharp[corepseudocode # femessreoverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [! Code-vb[corepseudocode # femessreoverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die minimale Höhe ab bzw. legt diese fest.</summary>
        <value>Die minimale Höhe des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0,0. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. Allerdings ist <see cref="F:System.Double.PositiveInfinity" /> NICHT gültig, noch <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um eine von drei Eigenschaften <xref:System.Windows.FrameworkElement> , die Höheninformationen angeben.  Die anderen beiden sind <xref:System.Windows.FrameworkElement.Height%2A> und <xref:System.Windows.FrameworkElement.MaxHeight%2A> . Wenn ein Konflikt zwischen diesen Werten vorliegt, muss zunächst die Reihenfolge der Anwendung für die tatsächliche Höhenbestimmung berücksichtigt <xref:System.Windows.FrameworkElement.MinHeight%2A> werden, dann <xref:System.Windows.FrameworkElement.MaxHeight%2A> und schließlich, wenn sich diese innerhalb der Grenzen befinden <xref:System.Windows.FrameworkElement.Height%2A> .  
  
 Die Wert Einschränkungen für den <xref:System.Double> Wert werden von einem <xref:System.Windows.ValidateValueCallback> Mechanismus erzwungen. Wenn Sie versuchen, einen ungültigen Wert festzulegen, wird eine Lauf Zeit Ausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml
<object MinHeight="double"/>  
```

- oder -

```xaml
<object MinHeight="qualifiedDouble"/>  
```

<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts, der gleich oder größer als 0,0 ist. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Maßeinheit interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 Die gleichen <xref:System.Double> Bereichs Einschränkungen wie im Abschnitt mit den Eigenschafts Werten werden angewendet.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px` , `in` , `cm` , `pt` .  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll; 1In = = 96px  
  
 `cm` ist Zentimeter; 1cm = = (96/2,54) px  
  
 `pt` ist Punkte 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MinHeight" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Einschränkung des Elements für die minimale Breite ab bzw. legt diese fest.</summary>
        <value>Die Mindestbreite des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Der Standardwert ist 0,0. Dieser Wert kann ein beliebiger Wert gleich oder größer als 0,0 sein. Allerdings ist weder <see cref="F:System.Double.PositiveInfinity" /> noch <see cref="F:System.Double.NaN" /> gültig.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um eine von drei Eigenschaften <xref:System.Windows.FrameworkElement> , die Informationen zur Breite angeben.  Die anderen beiden sind <xref:System.Windows.FrameworkElement.Width%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A> .  Wenn ein Konflikt zwischen diesen Werten vorliegt, muss zunächst die Reihenfolge der Anwendung für die tatsächliche breiten Bestimmung berücksichtigt <xref:System.Windows.FrameworkElement.MinWidth%2A> werden, dann <xref:System.Windows.FrameworkElement.MaxWidth%2A> und schließlich, wenn sich diese innerhalb der Grenzen befinden <xref:System.Windows.FrameworkElement.Width%2A> .  
  
 Die Wert Einschränkungen für den <xref:System.Double> Wert werden von einem <xref:System.Windows.ValidateValueCallback> Mechanismus erzwungen. Wenn Sie versuchen, einen ungültigen Wert festzulegen, wird eine Lauf Zeit Ausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml 
<object MinWidth="double"/>  
```

- oder -

```xaml
<object MinWidth="qualifiedDouble"/>  
```
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts, der gleich oder größer als 0,0 ist. Dies wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Maßeinheit interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 Die gleichen <xref:System.Double> Bereichs Einschränkungen wie im Abschnitt mit den Eigenschafts Werten werden angewendet.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px` , `in` , `cm` , `pt` .  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll; 1In = = 96px  
  
 `cm` ist Zentimeter; 1cm = = (96/2,54) px  
  
 `pt` ist Punkte 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.MinWidth" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Die Richtung, in die der Fokus verschoben werden soll, als Wert der Enumeration.</param>
        <summary>Verschiebt den Tastaturfokus von diesem Element in einer angegebenen Durchlaufrichtung zu einem anderen Element.</summary>
        <returns>Gibt <see langword="true" /> zurück, wenn der Fokus erfolgreich verschoben wurde. <see langword="false" /> wird zurückgegeben, wenn das Zielelement in der angegebenen Richtung nicht vorhanden ist oder den Tastaturfokus nicht erhalten kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung überschreibt <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> und versiegelt die-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Handler implementiert, der mehrere mögliche Schaltflächen Eingaben behandelt. Jede Schaltfläche stellt ein mögliches dar <xref:System.Windows.Input.FocusNavigationDirection> . Der Handler verfolgt das Element mit dem aktuellen Tastaturfokus und ruft für <xref:System.Windows.FrameworkElement.MoveFocus%2A> dieses Element auf, indem er die entsprechende <xref:System.Windows.Input.FocusNavigationDirection> als Initialisierung für den <xref:System.Windows.Input.TraversalRequest> angegebenen Typparameter angibt.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.MergableProperty(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.MergableProperty(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Windows.Markup.DesignerSerializationOptions]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.DesignerSerializationOptions&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Elementnamens. Der Name stellt einen Verweis bereit, damit CodeBehind, wie etwa Ereignishandlercode, auf ein Markupelement verweisen kann, nachdem es während der Verarbeitung durch einen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Prozessor konstruiert wurde.</summary>
        <value>Der Name des Elements. Der Standardwert ist eine leere Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird am häufigsten verwendet, um einen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Elementnamen als Attribut in Markup anzugeben.  
  
 Diese Eigenschaft bietet im Wesentlichen eine Eigenschaft der WPF-Frameworkebene zum Festlegen der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name-Direktive](/dotnet/framework/xaml-services/x-name-directive).  
  
 Namen müssen innerhalb eines Namescope eindeutig sein. Weitere Informationen hierzu finden Sie unter [WPF-XAML-Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).  
  
 Das erhalten eines, <xref:System.Windows.FrameworkElement.Name%2A> Wenn Sie Elemente im Code erstellen, ist nicht üblich. Wenn Sie bereits über den entsprechenden Verweis im Code verfügen, können Sie einfach Methoden und Eigenschaften für den Element Verweis aufzurufen und benötigen nicht in der Regel <xref:System.Windows.FrameworkElement.Name%2A> . Eine Ausnahme ist, wenn die <xref:System.Windows.FrameworkElement.Name%2A> Zeichenfolge eine überladene Bedeutung hat, beispielsweise, wenn es sinnvoll ist, den Namen in anzuzeigen [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] . Das Festlegen eines <xref:System.Windows.FrameworkElement.Name%2A> aus Code Behind, wenn der ursprüngliche Wert <xref:System.Windows.FrameworkElement.Name%2A> aus Markup festgelegt wurde, wird ebenfalls nicht empfohlen. Wenn Sie die-Eigenschaft nach dem Laden von ändern, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wird der ursprüngliche Objekt Verweis nicht geändert. Die Objekt Verweise werden nur erstellt, wenn die zugrunde liegenden Namescopes während der Verarbeitung explizit erstellt werden. Sie müssen ausdrücklich aufzurufen <xref:System.Windows.FrameworkElement.RegisterName%2A> , um eine effektive Änderung an der- <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft eines bereits geladenen Elements vorzunehmen.  
  
 Ein wichtiger Fall, bei dem <xref:System.Windows.FrameworkElement.Name%2A> die Einstellung aus dem Code wichtig ist, ist das Registrieren von Namen für Elemente, für die Storyboards ausgeführt werden, sodass zur Laufzeit auf Sie verwiesen werden kann. Bevor Sie einen Namen registrieren können, müssen Sie möglicherweise auch eine-Instanz instanziieren und zuweisen <xref:System.Windows.NameScope> . Weitere Informationen finden Sie im Beispiel Abschnitt oder in der [Übersicht über Storyboards](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).  
  
 <xref:System.Windows.FrameworkElement.Name%2A>Die Einstellung aus dem Code weist eingeschränkte Anwendungen auf, aber das erhalten eines Elements von <xref:System.Windows.FrameworkElement.Name%2A> ist häufiger. Ein bestimmtes Szenario ist, wenn Ihre Anwendung ein Navigations Modell unterstützt, in dem Seiten in die Anwendung geladen werden, und der Lauf Zeit Code nicht notwendigerweise Code Behind für diese Seite definiert ist. Die hilfsprogrammmethode <xref:System.Windows.FrameworkElement.FindName%2A> , die von jedem verfügbar ist, <xref:System.Windows.FrameworkElement> kann jedes beliebige Element <xref:System.Windows.FrameworkElement.Name%2A> in der logischen Struktur für dieses Element finden und die Struktur nach Bedarf rekursiv durchsuchen. Oder Sie können die <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statische Methode von verwenden <xref:System.Windows.LogicalTreeHelper> , die auch eine <xref:System.Windows.FrameworkElement.Name%2A> Zeichenfolge als Argument annimmt.  
  
 Normalerweise verwendete Stamm Elemente <xref:System.Windows.Window> ( <xref:System.Windows.Controls.Page> z. b.) implementieren die-Schnittstelle <xref:System.Windows.Markup.INameScope> . Bei Implementierungen dieser Schnittstelle wird erwartet, dass die Namen innerhalb ihres Bereichs eindeutig sind. Die Stamm Elemente, die diese Schnittstelle definieren, definieren auch die Namescope-Verhaltens Grenzen für alle zugehörigen APIs.  
  
 Die- <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft dient auch als Bezeichner für andere Prozesse. Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Automatisierungs Modell verwendet Beispiels <xref:System.Windows.FrameworkElement.Name%2A> Weise als AutomationId für Clients und Anbieter.  
  
 Die für verwendeten Zeichen folgen Werte weisen <xref:System.Windows.FrameworkElement.Name%2A> einige Einschränkungen auf, die von der zugrunde liegenden [x:Name-Direktive](/dotnet/framework/xaml-services/x-name-directive) auferlegt werden, die durch die Spezifikation definiert ist [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Vor allem muss ein <xref:System.Windows.FrameworkElement.Name%2A> mit einem Buchstaben oder einem Unterstrich (_) beginnen und darf nur Buchstaben, Ziffern oder Unterstriche enthalten. Weitere Informationen hierzu finden Sie unter [WPF-XAML-Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> ist eine der sehr wenigen Abhängigkeits Eigenschaften, die nicht animiert werden können ( <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> ist `true` in den Metadaten), da der Name selbst für eine Animation entscheidend ist. Datenbindung a <xref:System.Windows.FrameworkElement.Name%2A> ist technisch möglich, ist aber ein äußerst ungewöhnliches Szenario, da eine Daten gebundene <xref:System.Windows.FrameworkElement.Name%2A> nicht den Hauptzweck der Eigenschaft erfüllen kann:, um einen bezeichnerverbindungspunkt für Code Behind bereitzustellen.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.FrameworkElement.Name%2A> -Eigenschaft im Code festgelegt, und anschließend wird der Name in der neu erstellten registriert, <xref:System.Windows.NameScope> indem aufgerufen wird <xref:System.Windows.FrameworkElement.RegisterName%2A> . Das hier dargestellte Verfahren ist eine Voraussetzung für die Animation mit Storyboards, da für Storyboards das Ziel von erforderlich ist <xref:System.Windows.FrameworkElement.Name%2A> und der Objekt Verweis nicht als Ziel verwendet werden kann.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Name" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird beim Überschreiben in einer abgeleiteten Klasse immer dann aufgerufen, wenn Anwendungscode oder interne Prozesse <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> aufrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung.  
  
 Vorlagen sind der Abschnitt der vollständigen visuellen Struktur eines Elements, das aus der Template-Eigenschaft eines stammt <xref:System.Windows.Style> , das auf das-Element angewendet wird. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](/dotnet/framework/wpf/controls/styling-and-templating).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Abgeleitete Klassen von <see cref="T:System.Windows.FrameworkElement" /> können diese Methode als Benachrichtigung für eine Vielzahl möglicher Szenarien verwenden: 
-Sie können Ihre eigene Implementierung von Code aufzurufen, der den Rest einer visuellen Elementstruktur erstellt.  
  
-Sie können Code ausführen, der auf der visuellen Struktur von Vorlagen basiert, die angewendet wurden, z. b. das Abrufen von Verweisen auf benannte Elemente, die aus einer Vorlage stammen.  
  
-Sie können Dienste einführen, die erst nach dem Abschluss der visuellen Struktur aus Vorlagen vorhanden sind.  
  
-Sie können Zustände und Eigenschaften von Elementen innerhalb der Vorlage festlegen, die von anderen Faktoren abhängig sind. Eigenschaftswerte können z. b. nur erkannt werden, wenn das übergeordnete Element bekannt ist oder wenn eine bestimmte abgeleitete Klasse eine gemeinsame Vorlage verwendet.  
  
Implementierer sollten die Basis Implementierung immer vor ihrer eigenen Implementierung abrufen. <see cref="T:System.Windows.FrameworkElement" /> selbst hat keine Standard Implementierung, aber auch dazwischenliegende Klassen sind möglich.  
  
 <see cref="T:System.Windows.Controls.Control" /> bietet eine ähnliche außer Kraft Setzung: <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Sie sollten die Basis Implementierung weiterhin für den Fall aufzurufen, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen). Unterklassen von <xref:System.Windows.FrameworkElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und das Ereignis absichtlich als behandelt zu markieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />-Element, das die Ereignisdaten enthält.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Sie sollten die Basis Implementierung weiterhin für den Fall aufzurufen, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen). Unterklassen von <xref:System.Windows.FrameworkElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und das Ereignis absichtlich als behandelt zu markieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />-Element, das die Ereignisdaten enthält.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.GotFocus" />-Ereignis dieses Element auf der Route erreicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu anderen Methoden in *, die von den Basiselementen verfügbar gemacht werden, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> verfügt über eine Standard Implementierung. Es verfügt insbesondere über eine-Implementierung, die die NULL-Implementierung auf der nächsten Ebene des Basis Elements nach unten überschreibt <xref:System.Windows.UIElement.OnGotFocus%2A> . Wenn das Ereignis aufgerufen wird, wird das <xref:System.Windows.FrameworkElement.OnGotFocus%2A> entsprechende Fokus Verhalten für dieses Element in Fällen festgelegt, in denen das Ereignis aus dem aktuellen Element aufgrund des Tastaturfokus stammt. Der <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Handler markiert die Ereignis Argumente nicht als behandelt, auch wenn der Fokus auf das aktuelle Element festgelegt ist. Wenn die Quelle des Ereignisses ein anderes Element in der Struktur (nicht das aktuelle Element) war, führt der Handler keine Aktion aus.  
  
 Sie können diese Methode überschreiben, um das Standardverhalten des Fokus für das Element zu ändern, aber beachten Sie, dass das Ändern des Fokus Verhaltens auf diese Weise besser erreicht werden kann, da das Element überhaupt nicht verwendet werden kann (siehe <xref:System.Windows.UIElement.Focusable%2A> ).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie beabsichtigen, das Ereignis in den Argumenten behandelt zu markieren, sollten Sie die Konsequenzen bei der Ereignis Behandlung in anderen übergeordneten Elementen in der Elementstruktur beachten. Da dieser Handler für ein Ereignis mit einem bubblingerweiterleitungs-Routing fungiert, ist das Festlegen des Fokus auf die aktuelle-Klasse <paramref name="sender" /> pro Ereignis Argument möglicherweise nicht geeignet. Der Fokus muss möglicherweise entweder in einem zusammengesetzten untergeordneten Element oder in einem übergeordneten Element auftreten, abhängig von der Zusammensetzung bestimmter Steuerelemente. Daher wird empfohlen, ein Fokus Ereignis als behandelt zu markieren, wenn die gesamte visuelle Struktur, die das Ereignis weiterleiten soll, Teil der Zusammensetzung eines Steuer Elements ist, das Sie erstellt haben.</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.RoutedEventArgs" />-Element, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.FrameworkElement.Initialized" />-Ereignis aus. Diese Methode wird immer aufgerufen, wenn <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> intern auf <see langword="true" /> festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese bestimmte on *-Methode ist kein klassenhandlerhook. Außerdem befolgt Sie genau die festgelegte [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] on *-Methoden Konvention nicht, dass das Übereinstimmungs Ereignis unterdrückt werden kann, indem diese Methode außer Kraft gesetzt und nicht die Basis Implementierung aufgerufen wird.  
  
 Beachten Sie, dass die <xref:System.Windows.FrameworkElement.IsInitialized%2A> -Eigenschaft schreibgeschützt ist, sodass Sie nicht festlegen können, <xref:System.Windows.FrameworkElement.IsInitialized%2A> um das Initialisierungs Verhalten zu erzwingen. Das Festlegen des Initialisierungs Zustands soll nur durch das [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework erfolgen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die Standardimplementierung dieser virtuellen Methode löst das Ereignis wie oben beschrieben aus. Bei Überschreibungen sollte die Basisimplementierung aufgerufen werden, um dieses Verhalten beizubehalten. Wenn Sie die Basis Implementierung nicht aufzurufen, wird das-Ereignis nicht nur <see cref="E:System.Windows.FrameworkElement.Initialized" /> wie bei einer <see cref="T:System.Windows.FrameworkElement" /> abgeleiteten Klasse, sondern auch mit zwei wichtigen Initialisierungs Vorgängen im Stil und im Design Stil unterdrückt, die von dieser Basis Implementierung implementiert werden.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten, die die geänderte Eigenschaft beschreibt, sowie die alten und neuen Werte.</param>
        <summary>Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.FrameworkElement" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet. Überschreibt <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht dafür vorgesehen, Eigenschafts Änderungen oder-Invalidierungen in der Regel zu erkennen. Er ist stattdessen für Änderungen des allgemeinen invalidierungsmusters vorgesehen, wenn bestimmte Informationen über breite Klassifizierungen von Eigenschaften bekannt sind.  
  
 Diese Methode wird möglicherweise mehrmals während der Lebensdauer eines Objekts aufgerufen. Aus diesem Grund können Sie eine bessere Leistung erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und dann eine Verbindung mit den <xref:System.Windows.CoerceValueCallback> <xref:System.Windows.PropertyChangedCallback> einzelnen Eigenschaften anfügen. Sie verwenden diese Methode jedoch, wenn eine <xref:System.Windows.FrameworkElement> eine beträchtliche Anzahl von Wert abhängigen Abhängigkeits Eigenschaften enthält, oder wenn Sie eine Logik wie das Renderingverhalten enthält, das für mehrere verwandte Fälle von Eigenschafts Invalidierungen erneut ausgeführt werden muss.  
  
 Beachten Sie, dass es eine identisch benannte `OnPropertyChanged` Methode mit einer anderen Signatur gibt (der Parametertyp ist <xref:System.ComponentModel.PropertyChangedEventArgs> ), die für eine Reihe von Klassen angezeigt werden kann. Wird `OnPropertyChanged` für Datenobjekt Benachrichtigungen verwendet und ist Teil des Vertrags für <xref:System.ComponentModel.INotifyPropertyChanged> .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Nennen Sie die Basis Implementierung immer als ersten Vorgang in der Implementierung. Wenn dies nicht der Fall ist, wird das gesamte [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaften System erheblich deaktiviert, was dazu führt, dass falsche Werte gemeldet werden. Die spezifische <see cref="T:System.Windows.FrameworkElement" /> Implementierung ist auch dafür verantwortlich, den richtigen Zustand für eine Vielzahl von Eigenschaften beizubehalten, die die sichtbare Benutzeroberfläche beeinflussen. Dazu gehört das invalidieren der visuellen Struktur auf der Grundlage von Änderungen am Stil zu den entsprechenden Zeiten.</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Details zu den an der Änderung beteiligten alten und neuen Größen.</param>
        <summary>Löst das <see cref="E:System.Windows.FrameworkElement.SizeChanged" />-Ereignis unter Verwendung der angegebenen Informationen als Teil der möglichen Ereignisdaten aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Wenn Sie diese Methode aufgerufen haben, setzen Sie die-Eigenschaft, <xref:System.Windows.FrameworkElement.ActualWidth%2A> die- <xref:System.Windows.FrameworkElement.ActualHeight%2A> Eigenschaft oder beides zurück, je nachdem, was in den bereitgestellten Argumenten als geändert angegeben wurde, und wird das-Ereignis immer zurücksetzen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Überschreiben Sie diese Methode nicht für typische Layoutszenarien. Das Layoutsystem wird in einer absichtlich asynchronen Weise betrieben, um sicherzustellen, dass alle möglichen layoutanordnen-und Measure-Fälle berücksichtigt werden. Das Layoutsystem überschreibt Methoden <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> und <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> ist in der Regel ausreichend für jede erforderliche Layoutanpassung. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> wird als Virtual verfügbar gemacht. Sie können <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> überschreiben, um in Ausnahmefällen zu korrigieren, in denen eine Lauf Zeit Verhaltensänderung in Bezug auf Eingabeereignisse, die mit der Neukomposition von Steuerelementen in der Antwort kombiniert werden, falsche Layoutinformationen  
  
Sie können diese Methode trotzdem in abgeleiteten Klassen überschreiben (Sie ist geschützt, aber nicht versiegelt). Rufen Sie immer die Basis Implementierung auf, um das oben erwähnte Verhalten beizubehalten, es sei denn, Sie haben sehr spezielle Gründe, das Renderingverhalten auf WPF-Frameworkebene zu deaktivieren Wenn das Ereignis nicht ausgelöst wird, führt dies zu einem <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> nicht standardmäßigen Layoutverhalten, wenn die Standard Implementierung des Layoutsystems auf WPF-Frameworkebene</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Der alte Stil.</param>
        <param name="newStyle">Der neue Stil.</param>
        <summary>Wird aufgerufen, wenn sich der verwendete Stil für dieses Element ändert und dadurch das Layout ungültig wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über eine Standard Implementierung, die ein internes Flag festlegt, das die Formatvorlagen Änderung angibt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Sie sollten diese Methode in der Regel nicht überschreiben. Jede Änderung an einem Stil, in der ein Measure oder eine Anordnungs Änderung beteiligt ist, löst bereits einen anderen Renderingdurchlauf aus, der eine typische Implementierung von <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> oder die Standardwerte voraussetzt <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />Außer Kraft setzungen von sind möglicherweise sinnvoll, wenn Ihre <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> Implementierungen eine absichtliche Optimierung oder Unterstützung von Teil Updates aufweisen, aber trotzdem Änderungen auf Stile direkt anwenden wollten. (Bei partiellen Updates handelt es sich um einen Versuch, mehrere inkrementelle Aufrufe von <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> und <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> für alle untergeordneten Elemente zu vermeiden.)</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn ein nicht behandeltes <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Sie sollten die Basis Implementierung weiterhin für den Fall aufzurufen, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen). Unterklassen von <xref:System.Windows.FrameworkElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und das Ereignis absichtlich als behandelt zu markieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Sie sollten die Basis Implementierung weiterhin für den Fall aufzurufen, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen). Unterklassen von <xref:System.Windows.FrameworkElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das alte übergeordnete Element. Kann <see langword="null" /> sein, um anzugeben, dass das Element zuvor über kein visuelles übergeordnetes Element verfügt hat.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element dieses Elements in der visuellen Struktur geändert wird. Überschreibt <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die visuelle Struktur unterscheidet sich potenziell von der logischen Struktur, da Sie keine Elemente auslässt, die nicht visuell dargestellt werden, z. b. Auflistungen, und einige Elemente auf Grundlage ihrer Design-und Stil Komposition erweitert. Weitere Informationen finden Sie unter [Strukturen in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die Standard Implementierung dieser virtuellen Methode fragt das neue übergeordnete Element ab, löst verschiedene Initialisierungs Ereignisse aus und legt interne Flags über den Initialisierungs Zustand von <see cref="T:System.Windows.FrameworkElement" /> entsprechend fest. Schließlich ruft Sie die aufeinander folgenden Basis Implementierungen gemäß der Deklaration von auf <see cref="T:System.Windows.UIElement" /> , die wiederum ihre Basis in aufruft <see cref="T:System.Windows.Media.Visual" /> . Die Basis Implementierung wird immer aufgerufen, um dieses Verhalten beizubehalten, andernfalls ist das Elementstruktur Verhalten für dieses Element, wenn es als untergeordnetes Element eines anderen Elements deklariert ist, möglicherweise nicht wie erwartet.  
  
Einige vorhandene [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Klassen überschreiben diese Methode, z. b <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" /> <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" /> .:. Das häufigste Szenario besteht darin, dass das neue übergeordnete Element einen bestimmten Typ aufweisen muss. Dies kann dazu führen, dass eine Ausnahme ausgelöst wird, wenn das neue übergeordnete Element einen Typtest nicht bestanden hat. Eine spezielle Version dieses Szenarios ist in Implementierungen für Listenelemente und Menü Elemente enthalten, die außerhalb eines übergeordneten visuellen Elements, das eine entsprechende Auflistung besitzt, nicht in den Speicher zu speichern. Beachten Sie, dass diese Fälle nicht notwendigerweise Ausnahmen hervorrufen, da es möglicherweise Designer Szenarien gibt, die sich auf die Neuzuordnung von Elementen stützen, die sich vorübergehend ohne Ihre "regulären" übergeordneten Elemente befinden.  
  
Diese Methode wird auch in bestimmten Elementen überschrieben, die in der Regel das Stamm Element sind, z  <see cref="T:System.Windows.Window" /> . b.. Ein weiterer Fall sind Elemente, die das sichtbare Stamm Element im Markup sind, jedoch eine größere Infrastruktur in einer kompilierten logischen Struktur (z <see cref="T:System.Windows.Controls.Page" /> . b.) automatisch generieren. Die <see cref="T:System.Windows.Window" /> -und- <see cref="T:System.Windows.Controls.Page" /> Implementierungen versiegeln die-Methode absichtlich.</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt einen Wert fest, der angibt, ob dieses Element die Formatvorlageneigenschaften aus Designformatvorlagen enthalten soll.</summary>
        <value><see langword="true" />, wenn dieses Element keine Designstileigenschaften verwendet, alle auf Stile zurückgehenden Eigenschaften aus den Stilen lokaler Anwendungen stammen und die Designstileigenschaften nicht angewendet werden. <see langword="false" />, wenn Anwendungsstile vor Designstilen auf Eigenschaften angewendet werden, die in Anwendungsstilen nicht explizit festgelegt wurden. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Verwendung dieser Eigenschaft ist eine indirekte Verwendung innerhalb des Setter eines Stils, der einen Stil mit Design bereitstellt.  
  
> [!IMPORTANT]
>  Wenn Sie <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> für ein Steuerelement auf festlegen `true` , wird die Standard Steuerelement Vorlage unterdrückt, die von den Designstilen bereitgestellt wird. Diese Steuerelement Vorlage umfasst in der Regel den Content Presenter und andere zusammengesetzte Elemente, die grundlegende [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Funktionalität und Visualisierung für das Steuerelement bereitstellen. Wenn das Steuerelement die gleichen Funktionen wie die Standarddesign Stile weiterhin unterstützen soll, müssen Sie einen alternativen Stil mit einer Steuerelement Vorlage angeben, die die gleiche Struktur repliziert. Weitere Informationen finden Sie unter [Übersicht über das Erstellen von Steuerelementen](/dotnet/framework/wpf/controls/control-authoring-overview).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das logische übergeordnete Element dieses Elements ab.</summary>
        <value>Das logische übergeordnete Element dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> kann `null` in Fällen vorkommen, in denen ein Element instanziiert wurde, aber nicht an eine logische Struktur angefügt ist, die schließlich eine Verbindung mit dem Stamm Element auf Seitenebene oder dem Anwendungs Objekt herstellt.  
  
 Beachten Sie, dass das logische übergeordnete Element eines Elements abhängig von der Funktionalität Ihrer Anwendung möglicherweise geändert werden kann. Wenn Sie den Wert dieser Eigenschaft beibehalten, wird diese Änderung nicht widerspiegelt. Sie sollten den Wert in der Regel direkt vor dem Bedarf erhalten.  
  
 Weitere Informationen zum Durchlaufen der logischen Struktur finden Sie Unterstrukturen [in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf) und in Szenarien, in denen die Verwendung  <xref:System.Windows.FrameworkElement.Parent%2A> von als Methode der übergeordneten Element Ermittlung angemessen ist.  
  
 Die Eigenschaften-Engine berechnet möglicherweise alle Eigenschaftswerte eines Elements neu, wenn diese neu erstellt werden, da einige Eigenschaften Werte über die logische Struktur erben. Das <xref:System.Windows.FrameworkElement.DataContext%2A> , das für Bindungen gilt, kann sich auch ändern, wenn Elemente neu zugeordnet werden.  
  
 Das übergeordnete Element eines Elements wird in der Regel nur durch die Bearbeitung von Auflistungen, durch die Verwendung von dedizierten Add-und Remove-Methoden oder durch Festlegen von Inhalts Eigenschaften von Elementen erreicht  
  
 Das typische Szenario für die Verwendung der- <xref:System.Windows.FrameworkElement.Parent%2A> Eigenschaft ist das Abrufen eines Verweises und das anschließende Abrufen verschiedener <xref:System.Windows.FrameworkElement> Eigenschaftswerte aus dem übergeordneten Element. Bei Vorlagen ist die <xref:System.Windows.FrameworkElement.Parent%2A> der Vorlage schließlich `null` . Um diesen Punkt zu erreichen und in die logische Struktur auszudehnen, in der die Vorlage tatsächlich angewendet wird, verwenden Sie <xref:System.Windows.FrameworkElement.TemplatedParent%2A> .  
  
 Beachten Sie, dass diese Eigenschaft in Fällen, in denen diese von den übergeordneten Elementen der logischen Struktur abweichen, keine übergeordneten Elemente von Visual Tree Übergeordnete Elemente von Visual Tree sind in der Regel für allgemeine Anwendungsfälle nicht wichtig, sind aber möglicherweise die gewünschten übergeordneten Elemente für bestimmte visuelle ebenenfälle. Siehe <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt Code, der das übergeordnete Element eines Elements überprüft und dann Eigenschaftswerte aus dem übergeordneten Element verwendet, um die Eigenschaften für das untergeordnete Element entsprechend festzulegen. In diesem Fall handelt es sich hierbei um Eigenschaften, die die Renderinggröße beeinflussen.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Das untergeordnete Element, das die Änderung meldet.</param>
        <summary>Unterstützt inkrementelle Layoutimplementierungen in spezielle Unterklassen des <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> wird aufgerufen, wenn ein untergeordnetes Element eine Eigenschaft für ungültig erklärt hat, die in den Metadaten entsprechend markiert ist, dass sie das Measure oder die Anordnungsdurchläufe des übergeordneten Elements während des Layouts beeinflusst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element über ein untergeordnetes Element verfügt, für das eine Eigenschaft für ungültig erklärt wurde, und die-Eigenschaft <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> während der Registrierung als oder <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> in den Eigenschafts Metadaten als markiert wurde, wird diese Methode aufgerufen. Der Methodenaufruf benachrichtigt das übergeordnete Element, welches bestimmte untergeordnete Element neu gemessen werden muss, wenn dieses Element eine partielle (inkrementelle) Aktualisierung des Layouts unterstützt.  
  
 Standardmäßig <xref:System.Windows.FrameworkElement> unterstützt kein inkrementelles Layout, und in der- <xref:System.Windows.FrameworkElement> Klasse hat diese Methode keine Standard Implementierung. Das Szenario, in dem diese Methode überschrieben wird, ist nicht üblich, da es erforderlich ist, das Standardverhalten des Layoutsystems zu ändern.  
  
 Ein Beispiel für ein Implementierungs Szenario könnte sein, wenn eine Klasse Typeinschränkungen für mögliche untergeordnete Elemente aufweist, die deutlich restriktiver sind als das Layoutsystem auf WPF-Frameworkebene. Aufgrund der Art dieser benutzerdefinierten Elemente können Eigenschafts Änderungen absichtlich verzögert werden, wenn Sie ein benutzerdefiniertes Layoutverhalten implementieren. Beispielsweise überschreibt die Measure-/Anordnung-Methode über schreibungen, die versuchen, den renderdurchlauf des untergeordneten Elements zu optimieren, möglicherweise für bestimmte Änderungs Typen, die normalerweise zu einem anderen Layoutdurchlauf führen würden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Die Richtung, für die eine mögliche Fokusänderung bestimmt werden soll.</param>
        <summary>Bestimmt das nächste Element, das relativ zu diesem Element den Fokus in einer angegebenen Fokusverschiebungsrichtung erhalten würde, verschiebt den Fokus jedoch nicht.</summary>
        <returns>Das nächste Element, auf das der Fokus verschoben würde, wenn der Fokus tatsächlich durchlaufen würde. Kann <see langword="null" /> zurückgeben, wenn der Fokus für die bereitgestellte Richtung nicht relativ zu diesem Element verschoben werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> ist die verwandte Methode, die den Fokus tatsächlich verschiebt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Handler implementiert, der mehrere mögliche Schaltflächen Eingaben behandelt, wobei jede Schaltfläche einen möglichen darstellt <xref:System.Windows.Input.FocusNavigationDirection> . Der Handler verfolgt das Element mit dem aktuellen Tastaturfokus und ruft für <xref:System.Windows.FrameworkElement.PredictFocus%2A> dieses Element auf und gibt die entsprechende <xref:System.Windows.Input.FocusNavigationDirection> als Initialisierung für den <xref:System.Windows.Input.TraversalRequest> bereitgestellten Typparameter an. Anstatt zu diesem Element zu wechseln <xref:System.Windows.FrameworkElement.MoveFocus%2A> , ändert der Handler die physischen Dimensionen des vorhergesagten Fokus Ziels zu Visualisierungs Zwecken.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Gibt eine der folgenden Richtungen im <see cref="T:System.Windows.Input.TraversalRequest" /> an: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Diese Richtungen sind für <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> unzulässig (aber für <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> zulässig).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Name für die angegebene Namensobjektzuordnung.</param>
        <param name="scopedElement">Objekt für die Zuordnung.</param>
        <summary>Stellt einen Accessor bereit, der Zugriff auf die <see cref="T:System.Windows.NameScope" />-Registrierungsmethode vereinfacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.NameScope.RegisterName%2A> . Die-Implementierung prüft aufeinander folgende übergeordnete Elemente, bis die entsprechende- <xref:System.Windows.NameScope> Implementierung gefunden wird, indem ein Element gefunden wird, das implementiert <xref:System.Windows.Markup.INameScope> . Weitere Informationen zu Namescopes finden Sie unter [WPF-XAML-Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).  
  
 <xref:System.Windows.FrameworkElement.RegisterName%2A>Der Aufruf von ist erforderlich, um Animations Storyboards für Anwendungen ordnungsgemäß zu verbinden, wenn Sie im Code erstellt werden. Dies liegt daran, dass eine der Schlüssel Storyboard-Eigenschaften, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> , eine Lauf Zeit Namenssuche verwendet, anstatt einen Verweis auf ein Ziel Element zu erstellen. Dies gilt auch dann, wenn auf dieses Element durch einen Verweis aus dem Code zugegriffen werden kann. Weitere Informationen dazu, warum Sie Namen für Storyboard-Ziele registrieren müssen, finden Sie unter [Übersicht über Storyboards](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das zu entfernende Element.</param>
        <summary>Entfernt das angegebene Objekt aus der logischen Struktur dieses Elements. <see cref="T:System.Windows.FrameworkElement" /> aktualisiert die übergeordneten Zeiger des betroffenen logischen Baums, um ihn mit der Löschung synchron zu halten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode für die Implementierung von Auflistungen für Objekte, die logische untergeordnete Elemente eines Elements darstellen. Dies kann in Eigenschaften-Getter oder-Setter, Klassen Handlern von `Changed` Ereignissen, Konstruktoren oder innerhalb der Auflistungs Typen selbst durchgeführt werden.  
  
 Für Steuerelement Autoren ist das Bearbeiten der logischen Struktur auf dieser Ebene nicht die empfohlene Vorgehensweise, es sei denn, es sind keine der bereitgestellten Inhalts Modelle der Basis Steuerelement Klasse geeignet. Betrachten Sie die Unterklassen auf der Ebene von <xref:System.Windows.Controls.ContentControl> , <xref:System.Windows.Controls.ItemsControl> und <xref:System.Windows.Controls.HeaderedItemsControl> . Diese Klassen bieten ein Inhalts Modell mit spezieller Erzwingung logischer untergeordneter Elemente durch dedizierte APIs sowie Unterstützung für andere Features, die in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelement wie z. b  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine- `Child` Eigenschaft für ein benutzerdefiniertes implementiert <xref:System.Windows.FrameworkElement> , das eine eigene Implementierung der visuellen Schicht implementiert. Der Setter der Eigenschaft ist so konzipiert, dass, wenn sich der Wert ändert, der alte Wert aus der logischen Struktur sowie eine klassenspezifische visuelle Auflistung entfernt wird. Die Werte werden zwischengespeichert, und dann wird der neue Wert sowohl der logischen Struktur der standardmäßigen WPF-Frameworkebene als auch der benutzerdefinierten visuellen Auflistung hinzugefügt.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> für dieses Element aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis weist auf eine übergeordnete <xref:System.Windows.Controls.ScrollViewer> (oder abgeleitete Klasse) hin, dass das Element, das das Ereignis auslöst, <xref:System.Windows.FrameworkElement.RequestBringIntoView> innerhalb des Bild lauffähigen Bereichs sichtbar gemacht werden soll. Der <xref:System.Windows.Controls.ScrollViewer> markiert das Ereignis dann <xref:System.Windows.FrameworkElement.RequestBringIntoView> als behandelt, indem die Klassen Behandlung des Ereignisses verwendet wird. In der Regel <xref:System.Windows.FrameworkElement.RequestBringIntoView> dürfen Ereignisdaten nicht durch eine Klasse, die einen scrollbereich steuert, oder durch einen beliebigen Instanzhandler als behandelt gekennzeichnet werden, da dadurch das beabsichtigte Ziel des Elements, das aufgerufen hat, beeinträchtigt würde <xref:System.Windows.FrameworkElement.BringIntoView%2A> .  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Windows.Markup.Ambient]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.Ambient&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das lokal definierte Ressourcenwörterbuch ab oder legt es fest.</summary>
        <value>Das derzeit lokal definierte Ressourcenwörterbuch, in dem mit einem Schlüssel auf jede Ressource zugegriffen werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ressourcen Wörterbücher, die vollständig oder teilweise in definiert werden können [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] , werden in der Regel als Eigenschafts Element erstellt und befinden sich in der Regel im Stamm Element für jede einzelne Seite oder für die Anwendung. Wenn Sie das Ressourcen Wörterbuch auf dieser Ebene platzieren, ist es leichter, von einzelnen untergeordneten Elementen auf der Seite zu suchen (oder von einer beliebigen Seite im Anwendungsfall). In den meisten Anwendungsszenarien empfiehlt es sich, Stile als Objekt Elemente innerhalb eines Ressourcen Wörterbuchs zu definieren oder als externe Ressourcen festgelegt zu werden, damit die gesamte Stil Ressource eigenständig sein kann (dieser Ansatz hilft bei der Trennung der Designer Zuständigkeiten von Entwickler Zuständigkeiten durch die Trennung der physischen Dateien, die bearbeitet werden müssen).  
  
 Beachten Sie, dass diese Eigenschaft nur das direkt in diesem Element deklarierte Ressourcen Wörterbuch zurückgibt. Dies unterscheidet sich von dem tatsächlichen Ressourcen Suchprozess, bei dem ein untergeordnetes Element auf alle Ressourcen zugreifen kann, die in den einzelnen übergeordneten Elementen definiert sind, wobei die Suche rekursiv nach oben erfolgt.  
  
 Auf Ressourcen kann auch durch Code aus der Auflistung verwiesen werden, aber beachten Sie, dass die in erstellten Ressourcen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] auf jeden Fall erst zugänglich sind, nachdem <xref:System.Windows.FrameworkElement.Loaded> das Element, das das Wörterbuch deklariert, ausgelöst wird. Tatsächlich werden Ressourcen asynchron analysiert, aber nicht sogar das <xref:System.Windows.FrameworkElement.Loaded> Ereignis ist eine Zusicherung, dass Sie auf eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definierte Ressource verweisen können. Aus diesem Grund sollten Sie im Allgemeinen nur [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] im Rahmen des Lauf Zeit Codes oder über andere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Techniken wie Stile oder Ressourcen Erweiterungs Verweise für Attributwerte auf definierte Ressourcen zugreifen. Wenn Sie über Code auf Ressourcen zugreifen, entspricht dies im Wesentlichen einem [DynamicResource](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) -Verweis aus [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .  
  
 Der zugrunde liegende <xref:System.Windows.ResourceDictionary> unterstützt die Methoden, die zum Hinzufügen, entfernen oder Abfragen von Ressourcen innerhalb der Sammlung mithilfe von Code erforderlich sind. Die- <xref:System.Windows.FrameworkElement.Resources%2A> Eigenschaft kann festgelegt werden, um das Szenario zu unterstützen, mit dem die Ressourcen Auflistung eines Elements vollständig ersetzt werden kann <xref:System.Windows.ResourceDictionary> .  
  
 Beachten Sie, dass die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] angezeigte Syntax kein-Element für enthält <xref:System.Windows.ResourceDictionary> . Dies ist ein Beispiel für eine implizite Auflistungs Syntax. ein Tag, das das Auflistungs Element darstellt, kann weggelassen werden. Stattdessen werden die Elemente angegeben, die der Auflistung als Elemente hinzugefügt werden. Weitere Informationen zu impliziten Auflistungen und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] finden Sie [in der XAML-Syntax im Detail](/dotnet/framework/wpf/advanced/xaml-syntax-in-detail). Ein Fall, bei dem a <xref:System.Windows.ResourceDictionary> weiterhin explizit als Element angegeben wird, ist, wenn Sie ein zusammen geführtes Wörterbuch einführen. in diesem Fall gibt es in der Regel keine untergeordneten Elemente <xref:System.Windows.ResourceDictionary> . Weitere Informationen finden Sie unter [zusammengeführte Ressourcen Wörterbücher](/dotnet/framework/wpf/advanced/merged-resource-dictionaries).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneormoreresourceelements*  
 Ein oder mehrere Objekt Elemente, von denen jede eine Ressource definiert. Jedes Ressourcen Eigenschaften Element <xref:System.Windows.ResourceDictionary> muss über einen eindeutigen Wert für die [x:Key-Direktive](/dotnet/framework/xaml-services/x-key-directive)verfügen, der als eindeutiger Schlüssel fungiert, wenn Werte aus dem abgerufen werden <xref:System.Windows.ResourceDictionary> .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="/dotnet/desktop-wpf/xaml-services/xkey-directive">x:Schlüssel-Attribut</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordnet eine Bindung zu diesem Element für die angegebene Abhängigkeitseigenschaft zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Gibt die Zieleigenschaft an, für die die Bindung eingerichtet werden soll.</param>
        <param name="path">Der Name der Quelleigenschaft oder der Pfad zu der für die Bindung verwendeten Eigenschaft.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Namens der Quelleigenschaft als Pfadangabe zur Datenquelle eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType> , die die aktuelle-Instanz als übergibt <xref:System.Windows.DependencyObject> und eine neue auf <xref:System.Windows.Data.Binding> der Grundlage des bereitgestellten `path` Parameters erstellt. Diese Signatur ist bequemer, wenn Sie eine einfache Standard Bindung einrichten. Wenn Sie Bindungseigenschaften für nicht standardmäßige Bedingungen angeben müssen oder oder verwenden möchten <xref:System.Windows.Data.MultiBinding> <xref:System.Windows.Data.PriorityBinding> , sollten Sie die <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> Signatur verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Bindung mit einem bestimmten Pfad festgelegt.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Gibt die Eigenschaft an, für die die Bindung eingerichtet werden soll.</param>
        <param name="binding">Stellt die Merkmale der Datenbindung dar.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Bindungsobjekts eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType> , die die aktuelle-Instanz als übergibt <xref:System.Windows.DependencyObject> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, das eine Flussrichtung angibt.</param>
        <param name="value">Ein Wert der Enumeration, der die Richtung angibt.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.FrameworkElement.FlowDirection" />-Eigenschaft für das angegebene Element fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Syntax der angefügten Eigenschaft für die- <xref:System.Windows.FrameworkElement.FlowDirection%2A> Eigenschaft und ermöglicht somit untergeordneten Elementen einer bereitgestellten <xref:System.Windows.FrameworkElement> die Fluss Richtung für die Anordnung innerhalb ihres übergeordneten Elements. Um den Wert für die aktuelle festzulegen <xref:System.Windows.FrameworkElement> , verwenden Sie den Direct- [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Accessor <xref:System.Windows.FrameworkElement.FlowDirection%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Die Eigenschaft, an die die Ressource gebunden ist.</param>
        <param name="name">Der Name der Ressource.</param>
        <summary>Sucht eine Ressource mit dem angegebenen Namen und richtet einen entsprechenden Ressourcenverweis für die angegebene Eigenschaft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ressourcen Verweis ähnelt der Verwendung einer [dynamikresource-Markup Erweiterung](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) im Markup. Der Ressourcen Verweis erstellt einen internen Ausdruck, der den Wert der angegebenen Eigenschaft für eine verzögerte Laufzeit bereitstellt. Der Ausdruck wird immer dann erneut ausgewertet, wenn das Ressourcen Wörterbuch einen geänderten Wert durch interne Ereignisse angibt oder wenn das aktuelle Element neu erstellt wird (eine übergeordnete Änderung würde den Pfad für die Wörterbuchsuche ändern).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der <see cref="P:System.Windows.FrameworkElement.Resources" />-Eigenschaft serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Resources" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies wird zurückgegeben, solange mindestens eine Schlüssel gebundene `true` Ressource im lokalen vorhanden ist <xref:System.Windows.FrameworkElement.Resources%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der <see cref="P:System.Windows.FrameworkElement.Style" />-Eigenschaft serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Style" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies wird zurückgegeben, `true` Wenn <xref:System.Windows.Style> lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der <see cref="P:System.Windows.FrameworkElement.Triggers" />-Eigenschaft serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkElement.Triggers" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt zurück, `true` Wenn die <xref:System.Windows.FrameworkElement.Triggers%2A> Eigenschaft lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Wert der <see cref="P:System.Windows.FrameworkElement.ActualHeight" />-Eigenschaft oder der <see cref="P:System.Windows.FrameworkElement.ActualWidth" />-Eigenschaft für dieses Element ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden. Direkt geroutete Ereignisse unterstützen andere Routing Ereignis Verhalten: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.  
  
 Das Layoutsystem liest Eigenschaften innerhalb der <xref:System.Windows.SizeChangedEventArgs> Argument Klasse dieses Ereignisses, um zu bestimmen, ob die gemeldeten Größenänderungen als signifikant angesehen werden sollen. Dies ermöglicht dem Layoutsystem oder den Steuerelement spezifischen Layoutimplementierungen, das Erzwingen einer Layoutänderung aufgrund von visuellen, nicht wahrnehmbaren unterschieden zwischen alten und neuen Höhen-oder breiten Werten zu vermeiden. Die nicht wahrnehmbare Unterschiede können durch Rundungs-oder Ergebnis Berechnungen von Gleit Komma Datentypen verursacht werden.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.SizeChanged" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Quellwert für eine vorhandene Eigenschaft ändert, die an dieses Element gebunden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für das- <xref:System.Windows.Data.Binding.SourceUpdated> Ereignis, das von jedem, der <xref:System.Windows.Data.Binding> diesem Element zugeordnet ist, ausgelöst wird.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von diesem Element beim Rendern verwendeten Stil ab oder legt ihn fest.</summary>
        <value>Der übernommene und nicht dem Standardstil entsprechende Stil für das Element, wenn ein Stil vorhanden ist. Andernfalls <see langword="null" />. Der Standardwert für ein mit den Standardwerten konstruiertes <see cref="T:System.Windows.FrameworkElement" /> ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Steuerelementen wird der aktuelle Stil häufig durch einen Standardstil von der Steuerelement Auswahl oder durch Stile, die in der Regel auf Steuerelemente dieses Typs durch Ressourcen auf der Seiten-oder Anwendungsebene (ein implizites Format) angewendet werden, bereitgestellt. Diese Eigenschaft legt Standard Stile (Theme) nicht fest oder gibt Sie zurück. Sie gibt jedoch entweder einen impliziten Stil oder einen expliziten Stil zurück, der für das Element fungiert. Im Fall impliziter oder expliziter Stile spielt es keine Rolle, ob der Stil als Ressource oder lokal definiert ist.  
  
 Das Festlegen der Stile hat einige Einschränkungen. Sie können die gesamte <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft zu einem beliebigen Zeitpunkt auf einen neuen zurücksetzen <xref:System.Windows.Style> , wodurch eine Neukomposition des Layouts erzwungen wird. Sobald dieser Stil jedoch von einem geladenen Element verwendet wird, <xref:System.Windows.Style> sollte als versiegelt angesehen werden. Der Versuch, eine Änderung an einer einzelnen Eigenschaft eines in Gebrauch verwendeten Stils vorzunehmen (z. b. in der Auflistung von <xref:System.Windows.Style.Setters%2A> ), bewirkt, dass eine Ausnahme ausgelöst wird. Ein Stil, der im Markup definiert ist, wird als in Gebrauch betrachtet, sobald er aus einem Ressourcen Wörterbuch (für Ressourcen) geladen wird, oder wenn die in enthaltene Seite geladen wird (für Inline Stile).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> ist eine Abhängigkeits Eigenschaft mit spezieller Rangfolge. Der lokal festgelegte Stil arbeitet im Allgemeinen mit der höchsten Rangfolge im Eigenschaften System. Wenn <xref:System.Windows.FrameworkElement.Style%2A> an dieser Stelle NULL ist, prüft beim Laden des Eigenschaften Systems beim Laden auf implizite Stile in lokalen oder Anwendungs Ressourcen, die diesen Typ angeben. Wenn die Formatvorlage nach diesem Schritt immer noch NULL ist, ergibt sich in der Regel der-Stil für Präsentationszwecke aus dem Standardformat (Design), aber der Standardstil wird nicht im <xref:System.Windows.FrameworkElement.Style%2A> Eigenschafts Wert zurückgegeben. Weitere Informationen finden Sie unter Priorität von [Abhängigkeits Eigenschafts Werten](/dotnet/framework/wpf/advanced/dependency-property-value-precedence) oder Stile [und](/dotnet/framework/wpf/controls/styling-and-templating)Vorlagen  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceextension*  
 Eines der folgenden:, oder. Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
 *styleresourcekey*  
 Der Schlüssel, der den angeforderten Stil bezeichnet. Der Schlüssel verweist auf eine vorhandene Ressource in einer <xref:System.Windows.ResourceDictionary> .  
  
> [!NOTE]
>  Die Syntax von Eigenschafts Elementen ist technisch möglich, wird jedoch für die meisten Stil Szenarios nicht empfohlen. Weitere Informationen finden Sie unter [Inline Stile und Vorlagen](/dotnet/framework/wpf/advanced/inline-styles-and-templates). Ein Bindungs Verweis mit [TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension) oder <xref:System.Windows.Data.Binding> ist ebenfalls möglich, aber nicht üblich.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Stil in einem Ressourcen Wörterbuch definiert.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Style" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="frameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter der <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />-Methode.</summary>
        <returns><see langword="true" />, wenn <paramref name="propertyName" /> verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.FrameworkElement>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen beliebigen Objektwert ab, der zum Speichern von benutzerdefinierten Informationen zu diesem Element verwendet werden kann, bzw. legt diesen fest.</summary>
        <value>Der vorgesehene Wert. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft entspricht den Tageigenschaften in anderen Microsoft-Programmier Modellen, wie z. b. Visual Basic for Applications oder Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> soll einen bereits vorhandenen Eigenschafts Speicherort bereitstellen, in dem Sie einige grundlegende benutzerdefinierte Informationen zu beliebigen speichern können <xref:System.Windows.FrameworkElement> , ohne dass Sie ein Element unterteilen müssen.  
  
 Da diese Eigenschaft ein Objekt annimmt, müssen Sie die Verwendung des Eigenschafts Elements verwenden, um die <xref:System.Windows.FrameworkElement.Tag%2A> -Eigenschaft in XAML auf einen anderen Wert als ein Objekt mit einem bekannten und integrierten Typkonverter (z. b. eine Zeichenfolge) festzulegen. Objekte, die auf diese Weise verwendet werden, befinden sich in der Regel nicht innerhalb der standardmäßigen WPF-Namespaces und benötigen daher möglicherweise eine Namespace Zuordnung zum externen Namespace, um als XAML-Elemente eingeführt zu werden. Weitere Informationen finden Sie unter [XAML-Namespaces und Namespace Zuordnung für WPF-XAML](/dotnet/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml) und [XAML und benutzerdefinierte Klassen für WPF](/dotnet/framework/wpf/advanced/xaml-and-custom-classes-for-wpf).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Tag" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Zielwert für eine Eigenschaftenbindung bei diesem Element ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für das- <xref:System.Windows.Data.Binding.TargetUpdated> Ereignis, das von jedem, der <xref:System.Windows.Data.Binding> diesem Element zugeordnet ist, ausgelöst wird. Dies bedeutet in der Regel, dass die betreffende Bindung eine bidirektionale Bindung ist und dass die gebundene Abhängigkeits Eigenschaft bestätigt, dass der vorherige Eigenschafts Wert nun gemäß einem beliebigen Validierungs-oder zwischen Speicherungs Schema, das die-Eigenschaft oder die Datenquelle unterstützt, ungültig ist.  
  
 Verwenden Sie die Ereignisdaten des <xref:System.Windows.FrameworkElement.TargetUpdated> Ereignisses, um die spezifische Eigenschaft zu ermitteln, die das Update des Zielwerts meldet.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die übergeordnete Vorlage dieses Elements ab. Diese Eigenschaft ist nicht relevant, wenn das Element nicht durch eine Vorlage erstellt wurde.</summary>
        <value>Das Element, dessen <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> die Erstellung dieses Elements verursacht hat. Dieser Wert ist häufig <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> ist häufig `null` für-Objekte, die im Anwendungs Markup oder Code erstellt werden. Dies liegt daran, dass Sie diese Objekte direkt und nicht über eine Vorlage erstellen. Objekt Verweise, die durch das Durchlaufen der logischen Struktur aus dem Stamm oder durch eine typische namens Referenz abgerufen werden, stammen nicht aus einer Vorlage.  
  
 Fälle, in denen <xref:System.Windows.FrameworkElement.TemplatedParent%2A> möglicherweise keine `null` Vorgänge wie Treffer Tests, Ereignis Behandlung für bestimmte Low-Level-Eingabeereignisse, das Durchlaufen der visuellen Struktur mit <xref:System.Windows.Media.VisualTreeHelper> oder das Arbeiten mit Enumeratoren sind, die möglicherweise Elemente zurückgeben, die aus Vorlagen stammen. Ein weiterer Fall ist, wenn Sie speziell für <xref:System.Windows.FrameworkTemplate.FindName%2A> eine vorhandene aufzurufen <xref:System.Windows.FrameworkTemplate> und mit dem zurückgegebenen-Objekt arbeiten.  
  
 Vorlagen sind tatsächlich freigegebene Objekte, bei denen der Inhalt der Vorlage nur einmal erstellt wird. Wenn Sie also einen Objekt Verweis auf ein Element erhalten, das aus einer Vorlage stammt, können Sie feststellen, dass die sichtbare logische Struktur nicht zum Seiten Stamm gelangt. Um einen solchen Vorlagen Verweis mit der logischen Struktur der Seite zu verbinden, sollten Sie den Wert erhalten <xref:System.Windows.FrameworkElement.TemplatedParent%2A> und weiterhin in der gewünschten Elementstruktur navigieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Bindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Category("Appearance")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Appearance")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das QuickInfo-Objekt ab, das für dieses Element in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] angezeigt wird, oder legt dieses Objekt fest.</summary>
        <value>Das QuickInfo-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert dieser Eigenschaft vom Typ ist <xref:System.Windows.Controls.ToolTip> , ist dieser Wert die QuickInfo, die in der verwendet wird [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] .  Wenn der Wert eines beliebigen anderen Typs ist, wird dieser Wert als *Inhalt* für eine <xref:System.Windows.Controls.ToolTip> bereitgestellte (erstellte) vom System verwendet. Weitere Informationen finden Sie unter <xref:System.Windows.Controls.ToolTipService>. Die Dienstklasse stellt angefügte Eigenschaften bereit, die verwendet werden können, um eine weiter anzupassen <xref:System.Windows.Controls.ToolTip> .  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>
```

- oder -

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *tooltipcontent*  
 Eine Zeichenfolge, die zum Anzeige Text für die wird <xref:System.Windows.FrameworkElement.ToolTip%2A> .  
  
 *tooltipobjectcontent*  
 Ein im Objekt Element Formular bereitgestelltes Objekt, das als Inhalt für den verwendet werden soll <xref:System.Windows.FrameworkElement> . In der Regel handelt es sich dabei um ein- <xref:System.Windows.FrameworkElement> Element oder ein anderes Element, das layoutcompositing für den erstellt <xref:System.Windows.FrameworkElement.ToolTip%2A> und schließlich Textinhalte innerhalb der Zusammensetzung enthält. In dieser Verwendung wird das <xref:System.Windows.Controls.ToolTip> Element implizit aus dem analysierten erstellt [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , und der *tooltipobjectcontent* -Inhalt wird als seine-Eigenschaft festgelegt <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> .  
  
 <`ToolTip` .../>  
 Siehe <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Windows.Controls.ToolTip> -Objekt im Code erstellt und dann die- <xref:System.Windows.FrameworkElement.ToolTip%2A> Eigenschaft für ein-Steuerelement festgelegt <xref:System.Windows.Controls.Primitives.StatusBar> .  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar vor dem Schließen einer QuickInfo über dem Element ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie das <xref:System.Windows.FrameworkElement.ToolTipClosing> Ereignis als behandelt markieren, wird das Schließen der QuickInfo nicht abgebrochen. Sobald die QuickInfo angezeigt wird, wird das Schließen der QuickInfo nur als Reaktion auf Benutzerinteraktion mit der Benutzeroberfläche durchgeführt.  
  
 Dieses Ereignis darf nicht <xref:System.Windows.EventTrigger> in einem Stil sein. Dies liegt daran, dass das Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst wieder verwendet, der keine Methoden zum Hinzufügen/Entfernen von Ereignissen für das Ereignis auf Dienst Ebene verfügbar macht.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>Überschreiben, um die Klassen Behandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Öffnen einer QuickInfo im Element auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass eine QuickInfo in der Benutzeroberfläche angezeigt wird, <xref:System.Windows.FrameworkElement.ToolTipOpening> kann der Handler für die <xref:System.Windows.Controls.ToolTipEventArgs> Ereignisdaten als behandelt markieren. Andernfalls wird die QuickInfo mit dem Wert der-Eigenschaft als QuickInfo- <xref:System.Windows.FrameworkElement.ToolTip%2A> Inhalt angezeigt. Ein weiteres mögliches Szenario besteht darin, dass Sie einen Handler schreiben können, der den Wert der- <xref:System.Windows.FrameworkElement.ToolTip%2A> Eigenschaft für das Element, das die Ereignis Quelle ist, zurücksetzt, kurz bevor die QuickInfo angezeigt wird.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> wird nicht ausgelöst, wenn der Wert von <xref:System.Windows.FrameworkElement.ToolTip%2A> ist `null` oder andernfalls nicht festgelegt ist. Legen Sie nicht absichtlich <xref:System.Windows.FrameworkElement.ToolTip%2A> auf fest, `null` Wenn eine QuickInfo geöffnet ist oder geöffnet wird. Dies hat keine Auswirkungen, wenn die QuickInfo geschlossen wird und stattdessen ein unerwünschtes visuelles Element in der Benutzeroberfläche erstellt wird.  
  
 Das <xref:System.Windows.FrameworkElement.ToolTipOpening> Ereignis darf nicht <xref:System.Windows.EventTrigger> in einem Stil sein. Dies liegt daran, dass das Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst wieder verwendet, der keine Methoden zum Hinzufügen/Entfernen von Ereignissen für das Ereignis auf Dienst Ebene verfügbar macht.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>Überschreiben, um die Klassen Behandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.ToolTip" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der direkt für dieses Element oder in untergeordneten Elementen eingerichteten Trigger ab.</summary>
        <value>Eine stark typisierte Auflistung von <see cref="T:System.Windows.Trigger" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Eigenschaft kann nur [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] über die angezeigte Auflistungs Syntax oder durch Zugriff auf das Auflistungs Objekt und mithilfe der verschiedenen Methoden, wie z. b. Add, festgelegt werden. Die-Eigenschaft für den Zugriff auf das Auflistungs Objekt selbst ist schreibgeschützt, die Auflistung selbst hat Lese-/Schreibzugriff. Die-Eigenschaft ist nur für Stamm Elemente vorhanden. Wenn Sie versuchen, ihn zu suchen oder an einem anderen Ort festzulegen, wird eine Ausnahme ausgelöst.  
  
 Diese Eigenschaft ermöglicht es Ihnen nicht, Trigger zu überprüfen, die als Teil der in diesem Element verwendeten Stile vorhanden sind. Sie meldet nur die Auflistung von Triggern, die der Auflistung buchstäblich hinzugefügt werden, entweder in Markup oder Code. Für Elemente sind in der Regel keine solchen Elemente standardmäßig vorhanden (z. b. über eine Vorlage); Es kommt häufiger vor, dass Trigger, die von Steuerelement-Zusammensetzung stammen, stattdessen in Stilen eingerichtet werden.  
  
 Im Hinblick auf das Verhalten (und der Versuch, herauszufinden, welche Auswirkung von der deklarierten Auflistung des Elements stammt <xref:System.Windows.FrameworkElement.Triggers%2A> ), können sich sowohl die auslösende Bedingung als auch der Triggereffekt auf diesem Element oder auf den untergeordneten Elementen in der logischen Struktur befinden. Beachten Sie Folgendes: Wenn Sie Lebensdauer Ereignisse wie zum Beispiel verwenden <xref:System.Windows.FrameworkElement.Loaded> , um diese Auflistung zu erhalten, sind die Trigger des untergeordneten Elements möglicherweise noch nicht vollständig geladen, und die Auflistung ist kleiner, als Sie tatsächlich zur Laufzeit wäre.  
  
 Beachten Sie, dass die Auflistung der Trigger, die für ein Element erstellt wurden, nur unterstützt <xref:System.Windows.EventTrigger> , keine Eigenschaften Trigger ( <xref:System.Windows.Trigger> ). Wenn Sie Eigenschafts Trigger benötigen, müssen Sie diese in einem Stil oder einer Vorlage platzieren und diesen Stil bzw. diese Vorlage dann entweder direkt über die- <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft oder indirekt über einen impliziten Format Verweis dem Element zuweisen.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneormoretriggers*  
 Mindestens ein definiertes <xref:System.Windows.EventTrigger> Element. Jeder dieser Auslösers soll gültige Storyboard-Aktionen und-Verweise enthalten. Beachten Sie, dass diese Auflistung nur für das Stamm Element einer Seite erstellt werden kann. Weitere Informationen finden Sie unter [Übersicht über Storyboards](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner der gesuchten Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Schlüssel und gibt diese Ressource zurück, sofern sie gefunden wurde.</summary>
        <returns>Die gefundene Ressource oder <see langword="null" />, wenn keine Ressource mit dem angegebenen <paramref name="key" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ressource im aufrufenden Element nicht gefunden wird, wird die übergeordnete Ressourcenstruktur durch die logische Struktur nach oben durchsucht, und zwar auf dieselbe Weise, wie die Struktur durchsucht wird, wenn eine Ressource zur Laufzeit von einem Schlüssel angefordert wurde. Die-Methode gibt `null` nur dann zurück, wenn keine Ressource dieses Schlüssels an einer beliebigen Stelle in der Ressourcenstruktur vorhanden war, und zwar gemäß den vorhandenen Bedingungen der Struktur zum Zeitpunkt des <xref:System.Windows.FrameworkElement.TryFindResource%2A> Aufrufs von.  
  
 In der Regel würden Sie den Rückgabewert sofort in den Typ der Eigenschaft umwandeln, die Sie mit dem zurückgegebenen Ressourcen Wert festlegen wollten.  
  
 Die- <xref:System.Windows.FrameworkElement.FindResource%2A> Methode weist ein ähnliches Verhalten auf, mit der Ausnahme, dass eine Ausnahme ausgelöst wird, wenn keine Ressource mit dem angegebenen Schlüssel zurückgegeben wurde.  
  
   
  
## Examples  
 Das folgende Beispiel wird als Schaltflächen Handler implementiert, bei dem mit der Schaltfläche, auf die geklickt wird, der Hintergrund auf einen Ressourcen definierten Pinsel festgelegt wird, der durch den Aufruf von <xref:System.Windows.FrameworkElement.TryFindResource%2A> für sich Dadurch wird die-Elementstruktur durchlaufen und die Ressource gefunden (die Ressource selbst ist in definiert [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] und wird nicht angezeigt).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Element aus einer Elementstruktur geladener Elemente entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden. Direkt geroutete Ereignisse unterstützen andere Routing Ereignis Verhalten: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.  
  
 <xref:System.Windows.FrameworkElement.Loaded> und <xref:System.Windows.FrameworkElement.Unloaded> können aufgrund von vom Benutzer initiierten Systemdesign Änderungen auch für Steuerelemente ausgelöst werden. Eine Designänderung bewirkt eine Invalidierung der Steuerelement Vorlage und der enthaltenen visuellen Struktur, die wiederum bewirkt, dass das gesamte Steuerelement entladen und neu geladen wird. Daher <xref:System.Windows.FrameworkElement.Unloaded> kann nicht davon ausgegangen werden, dass Sie nur bei der Navigation von der Seite stattfinden.  
  
 Beachten Sie, dass das-Ereignis nach dem Herunterfahren <xref:System.Windows.FrameworkElement.Unloaded> einer Anwendung nicht ausgelöst wird. Das Herunterfahren der Anwendung tritt auf, wenn die durch die-Eigenschaft definierte Bedingung <xref:System.Windows.Application.ShutdownMode%2A> auftritt. Wenn Sie Bereinigungs Code innerhalb eines Handlers für das- <xref:System.Windows.FrameworkElement.Unloaded> Ereignis platzieren, z <xref:System.Windows.Window> . b. für einen oder eine <xref:System.Windows.Controls.UserControl> , kann dieser nicht erwartungsgemäß aufgerufen werden.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.FrameworkElement.Unloaded" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichnern für Routingereignisse, um Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Name/Objekt-Paars, der aus dem aktuellen Bereich entfernt werden soll.</param>
        <summary>Vereinfacht den Zugriff auf die <see cref="T:System.Windows.NameScope" />-Methode zum Aufheben der Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein anderes Element mit demselben Namen erneut registrieren möchten, müssen Sie die Registrierung von Namen aufheben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet erneut den Standardstil auf den aktuellen <see cref="T:System.Windows.FrameworkElement" /> an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob die Layoutglättung auf die Größe und Position dieses Elements während des Layouts angewendet werden.</summary>
        <value><see langword="true" />, wenn die Layoutglättung angewendet wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> -Eigenschaft für ein-Element ist `true` , werden alle nicht ganzzahligen Pixelwerte, die während der <xref:System.Windows.UIElement.Measure%2A> -und-Durchläufen berechnet werden, <xref:System.Windows.UIElement.Arrange%2A> auf die ganzen Pixelwerte gerundet.  
  
 Diese Eigenschaft wird von untergeordneten Elementen geerbt.  
  
> [!NOTE]
>  Legen Sie <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> für `true` das root-Element auf fest. Das Layoutsystem fügt den übergeordneten Koordinaten untergeordnete Koordinaten hinzu. Wenn sich die übergeordneten Koordinaten nicht an einer Pixel Grenze befinden, befinden sich die untergeordneten Koordinaten daher ebenfalls nicht in einer Pixel Grenze. Wenn <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> nicht im Stamm festgelegt werden kann, legen Sie für das untergeordnete Element fest, <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> um den gewünschten Effekt zu erhalten.  
  
 Das Zeichnen von Objekten an Pixel Grenzen entfernt die halbtransparenten Kanten, die durch Antialiasing erzeugt werden, wenn ein Rand in der Mitte eines Geräte Pixels liegt. Die folgende Abbildung zeigt die Ausgabe einer einzelnen Zeile mit Pixel Breite, die in die Mitte eines Geräte Pixels fällt. Die Linie auf der linken Seite verwendet keine Layoutrundung und ist Antialiasing. Die Zeile auf der rechten Seite verwendet Layoutrundung.  
  
 ![Anti&#45;Alias Zeile im Vergleich zu einer einzelnen Pixel Linie.](~/add/media/pixelsnaplinecompare.PNG "Zeile mit Antialiasing verglichen mit Einzelpixelzeile")  
  
 Wenn Sie Layoutrundung und- <xref:System.Windows.GridUnitType.Star> Größe verwenden, erstellt das Layoutsystem kleine Variationen der Spalten-oder Zeilen Messungen, um das Rendering von Subpixeln zu vermeiden. Wenn ein Raster z. b. eine Gesamtbreite von 100 mit jeweils drei Spalten hat <xref:System.Windows.GridUnitType.Star> , anstatt drei Spalten zu erstellen, die eine gleich Breite von 33,3 haben, erstellt das Layoutsystem 2 Spalten mit einer Breite von 33 und einer mit einer Breite von 34.  
  
> [!NOTE]
>  In .NET 4,6 wurden Änderungen an der Layoutrundung vorgenommen, um die Instanzen von Clipping in Steuerelementen mit Rahmen zu verringern. Diese Funktion ist standardmäßig aktiviert, wenn das Ziel Framework .NET Framework 4,6 oder höher ist. Anwendungen, die auf frühere Versionen des Frameworks abzielen, können das neue Verhalten abonnieren, indem Sie die folgende Einstellung zu einer app.config-Datei hinzufügen: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` die Einstellung wird nur wirksam, wenn die Anwendung auf dem .NET Framework 4,6 ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie sich die <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> -Eigenschaft auf einer einzelnen Zeile mit Pixel Breite auswirkt. Die Linie auf der linken Seite verwendet keine Layoutrundung, und die Linie auf der rechten Seite verwendet Layoutrundung. Wenn Sie die Größe des Fensters langsam ändern, sehen Sie den Unterschied, dass die Layoutrundung durchführt.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vertikalen Ausrichtungsmerkmale ab bzw. legt diese fest. Sie werden auf dieses Element angewendet, wenn es Teil von einem übergeordneten Element ist, z. B. von einem Panel-Steuerelement oder von einem ItemsControl-Element.</summary>
        <value>Eine vertikale Ausrichtungseinstellung. Der Standardwert ist <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.FrameworkElement.Height%2A> -und- <xref:System.Windows.FrameworkElement.Width%2A> Eigenschaften für ein Element explizit festgelegt sind, übernehmen diese Messungen den Layoutobjekt und brechen die regulären Auswirkungen der Festlegung dieser Eigenschaft auf ab <xref:System.Windows.VerticalAlignment.Stretch> .  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> der [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaften Accessor für das, was in Wirklichkeit eine Abhängigkeits Eigenschaft ist. Bei dieser speziellen Abhängigkeits Eigenschaft ist der sichtbare "Default"-Wert in abgeleiteten Element Klassen, insbesondere-Steuerelementen, anders festgelegt. Dies geschieht in der Regel auf zwei Arten: die Abhängigkeits Eigenschaft wird für eine bestimmte abgeleitete Klasse neu registriert, jedoch mit unterschiedlichen Metadaten zum Festlegen der Standardwerte. oder es wird ein Standardstil angewendet, der den Wert der Abhängigkeits Eigenschaft unterschiedlich festlegt. Beispielsweise ist der sichtbare "Standard" von <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> für ein <xref:System.Windows.Controls.ComboBoxItem> Steuerelement, obwohl er <xref:System.Windows.VerticalAlignment.Center> <xref:System.Windows.Controls.ComboBoxItem> <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> direkt von erbt <xref:System.Windows.FrameworkElement> . Dies liegt daran, dass dieser Wert innerhalb des Standard Stils von <xref:System.Windows.Controls.ComboBoxItem> innerhalb der Steuerelement Vorlage des Stils zurückgesetzt wurde.  
  
 <xref:System.Windows.Controls.Canvas> verwendet beim Verfassen <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> des Layouts nicht, da <xref:System.Windows.Controls.Canvas> auf absoluter Positionierung basiert.  
  
 Wenn Sie von <xref:System.Windows.Controls.ComboBoxItem> oder abgeleiteten Klassen geerbt werden, wird <xref:System.Windows.Controls.ComboBoxItem> der Standardwert dieser Eigenschaft neu definiert als <xref:System.Windows.VerticalAlignment.Center> .  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der sichtbaren untergeordneten Elemente innerhalb dieses Elements ab.</summary>
        <value>Die Anzahl der sichtbaren untergeordneten Elemente für dieses Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Windows.FrameworkElement> Implementierung von <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> gibt immer entweder 0 (null) oder 1 zurück. Klassen, die eine untergeordnete visuelle Auflistung verwalten, die möglicherweise einen Wert überschreitet, müssen diese Eigenschaft und überschreiben <xref:System.Windows.FrameworkElement.GetVisualChild%2A> .  
  
 Diese Eigenschaft wird im Allgemeinen verwendet, um die oberen Begrenzungen der aktuellen untergeordneten Auflistung für die Implementierung der layoutüberschreibungs Vorgänge ( <xref:System.Windows.FrameworkElement.MeasureOverride%2A> ,) zu bestimmen <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein benutzerdefinierter Funktions Indikator die von einem deklarierten Werte verwendet <xref:System.Windows.Media.VisualCollection> , die für seine untergeordneten visuellen Elemente verwaltet werden, und diese Werte durch über schreibungen von und meldet <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> <xref:System.Windows.FrameworkElement.GetVisualChild%2A> .  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Ihre Klasse mehrere visuelle untergeordnete Elemente in einer Auflistung untergeordneter Elemente unterstützt, überschreiben Sie diese Eigenschaft, um die Anzahl der Elemente in dieser Auflistung zurückzugeben. Dies ist auch dann erforderlich, wenn das Sammlungsobjekt selbst eine Anzahl zurückgibt. Die elementlayoutlogik auf der WPF-Frameworkebene geht davon aus, dass alle Elemente über Ihre-Eigenschaft eine gültige Anzahl zurückgeben <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Elements ab bzw. legt diese fest.</summary>
        <value>Ruft die Breite des Elements in [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] ab. Der Standardwert ist <see cref="F:System.Double.NaN" />. Dieser Wert muss größer oder gleich 0,0 sein. Informationen zur Obergrenze finden Sie unter „Hinweise“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um eine von drei Eigenschaften <xref:System.Windows.FrameworkElement> , die Informationen zur Breite angeben.  Die anderen beiden sind <xref:System.Windows.FrameworkElement.MinWidth%2A> und <xref:System.Windows.FrameworkElement.MaxWidth%2A> .  Wenn ein Konflikt zwischen diesen Werten vorliegt, muss zunächst die Reihenfolge der Anwendung für die tatsächliche breiten Bestimmung berücksichtigt <xref:System.Windows.FrameworkElement.MinWidth%2A> werden, dann <xref:System.Windows.FrameworkElement.MaxWidth%2A> und schließlich, wenn sich diese innerhalb der Grenzen befinden <xref:System.Windows.FrameworkElement.Width%2A> .  
  
 Der Rückgabewert dieser Eigenschaft ist immer identisch mit dem Wert, der auf den Wert festgelegt wurde. Im Gegensatz dazu kann der Wert von <xref:System.Windows.FrameworkElement.ActualWidth%2A> variieren. Das Layout hat möglicherweise die vorgeschlagene Größe aus irgendeinem Grund abgelehnt. Außerdem arbeitet das Layoutsystem selbst asynchron in Relation zum Eigenschaften System Satz von <xref:System.Windows.FrameworkElement.Width%2A> und hat diese spezielle Änderung der Größenänderung möglicherweise noch nicht verarbeitet.  
  
 Zusätzlich zu zulässigen <xref:System.Double> Werten kann diese Eigenschaft auch sein <xref:System.Double.NaN?displayProperty=nameWithType> . Auf diese Weise geben Sie das Verhalten für die automatische Größenänderung an. [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]Legen Sie den Wert in der Zeichenfolge "Auto" (ohne Beachtung der Groß-/Kleinschreibung) fest, um das Verhalten der automatischen Größenanpassung Das Verhalten der automatischen Größenanpassung impliziert, dass das Element die verfügbare Breite ablegt. Beachten Sie jedoch, dass bestimmte Steuerelemente häufig Standardwerte in ihren Standardformaten bereitstellen, die das Verhalten der automatischen Größenänderung deaktivieren, es sei denn, es wird ausdrücklich erneut aktiviert.  
  
 Zusätzlich zur Überprüfungs Überprüfung gibt es einen nicht deterministischen oberen Wert, der <xref:System.Windows.FrameworkElement.Width%2A> vom Layoutsystem erzwungen wird (Dies ist eine sehr große Zahl, die größer als, <xref:System.Single.MaxValue?displayProperty=nameWithType> aber kleiner als ist <xref:System.Double.MaxValue?displayProperty=nameWithType> ). Wenn diese Grenze überschritten wird, wird das Element nicht mehr angezeigt, und es wird keine Ausnahme ausgelöst. Legen Sie keinen Wert fest, der <xref:System.Windows.FrameworkElement.Width%2A> deutlich größer als die maximale Größe einer möglichen visuellen Darstellung ist, oder diese nicht deterministische obere Grenze überschreiten.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml 
<object Width="double"/>  
```

- oder -

```xaml
<object Width ="qualifiedDouble"/>  
```

- oder -

```xaml
<object Width ="Auto"/>  
```  

<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *double*  
 <xref:System.Double>  
  
 Zeichen folgen Darstellung eines <xref:System.Double> Werts, der gleich oder größer als 0,0 ist. Informationen zur Obergrenze finden Sie unter „Hinweise“. Dieser Wert wird als [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] Maßeinheit interpretiert. Zeichen folgen müssen nicht explizit Dezimalstellen enthalten. Beispielsweise ist der Wert `1` akzeptabel.  
  
 *qualifiedDouble*  
 Ein *doppelter* Wert, wie oben beschrieben, gefolgt von einer der folgenden Einheiten Deklarations Zeichenfolgen: `px` , `in` , `cm` , `pt` .  
  
 `px` (Standard) ist [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` ist Zoll; 1In = = 96px  
  
 `cm` ist Zentimeter; 1cm = = (96/2,54) px  
  
 `pt` ist Punkte 1pt = = (96/72) px  
  
 `Auto`  
 Aktiviert das Verhalten der automatische Größenanpassung. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.FrameworkElement.Width" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
