<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d36f95ed7817d5da38f16c281bae2bbdb0dbdb7" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86715197" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert bestimmte Verhaltensaspekte einer Abhängigkeitseigenschaft beim Anwenden für einen bestimmten Typ, einschließlich Bedingungen, mit denen sie registriert wurde.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenschafts Metadaten können beim Aufrufen der- <xref:System.Windows.DependencyProperty.Register%2A> Methode (oder Variationen für angefügte Eigenschaften oder schreibgeschützte Abhängigkeits Eigenschaften) oder nach der ursprünglichen Besitzer Registrierung beim Aufrufen der-Methode definiert und verwendet werden <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> . <xref:System.Windows.DependencyProperty.AddOwner%2A> erfordert auch Eigenschafts Metadaten.  
  
 Diese Klasse ist eine konkrete Basisklasse, die in jedem dieser Aufrufe verwendet werden kann. Es ist jedoch sehr üblich, Metadaten mithilfe einer der abgeleiteten Klassen anzugeben, z <xref:System.Windows.FrameworkPropertyMetadata> . b.. Diese abgeleiteten Klassen unterstützen ausführlichere Metadaten, die als boolesche Eigenschaftswerte übernommen werden. diese sind nützlich, um Eigenschaften System-und Layoutverhalten zu erkennen oder zu aktivieren, die nur auf [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Frameworkebene implementiert sind.  
  
 Mehrere Eigenschaften dieser Klasse sind Lese-/Schreibzugriff auf das Objektmodell. Sie können jedoch nur vor der-Instanz geschrieben werden, die in einem Eigenschafts System Vorgang verwendet wird, z <xref:System.Windows.DependencyProperty.Register%2A> <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> . b. oder. Jede dieser Eigenschaften kann auch vom Konstruktor festgelegt werden, Sie werden jedoch verfügbar gemacht, sodass <xref:System.Windows.PropertyMetadata.Merge%2A> Sie von Methoden Implementierungen festgelegt werden können.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Dieser Typ und Member dieses Typs werden in der Regel nicht in verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der anzugebende Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit einem angegebenen Standardwert für die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für bereitgestellt wird, `defaultValue` muss mit dem in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegebenen Typ, auf den diese Metadaten angewendet werden, identisch sein oder mit diesem verknüpft werden. Konflikte zwischen dem metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die er angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist (der Konflikt führt zu einer Lauf Zeit Ausnahme).  
  
 Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann kein von angegeben werden. Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierungsverweis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen Standardwert und dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierungsverweis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der angegebene Typ `defaultValue` muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen dem metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die er angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist (der Konflikt führt zu einer Lauf Zeit Ausnahme).  
  
 Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann kein von angegeben werden. Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Verweis auf eine Handlerimplementierung, die aufgerufen werden muss, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Eigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen Standardwert und den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Windows.CoerceValueCallback> , aber nicht angeben möchten <xref:System.Windows.PropertyChangedCallback> , können Sie `null` für den-Parameter übergeben `propertyChangedCallback` .  
  
 Der Typ des Werts, der für bereitgestellt wird, `defaultValue` muss mit dem in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegebenen Typ, auf den diese Metadaten angewendet werden, identisch sein oder mit diesem verknüpft werden. Konflikte zwischen dem metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die er angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist (der Konflikt führt zu einer Lauf Zeit Ausnahme).  
  
 Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann kein von angegeben werden. Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine in diesen Metadaten angegebene <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung ab oder legt diese fest.</summary>
        <value>Ein Verweis auf eine <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rückrufe in den Eigenschafts Metadaten sind in der Regel keine öffentlichen Member für den enthaltenden Typ. Daher ist der Wert dieser Eigenschaft für die meisten Szenarien, in denen nur die Metadaten einer vorhandenen Abhängigkeits Eigenschaft verwendet werden, nicht wichtig. Ein Grund, warum diese Eigenschaft verfügbar gemacht wird, ist, dass metadatenunterklassen Ihre gewünschte Zusammenschluss Logik ausführen können, wenn sowohl Basis Metadaten als auch über schreibende/hinzugefügten <xref:System.Windows.CoerceValueCallback> Metadaten eine Die standardmäßige Zusammensetzungs Logik für einen <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> besteht jedoch darin, die vorherige zu ersetzen.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> wird im-Objektmodell als Lese-/Schreibzugriff definiert. Dies <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> kann nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> . Sobald die Metadaten jedoch als Teil eines Aufrufes von <xref:System.Windows.DependencyProperty.Register%2A> , oder verwendet werden <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , versiegelte das Eigenschaften System diese Metadateninstanz, und die Eigenschaften werden nun als unveränderlich eingestuft. Wenn Sie versuchen, einmal festzulegen, wird für <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` diese Metadateninstanz eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardwert der Abhängigkeitseigenschaft ab oder legt diesen fest.</summary>
        <value>Der Standardwert der Eigenschaft. Der Standardwert für eine- <see cref="T:System.Windows.PropertyMetadata" /> Instanz, die mit dem Parameter losen Konstruktor erstellt wird, ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> wird im-Objektmodell als Lese-/Schreibzugriff definiert. Dies <xref:System.Windows.PropertyMetadata.DefaultValue%2A> kann nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> . Sobald die Metadaten jedoch als Teil eines Aufrufes von <xref:System.Windows.DependencyProperty.Register%2A> , oder verwendet werden <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , versiegelte das Eigenschaften System diese Metadateninstanz, und die Eigenschaften werden nun als unveränderlich eingestuft. Wenn Sie versuchen, einmal festzulegen, wird für <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` diese Metadateninstanz eine Ausnahme ausgelöst.  
  
 Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann ein von nicht mithilfe von <xref:System.Windows.PropertyMetadata.DefaultValue%2A> oder dem-Konstruktor festgelegt werden. Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieses Typs werden in der Regel nicht in verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kann nach der Erstellung nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob die Metadaten auf eine Eigenschaft angewendet wurden, wodurch die betreffende Metadateninstanz als unveränderlich festgelegt wurde.</summary>
        <value><see langword="true" />, wenn die Metadateninstanz unveränderlich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschiedene Eigenschaften von <xref:System.Windows.PropertyMetadata> , wie z <xref:System.Windows.PropertyMetadata.DefaultValue%2A> . b., werden im Objektmodell als Lese-/Schreibzugriff definiert. So können diese Eigenschaften nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> . Nachdem die Metadaten jedoch im Rahmen eines Aufrufes, oder auf eine Abhängigkeits Eigenschaft <xref:System.Windows.DependencyProperty.Register%2A> angewendet <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wurden, wird diese Metadateninstanz vom Eigenschaften System versiegelt, und die Eigenschaften werden nun als unveränderlich eingestuft. Zum Zeitpunkt eines dieser Aufrufe <xref:System.Windows.PropertyMetadata.OnApply%2A> wird aufgerufen, und der Wert dieser Eigenschaft wird auf festgelegt `true` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.PropertyMetadata.IsSealed%2A> vor einem Set-Vorgang einer benutzerdefinierten Metadateneigenschaft überprüft.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Die Basismetadaten, die mit den Werten dieser Instanz zusammengeführt werden sollen.</param>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden.</param>
        <summary>Führt diese Metadaten mit den Basismetadaten zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern verwendet, wenn Metadaten überschrieben werden (- <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Merge für einen benutzerdefinierten Metadatentyp implementiert, der den Eigenschafts Metadaten eine zusätzliche Eigenschaft hinzufügt.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klassen Implementierungen, die von abgeleitet werden, <see cref="T:System.Windows.PropertyMetadata" /> sollten diese Methode überschreiben, um Metadaten-Eigenschaften zu berücksichtigen, die Sie in ihren Implementierungen hinzugefügt haben. Beispielsweise kann Ihre-Implementierung einen neuen flagbezogenen Enumerationswert hinzugefügt haben, und die <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Implementierung sollte dann in der Lage sein, diese Flags ordnungsgemäß zu kombinieren.  
  
Die Basis Implementierung muss immer vor dem Implementierungs Code aufgerufen werden, da die Basis Implementierung alle bereits für den Typ definierten Eigenschaften zusammenführt <see cref="T:System.Windows.PropertyMetadata" /> .  
  
Das genaue Verhalten der Zusammenführung liegt bei Ihnen. Sie können auswählen, ob Werte kombiniert werden, ob Sie den Basiswert wiederherstellen möchten, wenn die abgeleiteten Metadaten den Standardwert verbleiben, oder viele andere Verhalten auf der Grundlage der Typen von Eigenschaften, die Sie ihrer jeweiligen Metadatenklasse hinzugefügt haben, und ihrer Bedeutung.</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die die Metadaten angewendet wurden.</param>
        <param name="targetType">Der diesen Metadaten zugeordnete Typ, wenn es sich um typspezifische Metadaten handelt. Wenn es sich dabei um die Standardmetadaten handelt, ist dieser Wert ein NULL-Verweis.</param>
        <summary>Wird aufgerufen, wenn diese Metadaten auf eine Eigenschaft angewendet wurden. Dies gibt an, dass die Metadaten versiegelt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterklassen sollten sicherstellen, dass jede Änderbarkeit der Datenstruktur einer <xref:System.Windows.PropertyMetadata> Unterklasse als unveränderlich gekennzeichnet werden soll, sobald <xref:System.Windows.PropertyMetadata.OnApply%2A> aufgerufen wird. Dies wird aufgerufen, sobald die Metadaten auf einen Eigenschafts System Vorgang angewendet wurden (registrieren, Hinzufügen von Besitzern, außer Kraft setzen von Metadaten).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine in diesen Metadaten angegebene <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierung ab oder legt diese fest.</summary>
        <value>Ein Verweis auf eine <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rückrufe in den Eigenschafts Metadaten sind in der Regel keine öffentlichen Member für den definierenden Typ. Daher ist der Wert dieser Eigenschaft für die meisten Szenarien, in denen nur die Metadaten einer vorhandenen Abhängigkeits Eigenschaft verwendet werden, nicht wichtig. Ein Grund, warum diese Eigenschaft verfügbar gemacht wird, ist, dass Metadatenklassen Ihre gewünschte Zusammenschluss Logik ausführen können, wenn sowohl Basis Metadaten als auch über schreibende/hinzugefügten <xref:System.Windows.PropertyChangedCallback> Metadaten eine Die standardmäßige zusammenlaufslogik für besteht darin, alle <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> Implementierungen in einer Tabelle beizubehalten und jede dieser Elemente aufzurufen, wobei Rückrufe von der tiefsten Klasse in der Hierarchie erstellt werden, die zuerst ausgeführt wird.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> wird im-Objektmodell als Lese-/Schreibzugriff definiert. Dies <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> kann nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> . Sobald die Metadaten jedoch als Teil eines Aufrufes von <xref:System.Windows.DependencyProperty.Register%2A> , oder verwendet werden <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , versiegelte das Eigenschaften System diese Metadateninstanz, und die Eigenschaften werden nun als unveränderlich eingestuft. Wenn Sie versuchen, einmal festzulegen, wird für <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` diese Metadateninstanz eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
