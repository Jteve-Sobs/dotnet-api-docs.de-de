<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="423f853a60d99a5767f47d8a9e4d3ef0dce3cb15" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39845057" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert bestimmte Verhaltensaspekte einer Abhängigkeitseigenschaft beim Anwenden für einen bestimmten Typ, einschließlich Bedingungen, mit denen sie registriert wurde.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenschaftsmetadaten definiert und beim Aufrufen von während der Registrierung der Abhängigkeitseigenschaft verwendet werden kann, die <xref:System.Windows.DependencyProperty.Register%2A> -Methode (oder Varianten von angefügten Eigenschaften oder schreibgeschützte Abhängigkeitseigenschaften) oder nach dem ursprünglichen Besitzer Registrierung beim Aufrufen der <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> Methode. <xref:System.Windows.DependencyProperty.AddOwner%2A> Außerdem akzeptiert es Eigenschaftenmetadaten.  
  
 Diese Klasse ist eine konkrete Basisklasse, die in jedem dieser Aufrufe verwendet werden kann. Allerdings ist es üblich, geben Sie Metadaten mithilfe einer der abgeleiteten Klassen wie z. B. <xref:System.Windows.FrameworkPropertyMetadata>. Diese abgeleiteten Klassen unterstützen detailliertere Metadaten, die als boolesche Eigenschaftswert, dies ist hilfreich beim Erkennen von, oder Aktivieren einige System und das Layout Verhalten der Eigenschaft, die nur am implementiert werden die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Frameworkebene.  
  
 Werden mehrere Eigenschaften dieser Klasse kann nur geschrieben werden, bevor die Instanz, wie z. B. in einem Vorgang verwendet wird, aber Lese-/ Schreibzugriff auf das Objektmodell <xref:System.Windows.DependencyProperty.Register%2A> oder <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>. Jede dieser Eigenschaften kann auch festgelegt wurden durch den Konstruktor aber verfügbar gemacht werden, damit <xref:System.Windows.PropertyMetadata.Merge%2A> methodenimplementierungen können sie festlegen.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Dieser Typ und Member dieses Typs werden normalerweise nicht verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der anzugebende Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit einem angegebenen Standardwert für die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` muss übereinstimmen oder im Zusammenhang mit den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, möglich schwierig zu debuggen, da der Konflikt nicht erkennbare während der Kompilierung (der Konflikt wird eine Laufzeitausnahme ausgelöst).  
  
 Obwohl der Standardwert für den parameterlosen Konstruktor, eine `defaultValue` von <xref:System.Windows.DependencyProperty.UnsetValue> kann nicht angegeben werden. Dies dennoch versuchen, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierungsverweis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen Standardwert und dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierungsverweis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des angegebenen Werts `defaultValue` muss übereinstimmen oder im Zusammenhang mit den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, möglich schwierig zu debuggen, da der Konflikt nicht erkennbare während der Kompilierung (der Konflikt wird eine Laufzeitausnahme ausgelöst).  
  
 Obwohl der Standardwert für den parameterlosen Konstruktor, eine `defaultValue` von <xref:System.Windows.DependencyProperty.UnsetValue> kann nicht angegeben werden. Dies dennoch versuchen, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Verweis auf eine Handlerimplementierung, die aufgerufen werden muss, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Eigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen Standardwert und den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie angeben möchten einer <xref:System.Windows.CoerceValueCallback> aber keine <xref:System.Windows.PropertyChangedCallback>, können Sie übergeben `null` für die `propertyChangedCallback` Parameter.  
  
 Der Typ des Werts zur `defaultValue` muss übereinstimmen oder im Zusammenhang mit den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, möglich schwierig zu debuggen, da der Konflikt nicht erkennbare während der Kompilierung (der Konflikt wird eine Laufzeitausnahme ausgelöst).  
  
 Obwohl der Standardwert für den parameterlosen Konstruktor, eine `defaultValue` von <xref:System.Windows.DependencyProperty.UnsetValue> kann nicht angegeben werden. Dies dennoch versuchen, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine in diesen Metadaten angegebene <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung ab oder legt diese fest.</summary>
        <value>Ein Verweis auf eine <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rückrufe in den Metadaten sind nicht in der Regel öffentliche Member auf den enthaltenden Typ, damit der Wert dieser Eigenschaft nicht in den meisten Szenarien wichtig ist, die einfach einer vorhandenen Abhängigkeitseigenschaft-Metadaten zu nutzen. Ein Grund, diese Eigenschaft wird verfügbar gemacht, wird, damit Metadaten-Unterklassen auf die gewünschte Zusammenführungslogik ausführen können, wenn sowohl die grundlegenden Metadaten als auch die überschreiben/Hinzufügen von Metadaten angeben einer <xref:System.Windows.CoerceValueCallback>. Allerdings die standardmäßige Zusammenführungslogik für eine <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> besteht darin, das vorherige Beispiel ersetzen.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> im Objektmodell ist als Lese-/ Schreibzugriff definiert. Dies ist deshalb so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> angepasst werden kann, nach der Initialisierung der <xref:System.Windows.PropertyMetadata> Objekt selbst. Aber wenn die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und die Eigenschaften werden jetzt als unveränderlich angesehen. Es wird versucht, legen Sie <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> nach <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardwert der Abhängigkeitseigenschaft ab oder legt diesen fest.</summary>
        <value>Der Standardwert der Eigenschaft. Der Standardwert für eine <see cref="T:System.Windows.PropertyMetadata" /> Instanz, die mit dem parameterlosen Konstruktor erstellte <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> im Objektmodell ist als Lese-/ Schreibzugriff definiert. Dies ist deshalb so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> angepasst werden kann, nach der Initialisierung der <xref:System.Windows.PropertyMetadata> Objekt selbst. Aber wenn die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und die Eigenschaften werden jetzt als unveränderlich angesehen. Es wird versucht, legen Sie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> nach <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
 Obwohl der Standardwert für den parameterlosen Konstruktor, eine `defaultValue` von <xref:System.Windows.DependencyProperty.UnsetValue> kann nicht festgelegt werden, entweder <xref:System.Windows.PropertyMetadata.DefaultValue%2A> oder den Konstruktor. Dies dennoch versuchen, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieses Typs werden nicht in der Regel in verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kann nach der Erstellung nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob die Metadaten auf eine Eigenschaft angewendet wurden, wodurch die betreffende Metadateninstanz als unveränderlich festgelegt wurde.</summary>
        <value><see langword="true" />, wenn die Metadateninstanz unveränderlich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschiedene Eigenschaften des <xref:System.Windows.PropertyMetadata>, z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, in das Objektmodell als schreibgeschützt definiert sind. Dies ist, damit diese Eigenschaften nach der Initialisierung des angepasst werden können die <xref:System.Windows.PropertyMetadata> Objekt selbst. Jedoch, nachdem die Metadaten als Teil eines Aufrufs für eine Abhängigkeitseigenschaft angewendet wurde <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und die Eigenschaften werden jetzt als unveränderlich angesehen. Zum Zeitpunkt eines diese Aufrufe <xref:System.Windows.PropertyMetadata.OnApply%2A> aufgerufen wird, und der Wert dieser Eigenschaft wird festgelegt, um `true`.  
  
   
  
## Examples  
 Das folgende Beispiel überprüft <xref:System.Windows.PropertyMetadata.IsSealed%2A> vor einem Set-Vorgang, der eine benutzerdefinierte Metadateneigenschaft.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Die Basismetadaten, die mit den Werten dieser Instanz zusammengeführt werden sollen.</param>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden.</param>
        <summary>Führt diese Metadaten mit den Basismetadaten zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern verwendet, wenn die Metadaten überschrieben werden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode).  
  
   
  
## Examples  
 Das folgende Beispiel implementiert eine Zusammenführung für einen benutzerdefinierten Metadaten, die die Metadaten für eine zusätzliche Eigenschaft hinzufügt.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klasse von Implementierungen, die abgeleitet <see cref="T:System.Windows.PropertyMetadata" /> sollten diese Methode, um für alle Metadateneigenschaften-Konto hinzugefügt deren Implementierung wurde überschreiben. Z. B. Ihre Implementierung möglicherweise hinzugefügt, einen neuen Flag-Enumerationswert und die <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Implementierung sollte dann in der Lage, solche Flags ordnungsgemäß zu kombinieren.  Rufen Sie immer die basisimplementierung vor dem Code zur Implementierung, da übernimmt die basisimplementierung Zusammenführen aller Eigenschaften, die bereits definiert die <see cref="T:System.Windows.PropertyMetadata" /> Typ.  Das genaue Verhalten der Zusammenführung bleibt Ihnen überlassen. Sie können auswählen, um die Werte kombinieren, um den Basiswert zurückgesetzt wird, wenn die abgeleitete Metadaten beibehalten wurden. bei Standard und viele andere Verhaltensweisen, die auf der Grundlage der Eigenschaften, mit denen, die Sie Ihre bestimmten Metadaten-Klasse und ihre Bedeutungen hinzugefügt haben.</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die die Metadaten angewendet wurden.</param>
        <param name="targetType">Der diesen Metadaten zugeordnete Typ, wenn es sich um typspezifische Metadaten handelt. Wenn es sich dabei um die Standardmetadaten handelt, ist dieser Wert ein NULL-Verweis.</param>
        <summary>Wird aufgerufen, wenn diese Metadaten auf eine Eigenschaft angewendet wurden. Dies gibt an, dass die Metadaten versiegelt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterklassen sollten stellen sicher, dass jede Veränderlichkeit von der Struktur einer <xref:System.Windows.PropertyMetadata> Unterklasse gekennzeichnet werden soll als unveränderlich einmal <xref:System.Windows.PropertyMetadata.OnApply%2A> aufgerufen wird. Dies wird aufgerufen, nachdem die Metadaten zu einem Vorgang angewendet wird (registrieren, Besitzer hinzufügen, das Überschreiben von Metadaten).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine in diesen Metadaten angegebene <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierung ab oder legt diese fest.</summary>
        <value>Ein Verweis auf eine <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rückrufe in den Metadaten sind nicht in der Regel öffentliche Member in der definierenden Typs an, damit der Wert dieser Eigenschaft nicht in den meisten Szenarien wichtig ist, die einfach einer vorhandenen Abhängigkeitseigenschaft-Metadaten zu nutzen. Ein Grund, diese Eigenschaft wird verfügbar gemacht, wird, damit Metadatenklassen die gewünschte Zusammenführungslogik ausführen können, wenn sowohl die grundlegenden Metadaten als auch die überschreiben/Hinzufügen von Metadaten angeben einer <xref:System.Windows.PropertyChangedCallback>. Die standardmäßige Zusammenführungslogik für alle darin ist <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> Implementierungen in einer Tabelle und jeder Aufruf und Rückrufe hergestellt, indem die tiefste-Klasse in der Hierarchie, die zuerst ausgeführt.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> im Objektmodell ist als Lese-/ Schreibzugriff definiert. Dies ist deshalb so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> angepasst werden kann, nach der Initialisierung der <xref:System.Windows.PropertyMetadata> Objekt selbst. Aber wenn die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und die Eigenschaften werden jetzt als unveränderlich angesehen. Es wird versucht, legen Sie <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> nach <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>