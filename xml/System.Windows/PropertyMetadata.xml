<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d36f95ed7817d5da38f16c281bae2bbdb0dbdb7" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86715197" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="8a33c-101">Definiert bestimmte Verhaltensaspekte einer Abhängigkeitseigenschaft beim Anwenden für einen bestimmten Typ, einschließlich Bedingungen, mit denen sie registriert wurde.</span><span class="sxs-lookup"><span data-stu-id="8a33c-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-102">Eigenschafts Metadaten können beim Aufrufen der- <xref:System.Windows.DependencyProperty.Register%2A> Methode (oder Variationen für angefügte Eigenschaften oder schreibgeschützte Abhängigkeits Eigenschaften) oder nach der ursprünglichen Besitzer Registrierung beim Aufrufen der-Methode definiert und verwendet werden <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="8a33c-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> erfordert auch Eigenschafts Metadaten.</span><span class="sxs-lookup"><span data-stu-id="8a33c-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="8a33c-104">Diese Klasse ist eine konkrete Basisklasse, die in jedem dieser Aufrufe verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8a33c-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="8a33c-105">Es ist jedoch sehr üblich, Metadaten mithilfe einer der abgeleiteten Klassen anzugeben, z <xref:System.Windows.FrameworkPropertyMetadata> . b..</span><span class="sxs-lookup"><span data-stu-id="8a33c-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="8a33c-106">Diese abgeleiteten Klassen unterstützen ausführlichere Metadaten, die als boolesche Eigenschaftswerte übernommen werden. diese sind nützlich, um Eigenschaften System-und Layoutverhalten zu erkennen oder zu aktivieren, die nur auf [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Frameworkebene implementiert sind.</span><span class="sxs-lookup"><span data-stu-id="8a33c-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="8a33c-107">Mehrere Eigenschaften dieser Klasse sind Lese-/Schreibzugriff auf das Objektmodell. Sie können jedoch nur vor der-Instanz geschrieben werden, die in einem Eigenschafts System Vorgang verwendet wird, z <xref:System.Windows.DependencyProperty.Register%2A> <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> . b. oder.</span><span class="sxs-lookup"><span data-stu-id="8a33c-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="8a33c-108">Jede dieser Eigenschaften kann auch vom Konstruktor festgelegt werden, Sie werden jedoch verfügbar gemacht, sodass <xref:System.Windows.PropertyMetadata.Merge%2A> Sie von Methoden Implementierungen festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="8a33c-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="8a33c-109">Verwendung von XAML-Text</span><span class="sxs-lookup"><span data-stu-id="8a33c-109">XAML Text Usage</span></span>  
 <span data-ttu-id="8a33c-110">Dieser Typ und Member dieses Typs werden in der Regel nicht in verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a33c-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8a33c-111">Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8a33c-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8a33c-112">Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8a33c-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="8a33c-113">Der anzugebende Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span></span></param>
        <summary><span data-ttu-id="8a33c-114">Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit einem angegebenen Standardwert für die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-115">Der Typ des Werts, der für bereitgestellt wird, `defaultValue` muss mit dem in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegebenen Typ, auf den diese Metadaten angewendet werden, identisch sein oder mit diesem verknüpft werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="8a33c-116">Konflikte zwischen dem metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die er angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist (der Konflikt führt zu einer Lauf Zeit Ausnahme).</span><span class="sxs-lookup"><span data-stu-id="8a33c-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="8a33c-117">Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann kein von angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="8a33c-118">Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8a33c-119"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-119"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="8a33c-120">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="8a33c-121">Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierungsverweis.</span><span class="sxs-lookup"><span data-stu-id="8a33c-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="8a33c-122">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-122">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="8a33c-123">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="8a33c-124">Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen Standardwert und dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierungsverweis.</span><span class="sxs-lookup"><span data-stu-id="8a33c-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-125">Der angegebene Typ `defaultValue` muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="8a33c-126">Konflikte zwischen dem metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die er angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist (der Konflikt führt zu einer Lauf Zeit Ausnahme).</span><span class="sxs-lookup"><span data-stu-id="8a33c-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="8a33c-127">Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann kein von angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="8a33c-128">Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8a33c-129"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-129"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="8a33c-130">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-130">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="8a33c-131">Verweis auf eine Handlerimplementierung, die vom Eigenschaftensystem aufgerufen werden muss, wenn der effektive Wert der Eigenschaft geändert wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="8a33c-132">Verweis auf eine Handlerimplementierung, die aufgerufen werden muss, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Eigenschaft aufruft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="8a33c-133">Initialisiert eine neue Instanz der <see cref="T:System.Windows.PropertyMetadata" />-Klasse mit dem angegebenen Standardwert und den angegebenen Rückrufen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-134">Wenn Sie <xref:System.Windows.CoerceValueCallback> , aber nicht angeben möchten <xref:System.Windows.PropertyChangedCallback> , können Sie `null` für den-Parameter übergeben `propertyChangedCallback` .</span><span class="sxs-lookup"><span data-stu-id="8a33c-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="8a33c-135">Der Typ des Werts, der für bereitgestellt wird, `defaultValue` muss mit dem in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegebenen Typ, auf den diese Metadaten angewendet werden, identisch sein oder mit diesem verknüpft werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="8a33c-136">Konflikte zwischen dem metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die er angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist (der Konflikt führt zu einer Lauf Zeit Ausnahme).</span><span class="sxs-lookup"><span data-stu-id="8a33c-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="8a33c-137">Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann kein von angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="8a33c-138">Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8a33c-139"><paramref name="defaultValue" /> kann nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-139"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8a33c-140">Ruft einen Verweis auf eine in diesen Metadaten angegebene <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="8a33c-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="8a33c-141">Ein Verweis auf eine <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="8a33c-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-142">Die Rückrufe in den Eigenschafts Metadaten sind in der Regel keine öffentlichen Member für den enthaltenden Typ. Daher ist der Wert dieser Eigenschaft für die meisten Szenarien, in denen nur die Metadaten einer vorhandenen Abhängigkeits Eigenschaft verwendet werden, nicht wichtig.</span><span class="sxs-lookup"><span data-stu-id="8a33c-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="8a33c-143">Ein Grund, warum diese Eigenschaft verfügbar gemacht wird, ist, dass metadatenunterklassen Ihre gewünschte Zusammenschluss Logik ausführen können, wenn sowohl Basis Metadaten als auch über schreibende/hinzugefügten <xref:System.Windows.CoerceValueCallback> Metadaten eine</span><span class="sxs-lookup"><span data-stu-id="8a33c-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="8a33c-144">Die standardmäßige Zusammensetzungs Logik für einen <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> besteht jedoch darin, die vorherige zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="8a33c-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> wird im-Objektmodell als Lese-/Schreibzugriff definiert.</span><span class="sxs-lookup"><span data-stu-id="8a33c-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="8a33c-146">Dies <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> kann nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="8a33c-147">Sobald die Metadaten jedoch als Teil eines Aufrufes von <xref:System.Windows.DependencyProperty.Register%2A> , oder verwendet werden <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , versiegelte das Eigenschaften System diese Metadateninstanz, und die Eigenschaften werden nun als unveränderlich eingestuft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="8a33c-148">Wenn Sie versuchen, einmal festzulegen, wird für <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` diese Metadateninstanz eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8a33c-149">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-149">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8a33c-150">Ruft den Standardwert der Abhängigkeitseigenschaft ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="8a33c-150">Gets or sets the default value of the dependency property.</span></span></summary>
        <value><span data-ttu-id="8a33c-151">Der Standardwert der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-151">The default value of the property.</span></span> <span data-ttu-id="8a33c-152">Der Standardwert für eine- <see cref="T:System.Windows.PropertyMetadata" /> Instanz, die mit dem Parameter losen Konstruktor erstellt wird, ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> wird im-Objektmodell als Lese-/Schreibzugriff definiert.</span><span class="sxs-lookup"><span data-stu-id="8a33c-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="8a33c-154">Dies <xref:System.Windows.PropertyMetadata.DefaultValue%2A> kann nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="8a33c-155">Sobald die Metadaten jedoch als Teil eines Aufrufes von <xref:System.Windows.DependencyProperty.Register%2A> , oder verwendet werden <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , versiegelte das Eigenschaften System diese Metadateninstanz, und die Eigenschaften werden nun als unveränderlich eingestuft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="8a33c-156">Wenn Sie versuchen, einmal festzulegen, wird für <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` diese Metadateninstanz eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="8a33c-157">Obwohl es sich um den Standardwert für den Parameter losen Konstruktor handelt `defaultValue` , <xref:System.Windows.DependencyProperty.UnsetValue> kann ein von nicht mithilfe von <xref:System.Windows.PropertyMetadata.DefaultValue%2A> oder dem-Konstruktor festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="8a33c-158">Wenn Sie versuchen, dies zu tun, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="8a33c-159">Verwendung von XAML-Text</span><span class="sxs-lookup"><span data-stu-id="8a33c-159">XAML Text Usage</span></span>  
 <span data-ttu-id="8a33c-160">Member dieses Typs werden in der Regel nicht in verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a33c-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8a33c-161">Kann nach der Erstellung nicht auf den Wert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8a33c-162">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-162">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8a33c-163">Ruft einen Wert ab, der bestimmt, ob die Metadaten auf eine Eigenschaft angewendet wurden, wodurch die betreffende Metadateninstanz als unveränderlich festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="8a33c-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span></span></summary>
        <value><span data-ttu-id="8a33c-164"><see langword="true" />, wenn die Metadateninstanz unveränderlich ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8a33c-164"><see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-165">Verschiedene Eigenschaften von <xref:System.Windows.PropertyMetadata> , wie z <xref:System.Windows.PropertyMetadata.DefaultValue%2A> . b., werden im Objektmodell als Lese-/Schreibzugriff definiert.</span><span class="sxs-lookup"><span data-stu-id="8a33c-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="8a33c-166">So können diese Eigenschaften nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="8a33c-167">Nachdem die Metadaten jedoch im Rahmen eines Aufrufes, oder auf eine Abhängigkeits Eigenschaft <xref:System.Windows.DependencyProperty.Register%2A> angewendet <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> wurden, wird diese Metadateninstanz vom Eigenschaften System versiegelt, und die Eigenschaften werden nun als unveränderlich eingestuft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="8a33c-168">Zum Zeitpunkt eines dieser Aufrufe <xref:System.Windows.PropertyMetadata.OnApply%2A> wird aufgerufen, und der Wert dieser Eigenschaft wird auf festgelegt `true` .</span><span class="sxs-lookup"><span data-stu-id="8a33c-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8a33c-169">Im folgenden Beispiel wird <xref:System.Windows.PropertyMetadata.IsSealed%2A> vor einem Set-Vorgang einer benutzerdefinierten Metadateneigenschaft überprüft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="8a33c-170">Die Basismetadaten, die mit den Werten dieser Instanz zusammengeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-170">The base metadata to merge with this instance's values.</span></span></param>
        <param name="dp"><span data-ttu-id="8a33c-171">Die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-171">The dependency property to which this metadata is being applied.</span></span></param>
        <summary><span data-ttu-id="8a33c-172">Führt diese Metadaten mit den Basismetadaten zusammen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-172">Merges this metadata with the base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-173">Diese Methode wird intern verwendet, wenn Metadaten überschrieben werden (- <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode).</span><span class="sxs-lookup"><span data-stu-id="8a33c-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8a33c-174">Im folgenden Beispiel wird ein Merge für einen benutzerdefinierten Metadatentyp implementiert, der den Eigenschafts Metadaten eine zusätzliche Eigenschaft hinzufügt.</span><span class="sxs-lookup"><span data-stu-id="8a33c-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8a33c-175">Klassen Implementierungen, die von abgeleitet werden, <see cref="T:System.Windows.PropertyMetadata" /> sollten diese Methode überschreiben, um Metadaten-Eigenschaften zu berücksichtigen, die Sie in ihren Implementierungen hinzugefügt haben.</span><span class="sxs-lookup"><span data-stu-id="8a33c-175">Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations.</span></span> <span data-ttu-id="8a33c-176">Beispielsweise kann Ihre-Implementierung einen neuen flagbezogenen Enumerationswert hinzugefügt haben, und die <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Implementierung sollte dann in der Lage sein, diese Flags ordnungsgemäß zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="8a33c-176">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span></span>  
  
<span data-ttu-id="8a33c-177">Die Basis Implementierung muss immer vor dem Implementierungs Code aufgerufen werden, da die Basis Implementierung alle bereits für den Typ definierten Eigenschaften zusammenführt <see cref="T:System.Windows.PropertyMetadata" /> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-177">Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.</span></span>  
  
<span data-ttu-id="8a33c-178">Das genaue Verhalten der Zusammenführung liegt bei Ihnen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-178">The exact behavior of the merge is up to you.</span></span> <span data-ttu-id="8a33c-179">Sie können auswählen, ob Werte kombiniert werden, ob Sie den Basiswert wiederherstellen möchten, wenn die abgeleiteten Metadaten den Standardwert verbleiben, oder viele andere Verhalten auf der Grundlage der Typen von Eigenschaften, die Sie ihrer jeweiligen Metadatenklasse hinzugefügt haben, und ihrer Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="8a33c-179">You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="8a33c-180">Die Abhängigkeitseigenschaft, auf die die Metadaten angewendet wurden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-180">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="8a33c-181">Der diesen Metadaten zugeordnete Typ, wenn es sich um typspezifische Metadaten handelt.</span><span class="sxs-lookup"><span data-stu-id="8a33c-181">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="8a33c-182">Wenn es sich dabei um die Standardmetadaten handelt, ist dieser Wert ein NULL-Verweis.</span><span class="sxs-lookup"><span data-stu-id="8a33c-182">If this is default metadata, this value is a null reference.</span></span></param>
        <summary><span data-ttu-id="8a33c-183">Wird aufgerufen, wenn diese Metadaten auf eine Eigenschaft angewendet wurden. Dies gibt an, dass die Metadaten versiegelt wurden.</span><span class="sxs-lookup"><span data-stu-id="8a33c-183">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-184">Unterklassen sollten sicherstellen, dass jede Änderbarkeit der Datenstruktur einer <xref:System.Windows.PropertyMetadata> Unterklasse als unveränderlich gekennzeichnet werden soll, sobald <xref:System.Windows.PropertyMetadata.OnApply%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-184">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="8a33c-185">Dies wird aufgerufen, sobald die Metadaten auf einen Eigenschafts System Vorgang angewendet wurden (registrieren, Hinzufügen von Besitzern, außer Kraft setzen von Metadaten).</span><span class="sxs-lookup"><span data-stu-id="8a33c-185">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8a33c-186">Ruft einen Verweis auf eine in diesen Metadaten angegebene <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierung ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="8a33c-186">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="8a33c-187">Ein Verweis auf eine <see cref="T:System.Windows.PropertyChangedCallback" />-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="8a33c-187">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a33c-188">Die Rückrufe in den Eigenschafts Metadaten sind in der Regel keine öffentlichen Member für den definierenden Typ. Daher ist der Wert dieser Eigenschaft für die meisten Szenarien, in denen nur die Metadaten einer vorhandenen Abhängigkeits Eigenschaft verwendet werden, nicht wichtig.</span><span class="sxs-lookup"><span data-stu-id="8a33c-188">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="8a33c-189">Ein Grund, warum diese Eigenschaft verfügbar gemacht wird, ist, dass Metadatenklassen Ihre gewünschte Zusammenschluss Logik ausführen können, wenn sowohl Basis Metadaten als auch über schreibende/hinzugefügten <xref:System.Windows.PropertyChangedCallback> Metadaten eine</span><span class="sxs-lookup"><span data-stu-id="8a33c-189">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="8a33c-190">Die standardmäßige zusammenlaufslogik für besteht darin, alle <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> Implementierungen in einer Tabelle beizubehalten und jede dieser Elemente aufzurufen, wobei Rückrufe von der tiefsten Klasse in der Hierarchie erstellt werden, die zuerst ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8a33c-190">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="8a33c-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> wird im-Objektmodell als Lese-/Schreibzugriff definiert.</span><span class="sxs-lookup"><span data-stu-id="8a33c-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="8a33c-192">Dies <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> kann nach der Initialisierung des Objekts selbst angepasst werden <xref:System.Windows.PropertyMetadata> .</span><span class="sxs-lookup"><span data-stu-id="8a33c-192">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="8a33c-193">Sobald die Metadaten jedoch als Teil eines Aufrufes von <xref:System.Windows.DependencyProperty.Register%2A> , oder verwendet werden <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , versiegelte das Eigenschaften System diese Metadateninstanz, und die Eigenschaften werden nun als unveränderlich eingestuft.</span><span class="sxs-lookup"><span data-stu-id="8a33c-193">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="8a33c-194">Wenn Sie versuchen, einmal festzulegen, wird für <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` diese Metadateninstanz eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8a33c-194">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8a33c-195">Kann nach der Anwendung auf eine Abhängigkeitseigenschaftsoperation keine Metadateneigenschaft festlegen.</span><span class="sxs-lookup"><span data-stu-id="8a33c-195">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
