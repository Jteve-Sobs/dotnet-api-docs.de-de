<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6c278b4a8cb5cddf20cd2ef2e8908304e5541f0b" /><Meta Name="ms.sourcegitcommit" Value="9058026d5788c19bed0a767fc52b40a1eac8ebfe" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/24/2019" /><Meta Name="ms.locfileid" Value="72849332" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Kapselt eine Windows Presentation Foundation-Anwendung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> ist eine Klasse, die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] anwendungsspezifische Funktionalität kapselt, einschließlich der folgenden:  
  
-   **Anwendungs Lebensdauer**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Fenster, Eigenschaft und Ressourcenverwaltung im Anwendungsbereich**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Befehlszeilen Parameter und Beendigungs Code Verarbeitung**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType><xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implementiert das Singleton-Muster, um den gemeinsamen Zugriff auf seine Fenster-, Eigenschafts-und Ressourcenbereichs Dienste bereitzustellen. Folglich kann nur eine Instanz der <xref:System.Windows.Application>-Klasse pro <xref:System.AppDomain>erstellt werden.  
  
 Sie können eine <xref:System.Windows.Application> mit Markup, Markup und Code Behind oder Code implementieren. Wenn <xref:System.Windows.Application> mit Markup, ob Markup oder Markup und Code Behind implementiert ist, muss die Markup Datei als [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` Element konfiguriert werden.  
  
> [!NOTE]
>  Eine eigenständige Anwendung erfordert kein <xref:System.Windows.Application> Objekt. Es ist möglich, eine benutzerdefinierte `static` Einstiegspunkt Methode (`Main`) zu implementieren, die ein Fenster öffnet, ohne eine Instanz von <xref:System.Windows.Application>zu erstellen. [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] benötigen jedoch ein <xref:System.Windows.Application>-Objekt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Standardanwendung nur mit Markup definiert wird:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 Im folgenden Beispiel wird gezeigt, wie eine Standardanwendung nur mit Code definiert wird:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 Im folgenden Beispiel wird gezeigt, wie eine Standardanwendung mithilfe einer Kombination aus Markup und Code Behind definiert wird.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Der öffentliche <see langword="static" /> (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Außerdem sind die Methoden <see cref="M:System.Windows.Application.FindResource(System.Object)" /> und <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> sowie die Eigenschaften <see cref="P:System.Windows.Application.Properties" /> und <see cref="P:System.Windows.Application.Resources" /> Thread sicher.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Application" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pro <xref:System.AppDomain>kann nur eine Instanz der <xref:System.Windows.Application>-Klasse erstellt werden, um den gemeinsamen Zugriff auf einen einzelnen Satz von Anwendungsbereichs Fenstern,-Eigenschaften und-Ressourcen Daten sicherzustellen. Folglich erkennt der Parameter lose Konstruktor der <xref:System.Windows.Application>-Klasse, ob es sich bei der Instanz, die initialisiert wird, um die erste Instanz in einer <xref:System.AppDomain>handelt. Wenn dies nicht der Fall ist, wird ein <xref:System.InvalidOperationException> ausgelöst.  
  
 Das <xref:System.Windows.Application>-Objekt für die aktuelle <xref:System.AppDomain> wird von der statischen <xref:System.Windows.Application.Current%2A>-Eigenschaft verfügbar gemacht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Pro <see cref="T:System.Windows.Application" /> wird mehr als eine Instanz der <see cref="T:System.AppDomain" />-Klasse erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung als Vordergrundanwendung verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Windows Presentation Foundation Anwendung mit einem oder mehreren geöffneten Fenstern wird aktiviert (wird zur Vordergrund Anwendung), wenn eines der Fenster zum ersten Mal aktiviert wird, seit die Anwendung gestartet wurde, oder wenn eines der Fenster aktiviert ist, während die Anwendung ist inaktiv: Die Aktivierung erfolgt insbesondere, wenn Folgendes zutrifft:  
  
-   Eine Anwendung öffnet das erste Fenster.  
  
-   Ein Benutzer wechselt zur Anwendung, indem er Alt + Tab oder den Task-Manager verwendet.  
  
-   Ein Benutzer klickt auf die Task leisten Schaltfläche für eines der Fenster in einer Anwendung.  
  
 Anwendungen, die bei Aktivierung erkennen müssen, können das <xref:System.Windows.Application.Activated>-Ereignis behandeln.  
  
 Nachdem eine Anwendung zum ersten Mal aktiviert wurde, kann Sie während ihrer Lebensdauer mehrmals deaktiviert und erneut aktiviert werden. Wenn das Verhalten oder der Zustand einer Anwendung vom Aktivierungszustand abhängig ist, kann Sie sowohl <xref:System.Windows.Application.Activated> als auch <xref:System.Windows.Application.Deactivated> Ereignisse behandeln, um zu bestimmen, in welchem Aktivierungszustand Sie sich befinden.  
  
 Sobald eine Anwendung aktiv wird, wird <xref:System.Windows.Application.Activated> erst dann erneut ausgelöst, wenn die Anwendung deaktiviert wird, unabhängig davon, wie viele Fenster in einer Anwendung aktiviert werden, während die Anwendung aktiv ist.  
  
 <xref:System.Windows.Application.Activated> wird für [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]nicht ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie erkennen können, wenn eine eigenständige Anwendung aktiviert und deaktiviert wird.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Application" />-Objekt für die aktuelle <see cref="T:System.AppDomain" /> ab.</summary>
        <value>Das <see cref="T:System.Windows.Application" />-Objekt für die aktuelle <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> ist ein pro<xref:System.AppDomain> Singleton-Typ, der die statische <xref:System.Windows.Application.Current%2A>-Eigenschaft implementiert, um den gemeinsamen Zugriff auf die <xref:System.Windows.Application> Instanz für die aktuelle <xref:System.AppDomain>bereitzustellen. Durch diesen Entwurf wird gewährleistet, dass der durch <xref:System.Windows.Application>verwaltete Zustand, einschließlich der freigegebenen Ressourcen und des Zustands, über einen einzelnen freigegebenen Speicherort verfügbar ist.  
  
 Diese Eigenschaft ist Thread sicher und ist in jedem Thread verfügbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung nicht mehr die Vordergrundanwendung ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Benutzer die folgenden Aktionen ausführt, wird eine Windows Presentation Foundation Anwendung mit mindestens einem geöffneten Fenster deaktiviert (die Vordergrund Anwendung wird nicht mehr verwendet):  
  
-   Wechselt zu einer anderen Anwendung mithilfe von Alt + Tab oder mithilfe des Task-Managers.  
  
-   Klickt auf die Task leisten Schaltfläche für ein Fenster in einer anderen Anwendung.  
  
 Anwendungen, die die Aktivierung erkennen müssen, können das <xref:System.Windows.Application.Deactivated> Ereignis verarbeiten.  
  
 Nachdem eine Anwendung zum ersten Mal aktiviert wurde, kann Sie während ihrer Lebensdauer mehrmals deaktiviert und erneut aktiviert werden. Wenn das Verhalten oder der Zustand einer Anwendung vom Aktivierungszustand abhängig ist, kann Sie sowohl <xref:System.Windows.Application.Deactivated> als auch <xref:System.Windows.Application.Activated> Ereignisse behandeln, um zu bestimmen, in welchem Zustand Sie sich befinden.  
  
 <xref:System.Windows.Application.Deactivated> wird für [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]nicht ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie erkennen können, wenn eine eigenständige Anwendung deaktiviert und aktiviert wird.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn durch eine Anwendung eine Ausnahme ausgelöst wird, die jedoch nicht behandelt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig werden von Windows Presentation Foundation nicht behandelte Ausnahmen abgefangen, Benutzer über die Ausnahme von einem Dialogfeld benachrichtigt (von dem die Ausnahme gemeldet werden kann), und eine Anwendung wird automatisch heruntergefahren.  
  
 Wenn eine Anwendung jedoch eine benutzerdefinierte nicht behandelte Ausnahme Verarbeitung von einem zentralen Speicherort aus ausführen muss, sollten Sie <xref:System.Windows.Application.DispatcherUnhandledException>verarbeiten.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> wird von einem <xref:System.Windows.Application> für jede Ausnahme ausgelöst, die von Code, der auf dem Hauptbenutzer Oberflächen Thread ausgeführt wird, nicht behandelt wird.  
  
 Wenn eine Ausnahme nicht entweder in einem Thread für die Benutzeroberfläche (einem Thread mit einem eigenen <xref:System.Windows.Threading.Dispatcher>) oder einem Arbeitsthreads im Hintergrund (einem Thread ohne <xref:System.Windows.Threading.Dispatcher>) behandelt wird, wird die Ausnahme nicht an den Hauptbenutzer Oberflächen-Thread weitergeleitet. Folglich wird <xref:System.Windows.Application.DispatcherUnhandledException> nicht ausgelöst. In diesen Fällen müssen Sie Code schreiben, um Folgendes durchzuführen:  
  
1.  Behandeln Sie Ausnahmen im Hintergrund Thread.  
  
2.  Verteilen Sie diese Ausnahmen an den Hauptbenutzer Oberflächen-Thread.  
  
3.  Lösen Sie Sie im Haupt-UI-Thread erneut aus, ohne Sie zu behandeln, damit <xref:System.Windows.Application.DispatcherUnhandledException> ausgelöst werden kann.  
  
 Weitere Informationen finden Sie in der Übersicht über das [Threading Modell](~/docs/framework/wpf/advanced/threading-model.md) .  
  
 An den <xref:System.Windows.Application.DispatcherUnhandledException>-Ereignishandler wird ein <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> Argument mit Kontextinformationen bezüglich der Ausnahme übergangen, einschließlich:  
  
-   Die Ausnahme (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   Der <xref:System.Windows.Threading.Dispatcher> aus dem er stammt (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Sie können diese Informationen verwenden, um zu bestimmen, ob eine Ausnahme wiederherstellbar ist. Eine behebbare Ausnahme ist möglicherweise eine <xref:System.IO.FileNotFoundException>, z. B. während eine nicht behebbare Ausnahme ist ein <xref:System.StackOverflowException>, z. B.  
  
 Wenn Sie eine nicht behandelte Ausnahme von <xref:System.Windows.Application.DispatcherUnhandledException>verarbeiten und Sie nicht möchten, dass [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] die Verarbeitung fortsetzt, müssen Sie die Eigenschaft <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> auf `true`festlegen.  
  
 Im Gegensatz zu anderen Ereignissen, die von <xref:System.Windows.Application> ausgelöst werden, verfügt <xref:System.Windows.Application.DispatcherUnhandledException> nicht über eine übereinstimmende geschützte virtuelle Implementierung (ondispatcherunhandlerdexception). Folglich müssen Klassen, die von <xref:System.Windows.Application> abgeleitet werden, immer einen Ereignishandler mit <xref:System.Windows.Application.DispatcherUnhandledException> registrieren, um nicht behandelte Ausnahmen zu verarbeiten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie nicht behandelte Ausnahmen verarbeiten können, indem Sie das <xref:System.Windows.Application.DispatcherUnhandledException>-Ereignis behandeln.  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt kurz vor dem Herunterfahren einer Anwendung auf und kann nicht abgebrochen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann aus einem der folgenden Gründe heruntergefahren werden:  
  
-   Die <xref:System.Windows.Application.Shutdown%2A>-Methode des <xref:System.Windows.Application> Objekts wird entweder explizit oder entsprechend der <xref:System.Windows.Application.ShutdownMode%2A>-Eigenschaft aufgerufen.  
  
-   Der Benutzer beendet die Sitzung, indem er sich abmeldet oder herunterfährt.  
  
 Sie können erkennen, wann das Herunterfahren der Anwendung erfolgt, indem Sie das <xref:System.Windows.Application.Exit>-Ereignis behandeln und ggf. zusätzliche Verarbeitungsschritte durchführen.  
  
 Sie können auch <xref:System.Windows.Application.Exit> behandeln, um den Exitcode der Anwendung zu überprüfen oder zu ändern, wenn Sie <xref:System.Windows.Application.Shutdown%2A> nicht explizit aufzurufen müssen. Der Exitcode wird von der <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>-Eigenschaft des <xref:System.Windows.ExitEventArgs> Arguments verfügbar gemacht, das an den <xref:System.Windows.Application.Exit>-Ereignishandler übermittelt wird. Wenn die Anwendung nicht mehr ausgeführt wird, wird der Exitcode für die nachfolgende Verarbeitung an das Betriebssystem übermittelt.  
  
 Wenn Ihre Anwendung das <xref:System.Windows.Application.SessionEnding> Ereignis verarbeitet und anschließend abbricht, wird <xref:System.Windows.Application.Exit> nicht ausgelöst, und die Anwendung wird weiterhin in Übereinstimmung mit dem Herunterfahren ausgeführt.  
  
 Der Exitcode kann von einem [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]festgelegt werden, obwohl der Wert ignoriert wird.  
  
 Für [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]wird <xref:System.Windows.Application.Exit> in folgenden Situationen ausgelöst:  
  
-   Ein [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] wird von der navigiert.  
  
-   In [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], wenn die Registerkarte geschlossen wird, auf der die [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] gehostet wird.  
  
-   Wenn der Browser geschlossen wird.  
  
 In allen Fällen wird der Wert der <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>-Eigenschaft ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird Folgendes veranschaulicht:  
  
-   Behandeln Sie das <xref:System.Windows.Application.Exit>-Ereignis.  
  
-   Überprüfen und aktualisieren Sie die <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>-Eigenschaft der <xref:System.Windows.ExitEventArgs>.  
  
-   Schreiben Sie einen Eintrag in ein Anwendungsprotokoll in isoliertem Speicher.  
  
-   Speichert den Anwendungs Zustand in isoliertem Speicher.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Name der zu suchenden Ressource.</param>
        <summary>Sucht eine [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]-Ressource, z. B. einen <see cref="T:System.Windows.Style" /> oder einen <see cref="T:System.Windows.Media.Brush" /> mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird (siehe [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Das angeforderte Ressourcenobjekt. Wenn die angeforderte Ressource nicht gefunden werden kann, wird eine <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> sucht zunächst in Ressourcen im Anwendungsbereich für die angegebene Ressource. Ressourcen im Anwendungsbereich werden von <xref:System.Windows.Application>verwaltet und über die <xref:System.Windows.Application.Resources%2A>-Eigenschaft verfügbar gemacht. Wenn die angegebene Ressource nicht im Satz von Ressourcen für den Anwendungsbereich gefunden wird, werden <xref:System.Windows.Application.FindResource%2A> dann als nächstes die Systemressourcen durchsucht. System Ressourcen sind vom benutzerdefinierte Shellressourcen und umfassen Farben, Schriftarten und Shellkonfigurationen. Diese werden von den Typen <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>und <xref:System.Windows.SystemParameters> als statische Eigenschaften verfügbar gemacht. Wenn Sie <xref:System.Windows.Application.FindResource%2A> verwenden möchten, um Sie abzurufen, machen diese Typen auch Ressourcen Schlüsseleigenschaften verfügbar, die an <xref:System.Windows.Application.FindResource%2A>übermittelt werden sollen. beispielsweise <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Da <xref:System.Windows.Application.FindResource%2A> ein Objekt zurückgibt, müssen Sie den zurückgegebenen Wert in den entsprechenden Typ umwandeln, wenn die Ressource gefunden wird.  
  
> [!IMPORTANT]
>  Wenn Sie diese Methode für einen Schlüssel aufgerufen haben, der nicht gefunden werden kann, wird eine Ausnahme ausgelöst. Wenn Sie keine Ausnahmen behandeln möchten, die aus dem Aufrufen von <xref:System.Windows.Application.FindResource%2A>resultieren, rufen Sie stattdessen <xref:System.Windows.Application.TryFindResource%2A> auf. <xref:System.Windows.Application.TryFindResource%2A> gibt einen `null` Verweis zurück, wenn eine angeforderte Ressource nicht gefunden werden kann, und löst keine Ausnahme aus.  
  
 Diese Methode ist Thread sicher und kann von jedem Thread aufgerufen werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Application.FindResource%2A> verwendet wird, um eine Ressource zu suchen und <xref:System.Windows.ResourceReferenceKeyNotFoundException> zu verarbeiten, wenn die Ressource nicht gefunden wurde.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Die Ressource wurde nicht gefunden.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Navigator in der Anwendung mit der Navigation zu einem Inhaltsfragment beginnt. Die Navigation erfolgt sofort, wenn sich das gewünschte Fragment im aktuellen Inhalt befindet oder nachdem der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-Quellinhalt geladen wurde, sofern sich das gewünschte Fragment in einem anderen Inhalt befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Der relative <see cref="T:System.Uri" />, der einer freien Ressource zugeordnet wird.</param>
        <summary>Gibt einen Ressourcenstream für eine Inhaltsdatendatei zurück, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet (weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>Eine <see cref="T:System.Windows.Resources.StreamResourceInfo" /> mit einer Inhaltsdatendatei, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet. Wenn eine freie Ressource nicht gefunden wurde, wird NULL zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht Thread sicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> ist ein absoluter <see cref="T:System.Uri" />.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Der <see cref="T:System.Uri" />, der den Speicherort angibt, für den ein Cookie erstellt wurde.</param>
        <summary>Ruft ein Cookie für den von einem <see cref="T:System.Uri" /> angegebenen Speicherort ab.</summary>
        <returns>Ein <see cref="T:System.String" />-Wert, wenn das Cookie vorhanden ist, andernfalls wird eine <see cref="T:System.ComponentModel.Win32Exception" /> ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> Ruft ein Cookie für die angegebene <xref:System.Uri>ab. Wenn das Cookie nicht abgerufen werden kann, wird eine <xref:System.ComponentModel.Win32Exception> ausgelöst. Sie müssen den Code schreiben, um die Cookie-Zeichenfolge in eine Liste von Name-Wert-Paaren zu analysieren.  
  
 Eine Übersicht über Cookies in [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]finden Sie unter [Übersicht](~/docs/framework/wpf/app-development/navigation-overview.md)über die Navigation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wenn beim Abrufen des angegebenen Cookies ein Problem auftritt, wird von der <see langword="InternetGetCookie" />-Funktion (aufgerufen durch <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) ein [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]-Fehler ausgelöst.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum erhalten des Cookies für eine dateibasierte <see cref="T:System.Uri" />. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">zum erhalten des Cookies für eine nicht dateibasierte <see cref="T:System.Uri" />. Zugehörige Enumeration: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">Der <see cref="T:System.Uri" />, der einer freien Ressource auf der Ursprungssite zugeordnet wird.</param>
        <summary>Gibt einen Ressourcenstream für eine Ursprungssite-Datendatei zurück, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet (weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>Eine <see cref="T:System.Windows.Resources.StreamResourceInfo" /> mit einem Ressourcenstream für eine Ursprungssite-Datendatei, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet. Wenn die freie Ressource nicht gefunden wurde, wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht Thread sicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ist nicht relativ oder ist absolut, aber nicht im Format <c>pack://siteoforigin:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">Der <see cref="T:System.Uri" />, der einer eingebetteten Ressource zugeordnet wird.</param>
        <summary>Gibt einen Ressourcenstream für eine Ressourcendatendatei zurück, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet (weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>Eine <see cref="T:System.Windows.Resources.StreamResourceInfo" /> mit einem Ressourcenstream für eine Ressourcendatendatei, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht Thread sicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ist nicht relativ oder ist absolut, aber nicht im Format <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> kann nicht gefunden werden.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Inhalt, zu dem ein Navigator in der Anwendung navigiert ist, geladen und analysiert und mit dem Rendering begonnen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Lauschen auf Ereignisse für den Navigations Inhalt, z. b. das <xref:System.Windows.FrameworkElement.Loaded>-Ereignis auf <xref:System.Windows.Controls.Page>, bevor Sie auf Eigenschaften des Navigations Inhalts zugreifen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei, die sich unter dem angegebenen URI (Uniform Resource Identifier) befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Datei kann es sich um eine Anwendungscode Datei (als [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Seitenelement konfiguriert) oder eine Anwendungs Datendatei (eine Ressourcen Datei, Inhalts Datei oder eine Ursprungs Site Datei) handeln. Informationen hierzu finden Sie unter [WPF-Anwendungs Ressource, Inhalt und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!NOTE]
>  Diese Methode ist nicht Thread sicher.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">Ein <see cref="T:System.Uri" />, der einer relativen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei zugeordnet ist.</param>
        <summary>Lädt eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei, die sich unter dem angegebenen URI (Uniform Resource Identifier) befindet, und konvertiert sie in eine Instanz des Objekts, das durch das Stammelement der [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei angegeben wird.</summary>
        <returns>Eine Instanz des Stammelements, das durch die geladene XAML-Datei angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert muss explizit in denselben Typ wie das Stamm Element der [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] Datei konvertiert werden.  
  
 Bei der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Datei kann es sich um eine Anwendungscode Datei (als [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Seitenelement konfiguriert) oder eine Anwendungs Datendatei (eine Ressourcen Datei, Inhalts Datei oder eine Ursprungs Site Datei) handeln. Informationen hierzu finden Sie unter [WPF-Anwendungs Ressource, Inhalt und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!NOTE]
>  Diese Methode ist nicht Thread sicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="resourceLocator" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.Exception">Die Datei ist keine [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-Datei.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Ein Objekt des gleichen Typs wie das Stammelement der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei.</param>
        <param name="resourceLocator">Ein <see cref="T:System.Uri" />, der einer relativen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei zugeordnet ist.</param>
        <summary>Lädt eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei, die sich unter dem angegebenen URI (Uniform Resource Identifier) befindet, und konvertiert sie in eine Instanz des Objekts, das durch das Stammelement der [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Datei kann es sich um eine Anwendungscode Datei (als [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Seitenelement konfiguriert) oder eine Anwendungs Datendatei (eine Ressourcen Datei, Inhalts Datei oder eine Ursprungs Site Datei) handeln. Informationen hierzu finden Sie unter [WPF-Anwendungs Ressource, Inhalt und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!NOTE]
>  Diese Methode ist nicht Thread sicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="resourceLocator" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.Exception"><paramref name="component" /> ist ein Typ, der nicht dem Stammelement der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei entspricht.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Hauptfenster der Anwendung ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Window" />, das als Hauptanwendungsfenster festgelegt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> wird automatisch mit einem Verweis auf das erste <xref:System.Windows.Window> Objekt festgelegt, das in der <xref:System.AppDomain>instanziiert werden soll.  
  
 Sie können ein anderes Hauptfenster angeben, indem Sie festlegen, <xref:System.Windows.Application.MainWindow%2A> der <xref:System.Windows.Application.MainWindow%2A>-Eigenschaft ein weiteres <xref:System.Windows.Application.Windows%2A>-Objekt zuzuweisen.  
  
 Wenn die <xref:System.Windows.Application.ShutdownMode%2A>-Eigenschaft des <xref:System.Windows.Application> Objekts auf <xref:System.Windows.ShutdownMode.OnMainWindowClose>festgelegt ist, wird beim Schließen des Hauptfensters das Herunterfahren der Anwendung bewirkt.  
  
 Es ist möglich, die <xref:System.Windows.Application.MainWindow%2A>-Eigenschaft von [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]festzulegen, wenn das Hauptfenster einer Anwendung nicht das Fenster ist, das durch Festlegen der <xref:System.Windows.Application.StartupUri%2A>-Eigenschaft in [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]erzeugt wird. Die folgenden beiden Einschränkungen gelten für die [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Vorgehensweise:  
  
-   Sie können entweder eine [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]nur <xref:System.Windows.Window> oder eine [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]<xref:System.Windows.Navigation.NavigationWindow> als Hauptfenster angeben.  
  
-   Sie müssen die <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft des von Ihnen angegebenen Fensters festlegen. andernfalls wird Sie nicht angezeigt.  
  
 Der Verweis auf das erste <xref:System.Windows.Window> Objekt, das instanziiert werden soll, wird auch als erstes Element zur <xref:System.Windows.Application.Windows%2A> Auflistung hinzugefügt. Wenn <xref:System.Windows.Application.MainWindow%2A> anschließend mit einem Verweis auf einen anderen <xref:System.Windows.Window>festgelegt wird, wird die Position des Elements mit dem Verweis auf das Hauptfenster geändert, während die Reihenfolge der Elemente in <xref:System.Windows.Application.Windows%2A> unverändert bleibt. Verwenden Sie daher immer <xref:System.Windows.Application.MainWindow%2A>, um auf das Hauptfenster anstatt auf das erste Element in <xref:System.Windows.Application.Windows%2A>zu verweisen.  
  
> [!NOTE]
>  Wenn das Hauptfenster eine <xref:System.Windows.Navigation.NavigationWindow>ist und Sie bestimmten Zugriff auf <xref:System.Windows.Navigation.NavigationWindow> Member benötigen, müssen Sie den Wert von <xref:System.Windows.Application.MainWindow%2A> in <xref:System.Windows.Navigation.NavigationWindow>umwandeln.  
>   
>  Diese Eigenschaft ist nur über den Thread verfügbar, der das <xref:System.Windows.Application>-Objekt erstellt hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie das Hauptanwendungsfenster suchen.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Application.MainWindow%2A> mithilfe von [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]festgelegt wird.  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Application.MainWindow%2A> während des Anwendungs Starts im Code instanziiert wird.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> wird von einer in einem Browser gehosteten Anwendung festgelegt, z. B. [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Inhalt, zu dem ein Navigator in der Anwendung navigiert, gefunden wurde. Dieses Ereignis ist über die -Eigenschaft verfügbar, auch wenn diese noch nicht vollständig geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn von einem Navigator in der Anwendung eine neue Navigation angefordert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Fehler auftritt, während ein Navigator in der Anwendung zum angeforderten Inhalt navigiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während eines von einem Navigator in der Anwendung verwalteten Downloads regelmäßig ein, um Informationen zum Navigationsfortschritt bereitzustellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see langword="StopLoading" />-Methode eines Navigators in der Anwendung aufgerufen wird oder wenn von einem Navigator eine neue Navigation angefordert wird, während eine aktuelle Navigation noch ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder eine <xref:System.Windows.Navigation.NavigationWindow> oder eine <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Activated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnActivated%2A> wird das <xref:System.Windows.Application.Activated>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnActivated%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnActivated%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.Activated> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Deactivated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnDeactivated%2A> wird das <xref:System.Windows.Application.Deactivated>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnDeactivated%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnDeactivated%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.Deactivated> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.ExitEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Exit" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnExit%2A> wird das <xref:System.Windows.Application.Exit>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet wird, kann die <xref:System.Windows.Application.OnExit%2A>-Methode überschreiben. Die überschriebene Methode muss <xref:System.Windows.Application.OnExit%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.Exit> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.FragmentNavigation" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnFragmentNavigation%2A> wird das <xref:System.Windows.Application.FragmentNavigation>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnFragmentNavigation%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnFragmentNavigation%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.FragmentNavigation> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.LoadCompleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnLoadCompleted%2A> wird das <xref:System.Windows.Application.LoadCompleted>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnLoadCompleted%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnLoadCompleted%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.LoadCompleted> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Navigated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigated%2A> wird das <xref:System.Windows.Application.Navigated>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnNavigated%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnNavigated%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.Navigated> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Navigating" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigating%2A> wird das <xref:System.Windows.Application.Navigating>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnNavigating%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnNavigating%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.Navigating> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.NavigationFailed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigationFailed%2A> wird das <xref:System.Windows.Application.NavigationFailed>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnNavigationFailed%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnNavigationFailed%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.NavigationFailed> ausgelöst werden muss.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.NavigationProgress" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigationProgress%2A> wird das <xref:System.Windows.Application.NavigationProgress>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnNavigationProgress%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnNavigationProgress%2A> in der Basisklasse explizit aufruft, wenn <xref:System.Windows.Application.NavigationProgress> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.NavigationStopped" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigationStopped%2A> wird das <xref:System.Windows.Application.NavigationStopped>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnNavigationStopped%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnNavigationStopped%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.NavigationStopped> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.SessionEndingCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.SessionEnding" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnSessionEnding%2A> wird das <xref:System.Windows.Application.SessionEnding>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnSessionEnding%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnSessionEnding%2A> in der Basisklasse aufzurufen, wenn <xref:System.Windows.Application.SessionEnding> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.StartupEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Startup" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnStartup%2A> wird das <xref:System.Windows.Application.Startup>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Application> abgeleitet ist, kann <xref:System.Windows.Application.OnStartup%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Application.OnStartup%2A> in der Basisklasse aufgerufen werden, wenn das <xref:System.Windows.Application.Startup> Ereignis ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Eigenschaften für den Anwendungsbereich ab.</summary>
        <value>Ein <see cref="T:System.Collections.IDictionary" />, das die Eigenschaftswert für den Anwendungsbereich enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> macht ein Wörterbuch über <xref:System.Windows.Application.Properties%2A> verfügbar, das Sie zum Speichern von Eigenschaften des Anwendungsbereichs verwenden können. Dies ermöglicht es Ihnen, den Status für den gesamten Code in einem <xref:System.AppDomain> Thread sicher zu teilen, ohne eigenen Zustands Code schreiben zu müssen.  
  
 In <xref:System.Windows.Application.Properties%2A> gespeicherte Eigenschaften müssen in den entsprechenden Typ konvertiert werden, der zurückgegeben wird.  
  
 Die <xref:System.Windows.Application.Properties%2A>-Eigenschaft ist Thread sicher und ist in jedem Thread verfügbar.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Eigenschaft des Anwendungsbereichs mithilfe von <xref:System.Windows.Application.Properties%2A>erstellt und verwendet wird.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.Assembly" /> ab, die die Paket-URIs (Uniform Resource Identifier) für Ressourcen in einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Anwendung bereitstellt, oder legt diese fest.</summary>
        <value>Ein Verweis auf den <see cref="T:System.Reflection.Assembly" />, der die Paket-URIs (Uniform Resource Identifier) für Ressourcen in einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung bereitstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig werden [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Ressourcen zur Laufzeit in Bezug auf die Eintragsassembly aufgelöst, die durch den Wert identifiziert wird, der von der <xref:System.Reflection.Assembly.GetEntryAssembly%2A>-Methode zurückgegeben wird.  
  
 Die Eintragsassembly ist die Assembly, die von <xref:System.Reflection.Assembly.GetEntryAssembly%2A> zurückgegeben wird, und könnte wie folgt lauten:  
  
-   Die ausführbare Assembly in der Standard Anwendungsdomäne.  
  
-   Die erste Assembly, die ausgeführt werden soll, indem <xref:System.AppDomain.ExecuteAssembly%2A>aufgerufen wird.  
  
 In den folgenden Fällen kann eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly jedoch keinen Verweis auf die Eintragsassembly erhalten:  
  
-   Eine nicht verwaltete (Native) Anwendung hostet die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Assembly.  
  
-   Eine verwaltete Anwendung hostet die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly, indem Sie Sie mit einer anderen Methode als <xref:System.AppDomain.ExecuteAssembly%2A>in eine neue Anwendungsdomäne lädt.  
  
 In beiden Fällen gibt <xref:System.Reflection.Assembly.GetEntryAssembly%2A> `null`zurück, und die Ressourcen der [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly können nicht aufgelöst werden. In diesen Fällen können <xref:System.Windows.Application.ResourceAssembly%2A> nur einmal festgelegt werden, mit einem Verweis auf die Assembly, die zum Auflösen von Ressourcen verwendet werden soll.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> können nur einmal festgelegt werden, da es unwahrscheinlich ist, dass sich die Ressourcenassembly ändert, nachdem die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly geladen wurde.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> kann nicht festgelegt werden, wenn eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly die Eintragsassembly ermitteln kann, d. h., wenn <xref:System.Reflection.Assembly.GetEntryAssembly%2A> einen Verweis auf eine Assembly zurückgibt, anstatt `null`.  
  
 Diese Eigenschaft ist Thread sicher und ist in jedem Thread verfügbar.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> wird in .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Anwendung verfügt über eine Eintragsassembly, oder <see cref="P:System.Windows.Application.ResourceAssembly" /> wurde bereits festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Ressourcen für den Anwendungsbereich fest, z. B. Formate und Pinsel, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.ResourceDictionary" />-Objekt, das 0 (null) oder mehr Ressourcen für den Anwendungsbereich enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Application.Resources%2A>-Eigenschaft kann verwendet werden, um Ressourcen in den Fenstern und Elementen einer Anwendung gemeinsam zu nutzen. Außerdem ist die <xref:System.Windows.Application.Resources%2A>-Eigenschaft im Ressourcen Suchpfad enthalten, der in der folgenden Reihenfolge durchlaufen wird:  
  
1.  Elements  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  System  
  
 Folglich können [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Elemente an Ressourcen im Anwendungsbereich gebunden werden. Wenn sich Ressourcen ändern, stellt das Ressourcensystem zudem sicher, dass die an diese Ressourcen gebundenen Element Eigenschaften automatisch aktualisiert werden, um die Änderung widerzuspiegeln.  
  
 Ressourcen im Anwendungsbereich stellen eine einfache Möglichkeit dar, ein konsistentes Design in der gesamten Anwendung zu unterstützen. Sie können problemlos ein Design in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] erstellen, indem Sie das `Application.Resources`-Tag verwenden. Wenn Ihre Anwendung jedoch mehrere Designs unterstützt, die möglicherweise eine große Anzahl von Designelementen enthalten, ist es möglicherweise einfacher, Sie mit einer <xref:System.Windows.ResourceDictionary>-Instanz für jedes Design zu verwalten. Auf diese Weise kann ein neues Design angewendet werden, indem die Resources-Eigenschaft auf die entsprechende <xref:System.Windows.ResourceDictionary>festgelegt wird.  
  
 Bei der Verwendung von <xref:System.Windows.Application.Resources%2A>müssen zwei Aspekte berücksichtigt werden. Zuerst ist der Wörterbuch *Schlüssel* ein Objekt, sodass Sie genau dieselbe Objektinstanz verwenden müssen, wenn Sie einen Eigenschafts Wert festlegen und erhalten (Beachten Sie, dass beim Verwenden einer Zeichenfolge bei der Taste die Groß-/Kleinschreibung beachtet wird). Zweitens ist der Wörterbuch *Wert* ein Objekt, sodass Sie den Wert in den gewünschten Typ konvertieren müssen, wenn Sie einen Eigenschafts Wert erhalten.  
  
 <xref:System.Windows.Application.Resources%2A> ist Thread sicher und in jedem Thread verfügbar.  
  
   
  
## Examples  
In diesem Beispiel wird veranschaulicht, wie XAML mit Ressourcen im Anwendungsbereich verwendet wird, um eine konsistente visuelle Darstellung zu erstellen. Das erste Beispiel ist die Datei *app. XAML*; die zweite, von " *MainWindow. XAML*". 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 Im folgenden Beispiel wird gezeigt, wie eine Anwendungs Ressource im Code und in XAML (in der Datei "App. XAML C# " in einem WPF-Projekt oder in der Datei "Application. XAML" in einem Visual Basic WPF-Projekts) festgelegt wird.  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Anwendungs Ressource im Code erhalten.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet eine Windows Presentation Foundation-Anwendung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet eine Windows Presentation Foundation-Anwendung.</summary>
        <returns>Der Exitcode der <see cref="T:System.Int32" />-Anwendung, der beim Herunterfahren der Anwendung an das Betriebssystem zurückgegeben wird. In der Standardeinstellung ist der Exitcode 0 (null).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> wird aufgerufen, um eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Anwendung zu starten. Wenn Sie die <xref:System.Windows.Application> mit Markup oder Markup und Code Behind definieren, wird <xref:System.Windows.Application.Run%2A> implizit aufgerufen. Wenn Sie jedoch die <xref:System.Windows.Application> mit Code definieren, müssen Sie <xref:System.Windows.Application.Run%2A>explizit aufzurufen.  
  
 Wenn <xref:System.Windows.Application.Run%2A> aufgerufen wird, fügt <xref:System.Windows.Application> eine neue <xref:System.Windows.Threading.Dispatcher> Instanz an den UI-Thread an. Als nächstes wird die <xref:System.Windows.Threading.Dispatcher.Run%2A>-Methode des <xref:System.Windows.Threading.Dispatcher> Objekts aufgerufen, die ein nachrichtenpump startet, um Windows-Meldungen zu verarbeiten. Zum Schluss ruft das <xref:System.Windows.Threading.Dispatcher> Objekt die <xref:System.Windows.Application.OnStartup%2A>-Methode des <xref:System.Windows.Application>-Objekts auf, um das <xref:System.Windows.Application.Startup> Ereignis aufzurufen. Folglich wurde das Anwendungs Ausführungs Modell von dem Zeitpunkt festgelegt, zu dem Sie <xref:System.Windows.Application.Startup>verarbeitet haben. zu diesem Zeitpunkt wird die Anwendung als ausgeführt betrachtet.  
  
 Die Ausführung einer Anwendung wird beendet, wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird. der Wert der <xref:System.Windows.Application.ShutdownMode%2A>-Eigenschaft bestimmt, wann <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird und ob er automatisch erfolgt oder explizit aufgerufen werden muss.  
  
 <xref:System.Windows.Application.Run%2A> können nur aus dem Thread aufgerufen werden, der das <xref:System.Windows.Application>-Objekt erstellt. Außerdem kann <xref:System.Windows.Application.Run%2A> nicht von einem [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]aufgerufen werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Anwendung, die eine benutzerdefinierte <xref:System.Windows.Application> verwendet und daher explizit <xref:System.Windows.Application.Run%2A>aufruft.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> wird von einer im Browser gehosteten Anwendung (z. B. einem [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) aufgerufen.</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">Ein <see cref="T:System.Windows.Window" />, das beim Start einer Anwendung automatisch geöffnet wird.</param>
        <summary>Startet eine Windows Presentation Foundation-Anwendung und öffnet das angegebene Fenster.</summary>
        <returns>Der Exitcode der <see cref="T:System.Int32" />-Anwendung, der beim Herunterfahren der Anwendung an das Betriebssystem zurückgegeben wird. In der Standardeinstellung ist der Exitcode 0 (null).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erweitert die <xref:System.Windows.Application.Run%2A>-Methode, um das angegebene Fenster zu öffnen, nachdem eine Anwendung gestartet wurde.  
  
 Wenn Sie einen Code <xref:System.Windows.Application> definieren, der ein Fenster öffnet, wenn er gestartet wird, werden Sie explizit <xref:System.Windows.Application.Run%2A>aufgerufen.  
  
 Wenn Sie die <xref:System.Windows.Application> mit Markup oder Markup und Code Behind erstellen, können Sie mit einer der folgenden Techniken automatisch ein Fenster öffnen:  
  
-   Deklarativ durch Festlegen von <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Programm gesteuert, durch die Behandlung von <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Anwendung mit einer manuell erstellten statischen Einstiegspunkt Methode, die <xref:System.Windows.Application>instanziiert, bevor <xref:System.Windows.Application.Run%2A>aufgerufen wird.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> wird von einer im Browser gehosteten Anwendung (z. B. einem [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) aufgerufen.</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer die Windows-Sitzung beendet, indem er sich abmeldet oder das Betriebssystem herunterfährt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird eine Anwendung heruntergefahren, wenn die Windows-Sitzung beendet wird. Dies geschieht, wenn ein Benutzer sich abmeldet oder herunterfährt. Wenn dies der Fall ist, fordert Windows an, dass jede geöffnete Anwendung heruntergefahren wird. Es ist jedoch möglich, dass eine Anwendung möglicherweise nicht zum Herunterfahren bereit ist, wenn dies auftritt. Beispielsweise kann eine Anwendung Daten aufweisen, die sich in einem inkonsistenten Zustand befinden, oder mitten in einem Vorgang mit langer Laufzeit. In diesen Fällen kann es wünschenswert sein, die Beendigung der Sitzung zu verhindern, und es kann wünschenswert sein, Benutzern die Möglichkeit zu geben, die Sitzung zu beenden.  
  
 Sie können erkennen, wenn eine Sitzung beendet wird, indem Sie das <xref:System.Windows.Application.SessionEnding>-Ereignis behandeln. Wenn eine Anwendung verhindern soll, dass die Sitzung beendet wird, macht das <xref:System.Windows.SessionEndingCancelEventArgs> Argument, das an den Ereignishandler übermittelt wird, den <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> verfügbar, den Sie auf `true` festgelegt haben (der Standardwert ist `false`).  
  
 Wenn <xref:System.Windows.Application.SessionEnding> nicht behandelt wird oder ohne Abbruch verarbeitet wird, wird <xref:System.Windows.Application.Shutdown%2A> aufgerufen, und das <xref:System.Windows.Application.Exit>-Ereignis wird ausgelöst.  
  
 Um weitere Informationen dazu zu erhalten, warum die Sitzung beendet wird, kann eine Anwendung <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>untersuchen, wobei es sich um einen der <xref:System.Windows.ReasonSessionEnding> Werte (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> und <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>) handelt.  
  
 <xref:System.Windows.Application.SessionEnding> wird nicht von Konsolen Anwendungen ausgelöst.  
  
 <xref:System.Windows.Application.SessionEnding> wird nur auf dem Thread ausgelöst, der das <xref:System.Windows.Application>-Objekt erstellt.  
  
 <xref:System.Windows.Application.SessionEnding> wird für XAML-Browser Anwendungen (XBAPs) nicht ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das <xref:System.Windows.Application.SessionEnding>-Ereignis behandelt wird und der Benutzer das Abbrechen kann.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">Der <see cref="T:System.Uri" />, der den Speicherort angibt, für den das Cookie erstellt werden soll.</param>
        <param name="value">Der <see cref="T:System.String" />, der die Cookiedaten enthält.</param>
        <summary>Erstellt ein Cookie für den von einem <see cref="T:System.Uri" /> angegebenen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cookie ist ein beliebiges Datenelement, das von einer Anwendung auf dem Client Computer während Anwendungs Sitzungen (Sitzungs Cookies) oder Anwendungs übergreifend (persistente Cookies) gespeichert werden kann. Sie können beide Arten von Cookies erstellen, indem Sie <xref:System.Windows.Application.SetCookie%2A>aufrufen.  
  
 Cookie-Daten haben in der Regel die Form eines Name-Wert-Paars im folgenden Format:  
  
 `Name=Value`  
  
 Sie übergeben eine Zeichenfolge dieses Formats an <xref:System.Windows.Application.SetCookie%2A>zusammen mit der <xref:System.Uri> des Speicher Orts, für den das Cookie festgelegt werden soll (in der Regel die Anwendungsdomäne).  
  
 Ob ein Cookie ein Sitzungs Cookie oder ein dauerhaftes Cookie ist, hängt davon ab, ob die Cookie-Zeichenfolge, die Sie an <xref:System.Windows.Application.SetCookie%2A> übergeben, ein Ablaufdatum enthält. Die Zeichenfolge für ein Sitzungs Cookie enthält kein Ablaufdatum. Die Zeichenfolge für ein dauerhaftes Cookie hat den Wert und muss das folgende Format aufweisen:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Persistente Cookies werden im temporären Internet Dateien Ordner der aktuellen [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] Installation gespeichert, bis Sie ablaufen. in diesem Fall werden Sie gelöscht. Sie können ein dauerhaftes Cookie aus Ihrer Anwendung löschen, indem Sie das Ablaufdatum auf einen Datums-/Uhrzeitwert festlegen, der in der Vergangenheit liegt.  
  
 Eine Übersicht über Cookies in [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]finden Sie unter [Übersicht](~/docs/framework/wpf/app-development/navigation-overview.md)über die Navigation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wenn beim Erstellen des angegebenen Cookies ein Problem auftritt, wird von der <see langword="InternetSetCookie" />-Funktion (aufgerufen durch <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) ein [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]-Fehler ausgelöst.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum erhalten des Cookies für eine dateibasierte <see cref="T:System.Uri" />. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">zum erhalten des Cookies für eine nicht dateibasierte <see cref="T:System.Uri" />. Zugehörige Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fährt eine Anwendung herunter.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fährt eine Anwendung herunter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, wird die Ausführung einer Anwendung beendet. Sie können das <xref:System.Windows.Application.Exit>-Ereignis behandeln, um zu erkennen, wann eine Anwendung nicht mehr ausgeführt wird, um eine geeignete Verarbeitung auszuführen.  
  
 <xref:System.Windows.Application.Shutdown%2A> wird in den folgenden Situationen implizit durch Windows Presentation Foundation aufgerufen:  
  
-   Wenn <xref:System.Windows.Application.ShutdownMode%2A> auf <xref:System.Windows.ShutdownMode.OnLastWindowClose>festgelegt ist.  
  
-   Wenn die <xref:System.Windows.Application.ShutdownMode%2A> auf <xref:System.Windows.ShutdownMode.OnMainWindowClose>festgelegt ist.  
  
-   Wenn ein Benutzer eine Sitzung beendet und das <xref:System.Windows.Application.SessionEnding> Ereignis entweder nicht behandelt oder ohne Abbruch verarbeitet wird.  
  
 Das Aufrufen von <xref:System.Windows.Application.Shutdown%2A> bewirkt, dass eine Anwendung unabhängig von der <xref:System.Windows.Application.ShutdownMode%2A> Einstellung heruntergefahren wird. Wenn <xref:System.Windows.Application.ShutdownMode%2A> jedoch auf <xref:System.Windows.ShutdownMode.OnExplicitShutdown>festgelegt ist, müssen Sie <xref:System.Windows.Application.Shutdown%2A> zum Herunterfahren einer Anwendung aufzurufen.  
  
> [!IMPORTANT]
>  Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, wird die Anwendung unabhängig davon heruntergefahren, ob das <xref:System.Windows.Window.Closing>-Ereignis eines geöffneten Windows abgebrochen wird.  
  
 Diese Methode kann nur aus dem Thread aufgerufen werden, der das <xref:System.Windows.Application> Objekt erstellt hat.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zur Verwendung aller Windows-und Benutzereingabe Ereignisse ohne Einschränkung. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Ein ganzzahliger Exitcode für eine Anwendung. Der Standardexitcode ist 0 (null).</param>
        <summary>Fährt eine Anwendung herunter, die den angegebenen Exitcode an das Betriebssystem zurückgibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können das <xref:System.Windows.Application.Exit>-Ereignis behandeln, um einen Exitcode festzulegen. Wenn Sie <xref:System.Windows.Application.Shutdown%2A>jedoch explizit aufzurufen und <xref:System.Windows.Application.Exit> nur zum Festlegen eines Exitcodes verwenden, können Sie stattdessen <xref:System.Windows.Application.Shutdown%2A> abrufen.  
  
 Diese Methode kann nur aus dem Thread aufgerufen werden, der das <xref:System.Windows.Application> Objekt erstellt hat.  
  
 Informationen zu Exitcodes finden Sie unter <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType>.
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zur Verwendung aller Windows-und Benutzereingabe Ereignisse ohne Einschränkung. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bedingung ab, unter der die <see cref="M:System.Windows.Application.Shutdown" />-Methode aufgerufen wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.ShutdownMode" />-Enumerationswert. Der Standardwert ist <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen werden nicht mehr ausgeführt, wenn die <xref:System.Windows.Application.Shutdown%2A>-Methode der Anwendung aufgerufen wird. Das Herunterfahren kann implizit oder explizit erfolgen, wie durch den Wert der <xref:System.Windows.Application.ShutdownMode%2A>-Eigenschaft angegeben.  
  
 Wenn Sie <xref:System.Windows.Application.ShutdownMode%2A> auf <xref:System.Windows.ShutdownMode.OnLastWindowClose>festlegen, wird von Windows Presentation Foundation (WPF) implizit <xref:System.Windows.Application.Shutdown%2A> aufgerufen, wenn das letzte Fenster in einer Anwendung geschlossen wird. Dies ist auch dann der Fall, wenn derzeit instanziierte Fenster als Hauptfenster festgelegt werden (siehe <xref:System.Windows.Application.MainWindow%2A>).  
  
 Eine <xref:System.Windows.Application.ShutdownMode%2A> <xref:System.Windows.ShutdownMode.OnMainWindowClose> bewirkt, dass WPF implizit <xref:System.Windows.Application.Shutdown%2A> aufruft, wenn das <xref:System.Windows.Application.MainWindow%2A> geschlossen wird, auch wenn andere Fenster momentan geöffnet sind.  
  
 Die Lebensdauer einiger Anwendungen hängt möglicherweise nicht davon ab, wenn das Hauptfenster oder das letzte Fenster geschlossen wird, oder Sie ist möglicherweise nicht von Windows abhängig. In diesen Szenarien müssen Sie die <xref:System.Windows.Application.ShutdownMode%2A>-Eigenschaft auf <xref:System.Windows.ShutdownMode.OnExplicitShutdown>festlegen, was einen expliziten <xref:System.Windows.Application.Shutdown%2A>-Methoden Aufrufes erfordert, um die Anwendung zu beenden. Andernfalls wird die Anwendung weiter im Hintergrund ausgeführt.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> können von [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] deklarativ oder Programm gesteuert aus dem Code konfiguriert werden.  
  
 Diese Eigenschaft ist nur über den Thread verfügbar, der das <xref:System.Windows.Application>-Objekt erstellt hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Application.ShutdownMode%2A> konfiguriert werden, um anzugeben, dass eine Anwendung explizit geschlossen werden muss.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die <see cref="M:System.Windows.Application.Run" />-Methode des <see cref="T:System.Windows.Application" />-Objekts aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine typische Windows Presentation Foundation Anwendung kann beim Start eine Reihe von Initialisierungs Aufgaben ausführen, einschließlich:  
  
-   Verarbeiten von Befehlszeilen Parametern.  
  
-   Das Hauptfenster wird geöffnet.  
  
-   Ressourcen für den Anwendungsbereich werden initialisiert.  
  
-   Die Eigenschaften des Anwendungsbereichs werden initialisiert.  
  
 Sie können die Haupt-und Anwendungsbereichs Ressourcen deklarativ mithilfe [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> bzw. <xref:System.Windows.Application.Resources%2A>) angeben. Manchmal können die Ressourcen oder das Hauptfenster der Anwendung jedoch nur Programm gesteuert zur Laufzeit bestimmt werden. Darüber hinaus können Anwendungsbereichs Eigenschaften und Befehlszeilenparameter nur Programm gesteuert verwendet werden. Die programmgesteuerte Initialisierung kann ausgeführt werden, indem Sie das <xref:System.Windows.Application.Startup>-Ereignis behandeln, einschließlich der folgenden:  
  
-   Abrufen und Verarbeiten von Befehlszeilen Parametern, die über die <xref:System.Windows.StartupEventArgs.Args%2A>-Eigenschaft der <xref:System.Windows.StartupEventArgs>-Klasse verfügbar sind, die an den <xref:System.Windows.Application.Startup>-Ereignishandler übermittelt wird.  
  
-   Initialisieren Sie Ressourcen im Anwendungsbereich mithilfe der <xref:System.Windows.Application.Resources%2A>-Eigenschaft.  
  
-   Initialisieren Sie die Eigenschaften des Anwendungsbereichs mithilfe der <xref:System.Windows.Application.Properties%2A>-Eigenschaft.  
  
-   Instanziieren Sie ein (oder mehrere) Fenster, und zeigen Sie es an.  
  
> [!NOTE]
>  Befehlszeilenparameter können auch durch Aufrufen der statischen <xref:System.Environment.GetCommandLineArgs%2A>-Methode des <xref:System.Environment>-Objekts abgerufen werden. Allerdings ist <xref:System.Environment.GetCommandLineArgs%2A> für die Ausführung volle Vertrauenswürdigkeit erforderlich.  
  
 Wenn Sie <xref:System.Windows.Application.StartupUri%2A> mithilfe von [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]festlegen, ist das erstellte Hauptfenster weder in der <xref:System.Windows.Application.MainWindow%2A>-Eigenschaft noch in der <xref:System.Windows.Application.Windows%2A>-Eigenschaft des <xref:System.Windows.Application> Objekts verfügbar, bis das <xref:System.Windows.Application.Startup> Ereignis verarbeitet wurde. Wenn Sie während des Starts auf das Hauptfenster zugreifen müssen, müssen Sie manuell ein neues Fenster Objekt aus dem <xref:System.Windows.Application.Startup>-Ereignishandler erstellen.  
  
> [!NOTE]
>  Wenn Ihre Anwendung <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> verwendet, um eine Richtlinie für Anmelde Informationen anzugeben, müssen Sie <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> festlegen, nachdem <xref:System.Windows.Application.Startup> ausgelöst wurde. Andernfalls wird [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] direkt nach dem ausgelöst des <xref:System.Windows.Application.Startup> Ereignisses auf eine interne Standard Richtlinie festgelegt.  
  
 Die Befehlszeilenargumente, die an den <xref:System.Windows.Application.Startup>-Ereignishandler übermittelt werden, stimmen nicht mit den [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] Abfrage Zeichenfolgen-Parametern überein, die an eine [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]übermittelt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Befehlszeilenoptionen aus einer eigenständigen Anwendung abgerufen und verarbeitet werden. Wenn der **/StartMinimized** -Befehlszeilenparameter angegeben wurde, öffnet die Anwendung das Hauptfenster in einem minimierten Zustand.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] können keine Befehlszeilenargumente abrufen und verarbeiten, da Sie mit [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] Bereitstellung gestartet werden (siehe bereitstellen [einer WPF-Anwendung (](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)WPF)). Von den zum Starten verwendeten URLs können jedoch Abfragezeichenfolgenparameter abgerufen und verarbeitet werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Benutzeroberfläche ab, die automatisch angezeigt wird, wenn die Anwendung startet, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Uri" />, die sich auf die Benutzeroberfläche bezieht, die beim Start einer Anwendung automatisch geöffnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können <xref:System.Windows.Application.StartupUri%2A> verwenden, um beim Starten einer Anwendung automatisch eine UI-Ressource zu laden.  
  
 In der folgenden Tabelle werden die Typen von UI-Ressourcen, die geladen werden können, der Typ des Fensters, in dem Sie geöffnet werden, und der Anwendungstyp angezeigt, der als <xref:System.Windows.Application.StartupUri%2A>festgelegt werden kann.  
  
|Typ|Fenster|Anwendungstyp|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Nur eigenständig|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Nur eigenständig|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständig/Browser gehostet|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständig/Browser gehostet|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständig/Browser gehostet|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständig/Browser gehostet|  
  
 In der Regel legen Sie die <xref:System.Windows.Application.StartupUri%2A>-Eigenschaft in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]deklarativ fest. Sie können <xref:System.Windows.Application.StartupUri%2A> jedoch Programm gesteuert festlegen, z. b. von einem <xref:System.Windows.Application.Startup>-Ereignishandler, der bei Anwendungen nützlich ist, die nur die erforderlichen UI-Ressourcen zur Laufzeit laden können. Beispielsweise kann eine Anwendung bis zur Laufzeit warten, um Ihre Ressourcen zu laden, wenn der Name der UI-Ressource in einer Konfigurationsdatei gespeichert ist.  
  
 Unabhängig davon, ob Sie <xref:System.Windows.Application.StartupUri%2A> deklarativ oder Programm gesteuert festlegen, wird die entsprechende UI-Ressource erst geladen, nachdem das <xref:System.Windows.Application.Startup>-Ereignis behandelt wurde. Folglich haben Sie bei der Behandlung von <xref:System.Windows.Application.Startup>keinen Zugriff auf das resultierende Fenster entweder über die <xref:System.Windows.Application.Windows%2A>-Eigenschaft oder die <xref:System.Windows.Application.MainWindow%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> wird auf den Wert NULL festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Fragt ab, ob eine angegebene Ambiente-Eigenschaft im aktuellen Bereich verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die angeforderte Ambient-Eigenschaft verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Application>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Name der zu suchenden Ressource.</param>
        <summary>Sucht die angegebene Ressource.</summary>
        <returns>Das angeforderte Ressourcenobjekt. Wenn die angeforderte Ressource nicht gefunden werden kann, wird ein NULL-Verweis zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> sucht zunächst in Ressourcen im Anwendungsbereich für die angegebene Ressource. Ressourcen im Anwendungsbereich werden von <xref:System.Windows.Application>verwaltet und über die <xref:System.Windows.Application.Resources%2A>-Eigenschaft verfügbar gemacht. Wenn die angegebene Ressource nicht im Satz von Ressourcen für den Anwendungsbereich gefunden wird, werden <xref:System.Windows.Application.TryFindResource%2A> dann als nächstes die Systemressourcen durchsucht. System Ressourcen sind vom benutzerdefinierte Shellressourcen und umfassen Farben, Schriftarten und Shellkonfigurationen. Diese werden von den Typen <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>und <xref:System.Windows.SystemParameters> als statische Eigenschaften verfügbar gemacht. Wenn Sie <xref:System.Windows.Application.TryFindResource%2A> verwenden möchten, um Sie abzurufen, machen diese Typen auch Ressourcen Schlüsseleigenschaften verfügbar, die an <xref:System.Windows.Application.TryFindResource%2A>übermittelt werden sollen. beispielsweise <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Da <xref:System.Windows.Application.TryFindResource%2A> ein Objekt zurückgibt, müssen Sie den zurückgegebenen Wert in den entsprechenden Typ umwandeln, wenn die Ressource gefunden wird.  
  
 Diese Methode ist Thread sicher und kann von jedem Thread aufgerufen werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Application.TryFindResource%2A> zum Abrufen einer Ressource verwendet wird.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die instanziierten Fenster in einer Anwendung ab.</summary>
        <value>Eine <see cref="T:System.Windows.WindowCollection" />, die Verweise auf alle Fensterobjekte in der aktuellen <see cref="T:System.AppDomain" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Windows%2A>, sobald ein Fenster auf dem [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Thread instanziiert wird, wird automatisch ein <xref:System.Windows.Window> Verweis hinzugefügt. Windows, die von Arbeitsthreads erstellt wurden, werden nicht hinzugefügt. Ein <xref:System.Windows.Window> Verweis wird automatisch entfernt, nachdem das <xref:System.Windows.Window.Closing>-Ereignis behandelt wurde und bevor das <xref:System.Windows.Window.Closed>-Ereignis ausgelöst wird.  
  
 Standardmäßig wird das erste Element, das der <xref:System.Windows.Application.Windows%2A>-Eigenschaft hinzugefügt wird, zur <xref:System.Windows.Application.MainWindow%2A>.  
  
 Diese Eigenschaft ist nur über den Thread verfügbar, der das <xref:System.Windows.Application>-Objekt erstellt hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die <xref:System.Windows.Application.Windows%2A>-Eigenschaft aufzählen, um ein Windows-Menü auf oberster Ebene zu erstellen, das häufig für die [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] von Anwendungen wie [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]oder Anwendungen mit einer einzelnen Dokument Schnittstelle (Single Document Interface, SDI) mit mehreren Instanzen wie [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)]dient.  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
