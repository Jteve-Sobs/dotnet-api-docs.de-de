<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fae2d9443188f70f27cb5e0236bd13a172e59602" /><Meta Name="ms.sourcegitcommit" Value="a9b8eb12d69b131f7c0de74d471798e44e863282" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/04/2019" /><Meta Name="ms.locfileid" Value="66502043" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Kapselt eine Windows Presentation Foundation-Anwendung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> ist eine Klasse, kapselt [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] programmspezifische Funktionen, einschließlich der folgenden:  
  
-   **Anwendungslebensdauer**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Anwendungsbereich-Fenster, Eigenschafts- und Ressourcenverwaltung**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Befehlszeilenparameter und Exit Code Verarbeitung**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implementiert das Singletonmuster verwenden, um den freigegebenen Zugriff auf die Fenster, Eigenschaft und Ressource Scope-Dienste bereitzustellen. Daher nur eine Instanz der <xref:System.Windows.Application> Klasse erstellt werden kann, pro <xref:System.AppDomain>.  
  
 Sie können die implementieren eine <xref:System.Windows.Application> mit Markup, Markup und Code-Behind oder Code. Wenn <xref:System.Windows.Application> mit Markup implementiert wird, ob die Markupdatei Markup oder Markup und CodeBehind, als konfiguriert werden muss ein [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` Element.  
  
> [!NOTE]
>  Eine eigenständige Anwendung erfordert kein <xref:System.Windows.Application> Objekt; es ist möglich, die Implementierung eines benutzerdefinierten `static` Einstiegspunktmethode (`Main`), die öffnet ein Fenster ohne eine Instanz des <xref:System.Windows.Application>. Allerdings [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] erfordern eine <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine standard-Anwendung ist nur mit Markup definiert:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 Das folgende Beispiel zeigt, wie eine standardanwendung mit definiert wird nur code:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 Das folgende Beispiel zeigt, wie eine standardanwendung mit einer Kombination aus Markup und CodeBehind definiert.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Die öffentliche <see langword="static" /> (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Darüber hinaus die <see cref="M:System.Windows.Application.FindResource(System.Object)" /> und <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> Methoden und die <see cref="P:System.Windows.Application.Properties" /> und <see cref="P:System.Windows.Application.Resources" /> Eigenschaften sind threadsicher.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Application" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur eine Instanz des der <xref:System.Windows.Application> Klasse erstellt werden kann, pro <xref:System.AppDomain>, um den freigegebenen Zugriff auf einen Satz von Anwendungsbereich für Fenster, Eigenschaft und Ressource Daten sicherzustellen. Daher der Standardkonstruktor des der <xref:System.Windows.Application> Klasse erkennt, ob die Instanz initialisiert wird die erste Instanz in eine <xref:System.AppDomain>; ist dies nicht der Fall, ein <xref:System.InvalidOperationException> ausgelöst.  
  
 Die <xref:System.Windows.Application> Objekt für die aktuelle <xref:System.AppDomain> wird verfügbar gemacht, von der statischen <xref:System.Windows.Application.Current%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Pro <see cref="T:System.Windows.Application" /> wird mehr als eine Instanz der <see cref="T:System.AppDomain" />-Klasse erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung als Vordergrundanwendung verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Windows Presentation Foundation-Anwendung, die eine oder mehrere geöffneten Fenstern aktiviert ist (wird die Anwendung im Vordergrund) Wenn eines der Fenster zum ersten Mal aktiviert wird, da die Anwendung gestartet wurde oder wenn eines der Fenster aktiviert wird während die Anwendung ist inaktiv: Aktivierung insbesondere tritt auf, wenn:  
  
-   Eine Anwendung wird das erste Fenster geöffnet.  
  
-   Ein Benutzer wechselt für die Anwendung mithilfe von ALT + TAB oder mithilfe des Task-Manager.  
  
-   Ein Benutzer klickt auf die Taskleistenschaltfläche für eines der Fenster in einer Anwendung.  
  
 Anwendungen, die erkennen, wenn sie aktivieren müssen, können behandeln die <xref:System.Windows.Application.Activated> Ereignis.  
  
 Nach eine Anwendung zuerst aktiviert wird, kann er deaktiviert und oft während seiner Lebensdauer erneut aktiviert werden. Wenn der Aktivierungszustand Verhalten oder der Zustand der Anwendung abhängt, kann er sowohl verarbeiten <xref:System.Windows.Application.Activated> und <xref:System.Windows.Application.Deactivated> Ereignisse, um zu bestimmen, welche aktuellen Aktivierungszustand des.  
  
 Sobald eine Anwendung aktiv ist, wird <xref:System.Windows.Application.Activated> wird nicht erneut ausgelöst wird, bis die Anwendung deaktiviert wird, unabhängig davon, wie viele Fenster in einer Anwendung aktiviert werden, während die Anwendung aktiv ist,.  
  
 <xref:System.Windows.Application.Activated> wird nicht ausgelöst werden, für die [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie erkennen, wenn eine eigenständige Anwendung aktiviert und deaktiviert wird.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Application" />-Objekt für die aktuelle <see cref="T:System.AppDomain" /> ab.</summary>
        <value>Das <see cref="T:System.Windows.Application" />-Objekt für die aktuelle <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> ist eine pro-<xref:System.AppDomain> Singletontyp, der die statische implementiert <xref:System.Windows.Application.Current%2A> Eigenschaft zu gemeinsamen Zugriff auf die <xref:System.Windows.Application> Instanz für die aktuelle <xref:System.AppDomain>. Dieser Entwurf garantiert, diesen Status, die von verwalteten <xref:System.Windows.Application>, einschließlich freigegebene Ressourcen und des Zustands, ist aus einem gemeinsamen Standort verfügbar.  
  
 Diese Eigenschaft ist threadsicher und von jedem Thread verfügbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung nicht mehr die Vordergrundanwendung ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Windows Presentation Foundation-Anwendung, die eine oder mehrere geöffnete Fenster deaktiviert (beendet die vordergrundanwendung) Wenn ein Benutzer Folgendes ausführt:  
  
-   Wechselt zu einer anderen Anwendung mit ALT + TAB oder mithilfe des Task-Manager.  
  
-   Klickt auf die Taskleistenschaltfläche für ein Fenster in einer anderen Anwendung.  
  
 Anwendungen, die zum Erkennen der Deaktivierung kann behandeln, müssen die <xref:System.Windows.Application.Deactivated> Ereignis.  
  
 Nach eine Anwendung zuerst aktiviert wird, kann er deaktiviert und oft während seiner Lebensdauer erneut aktiviert werden. Wenn der Aktivierungszustand Verhalten oder der Zustand der Anwendung abhängt, kann er sowohl verarbeiten <xref:System.Windows.Application.Deactivated> und <xref:System.Windows.Application.Activated> Ereignisse, um zu bestimmen, die mit dem Status der.  
  
 <xref:System.Windows.Application.Deactivated> wird nicht ausgelöst werden, für die [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie erkennen, wenn eine eigenständige Anwendung deaktiviert und aktiviert wird.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn durch eine Anwendung eine Ausnahme ausgelöst wird, die jedoch nicht behandelt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation in der Standardeinstellung nicht behandelte Ausnahmen abfängt, benachrichtigt Benutzer über die Ausnahme in einem Dialogfeld (aus dem sie die Ausnahme melden können) und eine Anwendung automatisch heruntergefahren wird.  
  
 Aber wenn eine Anwendung für die Ausführung von benutzerdefinierten Ausnahmefehler Verarbeitungsschritte an einem zentralen Ort muss, Sie sollten behandeln <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> wird ausgelöst, indem ein <xref:System.Windows.Application> für jede Ausnahme, die vom Code auf dem Hauptbenutzeroberflächen-Thread ausgeführt wird nicht behandelt wird.  
  
 Wenn eine Ausnahme nicht auf einen Hintergrund UI-Thread behandelt wird (ein Thread mit eigenem <xref:System.Windows.Threading.Dispatcher>) oder ein Arbeitsthread im Hintergrund (ein Thread ohne eine <xref:System.Windows.Threading.Dispatcher>), die Ausnahme wird nicht auf dem Hauptbenutzeroberflächen-Thread weitergeleitet. Folglich <xref:System.Windows.Application.DispatcherUnhandledException> wird nicht ausgelöst. In diesen Fällen müssen Sie Code schreiben, um die folgenden Schritte ausführen:  
  
1.  Behandeln von Ausnahmen im Hintergrundthread.  
  
2.  Diese Ausnahmen an den Hauptthread der Benutzeroberfläche zu senden.  
  
3.  Lösen Sie sie auf dem Hauptbenutzeroberflächen-Thread erneut, ohne sie zu zu behandeln <xref:System.Windows.Application.DispatcherUnhandledException> ausgelöst werden soll.  
  
 Weitere Informationen finden Sie unter den [Threading-Modell](~/docs/framework/wpf/advanced/threading-model.md) Übersicht.  
  
 Die <xref:System.Windows.Application.DispatcherUnhandledException> übergebene Ereignishandler wird ein <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> Argument, das Kontextinformationen für die Ausnahme enthält einschließlich:  
  
-   Die Ausnahme (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   Die <xref:System.Windows.Threading.Dispatcher> aus dem sie stammen (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Sie können diese Informationen verwenden, um zu bestimmen, ob eine Ausnahme oder nicht wiederherstellbar ist. Eine behebbare Ausnahme ist möglicherweise eine <xref:System.IO.FileNotFoundException>, z. B. während eine nicht behebbare Ausnahme ist ein <xref:System.StackOverflowException>, z. B.  
  
 Eine nicht behandelte Ausnahme beim Verarbeiten <xref:System.Windows.Application.DispatcherUnhandledException>, und Sie möchten nicht [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] weiter verarbeitet, müssen Sie festlegen der <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> Eigenschaft `true`.  
  
 Im Gegensatz zu den anderen Ereignissen, die <xref:System.Windows.Application> auslöst, <xref:System.Windows.Application.DispatcherUnhandledException> wird keine entsprechende geschützt haben virtuelle Implementierung (OnDispatcherUnhandledException). Folglich Klassen, die abgeleitet <xref:System.Windows.Application> müssen immer registrieren einen Ereignishandler mit <xref:System.Windows.Application.DispatcherUnhandledException> nicht behandelte Ausnahmen zu verarbeiten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die Verarbeitung nicht behandelter Ausnahmen durch Behandeln der <xref:System.Windows.Application.DispatcherUnhandledException> Ereignis.  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt kurz vor dem Herunterfahren einer Anwendung auf und kann nicht abgebrochen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann für eine der folgenden Gründe heruntergefahren:  
  
-   Die <xref:System.Windows.Application.Shutdown%2A> Methode der <xref:System.Windows.Application> Objekt aufgerufen wird, entweder explizit oder wie festgelegt durch die <xref:System.Windows.Application.ShutdownMode%2A> Eigenschaft.  
  
-   Der Benutzer beendet die Sitzung durch abmelden oder Herunterfahren.  
  
 Sie können erkennen, bei Beenden der Anwendung durch Behandeln der <xref:System.Windows.Application.Exit> -Ereignis, und führen Sie eine zusätzliche Verarbeitung nach Bedarf.  
  
 Sie können auch behandeln <xref:System.Windows.Application.Exit> zu überprüfen oder ändern Exitcode der Anwendung aus, wenn Sie nicht aufrufen müssen <xref:System.Windows.Application.Shutdown%2A> explizit. Der Exitcode wird verfügbar gemacht, von der <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> Eigenschaft der <xref:System.Windows.ExitEventArgs> Argument, das an die <xref:System.Windows.Application.Exit> -Ereignishandler. Wenn die Anwendung wird beendet, wird der Exitcode an das Betriebssystem zur weiteren Verarbeitung übergeben.  
  
 Wenn Ihre Anwendung die <xref:System.Windows.Application.SessionEnding> Ereignis und anschließend abbricht, <xref:System.Windows.Application.Exit> wird nicht ausgelöst, und die Anwendung wird weiter ausgeführt, die in Übereinstimmung mit dem Modus für das Herunterfahren.  
  
 Der Exitcode kann festgelegt werden, von einem [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], obwohl der Wert ignoriert wird.  
  
 Für [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> wird in den folgenden Umständen ausgelöst:  
  
-   Ein [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] weg navigiert wird.  
  
-   In [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], wenn die Registerkarte, die hostet die [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] geschlossen wird.  
  
-   Wenn der Browser geschlossen wird.  
  
 In allen Fällen den Wert des der <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> Eigenschaft wird ignoriert.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie:  
  
-   Behandeln der <xref:System.Windows.Application.Exit> Ereignis.  
  
-   Untersuchen und Aktualisieren der <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> Eigenschaft der <xref:System.Windows.ExitEventArgs>.  
  
-   Schreiben eines Eintrags in einem Anwendungsprotokoll in einem isolierten Speicher.  
  
-   Speichern Sie den Zustand der Anwendung in den isolierten Speicher.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Name der zu suchenden Ressource.</param>
        <summary>Sucht eine [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]-Ressource, z. B. einen <see cref="T:System.Windows.Style" /> oder einen <see cref="T:System.Windows.Media.Brush" /> mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird (siehe [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Das angeforderte Ressourcenobjekt. Wenn die angeforderte Ressource nicht gefunden werden kann, wird eine <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> sucht zuerst im Anwendungsbereich Ressourcen für die angegebene Ressource. Anwendungsbereich Ressourcen werden durch verwaltet <xref:System.Windows.Application>, und stehen zur Verfügung, aus der <xref:System.Windows.Application.Resources%2A> Eigenschaft. Wenn die angegebene Ressource nicht, in der Menge der Ressourcen für den Anwendungsbereich gefunden wird <xref:System.Windows.Application.FindResource%2A> dann weiter durchsucht die Systemressourcen. Systemressourcen Shellressourcen, die vom Benutzer definiert sind, und enthalten von Farben, Schriftarten und Shell-Konfigurationen. Diese werden verfügbar gemacht, von der <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, und <xref:System.Windows.SystemParameters> eingibt, als statische Eigenschaften. Verwendung von <xref:System.Windows.Application.FindResource%2A> um diese zu erhalten, diese Typen auch verfügbar machen Ressource Schlüsseleigenschaften, die entwickelt wurden, übergeben werden soll <xref:System.Windows.Application.FindResource%2A>, z. B. <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Da <xref:System.Windows.Application.FindResource%2A> ein Objekt zurückgibt, Sie müssen den Rückgabewert in den entsprechenden Typ umwandeln, wenn die Ressource gefunden wird.  
  
> [!IMPORTANT]
>  Wenn Sie diese Methode für einen Schlüssel, die nicht gefunden werden kann aufrufen, wird eine Ausnahme ausgelöst. Wenn Sie nicht möchten, um Ausnahmen zu behandeln, die aus aufrufen <xref:System.Windows.Application.FindResource%2A>, rufen Sie <xref:System.Windows.Application.TryFindResource%2A> stattdessen <xref:System.Windows.Application.TryFindResource%2A> gibt eine `null` verweisen auf, wenn eine angeforderte Ressource nicht gefunden werden, und keine Ausnahme löst.  
  
 Diese Methode ist threadsicher und kann von jedem Thread aufgerufen werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit <xref:System.Windows.Application.FindResource%2A> um eine Ressource zu suchen und behandeln <xref:System.Windows.ResourceReferenceKeyNotFoundException> , wenn die Ressource nicht gefunden wird.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Die Ressource kann nicht gefunden werden.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Navigator in der Anwendung mit der Navigation zu einem Inhaltsfragment beginnt. Die Navigation erfolgt sofort, wenn sich das gewünschte Fragment im aktuellen Inhalt befindet oder nachdem der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-Quellinhalt geladen wurde, sofern sich das gewünschte Fragment in einem anderen Inhalt befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Der relative <see cref="T:System.Uri" />, der einer freien Ressource zugeordnet wird.</param>
        <summary>Gibt einen Ressourcenstream für eine Inhaltsdatendatei zurück, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet (weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>Eine <see cref="T:System.Windows.Resources.StreamResourceInfo" /> mit einer Inhaltsdatendatei, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet. Wenn eine freie Ressource nicht gefunden wurde, wird NULL zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> ist ein absoluter <see cref="T:System.Uri" />.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Der <see cref="T:System.Uri" />, der den Speicherort angibt, für den ein Cookie erstellt wurde.</param>
        <summary>Ruft ein Cookie für den von einem <see cref="T:System.Uri" /> angegebenen Speicherort ab.</summary>
        <returns>Ein <see cref="T:System.String" />-Wert, wenn das Cookie vorhanden ist, andernfalls wird eine <see cref="T:System.ComponentModel.Win32Exception" /> ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> Ruft ein Cookie für den angegebenen <xref:System.Uri>. Wenn das Cookie kann nicht abgerufen werden, eine <xref:System.ComponentModel.Win32Exception> ausgelöst. Sie müssen den Code, um die Cookiezeichenfolge in eine Liste von Name/Wert-Paare analysieren zu schreiben.  
  
 Eine Übersicht über Cookies in [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], finden Sie unter [Übersicht über die Navigation](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wenn beim Abrufen des angegebenen Cookies ein Problem auftritt, wird von der <see langword="InternetGetCookie" />-Funktion (aufgerufen durch <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) ein [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]-Fehler ausgelöst.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Abrufen der Cookies für eine dateibasierte <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">zum Abrufen der Cookies für eine nicht-dateibasierte <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">Der <see cref="T:System.Uri" />, der einer freien Ressource auf der Ursprungssite zugeordnet wird.</param>
        <summary>Gibt einen Ressourcenstream für eine Ursprungssite-Datendatei zurück, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet (weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>Eine <see cref="T:System.Windows.Resources.StreamResourceInfo" /> mit einem Ressourcenstream für eine Ursprungssite-Datendatei, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet. Wenn die freie Ressource nicht gefunden wurde, wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> ist nicht relativ oder ist absolut, aber nicht im Format <c>pack://siteoforigin:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">Der <see cref="T:System.Uri" />, der einer eingebetteten Ressource zugeordnet wird.</param>
        <summary>Gibt einen Ressourcenstream für eine Ressourcendatendatei zurück, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet (weitere Informationen finden Sie unter [WPF-Anwendungsressource, Inhalts- und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns>Eine <see cref="T:System.Windows.Resources.StreamResourceInfo" /> mit einem Ressourcenstream für eine Ressourcendatendatei, die sich unter dem angegebenen <see cref="T:System.Uri" /> befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> ist nicht relativ oder ist absolut, aber nicht im Format <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">Der an <see cref="T:System.Uri" /> übergebene <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> kann nicht gefunden werden.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Inhalt, zu dem ein Navigator in der Anwendung navigiert ist, geladen und analysiert und mit dem Rendering begonnen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Überwachen Sie Ereignisse auf dem Inhalt navigiert wie z. B. die <xref:System.Windows.FrameworkElement.Loaded> Ereignis auf <xref:System.Windows.Controls.Page> , bevor Sie Zugriff auf Eigenschaften des Inhalts navigiert.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei, die sich unter dem angegebenen [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Datei kann eine Anwendungscodedatei werden (konfiguriert als ein [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Element "Page") oder einer Anwendungsdatendatei (eine Ressourcendatei, Inhaltsdatei oder Ursprungssite Ausgabekonfigurationsdatei finden Sie unter [WPF-Anwendungsressource, Inhalt und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Diese Methode ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">Ein <see cref="T:System.Uri" />, der einer relativen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei zugeordnet ist.</param>
        <summary>Lädt eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei, die sich unter dem angegebenen [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] befindet, und konvertiert diese in eine Instanz des vom Stammelement der [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei angegebenen Objekts.</summary>
        <returns>Eine Instanz des Stammelements, das durch die geladene XAML-Datei angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Rückgabewert müssen explizit in den gleichen Typ wie das Stammelement des konvertiert die [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] Datei.  
  
 Die [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Datei kann eine Anwendungscodedatei werden (konfiguriert als ein [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Element "Page") oder einer Anwendungsdatendatei (eine Ressourcendatei, Inhaltsdatei oder Ursprungssite Ausgabekonfigurationsdatei finden Sie unter [WPF-Anwendungsressource, Inhalt und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Diese Methode ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="resourceLocator" /> ist ein absoluter [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Die Datei ist keine [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-Datei.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Ein Objekt des gleichen Typs wie das Stammelement der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei.</param>
        <param name="resourceLocator">Ein <see cref="T:System.Uri" />, der einer relativen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei zugeordnet ist.</param>
        <summary>Lädt eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei, die sich unter dem angegebenen [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] befindet, und konvertiert sie in eine Instanz des Objekts, das durch das Stammelement der [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]-Datei angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Datei kann eine Anwendungscodedatei werden (konfiguriert als ein [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Element "Page") oder einer Anwendungsdatendatei (eine Ressourcendatei, Inhaltsdatei oder Ursprungssite Ausgabekonfigurationsdatei finden Sie unter [WPF-Anwendungsressource, Inhalt und Datendateien](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Diese Methode ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="resourceLocator" /> ist ein absoluter [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception"><paramref name="component" /> ist ein Typ, der nicht dem Stammelement der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Datei entspricht.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Hauptfenster der Anwendung ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Window" />, das als Hauptanwendungsfenster festgelegt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> wird automatisch festgelegt, mit einem Verweis auf das erste <xref:System.Windows.Window> Objekt, das in der instanziiert werden die <xref:System.AppDomain>.  
  
 Geben Sie ein anderes Hauptfenster durch Festlegen <xref:System.Windows.Application.MainWindow%2A> Zuweisen von einem anderen <xref:System.Windows.Application.Windows%2A> -Objekt an die <xref:System.Windows.Application.MainWindow%2A> Eigenschaft.  
  
 Wenn die <xref:System.Windows.Application.ShutdownMode%2A> Eigenschaft der <xref:System.Windows.Application> Objekt nastaven NA hodnotu <xref:System.Windows.ShutdownMode.OnMainWindowClose>, das Hauptfenster schließen, wird die Anwendung heruntergefahren.  
  
 Es ist möglich, legen Sie die <xref:System.Windows.Application.MainWindow%2A> Eigenschaft [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], wenn das Hauptfenster der Anwendung nicht auf das Fenster, das durch Festlegen von erstellt wird, ist die <xref:System.Windows.Application.StartupUri%2A> -Eigenschaft in [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Die zwei Einschränkungen der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Ansatz sind:  
  
-   Geben Sie entweder eine [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-nur <xref:System.Windows.Window> oder [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-nur <xref:System.Windows.Navigation.NavigationWindow> als Hauptfenster.  
  
-   Sie müssen festlegen, die <xref:System.Windows.UIElement.Visibility%2A> -Eigenschaft des Fensters, die Sie angeben, andernfalls wird nicht angezeigt werden.  
  
 Der Verweis auf das erste <xref:System.Windows.Window> Objekt instanziiert werden auch als das erste Element hinzugefügt wird die <xref:System.Windows.Application.Windows%2A> Auflistung. Wenn <xref:System.Windows.Application.MainWindow%2A> später mit einem Verweis auf einen anderen festgelegt <xref:System.Windows.Window>, die Position des Elements mit dem Verweis auf das Hauptfenster wird geändert, während die Reihenfolge der Elemente im <xref:System.Windows.Application.Windows%2A> bleibt unverändert. Verwenden Sie daher stets <xref:System.Windows.Application.MainWindow%2A> zum Verweisen auf das Hauptfenster statt des ersten Elements im <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Wenn das Hauptfenster ist eine <xref:System.Windows.Navigation.NavigationWindow>, und Sie benötigen den Zugriff jeweils spezifisch zu <xref:System.Windows.Navigation.NavigationWindow> Member, Sie müssen den Wert des umgewandelt <xref:System.Windows.Application.MainWindow%2A> zu <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Diese Eigenschaft steht nur aus dem Thread, der erstellt das <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie das Hauptanwendungsfenster.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 Das folgende Beispiel zeigt, wie festgelegt <xref:System.Windows.Application.MainWindow%2A> mit [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 Das folgende Beispiel zeigt, wie Sie instanziieren die <xref:System.Windows.Application.MainWindow%2A> im Code während des Anwendungsstarts.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> wird von einer in einem Browser gehosteten Anwendung festgelegt, z. B. [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Inhalt, zu dem ein Navigator in der Anwendung navigiert, gefunden wurde. Dieses Ereignis ist über die -Eigenschaft verfügbar, auch wenn diese noch nicht vollständig geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn von einem Navigator in der Anwendung eine neue Navigation angefordert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Fehler auftritt, während ein Navigator in der Anwendung zum angeforderten Inhalt navigiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während eines von einem Navigator in der Anwendung verwalteten Downloads regelmäßig ein, um Informationen zum Navigationsfortschritt bereitzustellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see langword="StopLoading" />-Methode eines Navigators in der Anwendung aufgerufen wird oder wenn von einem Navigator eine neue Navigation angefordert wird, während eine aktuelle Navigation noch ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator ist entweder ein <xref:System.Windows.Navigation.NavigationWindow> oder <xref:System.Windows.Controls.Frame>.  
  
 Siehe <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Activated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnActivated%2A> wird das <xref:System.Windows.Application.Activated>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnActivated%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnActivated%2A> in der Basisklasse Wenn <xref:System.Windows.Application.Activated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Deactivated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnDeactivated%2A> wird das <xref:System.Windows.Application.Deactivated>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnDeactivated%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnDeactivated%2A> in der Basisklasse Wenn <xref:System.Windows.Application.Deactivated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.ExitEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Exit" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnExit%2A> wird das <xref:System.Windows.Application.Exit>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben die <xref:System.Windows.Application.OnExit%2A> Methode. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnExit%2A> in der Basisklasse Wenn <xref:System.Windows.Application.Exit> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.FragmentNavigation" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnFragmentNavigation%2A> wird das <xref:System.Windows.Application.FragmentNavigation>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnFragmentNavigation%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnFragmentNavigation%2A> in der Basisklasse Wenn <xref:System.Windows.Application.FragmentNavigation> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.LoadCompleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnLoadCompleted%2A> wird das <xref:System.Windows.Application.LoadCompleted>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnLoadCompleted%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnLoadCompleted%2A> in der Basisklasse Wenn <xref:System.Windows.Application.LoadCompleted> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Navigated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigated%2A> wird das <xref:System.Windows.Application.Navigated>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnNavigated%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnNavigated%2A> in der Basisklasse Wenn <xref:System.Windows.Application.Navigated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Navigating" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigating%2A> wird das <xref:System.Windows.Application.Navigating>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnNavigating%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnNavigating%2A> in der Basisklasse Wenn <xref:System.Windows.Application.Navigating> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.NavigationFailed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigationFailed%2A> wird das <xref:System.Windows.Application.NavigationFailed>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnNavigationFailed%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnNavigationFailed%2A> in der Basisklasse Wenn <xref:System.Windows.Application.NavigationFailed> ausgelöst werden soll.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.NavigationProgress" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigationProgress%2A> wird das <xref:System.Windows.Application.NavigationProgress>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnNavigationProgress%2A>. Die überschriebene Methode muss explizit aufrufen <xref:System.Windows.Application.OnNavigationProgress%2A> in der Basisklasse Wenn <xref:System.Windows.Application.NavigationProgress> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.NavigationStopped" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnNavigationStopped%2A> wird das <xref:System.Windows.Application.NavigationStopped>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnNavigationStopped%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnNavigationStopped%2A> in der Basisklasse Wenn <xref:System.Windows.Application.NavigationStopped> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.SessionEndingCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.SessionEnding" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnSessionEnding%2A> wird das <xref:System.Windows.Application.SessionEnding>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnSessionEnding%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnSessionEnding%2A> in der Basisklasse Wenn <xref:System.Windows.Application.SessionEnding> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.StartupEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Application.Startup" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Application.OnStartup%2A> wird das <xref:System.Windows.Application.Startup>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Application> kann überschreiben <xref:System.Windows.Application.OnStartup%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Application.OnStartup%2A> in der Basisklasse Wenn die <xref:System.Windows.Application.Startup> Ereignis ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Eigenschaften für den Anwendungsbereich ab.</summary>
        <value>Ein <see cref="T:System.Collections.IDictionary" />, das die Eigenschaftswert für den Anwendungsbereich enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> Stellt ein Wörterbuch über <xref:System.Windows.Application.Properties%2A> die Sie verwenden können, um anwendungsspezifische Eigenschaften zu speichern. Dadurch können Sie den Freigabezustand für den gesamten Code in eine <xref:System.AppDomain> auf threadsichere Weise, ohne Ihren eigenen Statuscode schreiben zu müssen.  
  
 Eigenschaften, die in gespeicherten <xref:System.Windows.Application.Properties%2A> muss in den entsprechenden zurückgegebenen Typ konvertiert werden.  
  
 Die <xref:System.Windows.Application.Properties%2A> Eigenschaft ist threadsicher und von jedem Thread verfügbar ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt wie erstellen und verwenden Sie eine für den Anwendungsbereich mit <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.Assembly" /> ab, die die Paket-[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] für Ressourcen in einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Anwendung bereitstellt, oder legt diese fest.</summary>
        <value>Ein Verweis auf die <see cref="T:System.Reflection.Assembly" />, die die Paket-[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] für Ressourcen in einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Anwendung bereitstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardeinstellung [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Ressourcen aufgelöst werden, zur Laufzeit in Bezug auf die Eintragsassembly, der durch den Rückgabewert aus identifiziert wird die <xref:System.Reflection.Assembly.GetEntryAssembly%2A> Methode.  
  
 Die Eintragsassembly ist die Assembly, die von zurückgegeben wird <xref:System.Reflection.Assembly.GetEntryAssembly%2A> und möglicherweise die folgenden:  
  
-   Die ausführbare Assembly in der Standardanwendungsdomäne.  
  
-   Die erste Assembly aufrufen ausgeführt werden soll <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 In den folgenden Fällen jedoch eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly einen Verweis auf die Eintragsassembly kann nicht abgerufen werden:  
  
-   Eine mit nicht verwalteten (systemeigenen) Anwendungshosts die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly.  
  
-   Eine verwaltete Anwendung hostet die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly Laden in eine neue Anwendungsdomäne mit einer Methode als <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 In beiden Fällen <xref:System.Reflection.Assembly.GetEntryAssembly%2A> gibt `null`, und die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] die Ressourcen-Assembly können nicht aufgelöst werden. In diesen Fällen <xref:System.Windows.Application.ResourceAssembly%2A> kann festgelegt werden, sobald nur mit einem Verweis auf die Assembly, die zum Auflösen von Ressourcen verwendet werden soll.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> kann nur einmal festgelegt werden, da es unwahrscheinlich ist, dass sich die Ressourcenassembly nach ändert die [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly geladen wird.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> kann nicht festgelegt werden, wenn eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Assembly erkennen, die Eintragsassembly – d. h. wenn <xref:System.Reflection.Assembly.GetEntryAssembly%2A> gibt einen Verweis auf eine Assembly statt `null`.  
  
 Diese Eigenschaft ist threadsicher und von jedem Thread verfügbar ist.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]-Anwendung verfügt über eine Eintragsassembly, oder <see cref="P:System.Windows.Application.ResourceAssembly" /> wurde bereits festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Ressourcen für den Anwendungsbereich fest, z. B. Formate und Pinsel, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.ResourceDictionary" />-Objekt, das 0 (null) oder mehr Ressourcen für den Anwendungsbereich enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Application.Resources%2A> Eigenschaft kann zum Freigeben von Ressourcen über virtuelle Windows- und die Elemente einer Anwendung verwendet werden. Darüber hinaus die <xref:System.Windows.Application.Resources%2A> Eigenschaft befindet sich in den Ressourcenpfad für die Suche, der in der folgenden Reihenfolge durchlaufen wird:  
  
1.  Elements  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  System  
  
 Folglich [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Elemente können auf Ressourcen der Anwendungsbereich zu binden. Darüber hinaus Ressourcen zu ändern, gewährleistet das Ressourcensystem dieses Element Eigenschaften, die an diese Ressourcen gebunden sind, werden automatisch aktualisiert, um die Änderung zu übernehmen.  
  
 Anwendungsbereich Ressourcen bieten eine einfache Möglichkeit, ein einheitliches Design in Ihrer Anwendung zu unterstützen. Sie können ganz einfach erstellen Sie ein Design in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] mithilfe der `Application.Resources` Tag. Aber wenn Ihre Anwendung mehrere Designs, die eine große Anzahl von Designelemente enthalten kann unterstützt, kann es einfacher sein Verwaltung über eine <xref:System.Windows.ResourceDictionary> Instanz für jedes Design. Auf diese Weise kann ein neues Design angewendet werden durch Festlegen der Resources-Eigenschaft an die entsprechende <xref:System.Windows.ResourceDictionary>.  
  
 Es gibt zwei Überlegungen, die bei der Verwendung <xref:System.Windows.Application.Resources%2A>. Zuerst wird das Wörterbuch *Schlüssel* ist ein Objekt, aus, damit Sie genau die gleiche Objektinstanz beim Festlegen und Abrufen eines Eigenschaftswerts (Beachten Sie, dass der Schlüssel Groß-und Kleinschreibung beachtet, wenn Sie eine Zeichenfolge zu verwenden) verwenden müssen. Anderen ist der *Wert* ist ein Objekt, aus, daher müssen Sie den Wert in den gewünschten Typ zu konvertieren, wenn einen Eigenschaftswert abgerufen werden.  
  
 <xref:System.Windows.Application.Resources%2A> Thread-sicher ist und von jedem Thread verfügbar ist.  
  
   
  
## Examples  
In diesem Beispiel wird veranschaulicht, wie XAML zusammen mit Anwendungsbereich Ressourcen verwenden, um ein einheitliches Erscheinungsbild zu erstellen. Das erste Beispiel stammt aus *"App.xaml"*; das zweite, aus *"MainWindow.xaml"*. 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 Das folgende Beispiel zeigt, wie eine Anwendungsressource in Code und XAML festgelegt (in der Datei "App.xaml" in einem C# WPF-Projekt oder die "Application.xaml"-Datei in einem Visual Basic-WPF-Projekt).  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 Das folgende Beispiel zeigt, wie Sie eine Anwendungsressource im Code abrufen.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet eine Windows Presentation Foundation-Anwendung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet eine Windows Presentation Foundation-Anwendung.</summary>
        <returns>Der Exitcode der <see cref="T:System.Int32" />-Anwendung, der beim Herunterfahren der Anwendung an das Betriebssystem zurückgegeben wird. In der Standardeinstellung ist der Exitcode 0 (null).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> wird aufgerufen, um das Starten einer [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Anwendung. Wenn Sie definieren Ihr <xref:System.Windows.Application> mithilfe von Markup oder Markup und CodeBehind <xref:System.Windows.Application.Run%2A> wird implizit aufgerufen werden. Aber wenn Sie definieren Ihrer <xref:System.Windows.Application> mithilfe von Code, Sie müssen explizit aufrufen <xref:System.Windows.Application.Run%2A>.  
  
 Wenn <xref:System.Windows.Application.Run%2A> aufgerufen wird, <xref:System.Windows.Application> Fügt ein neues <xref:System.Windows.Threading.Dispatcher> Instanz zum UI-Thread. Als Nächstes die <xref:System.Windows.Threading.Dispatcher> des Objekts <xref:System.Windows.Threading.Dispatcher.Run%2A> -Methode aufgerufen wird, wird die startet, ein Nachrichtensystem zum Windows-Meldungen zu verarbeiten. Schließlich die <xref:System.Windows.Threading.Dispatcher> -Objekt ruft die <xref:System.Windows.Application> des Objekts die <xref:System.Windows.Application.OnStartup%2A> Methode zum Auslösen der <xref:System.Windows.Application.Startup> Ereignis. Daher wurde das Anwendungsmodell für die Ausführung mit der Zeit, die Sie behandeln hergestellt <xref:System.Windows.Application.Startup>, an welcher Stelle die Anwendung betrachtet wird, ausgeführt werden.  
  
 Eine Anwendung nicht mehr ausgeführt werden, wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird; der Wert des der <xref:System.Windows.Application.ShutdownMode%2A> Eigenschaft bestimmt, wann <xref:System.Windows.Application.Shutdown%2A> wird aufgerufen, und, ob dies automatisch erfolgt, oder Sie explizit müssen aufrufen.  
  
 <xref:System.Windows.Application.Run%2A> kann aufgerufen werden, nur von der Thread, erstellt die <xref:System.Windows.Application> Objekt. Darüber hinaus <xref:System.Windows.Application.Run%2A> kann nicht aufgerufen werden, von einem [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Anwendung, die einen benutzerdefinierten <xref:System.Windows.Application> und muss daher explizit aufrufen <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> wird von einer im Browser gehosteten Anwendung (z. B. einem [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) aufgerufen.</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">Ein <see cref="T:System.Windows.Window" />, das beim Start einer Anwendung automatisch geöffnet wird.</param>
        <summary>Startet eine Windows Presentation Foundation-Anwendung und öffnet das angegebene Fenster.</summary>
        <returns>Der Exitcode der <see cref="T:System.Int32" />-Anwendung, der beim Herunterfahren der Anwendung an das Betriebssystem zurückgegeben wird. In der Standardeinstellung ist der Exitcode 0 (null).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erweitert die <xref:System.Windows.Application.Run%2A> Methode, um das angegebene Fenster zu öffnen, nach dem Starten einer Anwendung ausgeführt wird.  
  
 Wenn Sie einen Code definieren <xref:System.Windows.Application> , öffnet ein Fenster, beim Starten der Ausführung, die Sie explizit aufrufen, <xref:System.Windows.Application.Run%2A>.  
  
 Bei der Erstellung Ihrer <xref:System.Windows.Application> mithilfe von Markup oder Markup und CodeBehind, können Sie ein Fenster mit einem der folgenden Methoden automatisch öffnen:  
  
-   Deklarativ durch Festlegen von <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Programmgesteuert, durch die Behandlung <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Anwendung mit einer manuell erstellten statischen Einstiegspunktmethode, die instanziiert <xref:System.Windows.Application>, vor dem Aufruf <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> wird von einer im Browser gehosteten Anwendung (z. B. einem [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) aufgerufen.</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer die Windows-Sitzung beendet, indem er sich abmeldet oder das Betriebssystem herunterfährt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird eine Anwendung beendet, wenn die Windows-Sitzung beendet, das auftritt, wenn ein Benutzer ab- oder wird heruntergefahren. In diesem Fall fordert Windows jede geöffnete Anwendung heruntergefahren. Allerdings ist es möglich, dass eine Anwendung möglicherweise nicht zum Herunterfahren in diesem Fall bereit. Beispielsweise kann eine Anwendung Daten enthalten, die in einem inkonsistenten Zustand, oder klicken Sie in der Mitte einer lang andauernden Vorgang ist. In diesen Situationen kann wünschenswert sein, zu verhindern, dass die Sitzung beendet, dabei möglicherweise sinnvoller ist, können Benutzer entscheiden, ob die Sitzung beendet wird oder nicht.  
  
 Sie können erkennen, wenn eine Sitzung beendet wird, durch Behandeln der <xref:System.Windows.Application.SessionEnding> Ereignis. Wenn eine Anwendung benötigt, um zu verhindern, dass die Sitzung beendet, die <xref:System.Windows.SessionEndingCancelEventArgs> an den Ereignishandler übergebene Argument stellt die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> , die Sie festlegen, um `true` (der Standardwert ist `false`).  
  
 Wenn <xref:System.Windows.Application.SessionEnding> nicht behandelt wird oder ohne Abbruch, behandelt wird <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird und die <xref:System.Windows.Application.Exit> Ereignis wird ausgelöst.  
  
 Um erhalten weitere Informationen, warum die Sitzung beendet wird, eine Anwendung kann überprüfen <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, einer der der <xref:System.Windows.ReasonSessionEnding> Werte (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> und <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> wird von der konsolenanwendungen nicht ausgelöst.  
  
 <xref:System.Windows.Application.SessionEnding> wird ausgelöst, nur auf der Thread, erstellt die <xref:System.Windows.Application> Objekt.  
  
 <xref:System.Windows.Application.SessionEnding> für XAML-Browseranwendungen (XBAPs) wird nicht ausgelöst werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie behandelt die <xref:System.Windows.Application.SessionEnding> Ereignis und ermöglicht dem Benutzer, ihn abzubrechen.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">Der <see cref="T:System.Uri" />, der den Speicherort angibt, für den das Cookie erstellt werden soll.</param>
        <param name="value">Der <see cref="T:System.String" />, der die Cookiedaten enthält.</param>
        <summary>Erstellt ein Cookie für den von einem <see cref="T:System.Uri" /> angegebenen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cookie ist ein beliebiger Teil der Daten, die von einer Anwendung auf dem Clientcomputer während der Sitzungen (Sitzungscookies) oder über anwendungssitzungen (permanente Cookies) gespeichert werden können. Sie können beide Typen von Cookies durch den Aufruf erstellen <xref:System.Windows.Application.SetCookie%2A>.  
  
 Cookiedaten dauert in der Regel die Form von Name/Wert-Paar im folgenden Format an:  
  
 `Name=Value`  
  
 Sie übergeben eine Zeichenfolge dieses Format zum <xref:System.Windows.Application.SetCookie%2A>, zusammen mit den <xref:System.Uri> des Speicherorts für den das Cookie festgelegt werden soll (in der Regel die Anwendungsdomäne).  
  
 Ob ein Cookie ein Sitzungscookie oder ein permanentes Cookie, hängt davon ab, ob das Cookie-Zeichenfolge, übergeben Sie an <xref:System.Windows.Application.SetCookie%2A> ein Ablaufdatum enthält. Die Zeichenfolge für ein Sitzungscookie umfasst kein Ablaufdatum. Die Zeichenfolge für ein permanentes Cookie ist, muss das folgende Format:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Beständige Cookies werden gespeichert, in der aktuellen [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] temporäre Internetdateien-Ordner Installation, bis sie ablaufen, werden in diesem Fall gelöscht,. Sie können ein permanentes Cookie aus Ihrer Anwendung löschen, indem das Ablaufdatum auf ein Datum/Uhrzeit-Wert, der in der Vergangenheit liegt.  
  
 Eine Übersicht über Cookies in [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], finden Sie unter [Übersicht über die Navigation](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wenn beim Erstellen des angegebenen Cookies ein Problem auftritt, wird von der <see langword="InternetSetCookie" />-Funktion (aufgerufen durch <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) ein [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]-Fehler ausgelöst.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Abrufen der Cookies für eine dateibasierte <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">zum Abrufen der Cookies für eine nicht-dateibasierte <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fährt eine Anwendung herunter.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fährt eine Anwendung herunter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, wird eine Anwendung nicht mehr ausgeführt wird. Sie können behandeln die <xref:System.Windows.Application.Exit> Ereignis erkennen, wenn eine Anwendung zu beenden, ausgeführt wird, um die entsprechende Verarbeitung auszuführen.  
  
 <xref:System.Windows.Application.Shutdown%2A> wird implizit von Windows Presentation Foundation in den folgenden Situationen aufgerufen:  
  
-   Wenn <xref:System.Windows.Application.ShutdownMode%2A> nastaven NA hodnotu <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Wenn die <xref:System.Windows.Application.ShutdownMode%2A> nastaven NA hodnotu <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Wenn ein Benutzer eine Sitzung beendet und die <xref:System.Windows.Application.SessionEnding> Ereignis wurde mit einem Ausnahmefehler oder ohne Abbruch behandelt.  
  
 Aufrufen von <xref:System.Windows.Application.Shutdown%2A> explizit durch die Anwendung herunterzufahren, unabhängig von der <xref:System.Windows.Application.ShutdownMode%2A> festlegen. Aber wenn <xref:System.Windows.Application.ShutdownMode%2A> nastaven NA hodnotu <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, rufen Sie <xref:System.Windows.Application.Shutdown%2A> um eine Anwendung zu schließen.  
  
> [!IMPORTANT]
>  Wenn <xref:System.Windows.Application.Shutdown%2A> wird aufgerufen, die Anwendung wird heruntergefahren unabhängig davon, ob die <xref:System.Windows.Window.Closing> Ereignis von allen geöffneten Fenstern wird abgebrochen.  
  
 Diese Methode kann aufgerufen werden, nur aus dem Thread, der erstellt das <xref:System.Windows.Application> Objekt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, die alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Ein ganzzahliger Exitcode für eine Anwendung. Der Standardexitcode ist 0 (null).</param>
        <summary>Fährt eine Anwendung herunter, die den angegebenen Exitcode an das Betriebssystem zurückgibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können behandeln die <xref:System.Windows.Application.Exit> Ereignis einen Exitcode festgelegt. Aber wenn Sie explizit aufrufen <xref:System.Windows.Application.Shutdown%2A>, und Sie behandeln <xref:System.Windows.Application.Exit> nur um einen Exitcode festzulegen, die Sie aufrufen können <xref:System.Windows.Application.Shutdown%2A> stattdessen.  
  
 Diese Methode kann aufgerufen werden, nur aus dem Thread, der erstellt das <xref:System.Windows.Application> Objekt.  
  
 Finden Sie unter <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType> Informationen zum Exitcodes.
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, die alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bedingung ab, unter der die <see cref="M:System.Windows.Application.Shutdown" />-Methode aufgerufen wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.ShutdownMode" />-Enumerationswert. Der Standardwert ist <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen nicht mehr ausgeführt wird nur dann, wenn die <xref:System.Windows.Application.Shutdown%2A> der Anwendung wird aufgerufen. Herunterfahren kann implizit oder explizit durch den Wert des angegebenen vorgenommen. die <xref:System.Windows.Application.ShutdownMode%2A> Eigenschaft.  
  
 Setzen Sie <xref:System.Windows.Application.ShutdownMode%2A> zu <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) ruft implizit <xref:System.Windows.Application.Shutdown%2A> Wenn das letzte Fenster in einer Anwendung schließt, selbst wenn derzeit instanziierte Fenster als Hauptanwendungsfenster festgelegt werden (finden Sie unter <xref:System.Windows.Application.MainWindow%2A>).  
  
 Ein <xref:System.Windows.Application.ShutdownMode%2A> von <xref:System.Windows.ShutdownMode.OnMainWindowClose> bewirkt, dass WPF implizit Aufrufen <xref:System.Windows.Application.Shutdown%2A> bei der <xref:System.Windows.Application.MainWindow%2A> wird geschlossen, auch wenn andere Fenster gerade geöffnet sind.  
  
 Die Lebensdauer von einigen Anwendungen möglicherweise nicht abhängig, wenn das Hauptfenster oder das letzte Fenster geschlossen wird, oder möglicherweise überhaupt nicht werden abhängig von Windows. Für diese Szenarien müssen Sie festlegen der <xref:System.Windows.Application.ShutdownMode%2A> Eigenschaft <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, erfordert eine explizite <xref:System.Windows.Application.Shutdown%2A> Methodenaufrufs an die Anwendung zu beenden. Andernfalls wird die Anwendung weiter, die im Hintergrund ausgeführt.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> können deklarativ konfiguriert werden, von [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] oder programmgesteuert über Code.  
  
 Diese Eigenschaft steht nur aus dem Thread, der erstellt das <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie konfigurieren <xref:System.Windows.Application.ShutdownMode%2A> um anzugeben, dass eine Anwendung explizit geschlossen werden muss.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die <see cref="M:System.Windows.Application.Run" />-Methode des <see cref="T:System.Windows.Application" />-Objekts aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine typische Windows Presentation Foundation-Anwendung möglicherweise verschiedene Initialisierungsaufgaben ausführen, beim Start, einschließlich:  
  
-   Verarbeiten von Befehlszeilenparametern.  
  
-   Öffnen das Hauptfenster.  
  
-   Initialisieren von Anwendungsbereich Ressourcen.  
  
-   Initialisieren anwendungsspezifische Eigenschaften.  
  
 Sie können deklarativ angeben, das Hauptfenster und Anwendungsbereich-Ressourcen mithilfe von [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> und <xref:System.Windows.Application.Resources%2A>bzw.). In einigen Fällen kann jedoch die Ressourcen oder im Hauptfenster der Anwendung nur programmgesteuert zur Laufzeit ermittelt werden. Darüber hinaus können Eigenschaften für den Anwendungsbereich und Befehlszeilenparameter nur programmgesteuert verwendet werden. Die Initialisierung durch Programmierung durch Behandlung erfolgen kann die <xref:System.Windows.Application.Startup> Ereignis, einschließlich der folgenden:  
  
-   Abrufen und Verarbeiten von Befehlszeilenparametern, die verfügbar sind die <xref:System.Windows.StartupEventArgs.Args%2A> Eigenschaft der <xref:System.Windows.StartupEventArgs> -Klasse, die an die <xref:System.Windows.Application.Startup> -Ereignishandler.  
  
-   Initialisieren von anwendungsweiten Ressourcen mithilfe der <xref:System.Windows.Application.Resources%2A> Eigenschaft.  
  
-   Initialisieren Sie anwendungsspezifische Eigenschaften mithilfe der <xref:System.Windows.Application.Properties%2A> Eigenschaft.  
  
-   Instanziieren und (mindestens) Fenster anzeigen.  
  
> [!NOTE]
>  Befehlszeilenparameter können auch durch Aufrufen der statischen erworben werden <xref:System.Environment.GetCommandLineArgs%2A> Methode der <xref:System.Environment> Objekt. Allerdings <xref:System.Environment.GetCommandLineArgs%2A> erfordert volle Vertrauenswürdigkeit ausgeführt.  
  
 Setzen Sie <xref:System.Windows.Application.StartupUri%2A> mit [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], das Hauptfenster, die erstellt wurde ist nicht verfügbar ist, entweder der <xref:System.Windows.Application.MainWindow%2A> Eigenschaft oder die <xref:System.Windows.Application.Windows%2A> Eigenschaft der <xref:System.Windows.Application> Objekt bis nach der <xref:System.Windows.Application.Startup> -Ereignis verarbeitet wird. Wenn Sie Zugriff auf das Hauptfenster während des Starts benötigen, müssen Sie manuell erstellen Sie ein neues Fensterobjekt, aus Ihrem <xref:System.Windows.Application.Startup> -Ereignishandler.  
  
> [!NOTE]
>  Wenn Ihre Anwendung verwendet <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> um eine Anmeldeinformationsrichtlinie anzugeben, müssen Sie <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> nach <xref:System.Windows.Application.Startup> ausgelöst ist, andernfalls [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] wird auf eine interne Standardrichtlinie direkt nach der <xref:System.Windows.Application.Startup> -Ereignis ausgelöst wurde.  
  
 Die Befehlszeilenargumente, die übergeben werden, die <xref:System.Windows.Application.Startup> Ereignishandler sind nicht identisch mit der [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] Abfragezeichenfolgenparameter, die übergeben werden, ein [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die zum Abrufen und Verarbeiten von Optionen der Befehlszeile einer eigenständigen Anwendung. Wenn die **/StartMinimized** -Befehlszeilenparameter angegeben wurde, die Anwendung wird im Hauptfenster geöffnet, in einem minimierten Zustand.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] kann nicht abgerufen werden und Befehlszeilenargumente verarbeiten, da der Start mit [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] Bereitstellung (finden Sie unter [Bereitstellen einer WPF-Anwendung (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Von den zum Starten verwendeten URLs können jedoch Abfragezeichenfolgenparameter abgerufen und verarbeitet werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Benutzeroberfläche ab, die automatisch angezeigt wird, wenn die Anwendung startet, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Uri" /> mit Bezug auf die Benutzeroberfläche, die automatisch geöffnet wird, wenn eine Anwendung startet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können <xref:System.Windows.Application.StartupUri%2A> eine UI-Ressource automatisch zu laden, wenn eine Anwendung startet.  
  
 Die folgende Tabelle zeigt die Typen der UI-Ressourcen, die geladen werden können, den Typ des Fensters, in geöffnet werden und den Typ der Anwendung, die diese Ressourcen als festgelegt werden, können die <xref:System.Windows.Application.StartupUri%2A>.  
  
|Typ|Fenster|Anwendungstyp|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Nur eigenständige|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Nur eigenständige|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständige/Browser-gehostete|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständige/Browser-gehostete|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständige/Browser-gehostete|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Eigenständige/Browser-gehostete|  
  
 In der Regel legen Sie die <xref:System.Windows.Application.StartupUri%2A> Eigenschaft, die deklarativ im [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Sie können jedoch festlegen <xref:System.Windows.Application.StartupUri%2A> programmgesteuert, z. B. eine <xref:System.Windows.Application.Startup> -Ereignishandler, dies ist hilfreich bei Anwendungen, die nur die erforderlichen Ressourcen für die Benutzeroberfläche zur Laufzeit laden können. Beispielsweise kann eine Anwendung warten, bis zur Laufzeit zum Laden der Ressourcen, wenn der Name der UI-Ressource in einer Konfigurationsdatei gespeichert ist.  
  
 Gibt an, ob Sie festlegen, <xref:System.Windows.Application.StartupUri%2A> deklarativ oder programmgesteuert, die entsprechende Benutzeroberfläche-Ressource nicht geladen, bis nach der <xref:System.Windows.Application.Startup> -Ereignis behandelt wird. Daher haben Sie keinen Zugriff auf das resultierende Fenster aus der <xref:System.Windows.Application.Windows%2A> Eigenschaft oder das <xref:System.Windows.Application.MainWindow%2A> Eigenschaft bei der Behandlung <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> wird auf den Wert NULL festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Fragt ab, ob eine angegebene Ambiente-Eigenschaft im aktuellen Bereich verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die angeforderte Ambient-Eigenschaft verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Application>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Name der zu suchenden Ressource.</param>
        <summary>Sucht die angegebene Ressource.</summary>
        <returns>Das angeforderte Ressourcenobjekt. Wenn die angeforderte Ressource nicht gefunden werden kann, wird ein NULL-Verweis zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> sucht zuerst im Anwendungsbereich Ressourcen für die angegebene Ressource. Anwendungsbereich Ressourcen werden durch verwaltet <xref:System.Windows.Application>, und stehen zur Verfügung, aus der <xref:System.Windows.Application.Resources%2A> Eigenschaft. Wenn die angegebene Ressource nicht, in der Menge der Ressourcen für den Anwendungsbereich gefunden wird <xref:System.Windows.Application.TryFindResource%2A> dann weiter durchsucht die Systemressourcen. Systemressourcen Shellressourcen, die vom Benutzer definiert sind, und enthalten von Farben, Schriftarten und Shell-Konfigurationen. Diese werden verfügbar gemacht, von der <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, und <xref:System.Windows.SystemParameters> eingibt, als statische Eigenschaften. Verwendung von <xref:System.Windows.Application.TryFindResource%2A> um diese zu erhalten, diese Typen auch verfügbar machen Ressource Schlüsseleigenschaften, die entwickelt wurden, übergeben werden soll <xref:System.Windows.Application.TryFindResource%2A>, z. B. <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Da <xref:System.Windows.Application.TryFindResource%2A> ein Objekt zurückgibt, Sie müssen den Rückgabewert in den entsprechenden Typ umwandeln, wenn die Ressource gefunden wird.  
  
 Diese Methode ist threadsicher und kann von jedem Thread aufgerufen werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit <xref:System.Windows.Application.TryFindResource%2A> zum Abrufen einer Ressource.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die instanziierten Fenster in einer Anwendung ab.</summary>
        <value>Eine <see cref="T:System.Windows.WindowCollection" />, die Verweise auf alle Fensterobjekte in der aktuellen <see cref="T:System.AppDomain" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Window> Verweis wird automatisch hinzugefügt, um <xref:System.Windows.Application.Windows%2A> , sobald ein Fenster instanziiert ist die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Thread; Windows die vom Worker erstellten Threads werden nicht hinzugefügt. Ein <xref:System.Windows.Window> Verweis wird automatisch entfernt, nachdem die <xref:System.Windows.Window.Closing> -Ereignis behandelt wurde und vor dem seine <xref:System.Windows.Window.Closed> Ereignis wird ausgelöst.  
  
 Standardmäßig das erste Element hinzugefügt, um die <xref:System.Windows.Application.Windows%2A> Eigenschaft wird die <xref:System.Windows.Application.MainWindow%2A>.  
  
 Diese Eigenschaft steht nur aus dem Thread, der erstellt das <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Aufzählen der <xref:System.Windows.Application.Windows%2A> Eigenschaft, um eine Windows-Menü der obersten Ebene, zu erstellen, die häufigsten werden [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] Anwendungen wie [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], oder auf mehreren Instanzen einzelne Document Interface (SDI)-Anwendungen wie [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
