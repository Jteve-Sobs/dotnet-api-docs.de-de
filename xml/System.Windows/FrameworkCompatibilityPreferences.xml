<Type Name="FrameworkCompatibilityPreferences" FullName="System.Windows.FrameworkCompatibilityPreferences">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c96a295d0c173b37374a10c2fe4b96e65a76d555" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78836754" /></Metadata><TypeSignature Language="C#" Value="public static class FrameworkCompatibilityPreferences" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FrameworkCompatibilityPreferences extends System.Object" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkCompatibilityPreferences" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkCompatibilityPreferences" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkCompatibilityPreferences abstract sealed" />
  <TypeSignature Language="F#" Value="type FrameworkCompatibilityPreferences = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed FrameworkCompatibilityPreferences extends System.Object" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Enthält Eigenschaften, die angeben, wie sich eine Anwendung in Bezug auf WPF-Funktionen verhalten soll, die sich in der PresentationFramework-Assembly befinden.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AreInactiveSelectionHighlightBrushKeysSupported">
      <MemberSignature Language="C#" Value="public static bool AreInactiveSelectionHighlightBrushKeysSupported { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AreInactiveSelectionHighlightBrushKeysSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AreInactiveSelectionHighlightBrushKeysSupported { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AreInactiveSelectionHighlightBrushKeysSupported : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob die Anwendung die <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightBrush" /> und <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightTextBrush" />-Eigenschaften für die Farbe von inaktiven ausgewählten Elementen verwenden soll.</summary>
        <value><see langword="true" />,wenn die Anwendung die Eigenschaften <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightBrush" /> sowie <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightTextBrush" /> für die Farben inaktiver ausgewählter Elemente verwenden sollte; sonst <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft hängt von der WPF-Version ab, auf die Ihre APP abzielt.  Wenn Ihre APP auf WPF 4,0 oder eine frühere Version abzielt, wird der Standardwert `false`.  Wenn Ihre APP auf WPF 4,5 abzielt, wird der Standardwert `true`.  Wenn Sie diese Eigenschaft verwenden, um das Verhalten von WPF zu ändern, müssen Sie den Wert der Eigenschaft früh in der Lebensdauer der App ändern, z. b. im Konstruktor der Klasse, die von der Anwendung erbt.  Nachdem der Wert gelesen wurde, kann er nicht mehr geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepTextBoxDisplaySynchronizedWithTextProperty">
      <MemberSignature Language="C#" Value="public static bool KeepTextBoxDisplaySynchronizedWithTextProperty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property KeepTextBoxDisplaySynchronizedWithTextProperty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeepTextBoxDisplaySynchronizedWithTextProperty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepTextBoxDisplaySynchronizedWithTextProperty : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob ein datengebundenes <see cref="T:System.Windows.Controls.TextBox" />-Element eine Zeichenfolge anzeigen sollte, die dem Wert der Quelle ihrer <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft entspricht.</summary>
        <value><see langword="true" /> wenn eine datengebundene <see cref="T:System.Windows.Controls.TextBox" /> eine Zeichenfolge anzeigen sollte, die mit dem der Quelle ihrer <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft identisch ist; sonst, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft hängt von der WPF-Version ab, auf die Ihre APP abzielt.  Wenn Ihre APP auf WPF 4,0 oder eine frühere Version abzielt, wird der Standardwert `false`.  Wenn Ihre APP auf WPF 4,5 abzielt, wird der Standardwert `true`.  Wenn Sie diese Eigenschaft verwenden, um das Verhalten von WPF zu ändern, müssen Sie den Wert der Eigenschaft früh in der Lebensdauer der App ändern, z. b. im Konstruktor der Klasse, die von der Anwendung erbt.  Nachdem der Wert gelesen wurde, kann er nicht mehr geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldThrowOnCopyOrCutFailure">
      <MemberSignature Language="C#" Value="public static bool ShouldThrowOnCopyOrCutFailure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ShouldThrowOnCopyOrCutFailure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ShouldThrowOnCopyOrCutFailure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ShouldThrowOnCopyOrCutFailure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShouldThrowOnCopyOrCutFailure : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein fehlerhafter Kopier- oder Ausschneidvorgang in einer <see cref="T:System.Windows.Controls.Primitives.TextBoxBase" />-Instanz zu einer <see cref="T:System.Runtime.InteropServices.ExternalException" /> führt, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn ein fehlerhafter Kopier- oder Ausschneidvorgang in einer <see cref="T:System.Windows.Controls.Primitives.TextBoxBase" />-Instanz zu einer <see cref="T:System.Runtime.InteropServices.ExternalException" /> führt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Zwischenablage Vorgang fehlschlägt (z. b. mit einem **HRESULT 0x800401d0-Fehler (CLIPBRD_E_CANT_OPEN)** ), wird eine entsprechende <xref:System.Runtime.InteropServices.ExternalException> ausgelöst (die einen Typ von ExternalException darstellt).  
  
 Da die Win32-`OpenClipboard`-API Global agiert, sollten gut geschriebene Anwendungen die entsprechende `CloseClipboard` API abrufen, sobald Sie Ihre Zwischenablage Vorgänge abgeschlossen haben. Andernfalls können andere Anwendungen, die in derselben Sitzung ausgeführt werden, nicht auf die Zwischenablage Funktionen zugreifen.  
  
 In WPF wird eine solche Verweigerung des Zugriffs auf die Zwischenablage normalerweise automatisch ignoriert. Allerdings können Anwendungen bei einem Fehler eine `ExternalException` empfangen, indem Sie das <xref:System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure%2A>-Flag auf `true`festlegen. Wenn Sie sich jedoch für den Empfang von Ausnahmen entscheiden, muss die Anwendung auch <xref:System.Windows.Input.ApplicationCommands.Cut%2A> und <xref:System.Windows.Input.ApplicationCommands.Copy%2A> RoutedUICommands über einen <xref:System.Windows.Input.CommandBinding>verarbeiten und diese Bindung dann auf alle TextBoxBase-Steuerelemente (<xref:System.Windows.Controls.TextBox> und <xref:System.Windows.Controls.RichTextBox>) in der Anwendung anwenden. Die Anwendung muss sicherstellen, dass Sie externalexceptions verarbeitet, die sich aus Kopier-und Ausschneide Vorgängen im ausgeführten Handler der CommandBinding ergeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
