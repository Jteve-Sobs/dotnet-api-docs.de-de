<Type Name="FrameworkCompatibilityPreferences" FullName="System.Windows.FrameworkCompatibilityPreferences">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9d6cc315534a7cc85a43d94d0dbc20b7eba80a3f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36459613" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class FrameworkCompatibilityPreferences" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed FrameworkCompatibilityPreferences extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkCompatibilityPreferences" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkCompatibilityPreferences" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkCompatibilityPreferences abstract sealed" />
  <TypeSignature Language="F#" Value="type FrameworkCompatibilityPreferences = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Enthält Eigenschaften, die angeben, wie sich eine Anwendung in Bezug auf WPF-Funktionen verhalten soll, die sich in der PresentationFramework-Assembly befinden.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AreInactiveSelectionHighlightBrushKeysSupported">
      <MemberSignature Language="C#" Value="public static bool AreInactiveSelectionHighlightBrushKeysSupported { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AreInactiveSelectionHighlightBrushKeysSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AreInactiveSelectionHighlightBrushKeysSupported { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AreInactiveSelectionHighlightBrushKeysSupported : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob die Anwendung die <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightBrush" /> und <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightTextBrush" />-Eigenschaften für die Farbe von inaktiven ausgewählten Elementen verwenden soll.</summary>
        <value>
          <see langword="true" />,wenn die Anwendung die Eigenschaften <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightBrush" /> sowie <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightTextBrush" /> für die Farben inaktiver ausgewählter Elemente verwenden sollte; sonst <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft abhängig ist, welche Version von WPF, die Ihre app ausgerichtet ist.  Wenn Ihre app WPF 4.0 abzielt oder früher, der Standardwert ist `false`.  Wenn Ihre app mit WPF Version 4.5 ausgerichtet ist, wird der Standardwert ist `true`.  Wenn Sie diese Eigenschaft verwenden, um das Verhalten von WPF ändern, müssen Sie den Wert der Eigenschaft einem frühen Zeitpunkt in der Lebensdauer der app, wie in den Konstruktor der Klasse ändern, die von der Anwendung erbt.  Nach dem der Wert gelesen wird, können Sie es erneut nicht ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepTextBoxDisplaySynchronizedWithTextProperty">
      <MemberSignature Language="C#" Value="public static bool KeepTextBoxDisplaySynchronizedWithTextProperty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property KeepTextBoxDisplaySynchronizedWithTextProperty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeepTextBoxDisplaySynchronizedWithTextProperty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepTextBoxDisplaySynchronizedWithTextProperty : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob ein datengebundener <see cref="T:System.Windows.Controls.TextBox" /> Verweis eine Zeichenfolge anzeigen sollte, die dem Wert der Quelle ihrer <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft entspricht.</summary>
        <value>
          <see langword="true" /> wenn eine datengebundene <see cref="T:System.Windows.Controls.TextBox" /> eine Zeichenfolge anzeigen sollte, die mit dem der Quelle ihrer <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft identisch ist; sonst, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft abhängig ist, welche Version von WPF, die Ihre app ausgerichtet ist.  Wenn Ihre app WPF 4.0 abzielt oder früher, der Standardwert ist `false`.  Wenn Ihre app mit WPF Version 4.5 ausgerichtet ist, wird der Standardwert ist `true`.  Wenn Sie diese Eigenschaft verwenden, um das Verhalten von WPF ändern, müssen Sie den Wert der Eigenschaft einem frühen Zeitpunkt in der Lebensdauer der app, wie in den Konstruktor der Klasse ändern, die von der Anwendung erbt.  Nach dem der Wert gelesen wird, können Sie es erneut nicht ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldThrowOnCopyOrCutFailure">
      <MemberSignature Language="C#" Value="public static bool ShouldThrowOnCopyOrCutFailure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ShouldThrowOnCopyOrCutFailure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ShouldThrowOnCopyOrCutFailure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ShouldThrowOnCopyOrCutFailure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShouldThrowOnCopyOrCutFailure : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein fehlerhafter Kopier- oder Ausschneidvorgang in einer <see cref="T:System.Windows.Controls.Primitives.TextBoxBase" />-Instanz zu einer <see cref="T:System.Runtime.InteropServices.ExternalException" /> führt, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn ein fehlerhafter Kopier- oder Ausschneidvorgang in einer <see cref="T:System.Windows.Controls.Primitives.TextBoxBase" />-Instanz zu einer <see cref="T:System.Runtime.InteropServices.ExternalException" /> führt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Zwischenablagevorgang, wie z. B. fehlschlägt mit einer **HRESULT 0x800401D0 (CLIPBRD_E_CANT_OPEN)** Fehler, eine entsprechende <xref:System.Runtime.InteropServices.ExternalException> ausgelöst wird (dies eine Art von ExternalException ist).  
  
 Da die Win32 `OpenClipboard` API fungiert, gut geschriebene Anwendungen sollten rufen Sie die entsprechende `CloseClipboard` API, sobald sie ihre Zwischenablagevorgänge abgeschlossen wurden. Andere Anwendungen, die in der gleichen Sitzung ausgeführt werden, andernfalls nicht Zwischenablagefunktionen zugreifen werden.  
  
 In WPF werden solche ein Denial-of-Zugriff auf die Zwischenablage normalerweise still ignoriert. Anwendungen können jedoch angeben, dass Sie erhalten eine `ExternalException` bei einem Fehler durch Festlegen der <xref:System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure%2A> flag auf `true`. Jedoch Ausnahmen erhalten, für die Verwaltung erfordert auch die zu behandelnde Anwendung <xref:System.Windows.Input.ApplicationCommands.Cut%2A> und <xref:System.Windows.Input.ApplicationCommands.Copy%2A> RoutedUICommands über eine <xref:System.Windows.Input.CommandBinding>, und wenden Sie dann, dass die Bindung für alle TextBoxBase-Steuerelemente (<xref:System.Windows.Controls.TextBox> und <xref:System.Windows.Controls.RichTextBox>) in der die Anwendung. Anwendung muss sichergestellt sein, dass sie ExternalExceptions aus Kopier- und ausschneidebefehle Vorgänge in der CommandBinding-Element ausgeführt Handler behandelt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>