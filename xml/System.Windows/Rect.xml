<Type Name="Rect" FullName="System.Windows.Rect">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cf7d1387ee03ec7cae439135fbd676179308311f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680514" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Rect : IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Rect extends System.ValueType implements class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Rect" />
  <TypeSignature Language="VB.NET" Value="Public Structure Rect&#xA;Implements IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Rect : IFormattable" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.RectConverter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.Converters.RectValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Beschreibt die Breite, Höhe und Position eines Rechtecks.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_Duration"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="x,y,width,height"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *w*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Der Speicherort der X-Koordinate der linken Seite des Rechtecks.  
  
 *y*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Der Speicherort der y-Koordinate des oberen Randes des Rechtecks.  
  
 *width*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Ein nicht negativer Wert, der stellt die <xref:System.Windows.Rect.Width%2A> des Rechtecks.  
  
 *height*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Ein nicht negativer Wert, der stellt die <xref:System.Windows.Rect.Height%2A> des Rechtecks.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Rect" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rect (System.Windows.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.#ctor(System.Windows.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rect(System::Windows::Size size);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="size" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="size">Eine <see cref="T:System.Windows.Size" />-Struktur, die die Breite und Höhe des Rechtecks angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Rect" />-Struktur mit der angegebenen Größe an der Position (0,0).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.Windows.Rect> -Struktur unter Verwendung der <xref:System.Windows.Rect.%23ctor%28System.Windows.Size%29> Konstruktor.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample2_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rect (System.Windows.Point point1, System.Windows.Point point2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (point1 As Point, point2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rect(System::Windows::Point point1, System::Windows::Point point2);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point1">Der erste Punkt, den das neue Rechteck enthalten muss.</param>
        <param name="point2">Der zweite Punkt, den das neue Rechteck enthalten muss.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Rect" />-Struktur, die genau die erforderliche Größe hat, um die beiden angegebenen Punkte einzuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.Windows.Rect> -Struktur unter Verwendung der <xref:System.Windows.Rect.%23ctor%28System.Windows.Point%2CSystem.Windows.Point%29> Konstruktor.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample3_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample3_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rect (System.Windows.Point location, System.Windows.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Point location, valuetype System.Windows.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rect(System::Windows::Point location, System::Windows::Size size);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="location" Type="System.Windows.Point" />
        <Parameter Name="size" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="location">Ein Punkt, der die Position der linken oberen Ecke des Rechtecks angibt.</param>
        <param name="size">Eine <see cref="T:System.Windows.Size" />-Struktur, die die Breite und Höhe des Rechtecks angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Rect" />-Struktur mit der angegebenen Position der oberen linken Ecke und der angegebenen Breite und Höhe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.Windows.Rect> -Struktur unter Verwendung der <xref:System.Windows.Rect.%23ctor%28System.Windows.Point%2CSystem.Windows.Size%29> Konstruktor.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample4_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample4_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rect (System.Windows.Point point, System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Point point, valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rect(System::Windows::Point point, System::Windows::Vector vector);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="point">Der erste Punkt, den das Rechteck enthalten muss.</param>
        <param name="vector">Der Betrag, um den der angegebene Punkt verschoben werden soll. Das sich ergebende Rechteck weist genau die erforderliche Größe auf, um beide Punkte einzuschließen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Rect" />-Struktur, die genau die erforderliche Größe hat, um den angegebenen Punkt und die Summe aus dem angegebenen Punkt und dem angegebenen Vektor einzuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.Windows.Rect> -Struktur unter Verwendung der <xref:System.Windows.Rect.%23ctor%28System.Windows.Point%2CSystem.Windows.Vector%29> Konstruktor.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample5_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample5_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rect (double x, double y, double width, double height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 x, float64 y, float64 width, float64 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (x As Double, y As Double, width As Double, height As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rect(double x, double y, double width, double height);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="width" Type="System.Double" />
        <Parameter Name="height" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der linken oberen Ecke des Rechtecks.</param>
        <param name="y">Die y-Koordinate der linken oberen Ecke des Rechtecks.</param>
        <param name="width">Die Breite des Rechtecks.</param>
        <param name="height">Die Höhe des Rechtecks.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Rect" />-Struktur, mit der angegebenen x-Koordinate, y-Koordinate, Breite und Höhe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.Windows.Rect> -Struktur unter Verwendung der <xref:System.Windows.Rect.%23ctor%28System.Double%2CSystem.Double%2CSystem.Double%2CSystem.Double%29> Konstruktor.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample6_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample6_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="width" /> ist eine negativer Wert.  
  
 - oder -   
  
 <paramref name="height" /> ist eine negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public double Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Bottom { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den y-Achsen-Wert des unteren Rands des Rechtecks ab.</summary>
        <value>Der y-Achsen-Wert des unteren Rands des Rechtecks. Wenn das Rechteck leer ist, ist der Wert <see cref="F:System.Double.NegativeInfinity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wert der y-Achse die Unterseite des Rechtecks ist gleich der Summe der <xref:System.Windows.Rect.Y%2A> und <xref:System.Windows.Rect.Height%2A> Eigenschaften.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomLeft">
      <MemberSignature Language="C#" Value="public System.Windows.Point BottomLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point BottomLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.BottomLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BottomLeft As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point BottomLeft { System::Windows::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der linken unteren Ecke des Rechtecks ab.</summary>
        <value>Die Position der linken unteren Ecke des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position von der unteren linken Ecke des Rechtecks ist gleich (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>  +  <xref:System.Windows.Rect.Height%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomRight">
      <MemberSignature Language="C#" Value="public System.Windows.Point BottomRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point BottomRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.BottomRight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BottomRight As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point BottomRight { System::Windows::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der rechten unteren Ecke des Rechtecks ab.</summary>
        <value>Die Position der rechten unteren Ecke des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position von der unteren rechten Ecke des Rechtecks ist gleich (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>, <xref:System.Windows.Rect.Y%2A>  +  <xref:System.Windows.Rect.Height%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob das Rechteck den angegebenen Punkt oder das Rechteck enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Contains(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der zu überprüfende Punkt.</param>
        <summary>Gibt an, ob das Rechteck den angegebenen Punkt enthält.</summary>
        <returns>
          <see langword="true" />, wenn das Rechteck den angegebenen Punkt enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Contains%28System.Windows.Point%29> Methode, um zu bestimmen, ob das Rechteck angegebenen enthält <xref:System.Windows.Point>.  
  
 [!code-csharp[RectExamples_snip#ContainsExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#containsexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Rect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(valuetype System.Windows.Rect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Contains(System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Rect rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect">Das zu überprüfende Rechteck.</param>
        <summary>Gibt an, ob das Rechteck das angegebene Rechteck enthält.</summary>
        <returns>
          <see langword="true" /> wenn <paramref name="rect" /> vollständig im Rechteck enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Contains%28System.Windows.Rect%29> Methode, um zu bestimmen, ob ein Rechteck in einem anderen Rechteck enthalten ist.  
  
 [!code-csharp[RectExamples_snip#ContainsExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#containsexample2_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Contains(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (x As Double, y As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punkts, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punkts, der überprüft werden soll.</param>
        <summary>Gibt an, ob das Rechteck die angegebene x- und y-Koordinate enthält.</summary>
        <returns>
          <see langword="true" /> wenn (<paramref name="x" />, <paramref name="y" />) im Rechteck enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Contains%28System.Double%2CSystem.Double%29> Methode, um zu bestimmen, ob das Rechteck der durch die angegebenen x- und y-Koordinate angegebenen Punkt enthält.  
  
 [!code-csharp[RectExamples_snip#ContainsExample3_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#containsexample3_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Rect Empty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Rect Empty { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen besonderen Wert ab, der ein Rechteck ohne Position oder Bereich darstellt.</summary>
        <value>Das leere Rechteck, dessen <see cref="P:System.Windows.Rect.X" />-Eigenschaftswert und <see cref="P:System.Windows.Rect.Y" />-Eigenschaftswert <see cref="F:System.Double.PositiveInfinity" /> sind und dessen <see cref="P:System.Windows.Rect.Width" />-Eigenschaftswert und <see cref="P:System.Windows.Rect.Height" />-Eigenschaftswert <see cref="F:System.Double.NegativeInfinity" /> sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vermeiden Sie mathematische Berechnungen im Zusammenhang mit leeren Rechtecke an. Da beide <xref:System.Windows.Rect.X%2A> und <xref:System.Windows.Rect.Y%2A> unendliche Werte, Prozessor, die Vorgänge sind von diesen Operationen erheblich beeinträchtigt werden. Vergleiche, die im Zusammenhang mit diesen Werten wirkt sich nicht auf Leistung der Anwendung aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Rect.IsEmpty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob zwei Rechtecke gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, mit dem das aktuelle Rechteck verglichen werden soll.</param>
        <summary>Gibt an, ob das angegebene Objekt und das aktuelle Rechteck gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="o" /> ein <see cref="T:System.Windows.Rect" /> ist und den gleichen <see cref="P:System.Windows.Rect.Location" />-Wert und <see cref="P:System.Windows.Rect.Size" />-Wert wie das aktuelle Rechteck aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang überprüft auf Objektgleichheit.  
  
 In diesem Vergleich, zwei Instanzen von <xref:System.Double.NaN?displayProperty=nameWithType> als gleich betrachtet werden.  
  
> [!NOTE]
>  Position und Abmessungen des Rechtecks sind durch beschrieben <xref:System.Double> Werte. Da <xref:System.Double> Werte abnehmen können, wenn Sie bearbeitet, fehlschlagen, ein Vergleich zwischen zwei Werten, die logisch gleich sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Equals%28System.Object%29> Methode, um zu bestimmen, ob ein Rechteck mit einem angegebenen Objekt identisch ist.  
  
 [!code-csharp[RectExamples_snip#EqualsExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#equalsexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)" />
        <altmember cref="M:System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Windows.Rect value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Windows.Rect value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Equals(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Rect) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Windows::Rect value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="value">Das Rechteck, mit dem das aktuelle Rechteck verglichen werden soll.</param>
        <summary>Gibt an, ob as angegebene Rechteck und das aktuelle Rechteck gleich sind.</summary>
        <returns>
          <see langword="true" />, das angegebene Rechteck den gleichen <see cref="P:System.Windows.Rect.Location" />-Wert und <see cref="P:System.Windows.Rect.Size" />-Wert wie das aktuelle Rechteck aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang überprüft auf Objektgleichheit.  
  
 In diesem Vergleich, zwei Instanzen von <xref:System.Double.NaN?displayProperty=nameWithType> als gleich betrachtet werden.  
  
> [!NOTE]
>  Position und Abmessungen des Rechtecks sind durch beschrieben <xref:System.Double> Werte. Da <xref:System.Double> Werte abnehmen können, wenn Sie bearbeitet, fehlschlagen, ein Vergleich zwischen zwei Werten, die logisch gleich sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Equals%28System.Windows.Rect%29> Methode, um zu bestimmen, ob ein Rechteck mit einem angegebenen Rechteck identisch ist.  
  
 [!code-csharp[RectExamples_snip#EqualsExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#equalsexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)" />
        <altmember cref="M:System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (System.Windows.Rect rect1, System.Windows.Rect rect2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Windows.Rect rect1, valuetype System.Windows.Rect rect2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (rect1 As Rect, rect2 As Rect) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Windows::Rect rect1, System::Windows::Rect rect2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect1" Type="System.Windows.Rect" />
        <Parameter Name="rect2" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect1">Das erste der zu vergleichenden Rechtecke.</param>
        <param name="rect2">Das zweite der zu vergleichenden Rechtecke.</param>
        <summary>Gibt an, ob die angegebenen Rechtecke gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn die Rechtecke über den gleichen <see cref="P:System.Windows.Rect.Location" />-Wert und <see cref="P:System.Windows.Rect.Size" />-Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang überprüft auf Objektgleichheit.  
  
 In diesem Vergleich, zwei Instanzen von <xref:System.Double.NaN?displayProperty=nameWithType> als gleich betrachtet werden.  
  
> [!NOTE]
>  Position und Abmessungen des Rechtecks sind durch beschrieben <xref:System.Double> Werte. Da <xref:System.Double> Werte abnehmen können, wenn Sie bearbeitet, fehlschlagen, ein Vergleich zwischen zwei Werten, die logisch gleich sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Equals%28System.Windows.Rect%2CSystem.Windows.Rect%29> Methode, um zu bestimmen, ob ein Rechteck gleich einem anderen ist.  
  
 [!code-csharp[RectExamples_snip#EqualsExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#equalsexample2_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)" />
        <altmember cref="M:System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen Hashcode für das Rechteck.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Windows.Rect" />-Struktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt einen Hashcode mithilfe der <xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>, <xref:System.Windows.Rect.Width%2A>, und <xref:System.Windows.Rect.Height%2A> Eigenschaftswerte.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.GetHashCode%2A> den Hashcode der abzurufenden Methode eine <xref:System.Windows.Rect>.  
  
 [!code-csharp[RectExamples_snip#GetHashCodeExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#gethashcodeexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Rechtecks ab oder legt diese fest.</summary>
        <value>Eine positive Zahl, die die Höhe des Rechtecks darstellt. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Rect.Empty%2A> Rechteck hat eine <xref:System.Windows.Rect.Height%2A> von <xref:System.Double.NegativeInfinity>. Die <xref:System.Windows.Rect.Empty%2A> Rechteck ist schreibgeschützt; die <xref:System.Windows.Rect.Height%2A> kann nicht geändert werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Rect.Height" /> ist auf einen negativen Wert festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Rect.Height" /> ist auf ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck festgelegt.</exception>
        <altmember cref="P:System.Windows.Rect.Width" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Inflate">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Rechteck, das sich beim Erweitern oder Verkleinern eines Rechtecks um den angegebenen Betrag ergibt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Inflate">
      <MemberSignature Language="C#" Value="public void Inflate (System.Windows.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Inflate(valuetype System.Windows.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Inflate(System.Windows.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Inflate(System::Windows::Size size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="size">Gibt den Betrag an, um den das Rechteck erweitert werden soll. Die <see cref="T:System.Windows.Size" />-Eigenschaft der <see cref="P:System.Windows.Size.Width" />-Struktur gibt den Betrag an, um den die <see cref="P:System.Windows.Rect.Left" />-Eigenschaft und die <see cref="P:System.Windows.Rect.Right" />-Eigenschaft des Rechtecks erhöht werden sollen. Die <see cref="T:System.Windows.Size" />-Eigenschaft der <see cref="P:System.Windows.Size.Height" />-Struktur gibt den Betrag an, um den die <see cref="P:System.Windows.Rect.Top" />-Eigenschaft und die <see cref="P:System.Windows.Rect.Bottom" />-Eigenschaft des Rechtecks erhöht werden sollen.</param>
        <summary>Erweitert das Rechteck mithilfe der angegebenen <see cref="T:System.Windows.Size" /> in alle Richtungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Rect.Width%2A> des sich ergebenden Rechtecks vergrößert wird zweimal die <xref:System.Windows.Size.Width%2A> des angegebenen <xref:System.Windows.Size> -Struktur, da sowohl der linken und rechten Seite des Rechtecks vergrößert werden. Entsprechend der <xref:System.Windows.Rect.Height%2A> des sich ergebenden Rechtecks vergrößert wird zweimal die <xref:System.Windows.Size.Height%2A> des angegebenen <xref:System.Windows.Size> Struktur.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Inflate%28System.Windows.Size%29> Methode, um die Größe eines Rechtecks erhöhen.  
  
 [!code-csharp[RectExamples_snip#InflateExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#inflateexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Methode wird für das <see cref="P:System.Windows.Rect.Empty" />-Rechteck aufgerufen.</exception>
        <altmember cref="M:System.Windows.Rect.Scale(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Inflate">
      <MemberSignature Language="C#" Value="public void Inflate (double width, double height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Inflate(float64 width, float64 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Inflate(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Inflate (width As Double, height As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Inflate(double width, double height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Double" />
        <Parameter Name="height" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="width">Der Betrag, um den die linke und die rechte Seite des Rechtecks erweitert oder verkleinert werden sollen.</param>
        <param name="height">Der Betrag, um den der obere und der untere Rand des Rechtecks erweitert oder verkleinert werden sollen.</param>
        <summary>Erweitert oder verkleinert das Rechteck mithilfe der angegebenen Breite und Höhe in alle Richtungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Rect.Width%2A> der resultierende Rechteck wird erhöht oder verringert zweimal die angegebene Breite Offset, da sie auf der linken und der rechten Seite des Rechtecks angewendet wird. Entsprechend der <xref:System.Windows.Rect.Height%2A> des sich ergebenden Rechtecks erhöht oder verringert wird zweimal in der angegebenen Höhe.  
  
 Wenn die angegebene Breite oder Höhe des Rechtecks durch mehr als die aktuelle verkleinert <xref:System.Windows.Rect.Width%2A> oder <xref:System.Windows.Rect.Height%2A>– und dem Rechteck, das einen negativen Bereich – das Rechteck wird die <xref:System.Windows.Rect.Empty%2A> Rechteck.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Inflate%28System.Double%2CSystem.Double%29> Methode, um die Größe eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#InflateExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#inflateexample2_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Methode wird für das <see cref="P:System.Windows.Rect.Empty" />-Rechteck aufgerufen.</exception>
        <altmember cref="M:System.Windows.Rect.Scale(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Inflate">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Inflate (System.Windows.Rect rect, System.Windows.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Inflate(valuetype System.Windows.Rect rect, valuetype System.Windows.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Inflate(System::Windows::Rect rect, System::Windows::Size size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
        <Parameter Name="size" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="rect">Die zu ändernde <see cref="T:System.Windows.Rect" />-Struktur.</param>
        <param name="size">Gibt den Betrag an, um den das Rechteck erweitert werden soll. Die <see cref="T:System.Windows.Size" />-Eigenschaft der <see cref="P:System.Windows.Size.Width" />-Struktur gibt den Betrag an, um den die <see cref="P:System.Windows.Rect.Left" />-Eigenschaft und die <see cref="P:System.Windows.Rect.Right" />-Eigenschaft des Rechtecks erhöht werden sollen. Die <see cref="T:System.Windows.Size" />-Eigenschaft der <see cref="P:System.Windows.Size.Height" />-Struktur gibt den Betrag an, um den die <see cref="P:System.Windows.Rect.Top" />-Eigenschaft und die <see cref="P:System.Windows.Rect.Bottom" />-Eigenschaft des Rechtecks erhöht werden sollen.</param>
        <summary>Gibt das Rechteck zurück, das sich beim Erweitern des angegebenen Rechtecks um die angegebene <see cref="T:System.Windows.Size" /> in alle Richtungen ergibt.</summary>
        <returns>Das sich ergebende Rechteck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Rect.Width%2A> des sich ergebenden Rechtecks vergrößert wird zweimal die <xref:System.Windows.Size.Width%2A> des angegebenen <xref:System.Windows.Size> -Struktur, da sowohl der linken und rechten Seite des Rechtecks vergrößert werden. Entsprechend der <xref:System.Windows.Rect.Height%2A> des sich ergebenden Rechtecks vergrößert wird zweimal die <xref:System.Windows.Size.Height%2A> des angegebenen <xref:System.Windows.Size> Struktur.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Inflate%28System.Windows.Rect%2CSystem.Windows.Size%29> Methode, um die Größe eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#InflateExample3_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#inflateexample3_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="rect" /> ist ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck.</exception>
        <altmember cref="M:System.Windows.Rect.Scale(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Inflate">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Inflate (System.Windows.Rect rect, double width, double height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Inflate(valuetype System.Windows.Rect rect, float64 width, float64 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Inflate(System::Windows::Rect rect, double width, double height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
        <Parameter Name="width" Type="System.Double" />
        <Parameter Name="height" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="rect">Die zu ändernde <see cref="T:System.Windows.Rect" />-Struktur.</param>
        <param name="width">Der Betrag, um den die linke und die rechte Seite des Rechtecks erweitert oder verkleinert werden sollen.</param>
        <param name="height">Der Betrag, um den der obere und der untere Rand des Rechtecks erweitert oder verkleinert werden sollen.</param>
        <summary>Erstellt ein Rechteck, das sich beim Erweitern oder Verkleinern des angegebenen Rechtecks um die angegebenen Beträge für Breite und Höhe in alle Richtungen ergibt.</summary>
        <returns>Das sich ergebende Rechteck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Rect.Width%2A> der resultierende Rechteck wird erhöht oder verringert zweimal die angegebene Breite Offset, da sie auf der linken und der rechten Seite des Rechtecks angewendet wird. Entsprechend der <xref:System.Windows.Rect.Height%2A> des sich ergebenden Rechtecks erhöht oder verringert wird zweimal in der angegebenen Höhe.  
  
 Wenn die angegebenen Modifizierer Breite oder Höhe des Rechtecks durch mehr als die aktuelle verkleinert <xref:System.Windows.Rect.Width%2A> oder <xref:System.Windows.Rect.Height%2A>– und dem Rechteck, das einen negativen Bereich – Methodenrückgabe <xref:System.Windows.Rect.Empty%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Inflate%28System.Windows.Rect%2CSystem.Double%2CSystem.Double%29> Methode, um die Größe eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#InflateExample4_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#inflateexample4_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="rect" /> ist ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck.</exception>
        <altmember cref="M:System.Windows.Rect.Scale(System.Double,System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht die Schnittfläche von zwei Rechtecken.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public void Intersect (System.Windows.Rect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Intersect(valuetype System.Windows.Rect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Intersect(System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Intersect(System::Windows::Rect rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect">Das Rechteck, das eine Schnittfläche mit dem aktuellen Rechteck bildet.</param>
        <summary>Sucht die Schnittfläche des aktuellen Rechtecks und des angegebenen Rechtecks und speichert das Ergebnis als das aktuelle Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Überschneidung vorhanden ist, wird das aktuelle Rechteck <xref:System.Windows.Rect.Empty%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Intersect%28System.Windows.Rect%29> -Methode ermittelt die Schnittmenge zweier Rechtecke und speichern Sie das Ergebnis als Rechteck.  
  
 [!code-csharp[RectExamples_snip#IntersectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#intersectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.IntersectsWith(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Intersect (System.Windows.Rect rect1, System.Windows.Rect rect2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Intersect(valuetype System.Windows.Rect rect1, valuetype System.Windows.Rect rect2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intersect (rect1 As Rect, rect2 As Rect) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Intersect(System::Windows::Rect rect1, System::Windows::Rect rect2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect1" Type="System.Windows.Rect" />
        <Parameter Name="rect2" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect1">Das erste der zu vergleichenden Rechtecke.</param>
        <param name="rect2">Das zweite der zu vergleichenden Rechtecke.</param>
        <summary>Gibt die Schnittfläche der angegebenen Rechtecke zurück.</summary>
        <returns>Die Schnittmenge der beiden Rechtecke oder <see cref="P:System.Windows.Rect.Empty" />, wenn keine Schnittmenge vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Intersect%28System.Windows.Rect%2CSystem.Windows.Rect%29> Methode, um die Schnittmenge zweier Rechtecke zu ermitteln.  
  
 [!code-csharp[RectExamples_snip#IntersectExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#intersectexample2_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.IntersectsWith(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="IntersectsWith">
      <MemberSignature Language="C#" Value="public bool IntersectsWith (System.Windows.Rect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IntersectsWith(valuetype System.Windows.Rect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.IntersectsWith(System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IntersectsWith(System::Windows::Rect rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect">Das zu überprüfende Rechteck.</param>
        <summary>Gibt an, ob sich das angegebene Rechteck mit dem aktuellen Rechteck überschneidet.</summary>
        <returns>
          <see langword="true" />, wenn sich das angegebene Rechteck mit dem aktuellen Rechteck überschneidet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.IntersectsWith%2A> Methode, um zu bestimmen, ob die Schnittmenge zweier Rechtecke.  
  
 [!code-csharp[RectExamples_snip#IntersectsWithExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#intersectswithexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Rechteck das <see cref="P:System.Windows.Rect.Empty" />-Rechteck ist.</summary>
        <value>
          <see langword="true" />, wenn das Rechteck das <see cref="P:System.Windows.Rect.Empty" />-Rechteck ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nicht auf 0 (null) Bereich getestet. ein Rechteck mit 0 (null) ist nicht notwendigerweise die <xref:System.Windows.Rect.Empty%2A> Rechteck. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Rect.Empty%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Rect.Empty" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Left" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den x-Achsen-Wert des linken Rands des Rechtecks ab.</summary>
        <value>Der x-Achsen-Wert des linken Rands des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Abrufen dieser Eigenschaft entspricht dem Abrufen der <xref:System.Windows.Rect.X%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Rect.X" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Windows.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point Location { System::Windows::Point get(); void set(System::Windows::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der linken oberen Ecke des Rechtecks ab oder legt diese fest.</summary>
        <value>Die Position der linken oberen Ecke des Rechtecks. Der Standardwert ist (0, 0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position der oberen linken Ecke des Rechtecks ist gleich (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Rect.Location" /> ist auf ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck festgelegt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Offset">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt ein Rechteck durch den angegebenen Betrag.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public void Offset (System.Windows.Vector offsetVector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Offset(valuetype System.Windows.Vector offsetVector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Offset(System.Windows.Vector)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Offset (offsetVector As Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Offset(System::Windows::Vector offsetVector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetVector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="offsetVector">Ein Vektor, der die Beträge angibt, um die das Rechteck horizontal und vertikal verschoben werden soll.</param>
        <summary>Verschiebt das Rechteck um den angegebenen Vektor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode für ein leeres Rechteck (<xref:System.Windows.Rect.Empty%2A?displayProperty=nameWithType>) ist nicht zulässig.  
  
 Beachten Sie, dass der Aufruf der <xref:System.Windows.Rect.Offset%2A> Methode haben nur Auswirkungen, wenn Sie ändern können, die <xref:System.Windows.Rect.X%2A> und <xref:System.Windows.Rect.Y%2A> direkt auf Eigenschaften. Da <xref:System.Windows.Rect> ist ein Werttyp ist, wenn Sie verweisen auf eine <xref:System.Windows.Rect> Objekt mithilfe einer Eigenschaft oder der Indexer zu verwenden, erhalten Sie eine Kopie des Objekts, keinen Verweis auf das Objekt. Wenn Sie versuchen, ändern Sie <xref:System.Windows.Rect.X%2A> oder <xref:System.Windows.Rect.Y%2A> auf eine Eigenschaft oder einen Indexer ein Compilerfehler auftritt. Auf ähnliche Weise aufrufen <xref:System.Windows.Rect.Offset%2A> auf die Eigenschaft oder der Indexer ändert sich nicht das zugrunde liegende Objekt.  Wenn Sie den Wert ändern möchten eine <xref:System.Windows.Rect> , auf den als eine Eigenschaft oder einen Indexer verwiesen wird, erstellen Sie ein neues <xref:System.Windows.Rect>, ändern Sie die Felder, und weisen Sie ihm anschließend die <xref:System.Windows.Rect> zurück an die Eigenschaft oder der Indexer.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Offset%28System.Windows.Vector%29> Methode, um die Position eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#OffsetExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#offsetexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Methode wird für das <see cref="P:System.Windows.Rect.Empty" />-Rechteck aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public void Offset (double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Offset(float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Offset(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Offset (offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Offset(double offsetX, double offsetY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offsetX">Der Betrag, um den das Rechteck horizontal verschoben werden soll.</param>
        <param name="offsetY">Der Betrag, um den das Rechteck vertikal verschoben werden soll.</param>
        <summary>Verschiebt das Rechteck horizontal und vertikal um den jeweils angegebenen Betrag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode für ein leeres Rechteck (<xref:System.Windows.Rect.Empty%2A?displayProperty=nameWithType>) ist nicht zulässig.  
  
 Beachten Sie, dass der Aufruf der <xref:System.Windows.Rect.Offset%2A> Methode haben nur Auswirkungen, wenn Sie ändern können, die <xref:System.Windows.Rect.X%2A> und <xref:System.Windows.Rect.Y%2A> direkt auf Eigenschaften. Da <xref:System.Windows.Rect> ist ein Werttyp ist, wenn Sie verweisen auf eine <xref:System.Windows.Rect> Objekt mithilfe einer Eigenschaft oder der Indexer zu verwenden, erhalten Sie eine Kopie des Objekts, keinen Verweis auf das Objekt. Wenn Sie versuchen, ändern Sie <xref:System.Windows.Rect.X%2A> oder <xref:System.Windows.Rect.Y%2A> auf eine Eigenschaft oder einen Indexer ein Compilerfehler auftritt. Auf ähnliche Weise aufrufen <xref:System.Windows.Rect.Offset%2A> auf die Eigenschaft oder der Indexer ändert sich nicht das zugrunde liegende Objekt.  Wenn Sie den Wert ändern möchten eine <xref:System.Windows.Rect> , auf den als eine Eigenschaft oder einen Indexer verwiesen wird, erstellen Sie ein neues <xref:System.Windows.Rect>, ändern Sie die Felder, und weisen Sie ihm anschließend die <xref:System.Windows.Rect> zurück an die Eigenschaft oder der Indexer.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Offset%28System.Double%2CSystem.Double%29> Methode, um die Position eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#OffsetExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#offsetexample2_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Methode wird für das <see cref="P:System.Windows.Rect.Empty" />-Rechteck aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Offset (System.Windows.Rect rect, System.Windows.Vector offsetVector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Offset(valuetype System.Windows.Rect rect, valuetype System.Windows.Vector offsetVector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Offset(System::Windows::Rect rect, System::Windows::Vector offsetVector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
        <Parameter Name="offsetVector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="rect">Das ursprüngliche Rechteck.</param>
        <param name="offsetVector">Ein Vektor, der den horizontalen und den vertikalen Offset für das neue Rechteck angibt.</param>
        <summary>Gibt ein Rechteck zurück, das im Bezug auf das angegebene Rechteck um den angegebenen Vektor versetzt ist.</summary>
        <returns>Das sich ergebende Rechteck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf dieser Methode ein leeres Rechteck (<xref:System.Windows.Rect.Empty%2A?displayProperty=nameWithType>) ist nicht zulässig.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Offset%28System.Windows.Rect%2CSystem.Windows.Vector%29> Methode, um die Position eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#OffsetExample3_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#offsetexample3_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="rect" /> ist <see cref="P:System.Windows.Rect.Empty" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Offset (System.Windows.Rect rect, double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Offset(valuetype System.Windows.Rect rect, float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Offset(System::Windows::Rect rect, double offsetX, double offsetY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="rect">Das zu verschiebende Rechteck.</param>
        <param name="offsetX">Der horizontale Offset für das neue Rechteck.</param>
        <param name="offsetY">Der vertikale Offset für das neue Rechteck.</param>
        <summary>Gibt ein Rechteck zurück, das im Bezug auf das angegebene Rechteck um den angegebenen horizontalen und vertikalen Betrag versetzt ist.</summary>
        <returns>Das sich ergebende Rechteck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf dieser Methode ein leeres Rechteck (<xref:System.Windows.Rect.Empty%2A?displayProperty=nameWithType>) ist nicht zulässig.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Offset%28System.Windows.Rect%2CSystem.Double%2CSystem.Double%29> Methode, um die Position eines Rechtecks zu ändern.  
  
 [!code-csharp[RectExamples_snip#OffsetExample4_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#offsetexample4_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="rect" /> ist <see cref="P:System.Windows.Rect.Empty" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Rect rect1, System.Windows.Rect rect2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.Rect rect1, valuetype System.Windows.Rect rect2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (rect1 As Rect, rect2 As Rect) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Rect rect1, System::Windows::Rect rect2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect1" Type="System.Windows.Rect" />
        <Parameter Name="rect2" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect1">Das erste der zu vergleichenden Rechtecke.</param>
        <param name="rect2">Das zweite der zu vergleichenden Rechtecke.</param>
        <summary>Vergleicht zwei Rechtecke auf genaue Übereinstimmung.</summary>
        <returns>
          <see langword="true" />, wenn die Rechtecke über den gleichen <see cref="P:System.Windows.Rect.Location" />-Wert und <see cref="P:System.Windows.Rect.Size" />-Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang überprüft auf Objektgleichheit.  
  
 In diesem Vergleich, zwei Instanzen von <xref:System.Double.NaN?displayProperty=nameWithType> als gleich betrachtet werden.  
  
> [!NOTE]
>  Position und Abmessungen des Rechtecks sind durch beschrieben <xref:System.Double> Werte. Da <xref:System.Double> Werte abnehmen können, wenn Sie bearbeitet, fehlschlagen, ein Vergleich zwischen zwei Werten, die logisch gleich sind.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Windows.Rect.Equals%28System.Windows.Rect%2CSystem.Windows.Rect%29?displayProperty=nameWithType>  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.op_Equality%2A> Operator, um zu bestimmen, ob zwei Rechtecke genau gleich sind.  
  
 [!code-csharp[RectExamples_snip#OverloadedEqualityOperatorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#overloadedequalityoperatorexample)]
 [!code-vb[RectExamples_snip#OverloadedEqualityOperatorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RectExamples_snip/visualbasic/rectexample.vb#overloadedequalityoperatorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Rect rect1, System.Windows.Rect rect2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.Rect rect1, valuetype System.Windows.Rect rect2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (rect1 As Rect, rect2 As Rect) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Rect rect1, System::Windows::Rect rect2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect1" Type="System.Windows.Rect" />
        <Parameter Name="rect2" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect1">Das erste der zu vergleichenden Rechtecke.</param>
        <param name="rect2">Das zweite der zu vergleichenden Rechtecke.</param>
        <summary>Vergleicht zwei Rechtecke auf Ungleichheit.</summary>
        <returns>
          <see langword="true" />, wenn die Rechtecke nicht über den gleichen <see cref="P:System.Windows.Rect.Location" />-Wert und <see cref="P:System.Windows.Rect.Size" />-Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang prüft auf Ungleichheit Objekt.  
  
 In diesem Vergleich, zwei Instanzen von <xref:System.Double.NaN?displayProperty=nameWithType> als gleich betrachtet werden.  
  
> [!NOTE]
>  Position und Abmessungen des Rechtecks sind durch beschrieben <xref:System.Double> Werte. Da <xref:System.Double> Werte abnehmen können, wenn Sie bearbeitet, fehlschlagen, ein Vergleich zwischen zwei Werten, die logisch gleich sind.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Windows.Rect.Equals%28System.Windows.Rect%2CSystem.Windows.Rect%29?displayProperty=nameWithType>  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.op_Inequality%2A> Operator, um zu bestimmen, ob zwei Rechtecke nicht genau gleich sind.  
  
 [!code-csharp[RectExamples_snip#OverloadedInequalityOperatorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#overloadedinequalityoperatorexample)]
 [!code-vb[RectExamples_snip#OverloadedInequalityOperatorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RectExamples_snip/visualbasic/rectexample.vb#overloadedinequalityoperatorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Parse (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Parse(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (source As String) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Parse(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Die Zeichenfolgendarstellung des Rechtecks im Format "x, y, Breite, Höhe".</param>
        <summary>Erstellt ein neues Rechteck aus der angegebenen Zeichenfolgendarstellung.</summary>
        <returns>Das sich ergebende Rechteck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Parse%2A> Methode, um eine Darstellung eines Rechtecks in Konvertieren einer <xref:System.Windows.Rect> Struktur.  
  
 [!code-csharp[RectExamples_snip#ParseExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#parseexample)]
 [!code-vb[RectExamples_snip#ParseExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RectExamples_snip/visualbasic/rectexample.vb#parseexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public double Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Right { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den x-Achsen-Wert des rechten Rands des Rechtecks ab.</summary>
        <value>Der x-Achsen-Wert des rechten Rands des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der x-Achsen-Wert, der der rechten Seite des Rechtecks ist gleich der Summe der <xref:System.Windows.Rect.X%2A> und <xref:System.Windows.Rect.Width%2A> Eigenschaften.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (double scaleX, double scaleY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float64 scaleX, float64 scaleY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Scale(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (scaleX As Double, scaleY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(double scaleX, double scaleY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">Der Skalierungsfaktor in x-Richtung.</param>
        <param name="scaleY">Der Skalierungsfaktor in y-Richtung.</param>
        <summary>Multipliziert die Größe des aktuellen Rechtecks mit dem angegeben x-Wert und y-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Scale%2A> Methode, um die Breite und Höhe eines Rechtecks um den angegebenen Betrag zu multiplizieren.  
  
 [!code-csharp[RectExamples_snip#ScaleExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#scaleexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.Inflate(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Windows.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size Size { System::Windows::Size get(); void set(System::Windows::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe und Breite des Rechtecks ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Windows.Size" />-Struktur, die die Breite und Höhe des Rechtecks angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Rect.Size" /> ist auf ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Das zu verwendende Format.  
  
 - oder -   
  
 Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic), wenn das für den Typ der <see cref="T:System.IFormattable" /> -Implementierung definierte Standardformat verwendet werden soll.</param>
        <param name="provider">Der zum Formatieren des Werts zu verwendende Anbieter.  
  
 - oder -   
  
 Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic), wenn die Informationen über numerische Formate dem aktuellen Gebietsschema des Betriebssystems entnommen werden sollen.</param>
        <summary>Formatiert den Wert der aktuellen Instanz mit dem angegebenen Format.</summary>
        <returns>Eine Zeichenfolgendarstellung des Rechtecks.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Rect>-Instanz in eine <xref:System.IFormattable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IFormattable" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Top" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die y-Achsen-Position des oberen Rands des Rechtecks ab.</summary>
        <value>Die y-Achsen-Position des oberen Rands des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Abrufen dieser Eigenschaft entspricht dem Abrufen der <xref:System.Windows.Rect.Y%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Rect.Y" />
      </Docs>
    </Member>
    <Member MemberName="TopLeft">
      <MemberSignature Language="C#" Value="public System.Windows.Point TopLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point TopLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.TopLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLeft As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point TopLeft { System::Windows::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der linken oberen Ecke des Rechtecks ab.</summary>
        <value>Die Position der linken oberen Ecke des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position der oberen linken Ecke des Rechtecks ist gleich (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopRight">
      <MemberSignature Language="C#" Value="public System.Windows.Point TopRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point TopRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.TopRight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopRight As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point TopRight { System::Windows::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der rechten oberen Ecke des Rechtecks ab.</summary>
        <value>Die Position der rechten oberen Ecke des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position der oberen rechten Ecke des Rechtecks ist gleich (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>, <xref:System.Windows.Rect.Y%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung des Rechtecks zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung des Rechtecks zurück.</summary>
        <returns>Eine Zeichenfolgendarstellung des aktuellen Rechtecks. Die Zeichenfolge weist das folgende Format auf: "<see cref="P:System.Windows.Rect.X" />,<see cref="P:System.Windows.Rect.Y" />,<see cref="P:System.Windows.Rect.Width" />,<see cref="P:System.Windows.Rect.Height" />".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.ToString> eine Zeichenfolgendarstellung der abzurufenden Methode eine <xref:System.Windows.Rect> Struktur.  
  
 [!code-csharp[RectExamples_snip#ToStringExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#tostringexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Kulturspezifische Formatierungsinformationen.</param>
        <summary>Gibt mithilfe des angegebenen Formatanbieters eine Zeichenfolgendarstellung des Rechtecks zurück.</summary>
        <returns>Eine Zeichenfolgendarstellung des aktuellen Rechtecks, die vom angegebenen Formatanbieter bestimmt wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transform">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Transformiert ein Rechteck mithilfe der angegebenen Matrix.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Transform(System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Windows::Media::Matrix matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Eine Matrix, die die anzuwendende Transformation angibt.</param>
        <summary>Transformiert das Rechteck durch Anwenden der angegebenen Matrix.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Transform%28System.Windows.Media.Matrix%29> -Methode zum Transformieren einer <xref:System.Windows.Rect> Struktur mithilfe einer <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[RectExamples_snip#TransformExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#transformexample1_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Transform (System.Windows.Rect rect, System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Transform(valuetype System.Windows.Rect rect, valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Transform(System::Windows::Rect rect, System::Windows::Media::Matrix matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="rect">Ein Rechteck, das die Grundlage für die Transformation darstellt.</param>
        <param name="matrix">Eine Matrix, die die anzuwendende Transformation angibt.</param>
        <summary>Gibt das Rechteck zurück, das sich durch das Anwenden der angegebenen Matrix auf das angegebene Rechteck ergibt.</summary>
        <returns>Das Rechteck, das sich aus der Operation ergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Transform%28System.Windows.Rect%2CSystem.Windows.Media.Matrix%29> Methode zum Erstellen eines neuen <xref:System.Windows.Rect> -Struktur, die aus der Anwendung führt eine <xref:System.Windows.Media.Matrix> auf ein vorhandenes Rechteck.  
  
 [!code-csharp[RectExamples_snip#TransformExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#transformexample2_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Rechteck, das genau groß genug ist, um ein angegebenes Rechteck und einen angegebenen Punkt oder ein zweites Rechteck einzuschließen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public void Union (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Union(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Union(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Union(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der einzuschließende Punkt.</param>
        <summary>Erweitert das aktuelle Rechteck genau so weit, dass es den angegebenen Punkt einschließt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Union%28System.Windows.Point%29> Methode, um das aktuelle Rechteck genau genug erweitert werden, enthalten einen bestimmten <xref:System.Windows.Point>.  
  
 [!code-csharp[RectExamples_snip#UnionExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#unionexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.Contains(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public void Union (System.Windows.Rect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Union(valuetype System.Windows.Rect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Union(System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Union(System::Windows::Rect rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect">Das einzuschließende Rechteck.</param>
        <summary>Erweitert das aktuelle Rechteck genau so weit, dass es das angegebene Rechteck einschließt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Union%28System.Windows.Rect%29> Methode, um das aktuelle Rechteck genau genug zu erweitern, auf das angegebene Rechteck enthalten.  
  
 [!code-csharp[RectExamples_snip#UnionExample2_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#unionexample2_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.Contains(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Union (System.Windows.Rect rect, System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Union(valuetype System.Windows.Rect rect, valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Union(System::Windows::Rect rect, System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Windows.Rect" />
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="rect">Das einzuschließende Rechteck.</param>
        <param name="point">Der einzuschließende Punkt.</param>
        <summary>Erstellt ein Rechteck, das genau groß genug ist, um das angegebene Rechteck und den angegebenen Punkt einzuschließen.</summary>
        <returns>Ein Rechteck, das genau groß genug ist, um das angegebene Rechteck und den angegebenen Punkt einzuschließen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Union%28System.Windows.Rect%2CSystem.Windows.Point%29> Methode, um ein Rechteck zu erstellen, die genau groß genug ist, für einen angegebenen Rechteck enthalten ist und eine angegebene <xref:System.Windows.Point>.  
  
 [!code-csharp[RectExamples_snip#UnionExample3_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#unionexample3_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.Contains(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Windows.Rect Union (System.Windows.Rect rect1, System.Windows.Rect rect2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Rect Union(valuetype System.Windows.Rect rect1, valuetype System.Windows.Rect rect2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Union (rect1 As Rect, rect2 As Rect) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Rect Union(System::Windows::Rect rect1, System::Windows::Rect rect2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect1" Type="System.Windows.Rect" />
        <Parameter Name="rect2" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="rect1">Das erste einzuschließende Rechteck.</param>
        <param name="rect2">Das zweite einzuschließende Rechteck.</param>
        <summary>Erstellt ein Rechteck, das genau groß genug ist, um die beiden angegebenen Rechtecke einzuschließen.</summary>
        <returns>Das sich ergebende Rechteck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Rect.Union%28System.Windows.Rect%2CSystem.Windows.Rect%29> Methode, um ein Rechteck zu erstellen, die genau groß genug ist, für die zwei angegebenen Rechtecke enthalten ist.  
  
 [!code-csharp[RectExamples_snip#UnionExample4_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#unionexample4_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Rect.Contains(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Rechtecks ab bzw. legt diese fest.</summary>
        <value>Eine positive Zahl, die die Breite des Rechtecks darstellt. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Rect.Empty%2A> Rechteck hat eine <xref:System.Windows.Rect.Width%2A> von <xref:System.Double.NegativeInfinity>. Die <xref:System.Windows.Rect.Empty%2A> Rechteck ist schreibgeschützt; die <xref:System.Windows.Rect.Width%2A> kann nicht geändert werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Rect.Width" /> ist auf einen negativen Wert festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Rect.Width" /> ist auf ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck festgelegt.</exception>
        <altmember cref="P:System.Windows.Rect.Height" />
      </Docs>
    </Member>
    <Member MemberName="X">
      <MemberSignature Language="C#" Value="public double X { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 X" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.X" />
      <MemberSignature Language="VB.NET" Value="Public Property X As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double X { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den x-Achsen-Wert des linken Rands des Rechtecks ab oder legt ihn fest.</summary>
        <value>Der x-Achsen-Wert des linken Rands des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Abrufen dieser Eigenschaft entspricht dem Abrufen der <xref:System.Windows.Rect.Left%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Rect.X" /> ist auf ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck festgelegt.</exception>
        <altmember cref="P:System.Windows.Rect.Y" />
      </Docs>
    </Member>
    <Member MemberName="Y">
      <MemberSignature Language="C#" Value="public double Y { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Y" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Rect.Y" />
      <MemberSignature Language="VB.NET" Value="Public Property Y As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Y { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den y-Achsen-Wert des oberen Rands des Rechtecks ab oder legt ihn fest.</summary>
        <value>Der y-Achsen-Wert des oberen Rands des Rechtecks.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Abrufen dieser Eigenschaft entspricht dem Abrufen der <xref:System.Windows.Rect.Top%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Rect> Struktur, die die Abmessungen und Position eines Rechtecks mit XAML angeben.  
  
 [!code-csharp[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/CSharp/RectExample.cs#rectexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/visualbasic/rectexample.vb#rectexamplewholepage)]
 [!code-xaml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/samples/snippets/xaml/VS_Snippets_Wpf/GeometriesMiscSnippets_snip/XAML/RectExample.xaml#rectexamplewholepage)]  
  
 Das folgende Beispiel zeigt, wie Sie per Code erstellen Sie ein Rechteck, und fügen es auf der Seite. Das Beispiel veranschaulicht auch zum Suchen von Größe und Informationen über das neue Rechteck und Rendern der Informationen in einem <xref:System.Windows.Controls.TextBox> unter dem Rechteck.  
  
 [!code-csharp[RectExamples_snip#CreateRectExample1_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/RectExamples_snip/CSharp/RectExample.cs#createrectexample1_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Rect.Y" /> ist auf ein <see cref="P:System.Windows.Rect.Empty" />-Rechteck festgelegt.</exception>
        <altmember cref="P:System.Windows.Rect.X" />
      </Docs>
    </Member>
  </Members>
</Type>