<Type Name="PresentationSource" FullName="System.Windows.PresentationSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ea36a93ff6ae745d56d21945e9a038cf38cd816d" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77221611" /></Metadata><TypeSignature Language="C#" Value="public abstract class PresentationSource : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract PresentationSource extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PresentationSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PresentationSource&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class PresentationSource abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type PresentationSource = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine abstrakte Basisklasse für Klassen dar, die Inhalte aus einer anderen Technologie als Teil eines Interoperationsszenarios präsentieren. Darüber hinaus stellt diese Klasse statische Methoden für die Arbeit mit diesen Quellen bereit sowie die grundlegende Architektur für die Darstellung eines visuellen Layers.</summary>
    <remarks>To be added.</remarks>
    <altmember cref="T:System.Windows.Interop.HwndSource" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PresentationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PresentationSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Stellt beim Aufruf durch den Konstruktor einer abgeleiteten Klasse die Initialisierung für Basisklassenwerte bereit.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSource">
      <MemberSignature Language="C#" Value="protected void AddSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.AddSource" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddSource ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddSource();" />
      <MemberSignature Language="F#" Value="member this.AddSource : unit -&gt; unit" Usage="presentationSource.AddSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt der Liste bekannter Präsentationsquellen eine abgeleitete Instanz der <see cref="T:System.Windows.PresentationSource" />-Klasse hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte von abgeleiteten Klassen aufgerufen werden, um anzugeben, dass Sie nachverfolgt werden müssen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSourceChangedHandler">
      <MemberSignature Language="C#" Value="public static void AddSourceChangedHandler (System.Windows.IInputElement element, System.Windows.SourceChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddSourceChangedHandler(class System.Windows.IInputElement element, class System.Windows.SourceChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.AddSourceChangedHandler(System.Windows.IInputElement,System.Windows.SourceChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddSourceChangedHandler (element As IInputElement, handler As SourceChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddSourceChangedHandler(System::Windows::IInputElement ^ element, System::Windows::SourceChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddSourceChangedHandler : System.Windows.IInputElement * System.Windows.SourceChangedEventHandler -&gt; unit" Usage="System.Windows.PresentationSource.AddSourceChangedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="handler" Type="System.Windows.SourceChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, dem der Handler hinzugefügt werden soll.</param>
        <param name="handler">Die Implementierung des Handlers, die hinzugefügt werden soll.</param>
        <summary>Fügt dem bereitgestellten Element einen Handler für das <see langword="SourceChanged" />-Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ungeachtet dessen, was der Syntax Block für dieses Ereignis angibt, gibt es keine legitime [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Verwendung angefügter Eigenschaften. Sie sollten nicht versuchen, Handler in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]hinzuzufügen, und Handler im Code sollten nur in Objekten platziert werden, die als Hosts für Präsentations Inhalte (<xref:System.Windows.PresentationSource>) fungieren. Solche Handler sollten nur während der Objekt Initialisierung angefügt werden und sollten explizit in einer Löschmethode oder einer gleichwertigen Objekt Bereinigung entfernt werden.  
  
 Obwohl es sich hierbei um ein Routing Ereignis handelt, gibt es besondere Einschränkungen für dieses Ereignis, die sich vom normalen Routing Ereignis Verhalten unterscheiden, aufgrund der relativ kleinen Anzahl von Elementen in einem typischen Anwendungsszenario, die sich auf die Behandlung dieses Problems beziehen. Veranstalter.  
  
-   Sie können die Methoden <xref:System.Windows.UIElement> oder <xref:System.Windows.ContentElement> <xref:System.Windows.UIElement.AddHandler%2A> nicht zum Hinzufügen von Handlern verwenden. Hierzu muss <xref:System.Windows.PresentationSource.AddSourceChangedHandler%2A> verwendet werden.  
  
-   Die C# `+=`-und `-=` Ereignishandlersyntax und zugehörige sprachspezifische handlersyntaxen werden nicht unterstützt, da das Ereignis selbst nicht als öffentlich verfügbar gemacht wird. Nur die Methoden des <xref:System.Windows.PresentationSource>-Hilfsprogramms zum direkten hinzufügen und Entfernen von Handlern werden unterstützt.  
  
-   Klassen Handler sind nicht zulässig. Insbesondere können Sie <xref:System.Windows.EventManager.RegisterClassHandler%2A> nicht für dieses Ereignis in einem Klassenkonstruktor aufrufen, weil ein Bezeichnerfeld für SourceChanged vorhanden ist, aber der Bezeichner nicht öffentlich ist.  
  
-   Alle registrierten Handler empfangen das SourceChanged-Ereignis auch dann, wenn einer der Handler versucht, die Argumente als behandelt zu markieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearContentRenderedListeners">
      <MemberSignature Language="C#" Value="protected void ClearContentRenderedListeners ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearContentRenderedListeners() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.ClearContentRenderedListeners" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearContentRenderedListeners ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearContentRenderedListeners();" />
      <MemberSignature Language="F#" Value="member this.ClearContentRenderedListeners : unit -&gt; unit" Usage="presentationSource.ClearContentRenderedListeners " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Liste mit Listenern für das <see cref="E:System.Windows.PresentationSource.ContentRendered" />-Ereignis auf <see langword="null" /> fest.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.PresentationSource.ContentRendered" />
      </Docs>
    </Member>
    <Member MemberName="CompositionTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CompositionTarget CompositionTarget { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CompositionTarget CompositionTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.CompositionTarget" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositionTarget As CompositionTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CompositionTarget ^ CompositionTarget { System::Windows::Media::CompositionTarget ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositionTarget : System.Windows.Media.CompositionTarget" Usage="System.Windows.PresentationSource.CompositionTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das visuelle Ziel für die Elemente ab, die in der Quelle angezeigt werden.</summary>
        <value>Ein visuelles Ziel (Instanz einer abgeleiteten <see cref="T:System.Windows.Media.CompositionTarget" />-Klasse).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert dieser Eigenschaft basiert auf einer Implementierung von <xref:System.Windows.PresentationSource.GetCompositionTargetCore%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Abgeleitete Klassen können diese Eigenschaft als Schatten festlegen, um einen typspezifischen Wert anzubieten.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.PresentationSource.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ContentRendered As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Inhalt gerendert wurde und für Benutzerinteraktionen bereit ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentSources">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable CurrentSources { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IEnumerable CurrentSources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.CurrentSources" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentSources As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IEnumerable ^ CurrentSources { System::Collections::IEnumerable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSources : System.Collections.IEnumerable" Usage="System.Windows.PresentationSource.CurrentSources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine Quellenliste zurück.</summary>
        <value>Eine Liste schwacher Verweise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Liste unterstützt einen Enumerator über eine schreibgeschützte Thread sichere Kopie der Quellenliste, die mit <xref:System.Windows.PresentationSource.AddSource%2A>hinzugefügt wurde.  
  
 Der Enumerator überspringt alle unzustellbaren schwachen Verweise in der Liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromDependencyObject">
      <MemberSignature Language="C#" Value="public static System.Windows.PresentationSource FromDependencyObject (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PresentationSource FromDependencyObject(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.FromDependencyObject(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PresentationSource ^ FromDependencyObject(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member FromDependencyObject : System.Windows.DependencyObject -&gt; System.Windows.PresentationSource" Usage="System.Windows.PresentationSource.FromDependencyObject dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PresentationSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Das <see cref="T:System.Windows.DependencyObject" />, für den die Quelle gesucht werden soll.</param>
        <summary>Gibt die Quelle zurück, in der eine bereitgestellte <see cref="T:System.Windows.DependencyObject" />-Klasse präsentiert wird.</summary>
        <returns>Die <see cref="T:System.Windows.PresentationSource" />, in der das Abhängigkeitsobjekt präsentiert wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromVisual">
      <MemberSignature Language="C#" Value="public static System.Windows.PresentationSource FromVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PresentationSource FromVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.FromVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PresentationSource ^ FromVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="static member FromVisual : System.Windows.Media.Visual -&gt; System.Windows.PresentationSource" Usage="System.Windows.PresentationSource.FromVisual visual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PresentationSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Das <see cref="T:System.Windows.Media.Visual" />, für den die Quelle gesucht werden soll.</param>
        <summary>Gibt die Quelle zurück, in der eine bereitgestellte <see cref="T:System.Windows.Media.Visual" />-Klasse präsentiert wird.</summary>
        <returns>Die <see cref="T:System.Windows.PresentationSource" />, in der das visuelle Element präsentiert wird, oder <see langword="null" />, wenn <paramref name="visual" /> freigegeben wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="visual" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCompositionTargetCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Media.CompositionTarget GetCompositionTargetCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.CompositionTarget GetCompositionTargetCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.GetCompositionTargetCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetCompositionTargetCore () As CompositionTarget" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Media::CompositionTarget ^ GetCompositionTargetCore();" />
      <MemberSignature Language="F#" Value="abstract member GetCompositionTargetCore : unit -&gt; System.Windows.Media.CompositionTarget" Usage="presentationSource.GetCompositionTargetCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse ein visuelles Ziel für die angegebene Quelle zurück.</summary>
        <returns>Gibt ein <see cref="T:System.Windows.Media.CompositionTarget" /> als Ziel für das Rendern des visuellen Objekts zurück.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Überschreiben Sie diese Methode, um den Wert zu deklarieren, den die <see cref="P:System.Windows.PresentationSource.CompositionTarget" /> schreibgeschützte Eigenschaft zurückgibt.  
  
Ihre außer Kraft Setzung sollte typspezifische Instanzen der <see cref="T:System.Windows.Media.CompositionTarget" /> abgeleiteten Klassentyp zurückgeben, die für das Interoperation-Szenario verwendet werden.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public abstract bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.PresentationSource.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob das Objekt verworfen wird.</summary>
        <value><see langword="true" />, wenn das Objekt freigegeben wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Es wird erwartet, dass abgeleitete Klassen <see cref="T:System.IDisposable" /> implementieren oder ein entsprechendes Verhalten bereitstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RemoveSource">
      <MemberSignature Language="C#" Value="protected void RemoveSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.RemoveSource" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveSource ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveSource();" />
      <MemberSignature Language="F#" Value="member this.RemoveSource : unit -&gt; unit" Usage="presentationSource.RemoveSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt eine abgeleitete Instanz der <see cref="T:System.Windows.PresentationSource" />-Klasse aus der Liste bekannter Präsentationsquellen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSourceChangedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveSourceChangedHandler (System.Windows.IInputElement e, System.Windows.SourceChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveSourceChangedHandler(class System.Windows.IInputElement e, class System.Windows.SourceChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.RemoveSourceChangedHandler(System.Windows.IInputElement,System.Windows.SourceChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveSourceChangedHandler (e As IInputElement, handler As SourceChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveSourceChangedHandler(System::Windows::IInputElement ^ e, System::Windows::SourceChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveSourceChangedHandler : System.Windows.IInputElement * System.Windows.SourceChangedEventHandler -&gt; unit" Usage="System.Windows.PresentationSource.RemoveSourceChangedHandler (e, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.IInputElement" />
        <Parameter Name="handler" Type="System.Windows.SourceChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="e">Das Element, aus dem der Handler entfernt wird.</param>
        <param name="handler">Die Implementierung des Handlers, die entfernt wird.</param>
        <summary>Entfernt einen Handler für das <see langword="SourceChanged" />-Ereignis aus dem bereitgestellten Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl es sich hierbei um ein Routing Ereignis handelt, gibt es besondere Einschränkungen für dieses Ereignis, die sich vom normalen Routing Ereignis Verhalten unterscheiden, aufgrund der relativ kleinen Anzahl von Elementen in einem typischen Anwendungsszenario, die sich auf die Behandlung dieses Problems beziehen. Veranstalter.  
  
-   Sie können die <xref:System.Windows.UIElement>-oder <xref:System.Windows.ContentElement> <xref:System.Windows.UIElement.RemoveHandler%2A>-Methoden nicht zum Entfernen von Handlern verwenden. Hierzu muss <xref:System.Windows.PresentationSource.RemoveSourceChangedHandler%2A> verwendet werden.  
  
-   Die C# `+=`-und `-=`-Ereignishandlersyntax und andere sprachspezifische handlersyntaxen werden nicht unterstützt, da das Ereignis selbst nicht als öffentlich verfügbar gemacht wird. Nur die Methoden des <xref:System.Windows.PresentationSource>-Hilfsprogramms zum direkten hinzufügen und Entfernen von Handlern werden unterstützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PresentationSource.AddSourceChangedHandler(System.Windows.IInputElement,System.Windows.SourceChangedEventHandler)" />
      </Docs>
    </Member>
    <Member MemberName="RootChanged">
      <MemberSignature Language="C#" Value="protected void RootChanged (System.Windows.Media.Visual oldRoot, System.Windows.Media.Visual newRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RootChanged(class System.Windows.Media.Visual oldRoot, class System.Windows.Media.Visual newRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.RootChanged(System.Windows.Media.Visual,System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RootChanged (oldRoot As Visual, newRoot As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RootChanged(System::Windows::Media::Visual ^ oldRoot, System::Windows::Media::Visual ^ newRoot);" />
      <MemberSignature Language="F#" Value="member this.RootChanged : System.Windows.Media.Visual * System.Windows.Media.Visual -&gt; unit" Usage="presentationSource.RootChanged (oldRoot, newRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldRoot" Type="System.Windows.Media.Visual" />
        <Parameter Name="newRoot" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="oldRoot">Die alte <see cref="T:System.Windows.Media.Visual" />-Stammklasse.</param>
        <param name="newRoot">Die neue <see cref="T:System.Windows.Media.Visual" />-Stammklasse.</param>
        <summary>Stellt Benachrichtigung über Änderungen der <see cref="T:System.Windows.Media.Visual" />-Stammklasse bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen sollten diese Methode aufgerufen werden, um anzugeben, dass sich deren Stamm <xref:System.Windows.Media.Visual> geändert hat.  
  
 Wenn diese Methode aufgerufen wird, werden zwei Objekt Lebensdauer-Ereignisse für die angegebenen visuellen Stamm Elemente ausgelöst, wenn dies nur dann der Fall ist, wenn diese visuellen Elemente <xref:System.Windows.FrameworkElement> abgeleiteten Klassen sind.  
  
-   Das alte visuelle Stamm Element hebt das <xref:System.Windows.FrameworkElement.Unloaded>-Ereignis auf und verarbeitet seine Struktur von Elementen nach unten, wobei dieses Ereignis an jedes untergeordnete Element gesendet wird.  
  
-   Das neue visuelle Stamm Element hebt das <xref:System.Windows.FrameworkElement.Loaded>-Ereignis auf und verarbeitet seine Struktur von Elementen nach unten, wobei dieses Ereignis an jedes untergeordnete Element gesendet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootVisual">
      <MemberSignature Language="C#" Value="public abstract System.Windows.Media.Visual RootVisual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual RootVisual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.RootVisual" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property RootVisual As Visual" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Windows::Media::Visual ^ RootVisual { System::Windows::Media::Visual ^ get(); void set(System::Windows::Media::Visual ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RootVisual : System.Windows.Media.Visual with get, set" Usage="System.Windows.PresentationSource.RootVisual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse das Stammelement ab, das in der Quelle angezeigt wird, oder legt dieses fest.</summary>
        <value>Das Stammelement.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
