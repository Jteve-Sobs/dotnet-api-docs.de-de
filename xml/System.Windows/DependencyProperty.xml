<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0129b0c47acecd870bafaaa4655db115fee937a4" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55372655" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Eigenschaft dar, die durch Methoden festgelegt werden kann, z. B. Formatierung, Datenbindung, Animation und Vererbung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyProperty> unterstützt die folgenden Funktionen in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Die Eigenschaft kann in einem Stil festgelegt werden. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Die Eigenschaft kann über die Datenbindung festgelegt werden. Weitere Informationen zur Datenbindung mit Abhängigkeitseigenschaften finden Sie unter [Vorgehensweise: Binden der Eigenschaften von zwei Steuerelementen](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Die Eigenschaft kann mit einem dynamischen Ressourcenverweis festgelegt werden. Weitere Informationen finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Die Eigenschaft kann den Wert automatisch von einem übergeordneten Element in der Elementstruktur erben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Die Eigenschaft kann animiert werden. Weitere Informationen finden Sie unter [Übersicht über Animation](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Die Eigenschaft kann melden, wenn der vorherige Wert der Eigenschaft geändert wurde und den Wert der Eigenschaft umgewandelt werden kann. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Die Eigenschaft meldet Informationen zu [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], z. B., ob Ändern eines Eigenschaftswerts das Layoutsystem die visuellen Objekte für ein Element Zertifikatsinfrastruktur mehr erforderlich ist.  
  
-   Die Eigenschaft empfängt-Unterstützung in den [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Beispielsweise kann die Eigenschaft bearbeitet werden, der **Eigenschaften** Fenster.  
  
 Weitere Informationen zu Abhängigkeitseigenschaften finden Sie unter [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Wenn Sie Eigenschaften für die benutzerdefinierten Typen zur Unterstützung von Funktionen in der vorangehenden Liste wünschen, sollten Sie eine Abhängigkeitseigenschaft erstellen.  Vorgehensweise: Erstellen von benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter [benutzerdefinierte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Eine angefügte Eigenschaft ist eine Eigenschaft, mit der jedes beliebige Objekt an den Informationen in den Typ, der die angefügte Eigenschaft definiert. In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], jeder Typ, der von erbt <xref:System.Windows.DependencyObject> können unabhängig davon, ob der Typ vom Typ erbt, die die Eigenschaft definiert eine angefügte Eigenschaft. Eine angefügte Eigenschaft ist ein Feature von der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sprache.  Eine angefügte Eigenschaft festlegen, in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], verwenden Sie die *Besitzertyp*. *PropertyName* Syntax. Ein Beispiel für eine angefügte Eigenschaft ist die <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Eigenschaft. Wenn eine Eigenschaft zu erstellen, die auf allen verwendet werden können sollen <xref:System.Windows.DependencyObject> eingibt, dann sollten Sie eine angefügte Eigenschaft erstellen. Weitere Informationen zu angefügten Eigenschaften, einschließlich Informationen zum Erstellen, finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `dependencyPropertyName`  
 Eine Zeichenfolge, der angibt, die <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> der gewünschten Abhängigkeitseigenschaft. Dies kann vorangestellt werden ein XML-Namespacepräfix, wenn die Eigenschaft nicht in der XML-Standardnamespace ist (Weitere Informationen finden Sie unter [XAML-Namespaces und Namespace-Zuordnung für WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Eine Zeichenfolge, die eines Besitzertyps für eine Abhängigkeitseigenschaft, der einen Punkt (.) gibt an, und klicken Sie dann die <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` kann auch ein XML-Namespacepräfix vorangestellt werden. Diese Verwendung ist speziell für spät gebundene-Stile und Vorlagen, der Besitzer der Abhängigkeitseigenschaft angegeben werden, muss für die Analyse von Kontext, da die `TargetType` ist noch nicht bekannt. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Eine Zeichenfolge, die den Besitzer einer angefügten Eigenschaft, ein Punkt (.) und dann den Namen der angefügten Eigenschaft angibt. `attachedPropertyOwnerType` kann auch ein XML-Namespacepräfix vorangestellt werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits für einen Typ registriert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Der Typ, der als ein Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</param>
        <summary>Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde.</summary>
        <returns>Ein Verweis auf den ursprünglichen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner, der die Abhängigkeitseigenschaft angibt. Dieser Bezeichner sollte von der hinzufügenden Klasse als <see langword="public static readonly" />-Feld verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht das Eigenschaftensystem Abhängigkeitseigenschaft für einen Typ zu erkennen, die nicht diese Abhängigkeitseigenschaft ursprünglich registriert hat.  
  
 In der Regel <xref:System.Windows.DependencyProperty.AddOwner%2A> wird verwendet, um Abhängigkeitseigenschaften Klassen hinzufügen, die nicht bereits die Abhängigkeitseigenschaft über Vererbung von verwalteten Klasse verfügbar machen (klassenvererbung würde dazu führen, dass die Wrappereigenschaften, die von der abgeleiteten Klasse geerbt werden und somit wird allgemein Membertabelle bietet Zugriff auf die Abhängigkeitseigenschaft bereits). <xref:System.Windows.DependencyProperty.AddOwner%2A> ermöglicht das Eigenschaftensystem Abhängigkeitseigenschaft für einen Typ zu erkennen, die nicht die Abhängigkeitseigenschaft ursprünglich registriert hat.  
  
 Diese Signatur lässt sich nicht zum Angeben von Metadaten.  Wenn Sie diese Methode verwenden, wird die Metadaten automatisch für die neue generiert <xref:System.Windows.DependencyProperty> und ihren Besitzertyp. Die automatisch generierten Metadaten ist das Ergebnis der zusammengeführten Metadaten aller Basistypen, die diese Eigenschaft definiert haben. Wenn keine zusammengeführte Metadaten verfügbar ist, wird die Standardmetadaten für die Eigenschaft verwendet. Wenn die Eigenschaft, mithilfe registriert ist der <xref:System.Windows.DependencyProperty.RegisterAttached%2A> -Methode, und klicken Sie dann auf die Standardmetadaten, ist identisch mit den Metadaten, die erstellt wird <xref:System.Windows.DependencyProperty.RegisterAttached%2A> aufgerufen wurde. Andernfalls die <xref:System.Windows.PropertyMetadata> -Objekt wird erstellt, mit der <xref:System.Windows.PropertyMetadata.DefaultValue%2A> -Eigenschaft auf den Standardwert für den Eigenschaftentyp und alle anderen Eigenschaften festgelegt die <xref:System.Windows.PropertyMetadata> nastaven NA hodnotu `null`. Verwenden der <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> Signatur, wenn Metadaten für die Version der Abhängigkeitseigenschaft bereitgestellt, wie in den bereitgestellten Typ hinzugefügt werden sollen.  
  
 Der Rückgabewert dieser Methode wird in der Regel zum Deklarieren und einzugehen, die Abhängigkeitseigenschaft Bezeichner einer Abhängigkeitseigenschaft. Der Bezeichner bietet Zugriff auf die Abhängigkeitseigenschaft, wenn das Eigenschaftensystem aufgerufen werden soll [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] auf die hinzufügende Besitzerklasse für die Abhängigkeitseigenschaft, insbesondere, wenn er vorhanden. Der gleiche Name für den ursprünglichen Besitzer und hinzugefügte Benutzer sollte verwendet werden, die ähnliche Funktionen an. Verwenden Sie die <xref:System.Windows.DependencyProperty> Rückgabewert der <xref:System.Windows.DependencyProperty.AddOwner%2A> Methode der Bezeichner der Abhängigkeitseigenschaft definieren, sowie zum Deklarieren [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Die <xref:System.Windows.DependencyProperty.AddOwner%2A> oben empfohlenen Methode wird verwendet, wenn es sich bei Erstellen von Abhängigkeitseigenschaften, die innerhalb von deklariert werden [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Beispielsweise sowohl <xref:System.Windows.Controls.Border> und <xref:System.Windows.Controls.Control> definieren eine `BorderBrush` Abhängigkeitseigenschaft, die ähnliche Funktionen aufweisen. <xref:System.Windows.Controls.Control> definiert die `BorderBrush` Eigenschaft im Eigenschaftensystem durch Aufrufen von <xref:System.Windows.DependencyProperty.AddOwner%2A> basierend auf dem ursprünglichen Besitzer <xref:System.Windows.Controls.Border> und ihre registrierte <xref:System.Windows.Controls.Border.BorderBrushProperty> Abhängigkeit Eigenschaft Bezeichner. Die <xref:System.Windows.DependencyProperty.AddOwner%2A> zurückgegeben Wert wird dann verwendet, um ein neues statisches <xref:System.Windows.DependencyProperty> Feld (<xref:System.Windows.Controls.Control.BorderBrushProperty>) für diese Eigenschaft auf den Besitzer hinzugefügt und ein `BorderBrush` Eigenschaftenwrapper auch deklariert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Der Typ, der als Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</param>
        <param name="typeMetadata">Die Metadaten, die die Abhängigkeitseigenschaft beschreiben, wie sie für den bereitgestellten Typ vorhanden sind.</param>
        <summary>Fügt einen anderen Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde. Dabei werden Abhängigkeitseigenschaft-Metadaten für die Abhängigkeitseigenschaft bereitgestellt, wie sie für den bereitgestellten Besitzertyp vorhanden sind.</summary>
        <returns>Ein Verweis auf den ursprünglichen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner, der die Abhängigkeitseigenschaft angibt. Dieser Bezeichner sollte von der hinzufügenden Klasse als <see langword="public static readonly" />-Feld verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht das Eigenschaftensystem Abhängigkeitseigenschaft für einen Typ zu erkennen, die nicht diese Abhängigkeitseigenschaft ursprünglich registriert hat.  
  
 Der Rückgabewert dieser Methode wird zum Deklarieren und verfügbar zu machen die Abhängigkeitseigenschaft, insbesondere, wie sie auf die hinzufügende Besitzerklasse vorhanden ist. Im Allgemeinen sollte der gleiche Name für den ursprünglichen Besitzer und Besitzer hinzugefügt verwendet werden, die ähnliche Funktionen an. Es wird empfohlen, die Bezeichner, sowie neue verfügbar zu machen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Die <xref:System.Windows.DependencyProperty.AddOwner%2A> oben empfohlenen Methoden wird beim Erstellen verwendet [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] innerhalb deklarierten [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Beispielsweise sowohl <xref:System.Windows.Controls.Border> und <xref:System.Windows.Controls.Control> definieren eine `BorderBrush` Abhängigkeitseigenschaft, die ähnliche Funktionen aufweisen. <xref:System.Windows.Controls.Control> definiert die `BorderBrush` Eigenschaft im Eigenschaftensystem durch Aufrufen von <xref:System.Windows.DependencyProperty.AddOwner%2A> für den ursprünglichen Besitzer <xref:System.Windows.Controls.Border> und ihre registrierte <xref:System.Windows.Controls.Border.BorderBrushProperty> Abhängigkeit Eigenschaft Bezeichner. Die <xref:System.Windows.DependencyProperty.AddOwner%2A> zurückgegeben Wert wird dann verwendet, um ein neues statisches <xref:System.Windows.DependencyProperty> Feld (<xref:System.Windows.Controls.Control.BorderBrushProperty>) für diese Eigenschaft auf den Besitzer hinzugefügt und ein `BorderBrush` Eigenschaftenwrapper auch deklariert wird.  
  
 Der Bezeichner des hinzugefügten Besitzers Abhängigkeitseigenschaft zu verwendende für Vorgänge wie z. B. <xref:System.Windows.DependencyObject.GetValue%2A>. Jedoch typspezifische Vorgänge im Zusammenhang mit Typen oder Instanzen der Klasse, die hinzugefügt wurde, wie Sie weiterhin Besitzer über unterschiedliche Metadaten zurückgeben die erwarteten Ergebnisse auch wenn die ursprüngliche (nicht des hinzugefügten Besitzers) in Abhängigkeit der Bezeichner angegeben wird Aufrufe von Methoden wie z. B. <xref:System.Windows.DependencyObject.GetValue%2A> oder <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Die Metadaten für den hinzugefügten Besitzer wird aufrechterhalten, durch die <xref:System.Windows.DependencyProperty.AddOwner%2A> selbst, nicht unbedingt auf die verwiesen wird ausschließlich von Feld-ID hinzufügen von Owner-Klasse aufrufen. Dennoch ist es empfiehlt sich, die Bezeichner, sowie neue [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A>, da die Abweichung zwischen geschieht dies nicht erstellt werden. die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] -Darstellung der Eigenschaften.  
  
 Die angegebene Metadaten wird mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist. Alle Eigenschaften, die in den ursprünglichen grundlegenden Metadaten angegeben wurden, werden beibehalten. Nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale der grundlegenden Metadaten überschrieben. Einige Merkmale, z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, ersetzt werden, wenn sie in den neuen Metadaten angegeben sind. Andere, z. B. <xref:System.Windows.PropertyChangedCallback>, kombiniert werden. Letzten Endes hängt das mergeverhalten der Metadaten-Eigenschaftentyp, die für das Überschreiben verwendet wird, also das hier beschriebene Verhalten für die vorhandene Eigenschaft Metadaten-Klassen, die von verwendet [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Abhängigkeitseigenschaften. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-metadata.md) und [Framework-Eigenschaftenmetadaten](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardmetadaten der Abhängigkeitseigenschaft ab.</summary>
        <value>Die Standardmetadaten der Abhängigkeitseigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardmetadaten handelt, die Metadaten, die für dieses Objekt oder ein Objekt eines abgeleiteten Typs verfügbar ist, in denen keine alternative Metadaten angegeben wurden durch eine explizite <xref:System.Windows.DependencyProperty.Register%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> aufrufen.  
  
 Wenn der ursprüngliche Besitzer Metadaten mit dem ersten angewendet <xref:System.Windows.DependencyProperty.Register%2A> Aufruf, der die Abhängigkeitseigenschaft, hergestellt wird, wird, dass die Metadaten als zurückgegeben <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Wenn keine Metadaten, in der ursprünglichen angewendet wurde <xref:System.Windows.DependencyProperty.Register%2A> aufrufen, und klicken Sie dann die Standardmetadaten aus generiert wird die <xref:System.Windows.DependencyProperty.Register%2A> Aufruf und dieser Wert wird zurückgegeben, als die <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Der Hauptzweck der Standardmetadaten an, die mit einem <xref:System.Windows.DependencyProperty> besteht darin, geben Sie einen Standardwert für diese Eigenschaft auf einem <xref:System.Windows.DependencyObject> oder einen abgeleiteten Typ.  
  
 Bei nicht angefügten Eigenschaften nicht dem Metadatentyp, der von dieser Eigenschaft zurückgegebene in abgeleiteten Typen umgewandelt werden <xref:System.Windows.PropertyMetadata> eingeben, auch wenn die Eigenschaft ursprünglich mit einem abgeleiteten Metadatentyp registriert wurde. Rufen Sie die ursprünglich registrierte Metadaten, einschließlich der ursprünglichen Metadatentyp abweichen möglicherweise abgeleiteten können <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> stattdessen als Parameter übergeben, die ursprüngliche Registrierung eingeben kann.  
  
 Für angefügte Eigenschaften muss der Typ der von dieser Eigenschaft zurückgegebenen Metadaten entspricht den Typ in der ursprünglichen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Registrierungsmethode.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für diese <see cref="T:System.Windows.DependencyProperty" /> zurück.</summary>
        <returns>Der Hashcode für diese <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendet einen eigenen eindeutigen Bezeichner für das Eigenschaftensystem <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, und der Wert dieser Eigenschaft zurückgegeben wird, indem <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die dieser Abhängigkeitseigenschaft zugeordneten Metadaten zurück, wie sie für einen bestimmten Typ vorhanden sind. Dies kann der Typ sein, für den die Abhängigkeitseigenschaft zuerst registriert wurde, ein Typ, dem sie später hinzugefügt wurde, oder einen Typ, für den die Abhängigkeitseigenschaft über Vererbung abgerufen wurde, wobei die Metadaten jedoch ausdrücklich überschrieben wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Der spezifische Typ, von dem die Metadaten für die Abhängigkeitseigenschaft abgerufen werden sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen vorhanden Typ vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben der Typ oder einen Objektverweis verwenden, wie der Typ ist erforderlich, da die Metadaten aus der ursprünglichen Registrierung aufgrund von abweichen können <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Aufrufe, die die Metadaten der Abhängigkeitseigenschaft ändern, wie sie für einen Typ vorhanden ist.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Metadaten für eine Abhängigkeitseigenschaft, die basierend auf seinem Typ ab. Der Typ wird abgerufen, mithilfe einer `typeof` Operator.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Ein Abhängigkeitsobjekt, dessen Typ überprüft wird, um zu ermitteln, von welcher typenspezifischen Version der Abhängigkeitseigenschaft die Metadaten stammen sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, da sie für die angegebene Objektinstanz vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben eines Typs oder ein Objektverweis ist erforderlich, da die Metadaten einer angegebenen Abhängigkeitseigenschaft von der ursprünglichen Registrierung aufgrund von abweichen können <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Aufrufe, die die Metadaten für ein genauer bestimmt werden können, auf eine Geben Sie ein.  
  
 Wenn Sie basierend auf einer Instanz Metadaten anfordern, übergeben Sie eigentlich nur die Instanz, damit der Typ intern ausgewertet werden kann. Metadaten für Abhängigkeitseigenschaften ändern sich nicht pro Instanz; Es ist immer für eine beliebige Kombination von Typ und Eigenschaft konsistent.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Metadaten für eine Abhängigkeitseigenschaft, die anhand einer bestimmten <xref:System.Windows.DependencyObject> Instanz.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Ein bestimmtes Objekt, das den Abhängigkeitsobjekttyp aufzeichnet, von dem die Metadaten für die Abhängigkeitseigenschaft stammen sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen Typ vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben eines Typs oder ein Objektverweis ist erforderlich, da die Metadaten einer angegebenen Abhängigkeitseigenschaft von der ursprünglichen Registrierung aufgrund von abweichen können <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Aufrufe, die die Metadaten für ein genauer bestimmt werden können, auf eine Geben Sie ein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Metadaten für eine Abhängigkeitseigenschaft, die basierend auf dessen <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen intern generierten Wert ab, der die Abhängigkeitseigenschaft eindeutig identifiziert.</summary>
        <value>Ein eindeutiger numerischer Bezeichner.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert ist eine ganze Zahl, nicht auf ein global eindeutiger Bezeichner (GUID). In der Regel mit diesem Indexwert ist nicht erforderlich, und es gibt keinen Indexzugriff auf Tabellen alle Abhängigkeitseigenschaften. Abhängigkeitseigenschaften sollten stattdessen von ihrer Bezeichnerfelder verwiesen werden.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> wird intern verwendet, für einen schnelleren Zugriff auf Datenstrukturen, mit denen die <xref:System.Windows.DependencyProperty.GlobalIndex%2A> als nullbasierte Arrayindex. Eine ähnliche Verwendung verfügen möglicherweise über Anwendungen für Designer oder Tools.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Bestimmt, ob ein angegebener Wert für den Typ dieser Abhängigkeitseigenschaft akzeptiert wird, wie anhand des in der Registrierung der ursprünglichen Abhängigkeitseigenschaft angegebenen Eigenschaftentyps überprüft wurde.</summary>
        <returns><see langword="true" />, wenn der angegebene Wert der registrierte Eigenschaftentyp oder ein zulässiger abgeleiteter Typ ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `null` ist ein gültiger Typ für Abhängigkeitseigenschaften Verweis oder für eine <xref:System.Nullable%601> Abhängigkeitseigenschaft fest, und würde zurückgeben `true` in diesen Fällen. In Fällen, in dem die Abhängigkeitseigenschaft weder ein Verweis ist, noch eine <xref:System.Nullable%601> Typ <xref:System.Windows.DependencyProperty.IsValidType%2A> zurück `false` für einen null-Wert anstelle von lösen eine Ausnahme.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyProperty.IsValidType%2A> als eine Überprüfung vor dem Aufruf <xref:System.Windows.DependencyObject.SetValue%2A> für die Abhängigkeitseigenschaft.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Bestimmt, ob der angegebene Wert für den Eigenschaftentyp durch eine einfache Typüberprüfung zulässig ist und ob er sich potenziell im zulässigen Wertebereich für den Typ befindet.</summary>
        <returns><see langword="true" />, wenn der Wert zulässig ist und den richtigen Typ oder einen abgeleiteten Typ aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für eine Abhängigkeitseigenschaft kann über einen zulässigen Werte für diesen Typ angegeben werden eine <xref:System.Windows.ValidateValueCallback> , die in der Registrierung der Abhängigkeitseigenschaft bereitgestellt wird.  
  
 Diese Methode ruft <xref:System.Windows.DependencyProperty.IsValidType%2A> intern. Wenn die fragliche Abhängigkeitseigenschaft keine <xref:System.Windows.ValidateValueCallback>, dann ist das Aufrufen dieser Methode entspricht dem Aufruf <xref:System.Windows.DependencyProperty.IsValidType%2A>. Wenn die Abhängigkeitseigenschaft besitzt eine <xref:System.Windows.ValidateValueCallback>, und wenn <xref:System.Windows.DependencyProperty.IsValidType%2A> zurückgegeben hätte `true`, wird der Wert werden zurückgegeben, wie Sie in der Rückruf implementiert.  
  
 Ein null-Wert ist ein gültiger Wert für Abhängigkeitseigenschaften Verweis oder für eine <xref:System.Nullable%601> Abhängigkeitseigenschaft fest, und würde zurückgeben `true` in diesen Fällen. In Fällen, in dem die Abhängigkeitseigenschaft weder ein Verweis ist, noch eine <xref:System.Nullable%601> Typ <xref:System.Windows.DependencyProperty.IsValidType%2A> zurück `false` für einen null-Wert anstelle von lösen eine Ausnahme.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyProperty.IsValidValue%2A> als eine Überprüfung vor dem Aufruf <xref:System.Windows.DependencyObject.SetValue%2A> für die Abhängigkeitseigenschaft.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Abhängigkeitseigenschaft ab.</summary>
        <value>Den Namen der Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft ab, der als Name der `name` Parameter während der Registrierung der Abhängigkeitseigenschaft. Dieser Name ist unveränderlich und nicht `null` oder eine leere Zeichenfolge. Aufgrund des doppelten namensregistrierungen für den gleichen Besitzertyp sind nicht zulässig, und es werden eine Ausnahme ausgelöst, wenn Sie versuchen, registrieren Sie das Duplikat.  
  
> [!IMPORTANT]
>  Die <xref:System.Windows.DependencyProperty.Name%2A> einer Abhängigkeit Eigenschaft muss die Konvention eingehalten, der mit dem Namen des Bezeichners der Abhängigkeitseigenschaft ohne das Suffix "-Eigenschaft" übereinstimmt. Weitere Informationen finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Das folgende Beispiel fragt verschiedene Merkmale der Bezeichner einer Abhängigkeitseigenschaft, einschließlich der <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt alternative Metadaten für diese Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, im Gegensatz zu den Metadaten, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</param>
        <param name="typeMetadata">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</param>
        <summary>Gibt alternative Metadaten für diese Abhängigkeitseigenschaft an, wenn sie in Instanzen eines angegebenen Typs vorhanden ist. Dabei werden die Metadaten überschrieben, die für die Abhängigkeitseigenschaft bei der Vererbung von Basistypen vorhanden waren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadaten für Abhängigkeitseigenschaften sollte überschrieben werden, bevor Sie das Eigenschaftensystem die Abhängigkeitseigenschaft verwendet. Dies entspricht der Zeit, die bestimmte Instanzen erstellt werden, mit der Klasse, die die Abhängigkeitseigenschaft registriert. Aufrufe von <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als die `forType` Parameter dieser Methode oder über eine ähnliche Instanziierung. Es wird versucht, Metadaten zu ändern, nachdem die Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, es wird aber führt zu inkonsistentem Verhalten im Eigenschaftensystem.  
  
 Nachdem Metadaten für einen bestimmten abgeleiteten Klasse außer Kraft setzen, die mit dieser Methode eingerichtet wurde, werden nachfolgende Versuche zum Überschreiben von Metadaten in dieser abgeleiteten Klasse eine Ausnahme ausgelöst.  
  
 Die angegebene Metadaten wird mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist. Alle Eigenschaften, die in den ursprünglichen grundlegenden Metadaten angegeben wurden, werden beibehalten. nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale der grundlegenden Metadaten überschrieben. Einige Merkmale wie z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ersetzt werden, wenn in den neuen Metadaten angegeben. Andere, z. B. <xref:System.Windows.PropertyChangedCallback>, kombiniert werden. Letzten Endes hängt das mergeverhalten der Metadaten-Eigenschaftentyp, die für das Überschreiben verwendet wird, also das hier beschriebene Verhalten für die vorhandene Eigenschaft Metadaten-Klassen, die von verwendet [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Abhängigkeitseigenschaften. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-metadata.md) und [Framework-Eigenschaftenmetadaten](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft zu überschreiben (dieser Vorgang kann nicht mit dieser Signatur ausgeführt werden).</exception>
        <exception cref="T:System.ArgumentException">Metadaten wurden für die Abhängigkeitseigenschaft bereits festgelegt, wie im bereitgestellten Typ vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</param>
        <param name="typeMetadata">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</param>
        <param name="key">Der Zugriffsschlüssel für eine schreibgeschützte Abhängigkeitseigenschaft.</param>
        <summary>Stellt alternative Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, wodurch die Metadaten überschrieben werden, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden. Sie müssen die <see cref="T:System.Windows.DependencyPropertyKey" /> für die schreibgeschützte Abhängigkeitseigenschaft übergeben, um das Auslösen einer Ausnahme zu vermeiden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur bietet die zugrunde liegende Implementierung für den Bezeichner für eine schreibgeschützte Abhängigkeitseigenschaft (<xref:System.Windows.DependencyPropertyKey>) Methode. Wenn Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft zu überschreiben, verwenden Sie <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Metadaten für Abhängigkeitseigenschaften sollte überschrieben werden, bevor Sie das Eigenschaftensystem die Abhängigkeitseigenschaft verwendet. Dies entspricht der Zeit, die bestimmte Objekte erstellt werden, für die Klasse, die die Abhängigkeitseigenschaft registriert. Aufrufe von <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als die `forType` Parameter dieser Methode oder über eine ähnliche Instanziierung. Es wird versucht, Metadaten zu ändern, nachdem die Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, es wird aber führt zu inkonsistentem Verhalten im Eigenschaftensystem.  
  
 Nachdem Metadaten für einen bestimmten abgeleiteten Klasse außer Kraft setzen, die mit dieser Methode eingerichtet wurde, werden nachfolgende Versuche zum Überschreiben von Metadaten in dieser abgeleiteten Klasse eine Ausnahme ausgelöst.  
  
 Die angegebene Metadaten wird mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist. Alle Eigenschaften, die in den ursprünglichen grundlegenden Metadaten angegeben wurden, werden beibehalten. nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale der grundlegenden Metadaten überschrieben. Einige Merkmale wie z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ersetzt werden, wenn in den neuen Metadaten angegeben. Andere, z. B. <xref:System.Windows.PropertyChangedCallback>, kombiniert werden. Der mergeverhalten hängt vom Typ der Metadaten für die Überschreibung verwendet wird ab. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-metadata.md) und [Framework-Eigenschaftenmetadaten](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Objekts ab, das die Abhängigkeitseigenschaft im Eigenschaftensystem registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</summary>
        <value>Der Typ des Objekts, das die Eigenschaft registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wurde während der Registrierung bereitgestellt werden. Der Besitzer wird entweder der ursprünglichen Registrierung Typ in der eine <xref:System.Windows.DependencyProperty> aus generierter Bezeichner eine <xref:System.Windows.DependencyProperty.Register%2A> Aufruf oder der Typ, der sich selbst als Besitzer im Fall von hinzugefügt eine <xref:System.Windows.DependencyProperty> aus generierter Bezeichner ein <xref:System.Windows.DependencyProperty.AddOwner%2A> aufrufen.  
  
 Die <xref:System.Windows.DependencyProperty.OwnerType%2A> auf ein beliebiges <xref:System.Windows.DependencyProperty> ist unveränderlich und nicht `null` in einen gültigen <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Im folgende Beispiel ruft den Besitzertyp basierend auf den Bezeichner einer Abhängigkeitseigenschaft `dp`, und klicken Sie dann Ruft Metadaten für den Besitzertyp ab, dem gleichen Bezeichner. Dieser Vorgang entspricht dem Abrufen von <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> auf `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, den die Abhängigkeitseigenschaft für den Wert verwendet.</summary>
        <value>Der <see cref="T:System.Type" /> des Eigenschaftswerts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft meldet den Typ des Werts der Eigenschaft, gemäß der Deklaration von der ursprünglichen Registrierung, durch die `propertyType` Parameter. Ähnlich wie die <xref:System.Windows.DependencyProperty.Name%2A>, welche Eigenschaft eine Abhängigkeitseigenschaft ist unveränderlich, nach der Registrierung.  
  
   
  
## Examples  
 Das folgende Beispiel fragt verschiedene Merkmale der Bezeichner einer Abhängigkeitseigenschaft, einschließlich der <xref:System.Windows.DependencyProperty.PropertyType%2A>. Zeichenfolge für den Typnamen der <xref:System.Windows.DependencyProperty.PropertyType%2A> wird abgerufen, von dem zurückgegebenen <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die von dieser <see cref="T:System.Windows.DependencyProperty" />-Instanz angegebene Abhängigkeitseigenschaft eine schreibgeschützte Abhängigkeitseigenschaft ist.</summary>
        <value><see langword="true" />, wenn die Abhängigkeitseigenschaft schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schreibgeschützte Abhängigkeitseigenschaften im Eigenschaftensystem registriert sind, durch den Aufruf der <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Methode im Gegensatz zu den <xref:System.Windows.DependencyProperty.Register%2A> Methode. Angefügte Eigenschaften können auch als nur-Lese registriert werden; finden Sie unter <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Schreibgeschützte Abhängigkeitseigenschaften ist erforderlich, eine <xref:System.Windows.DependencyPropertyKey> Bezeichner anstelle eines <xref:System.Windows.DependencyProperty> Bezeichner auszuführenden Vorgänge mit Metadaten wie z. B. das Überschreiben der Metadaten oder Festlegen des Werts. Wenn Sie eine Auflistung von erhalten <xref:System.Windows.DependencyProperty> Bezeichner durch einen Aufruf von <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> oder einem anderen [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] , verfügbar macht, Bezeichner, überprüfen Sie die <xref:System.Windows.DependencyProperty.ReadOnly%2A> Wert vor dem Aufrufen <xref:System.Windows.DependencyObject.SetValue%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> verwenden, der Abhängigkeitseigenschaftbezeichner als Eingabeparameter, um sicherzustellen, dass die Abhängigkeitseigenschaft, die den Bezeichner darstellt, nicht schreibgeschützt ist. Wenn der Wert des <xref:System.Windows.DependencyProperty.ReadOnly%2A> ist `true` für eine Abhängigkeitseigenschaft, es ist keine programmgesteuerte Möglichkeit zum Abrufen eines Verweises auf die <xref:System.Windows.DependencyPropertyKey> Bezeichner für die Abhängigkeitseigenschaft, die aus den Metadaten oder aus der <xref:System.Windows.DependencyProperty> Bezeichner; der Bezeichner muss als ein statisches Feld verfügbar sein, um Aufrufen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> für eine schreibgeschützte Abhängigkeitseigenschaft.  
  
 Wenn Sie eine benutzerdefinierte Abhängigkeitseigenschaft erstellen und registrieren Sie ihn als schreibgeschützt, definieren Sie nur einen Get-Accessor für die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Wrapper-Eigenschaft. Andernfalls müssen die Klasse ein verwirrendes Objektmodell für den Eigenschaftenwrapper im Vergleich zu den Zugriff auf die dahinter liegende Abhängigkeitseigenschaft. Weitere Informationen finden Sie unter [benutzerdefinierte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/custom-dependency-properties.md) oder [schreibgeschützte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Standardmetadaten und die Eigenschaft Bezeichner Abhängigkeitseigenschaften aus verschiedenen Feldern der Dependency-Eigenschaft ab, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine Abhängigkeitseigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft. Der Name muss innerhalb des Registrierungsnamespace des Besitzertyps eindeutig sein.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine Abhängigkeitseigenschaft, einschließlich einen Validierungsrückruf (die Rückruf-Definition wird nicht angezeigt; Weitere Informationen über die Rückruf-Definition finden Sie unter <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine angefügte Eigenschaft mit dem Eigenschaftensystem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist ein Eigenschaftenkonzept von definierten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften an. Da die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügte Eigenschaften sind Abhängigkeitseigenschaften handelt, können Metadaten auf Sie angewendet werden, die vom allgemeinen Eigenschaftensystem für Vorgänge wie die Layoutmerkmale reporting verwendet werden kann. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine angefügte Eigenschaft für eine abstrakte Klasse, die mit diesem <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Signatur.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft. Dies kann den Standardwert sowie andere Merkmale einschließen.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftenmetadaten.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist ein Eigenschaftenkonzept von definierten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften an. Da die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügte Eigenschaften sind Abhängigkeitseigenschaften handelt, können Metadaten auf Sie angewendet werden, die vom allgemeinen Eigenschaftensystem für Vorgänge wie die Layoutmerkmale reporting verwendet werden kann. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anstelle von <xref:System.Windows.DependencyProperty.Register%2A> dient zur Unterstützung von Vererbung von Eigenschaftswerten. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse definiert, die die Abhängigkeitseigenschaft verfügbar zu machen und selbst wenn Sie nicht beabsichtigen, Get * "und" Set * statische Methoden zur Bereitstellung verfügbar zu machen "true" angefügt. Unterstützung für Eigenschaftenaccessoren.   Obwohl die Vererbung von Eigenschaftswerten bei nicht angefügten Abhängigkeitseigenschaften zu funktionieren scheint, ist das Vererbungsverhalten einer nicht angefügten Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Registrieren der Eigenschaft als effektiv angefügt wird die angefügte Eigenschaft eine globale Eigenschaft im Eigenschaftensystem, und stellt sicher, dass die Vererbung von Eigenschaftswerten über alle hinweg in einer Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft. Dies kann den Standardwert sowie andere Merkmale einschließen.</param>
        <param name="validateValueCallback">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und dem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist ein Eigenschaftenkonzept von definierten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften an. Da die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügte Eigenschaften sind Abhängigkeitseigenschaften handelt, können Metadaten auf Sie angewendet werden, die vom allgemeinen Eigenschaftensystem für Vorgänge wie die Layoutmerkmale reporting verwendet werden kann. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anstelle von <xref:System.Windows.DependencyProperty.Register%2A> dient zur Unterstützung von Vererbung von Eigenschaftswerten. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse definiert, die die Abhängigkeitseigenschaft verfügbar zu machen und selbst wenn Sie nicht beabsichtigen, Get * "und" Set * statische Methoden zur Bereitstellung verfügbar zu machen "true" angefügt. Unterstützung für Eigenschaftenaccessoren.   Obwohl die Vererbung von Eigenschaftswerten bei nicht angefügten Abhängigkeitseigenschaften zu funktionieren scheint, ist das Vererbungsverhalten einer nicht angefügten Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Registrieren der Eigenschaft als effektiv angefügt wird die angefügte Eigenschaft eine globale Eigenschaft im Eigenschaftensystem, und stellt sicher, dass die Vererbung von Eigenschaftswerten über alle hinweg in einer Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine angefügte Eigenschaft für eine abstrakte Klasse, die mit diesem <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Signatur. Diese angefügte Eigenschaft ist eine Enumeration Type-Eigenschaft, und die Registrierung Fügt einen Validierungsrückruf, um sicherzustellen, dass der angegebene Wert den Wert der Enumeration ist.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine schreibgeschützte angefügte Eigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine schreibgeschützte angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>hingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel verwendet werden können, Festlegen des Werts der Abhängigkeitseigenschaft durch Aufrufen von <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Ihr Klassenentwurf wirkt sich Ihre Anforderungen, jedoch wird allgemein empfohlen, beschränken den Zugriff und die Sichtbarkeit aller <xref:System.Windows.DependencyPropertyKey> , nur die Teile des Codes, die die Abhängigkeitseigenschaft als Teil der Klasse oder die Anwendung Logik festgelegt sind. Es wird empfohlen, dass Sie Bezeichner einer Abhängigkeitseigenschaft für die schreibgeschützte Abhängigkeitseigenschaft verfügbar machen, indem der Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` Feld in Ihrer Klasse auf.  
  
 Schreibgeschützte angefügte Eigenschaften sind Szenario selten vorkommt, da das primäre Szenario für eine angefügte Eigenschaft mit der Verwendung in der ist [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Ohne einen öffentlichen Setter, kann keine angefügte Eigenschaft festgelegt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft als zur Unterstützung der Vererbung von Eigenschaftswerten ist angefügt. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse definiert, die die Abhängigkeitseigenschaft verfügbar zu machen und selbst wenn Sie nicht beabsichtigen, Get * "und" Set * statische Methoden zur Bereitstellung verfügbar zu machen "true" angefügt. Unterstützung für Eigenschaftenaccessoren.   Obwohl die Vererbung von Eigenschaftswerten bei nicht angefügten Abhängigkeitseigenschaften zu funktionieren scheint, ist das Vererbungsverhalten einer nicht angefügten Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Registrieren der Eigenschaft als effektiv angefügt wird die angefügte Eigenschaft eine globale Eigenschaft im Eigenschaftensystem, und stellt sicher, dass die Vererbung von Eigenschaftswerten über alle hinweg in einer Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine schreibgeschützte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</summary>
        <returns>Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>hingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die den darstellen <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel verwendet werden können, Festlegen des Werts der Abhängigkeitseigenschaft durch Aufrufen von <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Ihr Klassenentwurf wirkt sich Ihre Anforderungen, jedoch wird allgemein empfohlen, beschränken den Zugriff und die Sichtbarkeit aller <xref:System.Windows.DependencyPropertyKey> , nur die Teile des Codes, die die Abhängigkeitseigenschaft als Teil der Klasse oder die Anwendung Logik festgelegt sind. Es wird empfohlen, dass Sie Bezeichner einer Abhängigkeitseigenschaft für die schreibgeschützte Abhängigkeitseigenschaft verfügbar machen, indem der Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` Feld in Ihrer Klasse auf.  
  
 Schreibgeschützte angefügte Eigenschaften sind Szenario selten vorkommt, da das primäre Szenario für eine angefügte Eigenschaft mit der Verwendung in der ist [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Ohne einen öffentlichen Setter, kann keine angefügte Eigenschaft festgelegt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft registrieren, wie anstelle von angeschlossenen <xref:System.Windows.DependencyProperty.Register%2A> dient zur Unterstützung von Vererbung von Eigenschaftswerten. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse definiert, die die Abhängigkeitseigenschaft verfügbar zu machen und selbst wenn Sie nicht beabsichtigen, Get * "und" Set * statische Methoden zur Bereitstellung verfügbar zu machen "true" angefügt. Unterstützung für Eigenschaftenaccessoren.   Obwohl die Vererbung von Eigenschaftswerten bei nicht angefügten Abhängigkeitseigenschaften zu funktionieren scheint, ist das Vererbungsverhalten einer nicht angefügten Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Registrieren der Eigenschaft als effektiv angefügt wird die angefügte Eigenschaft eine globale Eigenschaft im Eigenschaftensystem, und stellt sicher, dass die Vererbung von Eigenschaftswerten über alle hinweg in einer Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine Abhängigkeitseigenschaft als schreibgeschützte Abhängigkeitseigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>hingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel verwendet werden können, Festlegen des Werts der Abhängigkeitseigenschaft durch Aufrufen von <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Ihr Klassenentwurf wirkt sich Ihre Anforderungen, jedoch wird allgemein empfohlen, beschränken den Zugriff und die Sichtbarkeit aller <xref:System.Windows.DependencyPropertyKey> , nur die Teile des Codes, die die Abhängigkeitseigenschaft als Teil der Klasse oder die Anwendung Logik festgelegt sind. Es wird empfohlen, dass Sie Bezeichner einer Abhängigkeitseigenschaft für die schreibgeschützte Abhängigkeitseigenschaft verfügbar machen, indem der Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` Feld in Ihrer Klasse auf.  
  
 Schreibgeschützte Abhängigkeitseigenschaften sind ein ziemlich typischen Fall sowohl in der vorhandenen [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] und Szenarios für das Anpassen, da andere [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Features möglicherweise eine Abhängigkeitseigenschaft, auch wenn diese Eigenschaft nicht festgelegt werden, indem sein soll Aufrufer. Können Sie den Wert einer schreibgeschützten Abhängigkeitseigenschaft als Grundlage für andere Systemoperationen, die eine Abhängigkeitseigenschaft, wie z. B. der Basis einer <xref:System.Windows.Trigger> für die Abhängigkeitseigenschaft in einem Stil.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine `AquariumSize` Abhängigkeitseigenschaft als schreibgeschützt. Das Beispiel definiert `AquariumSizeKey` als einen internen Schlüssel (also, dass andere Klassen in der Assembly konnte Metadaten überschreiben) und der Bezeichner der Abhängigkeitseigenschaft auf der Grundlage dieses Schlüssels als macht `AquariumSizeProperty`. Darüber hinaus wird ein Wrapper für erstellt `AquariumSize`, mit nur einem Get-Accessor.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</summary>
        <returns>Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>hingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel verwendet werden können, Festlegen des Werts der Abhängigkeitseigenschaft durch Aufrufen von <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Ihr Klassenentwurf wirkt sich Ihre Anforderungen, jedoch wird allgemein empfohlen, beschränken den Zugriff und die Sichtbarkeit aller <xref:System.Windows.DependencyPropertyKey> , nur die Teile des Codes, die die Abhängigkeitseigenschaft als Teil der Klasse oder die Anwendung Logik festgelegt sind. Es wird empfohlen, dass Sie Bezeichner einer Abhängigkeitseigenschaft für die schreibgeschützte Abhängigkeitseigenschaft verfügbar machen, indem der Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` Feld in Ihrer Klasse auf.  
  
 Schreibgeschützte Abhängigkeitseigenschaften sind ziemlich üblich. Können Sie den Wert einer schreibgeschützten Abhängigkeitseigenschaft als Grundlage für andere Systemoperationen, die eine Abhängigkeitseigenschaft, wie z. B. der Basis einer <xref:System.Windows.Trigger> für die Abhängigkeitseigenschaft in einem Stil.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
 Überprüfung für eine schreibgeschützte Abhängigkeitseigenschaft möglicherweise weniger wichtig. Die nicht öffentliche Zugriffsebene, die Sie für den Schlüssel angeben, verringert die Wahrscheinlichkeit für den beliebigen ungültige Eingabe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichenfolgendarstellung der Abhängigkeitseigenschaft zurück.</summary>
        <returns>Die Zeichenfolgendarstellung der Abhängigkeitseigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung gibt die <xref:System.Windows.DependencyProperty.Name%2A> -Eigenschaftswert.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen statischen Wert an, der vom [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem verwendet wird, und nicht <see langword="null" />, um anzugeben, dass die Eigenschaft vorhanden ist, der Wert jedoch nicht vom Eigenschaftensystem festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> ist ein Sentinelwert, die für Szenarien verwendet wird, in denen die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ist nicht möglich, um eine angeforderte zu bestimmen, <xref:System.Windows.DependencyProperty> Wert. <xref:System.Windows.DependencyProperty.UnsetValue> wird verwendet, statt `null`, da `null` möglicherweise einen gültigen Eigenschaftswert als auch einen gültigen (und häufig verwendete) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> wird niemals zurückgegeben, von <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Beim Aufruf <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> für eine Abhängigkeitseigenschaft auf einem <xref:System.Windows.DependencyObject> Instanz angewendet wird, eine der folgenden:  
  
-   Eine Abhängigkeitseigenschaft hat den Standardwert, der in den Metadaten eingerichtet, und dieser Wert wird zurückgegeben. Dieser Wert kann aus stammen <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Ein anderer Wert vom Eigenschaftensystem hergestellt wurde, und der Standardwert ist nicht mehr relevant. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Festlegen einer <xref:System.Windows.PropertyMetadata.DefaultValue%2A> von <xref:System.Windows.DependencyProperty.UnsetValue> ist ausdrücklich nicht zulässig.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Gibt <xref:System.Windows.DependencyProperty.UnsetValue> Wenn die angeforderte Eigenschaft nicht lokal festgelegt wurde.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung, bei Verwendung als den Rückgabewert einer <xref:System.Windows.CoerceValueCallback>. Weitere Informationen finden Sie unter [Abhängigkeitsrückrufe und Validierung von](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Wenn Sie mit einer Datenbank binden, beachten Sie, dass <xref:System.Windows.DependencyProperty.UnsetValue> ist nicht gleichbedeutend mit <xref:System.DBNull.Value>, auf ähnliche Weise wie <xref:System.DBNull.Value> ist nicht gleichbedeutend mit dem ein NULL-Wert "true".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wertvalidierungsrückruf für die Abhängigkeitseigenschaft ab.</summary>
        <value>Der Wertvalidierungsrückruf für diese Abhängigkeitseigenschaft, wie für den <paramref name="validateValueCallback" />-Parameter in der ursprünglichen Registrierung der Abhängigkeitseigenschaft angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enthält diese Eigenschaft `null` für jede Abhängigkeitseigenschaft keine registrierten Validierungsrückruf.  
  
 Wert Rückrufe in gewisser statische fungieren müssen überprüfen: Überprüfung angewendet wird, über die <xref:System.Windows.ValidateValueCallback> kann nicht bestimmt werden, ob der angegebene Wert für eine bestimmte Instanz gültig ist. Der Rückruf kann nur bestimmen, ob alle Objekte, die die Abhängigkeitseigenschaft besitzt oder sollte nicht den angegebenen Wert als gültig akzeptieren soll. Wenn Sie für die Validierung, die bekannt sein die Werte der anderen Abhängigkeitseigenschaften für eine bestimmte Instanz verwenden müssen müssen eine <xref:System.Windows.CoerceValueCallback> stattdessen. Die <xref:System.Windows.CoerceValueCallback> als Teil der Metadaten für Abhängigkeitseigenschaften, anstatt direkt in der Bezeichner der Abhängigkeitseigenschaft registriert ist. Weitere Informationen finden Sie unter [Abhängigkeitsrückrufe und Validierung von](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>