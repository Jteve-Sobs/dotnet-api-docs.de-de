<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e36dd257b906b7c94742536f4e333ac2cac8cd0" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660019" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Eigenschaft dar, die durch Methoden festgelegt werden kann, z. B. Formatierung, Datenbindung, Animation und Vererbung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyProperty> unterstützt die folgenden neuen Funktionen in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Die Eigenschaft kann in einem Format festgelegt werden. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Die Eigenschaft kann über die Datenbindung festgelegt werden. Weitere Informationen zu Datenbindungseigenschaften Abhängigkeit, finden Sie unter [Vorgehensweise: Binden von Eigenschaften von zwei Steuerelementen](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Die Eigenschaft kann mit einem dynamischen Ressourcenverweis festgelegt werden. Weitere Informationen finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Die Eigenschaft kann den Wert automatisch von einem übergeordneten Element in der Elementstruktur erben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Die Eigenschaft kann animiert werden. Weitere Informationen finden Sie unter [Übersicht über Animation](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Die Eigenschaft kann melden, wenn der vorherige Wert der Eigenschaft geändert wurde und die Eigenschaftswert umgewandelt werden kann. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Die Eigenschaft werden Informationen zu [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], z. B., ob das Layoutsystem die visuellen Elemente nach einem Element neu aufzubauen Ändern eines Eigenschaftswerts benötigen sollte.  
  
-   Die Eigenschaft empfängt Unterstützung in den [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Beispielsweise kann die Eigenschaft bearbeitet werden, der **Eigenschaften** Fenster.  
  
 Weitere Informationen zu Abhängigkeitseigenschaften finden Sie unter [Übersicht über Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Wenn Sie Eigenschaften auf die benutzerdefinierten Typen zur Unterstützung von Funktionen in der vorangehenden Liste aufgeführt werden soll, sollten Sie eine Abhängigkeitseigenschaft erstellen.  Vorgehensweise: Erstellen von benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter [benutzerdefinierte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Eine angefügte Eigenschaft ist eine Eigenschaft, die jedes Objekt auf die Informationen in den Typ ermöglicht, das die angefügte Eigenschaft definiert. In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], jeder Typ, der von erbt <xref:System.Windows.DependencyObject> können eine angefügte Eigenschaft unabhängig davon, ob der Typ vom Typ erbt, die die Eigenschaft definiert. Eine angefügte Eigenschaft ist ein Feature von der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sprache.  Eine angefügte Eigenschaft festgelegt wird, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], verwenden Sie die *Besitzertyp*.* PropertyName* Syntax. Ein Beispiel für eine angefügte Eigenschaft ist die <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Eigenschaft. Wenn eine Eigenschaft zu erstellen, die auf allen verwendet werden können sollen <xref:System.Windows.DependencyObject> eingibt, dann sollten Sie eine angefügte Eigenschaft erstellen. Weitere Informationen zu angefügten Eigenschaften, einschließlich Informationen zum Erstellen, finden Sie unter [Eigenschaftenübersicht angefügt](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `dependencyPropertyName`  
 Eine Zeichenfolge, die angibt, die <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> der gewünschten Abhängigkeitseigenschaft. Dies kann vorangestellt werden ein XML-Namespacepräfix, wenn die Eigenschaft nicht in der XML-Standardnamespace ist (Weitere Informationen finden Sie unter [XAML-Namespaces und Namespace-Zuordnung für WPF-XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Eine Zeichenfolge, die eine Besitzertyp der Abhängigkeitseigenschaft, einen Punkt (.) gibt an, und klicken Sie dann die <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` kann auch ein XML-Namespacepräfix vorangestellt werden. Diese Verwendung ist speziell für spät gebundene Stile und Vorlagen, die, in denen der Besitzer der Abhängigkeitseigenschaft angegeben werden, muss für die Analyse von Kontext, da die `TargetType` noch nicht bekannt ist. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Eine Zeichenfolge, die den Besitzer einer angefügten Eigenschaft, ein Punkt (.), und dann den Namen der angefügten Eigenschaft angibt. `attachedPropertyOwnerType` kann auch ein XML-Namespacepräfix vorangestellt werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits für einen Typ registriert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Der Typ, der als ein Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</param>
        <summary>Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde.</summary>
        <returns>Ein Verweis auf den ursprünglichen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner, der die Abhängigkeitseigenschaft angibt. Dieser Bezeichner sollte von der hinzufügenden Klasse als <see langword="public static readonly" />-Feld verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht das Eigenschaftensystem eine Abhängigkeitseigenschaft für einen Typ zu erkennen, die diese Abhängigkeitseigenschaft zunächst nicht registriert.  
  
 In der Regel <xref:System.Windows.DependencyProperty.AddOwner%2A> wird verwendet, um die Abhängigkeitseigenschaften Klassen hinzufügen, die nicht bereits die Abhängigkeitseigenschaft über Vererbung der verwalteten Klasse verfügbar machen (klassenvererbung würde dazu führen, dass die Wrappereigenschaften, die von der abgeleiteten Klasse geerbt werden und somit würde allgemeine Membertabelle bietet Zugriff auf die Abhängigkeitseigenschaft bereits). <xref:System.Windows.DependencyProperty.AddOwner%2A> ermöglicht es das Eigenschaftensystem eine Abhängigkeitseigenschaft für einen Typ zu erkennen, die dieser Abhängigkeitseigenschaft zunächst nicht registriert.  
  
 Diese Signatur lässt keine Metadaten angeben.  Wenn Sie diese Methode verwenden, wird die Metadaten automatisch für die neue generiert <xref:System.Windows.DependencyProperty> und Besitzertyp. Die automatisch generierten Metadaten ist das Ergebnis der zusammengeführten Metadaten von allen Basistypen, die diese Eigenschaft definiert haben. Wenn keine zusammengeführten Metadaten verfügbar ist, wird das Standardmetadatum für die Eigenschaft verwendet. Wenn die Eigenschaft, mithilfe registriert ist der <xref:System.Windows.DependencyProperty.RegisterAttached%2A> -Methode, und klicken Sie dann auf die Standardmetadaten ist identisch mit den Metadaten, die erstellt werden <xref:System.Windows.DependencyProperty.RegisterAttached%2A> aufgerufen wurde. Hingegen die <xref:System.Windows.PropertyMetadata> -Objekt wird erstellt, mit der <xref:System.Windows.PropertyMetadata.DefaultValue%2A> Eigenschaftensatz an Standardeinstellung für den Eigenschaftentyp und alle anderen Eigenschaften von der <xref:System.Windows.PropertyMetadata> auf festgelegt ist `null`. Verwenden der <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> Signatur, wenn Metadaten für die Version der Abhängigkeitseigenschaft bereitgestellt, wie in den bereitgestellten Typ hinzugefügt werden sollen.  
  
 Der Rückgabewert dieser Methode dient normalerweise zum Deklarieren und Verfügbarmachen von der Abhängigkeitseigenschaft durch Speichern der Bezeichner für eine Abhängigkeitseigenschaft. Der Bezeichner ermöglicht den Zugriff auf die Abhängigkeitseigenschaft, wenn Eigenschaftensystem aufgerufen werden soll [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] auf der hinzufügenden Besitzerklasse für die Abhängigkeitseigenschaft, insbesondere, wenn er vorhanden. Der gleiche Name für den ursprünglichen Besitzer und hinzugefügten Benutzer sollte verwendet werden, um anzugeben, die ähnliche Funktionen. Verwenden Sie die <xref:System.Windows.DependencyProperty> Rückgabewert aus der <xref:System.Windows.DependencyProperty.AddOwner%2A> Methode zum Definieren des Bezeichners der Abhängigkeitseigenschaft sowie zum Deklarieren [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Die <xref:System.Windows.DependencyProperty.AddOwner%2A> Methodik oben empfohlen wird verwendet, wenn die Abhängigkeitseigenschaften erstellen, die innerhalb von deklariert werden [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Z. B. sowohl <xref:System.Windows.Controls.Border> und <xref:System.Windows.Controls.Control> definieren eine `BorderBrush` Abhängigkeitseigenschaft, die ähnliche Funktionen haben. <xref:System.Windows.Controls.Control> definiert die `BorderBrush` Eigenschaft, um dem Eigenschaftensystem durch Aufrufen von <xref:System.Windows.DependencyProperty.AddOwner%2A> basierend auf dem ursprünglichen Besitzer <xref:System.Windows.Controls.Border> und seines registrierten <xref:System.Windows.Controls.Border.BorderBrushProperty> Abhängigkeit Eigenschaft Bezeichner. Die <xref:System.Windows.DependencyProperty.AddOwner%2A> zurückgeben Wert wird dann verwendet, um ein neues statisches <xref:System.Windows.DependencyProperty> Feld (<xref:System.Windows.Controls.Control.BorderBrushProperty>) für diese Eigenschaft auf den hinzugefügten Besitzer und eine `BorderBrush` Eigenschaftenwrapper auch deklariert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Der Typ, der als Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</param>
        <param name="typeMetadata">Die Metadaten, die die Abhängigkeitseigenschaft beschreiben, wie sie für den bereitgestellten Typ vorhanden sind.</param>
        <summary>Fügt einen anderen Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde. Dabei werden Abhängigkeitseigenschaft-Metadaten für die Abhängigkeitseigenschaft bereitgestellt, wie sie für den bereitgestellten Besitzertyp vorhanden sind.</summary>
        <returns>Ein Verweis auf den ursprünglichen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner, der die Abhängigkeitseigenschaft angibt. Dieser Bezeichner sollte von der hinzufügenden Klasse als <see langword="public static readonly" />-Feld verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht das Eigenschaftensystem eine Abhängigkeitseigenschaft für einen Typ zu erkennen, die diese Abhängigkeitseigenschaft zunächst nicht registriert.  
  
 Der Rückgabewert dieser Methode wird zum Deklarieren und Verfügbarmachen von der Abhängigkeitseigenschaft verwendet, insbesondere, wie sie auf der hinzufügenden Besitzerklasse vorhanden ist. Im Allgemeinen sollte der gleiche Name für den ursprünglichen Besitzer und hinzugefügten Benutzer verwendet werden, um anzugeben, die ähnliche Funktionen. Es wird empfohlen, die Bezeichner, die als auch neue verfügbar zu machen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Die <xref:System.Windows.DependencyProperty.AddOwner%2A> Methodik oben empfohlen wird verwendet, für die Erstellung [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] deklariert innerhalb von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Z. B. sowohl <xref:System.Windows.Controls.Border> und <xref:System.Windows.Controls.Control> definieren eine `BorderBrush` Abhängigkeitseigenschaft, die ähnliche Funktionen haben. <xref:System.Windows.Controls.Control> definiert die `BorderBrush` Eigenschaft, um dem Eigenschaftensystem durch Aufrufen von <xref:System.Windows.DependencyProperty.AddOwner%2A> für den ursprünglichen Besitzer <xref:System.Windows.Controls.Border> und seines registrierten <xref:System.Windows.Controls.Border.BorderBrushProperty> Abhängigkeit Eigenschaft Bezeichner. Die <xref:System.Windows.DependencyProperty.AddOwner%2A> zurückgeben Wert wird dann verwendet, um einen statischen herzustellen <xref:System.Windows.DependencyProperty> Feld (<xref:System.Windows.Controls.Control.BorderBrushProperty>) für diese Eigenschaft auf den hinzugefügten Besitzer und eine `BorderBrush` Eigenschaftenwrapper auch deklariert wird.  
  
 Bezeichner des Besitzers der hinzugefügten Abhängigkeitseigenschaft zu verwendende für Vorgänge wie z. B. <xref:System.Windows.DependencyObject.GetValue%2A>. Jedoch typspezifische Operationen mit Typen oder Instanzen der Klasse, die hinzugefügt wurde, als Besitzer über unterschiedliche Metadaten weiterhin zurück, der erwarteten Ergebnisse, selbst wenn die ursprüngliche (nicht die hinzugefügten Besitzers) in Abhängigkeitseigenschaftbezeichner angegeben ist Aufrufe von Methoden wie z. B. <xref:System.Windows.DependencyObject.GetValue%2A> oder <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Die Metadaten für den hinzugefügten Besitzer wird aufrechterhalten, durch die <xref:System.Windows.DependencyProperty.AddOwner%2A> aufrufen selbst, nicht unbedingt ausschließlich durch das Hinzufügen von Besitzer Bezeichner Klassenfeld verwiesen wird. Dennoch wird empfohlen, den Bezeichner, der als auch neue verfügbar zu machen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A>, da Unterschiede zwischen unterlassen erstellt werden. die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Darstellungen Ihrer Eigenschaften.  
  
 Die angegebenen Metadaten werden mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist. Alle Eigenschaften, die in der ursprünglichen Basismetadaten angegeben wurden, werden beibehalten. Nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale des grundlegenden Metadaten überschrieben. Einige Eigenschaften, z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, ersetzt werden, wenn sie die neuen Metadaten angegeben werden. Andere, z. B. <xref:System.Windows.PropertyChangedCallback>, kombiniert werden. Letztlich Typ der Metadaten für die Außerkraftsetzung verwendet werden, damit das hier beschriebene Verhalten für die vorhandene Eigenschaft Metadatenklassen von verwendet wird der Merge-Verhalten hängt [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Abhängigkeitseigenschaften. Weitere Informationen finden Sie unter [Metadaten für die Abhängigkeitseigenschaft](~/docs/framework/wpf/advanced/dependency-property-metadata.md) und [Framework Eigenschaftsmetadaten](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardmetadaten der Abhängigkeitseigenschaft ab.</summary>
        <value>Die Standardmetadaten der Abhängigkeitseigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardmetadaten, ist die Eigenschaftenmetadaten, die für dieses Objekt oder ein Objekt eines abgeleiteten Typs verfügbar ist, in denen keine alternative Metadaten angegeben wurden durch eine explizite <xref:System.Windows.DependencyProperty.Register%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> aufrufen.  
  
 Wenn der ursprüngliche Besitzer Metadaten mit dem ersten angewendet <xref:System.Windows.DependencyProperty.Register%2A> Aufruf, der die Abhängigkeitseigenschaft hergestellt wird, wird, die Metadaten als zurückgegeben <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Wenn keine Metadaten im ursprünglichen besaß <xref:System.Windows.DependencyProperty.Register%2A> aufrufen, wird das Standardmetadatum innerhalb generiert der <xref:System.Windows.DependencyProperty.Register%2A> Aufruf und dieser Wert wird zurückgegeben, als der <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Der Hauptzweck der Standardmetadaten an, die mit einem <xref:System.Windows.DependencyProperty> ist, geben Sie einen Standardwert für diese Eigenschaft für ein beliebiges <xref:System.Windows.DependencyObject> oder eines abgeleiteten Typs.  
  
 Für nicht angefügte Eigenschaften der von dieser Eigenschaft zurückgegebene Metadatentyp keine Typumwandlung in abgeleiteten Typen <xref:System.Windows.PropertyMetadata> eingeben, auch wenn die Eigenschaft ursprünglich mit einem abgeleiteten Metadatentyp registriert wurde. Wenn Sie die ursprünglich registrierte Metadaten einschließlich seiner ursprünglichen möglicherweise abgeleiteten Metadatentyp möchten, rufen <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> stattdessen als Parameter eingeben und übergeben die ursprünglichen registrieren.  
  
 Für angefügte Eigenschaften entspricht der Typ der Metadaten, die von dieser Eigenschaft zurückgegebene den Typ in der ursprünglichen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Registrierungsmethode.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für diesen <see cref="T:System.Windows.DependencyProperty" /> zurück.</summary>
        <returns>Der Hashcode für diese <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Eigenschaftensystem verwendet seinen eigenen eindeutigen Bezeichner <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, und der Wert dieser Eigenschaft zurückgegebene <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die dieser Abhängigkeitseigenschaft zugeordneten Metadaten zurück, wie sie für einen bestimmten Typ vorhanden sind. Dies kann der Typ sein, für den die Abhängigkeitseigenschaft zuerst registriert wurde, ein Typ, dem sie später hinzugefügt wurde, oder einen Typ, für den die Abhängigkeitseigenschaft über Vererbung abgerufen wurde, wobei die Metadaten jedoch ausdrücklich überschrieben wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Der spezifische Typ, von dem die Metadaten für die Abhängigkeitseigenschaft abgerufen werden sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen vorhanden Typ vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben, den Typ oder einen Objektverweis verwenden, wie der Typ ist erforderlich, da die Metadaten von der ursprünglichen Registrierung aufgrund von variieren kann <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Aufrufe, die die Metadaten der Abhängigkeitseigenschaft geändert werden, weil sie für einen Typ vorhanden ist.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Metadaten für eine Abhängigkeitseigenschaft, die auf Grundlage seines Typs ab. Der Typ wird abgerufen, mit einem `typeof` Operator.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Ein Abhängigkeitsobjekt, dessen Typ überprüft wird, um zu ermitteln, von welcher typenspezifischen Version der Abhängigkeitseigenschaft die Metadaten stammen sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, da sie für die angegebene Objektinstanz vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben eines Typs oder ein Objektverweis ist notwendig, da die Metadaten einer angegebenen Abhängigkeitseigenschaft, von der ursprünglichen Registrierung aufgrund von variieren kann <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Aufrufe, die die Eigenschaftenmetadaten optimieren können, wie sie für vorhanden ein Geben Sie ein.  
  
 Beim Anfordern von Metadaten der Eigenschaft basierend auf einer Instanz werden Sie die Instanz tatsächlich nur erfolgreich ausgeführt, damit dessen Typ intern ausgewertet werden kann. Die Metadaten für Abhängigkeitseigenschaften variiert pro Instanz nicht; Es ist immer für eine beliebige Kombination von bestimmten Typeigenschaft konsistent.  
  
   
  
## Examples  
 Im folgende Beispiel ruft Metadaten für eine Abhängigkeitseigenschaft, die anhand einer bestimmten <xref:System.Windows.DependencyObject> Instanz.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Ein bestimmtes Objekt, das den Abhängigkeitsobjekttyp aufzeichnet, von dem die Metadaten für die Abhängigkeitseigenschaft stammen sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen Typ vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben eines Typs oder ein Objektverweis ist notwendig, da die Metadaten einer angegebenen Abhängigkeitseigenschaft, von der ursprünglichen Registrierung aufgrund von variieren kann <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Aufrufe, die die Eigenschaftenmetadaten optimieren können, wie sie für vorhanden ein Geben Sie ein.  
  
   
  
## Examples  
 Im folgende Beispiel ruft Metadaten für eine Abhängigkeitseigenschaft, die basierend auf seiner <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen intern generierten Wert ab, der die Abhängigkeitseigenschaft eindeutig identifiziert.</summary>
        <value>Ein eindeutiger numerischer Bezeichner.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert ist eine ganze Zahl, keinen global eindeutigen Bezeichner (GUID). Im Allgemeinen die Verwendung dieses Werts Index ist nicht erforderlich, und es gibt keinen Indexzugriff auf Tabellen aller Abhängigkeitseigenschaften. Abhängigkeitseigenschaften sollte stattdessen über ihre Bezeichnerfelder verwiesen werden.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> wird intern verwendet, für einen schnelleren Zugriff auf Datenstrukturen, mit denen die <xref:System.Windows.DependencyProperty.GlobalIndex%2A> als Arrayindex nullbasierte. Eine ähnliche Verwendung verfügen möglicherweise über Anwendungen für den Designer oder -Tools.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Bestimmt, ob ein angegebener Wert für den Typ dieser Abhängigkeitseigenschaft akzeptiert wird, wie anhand des in der Registrierung der ursprünglichen Abhängigkeitseigenschaft angegebenen Eigenschaftentyps überprüft wurde.</summary>
        <returns>
          <see langword="true" />, wenn der angegebene Wert der registrierte Eigenschaftentyp oder ein zulässiger abgeleiteter Typ ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `null` ist ein gültiger Typ für Abhängigkeitseigenschaften vom Referenztyp oder für eine <xref:System.Nullable%601> Abhängigkeitseigenschaft und würde zurückgeben `true` in diesen Fällen. In Fällen, in dem die Abhängigkeitseigenschaft weder ein Verweis ist, noch eine <xref:System.Nullable%601> Typ <xref:System.Windows.DependencyProperty.IsValidType%2A> zurück `false` für einen null-Wert anstelle von lösen eine Ausnahme.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyProperty.IsValidType%2A> als eine Überprüfung vor dem Aufruf <xref:System.Windows.DependencyObject.SetValue%2A> auf die Abhängigkeitseigenschaft.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Bestimmt, ob der angegebene Wert für den Eigenschaftentyp durch eine einfache Typüberprüfung zulässig ist und ob er sich potenziell im zulässigen Wertebereich für den Typ befindet.</summary>
        <returns>
          <see langword="true" />, wenn der Wert zulässig ist und den richtigen Typ oder einen abgeleiteten Typ aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für eine Abhängigkeitseigenschaft kann über einen zulässigen Wertebereichs für diesen Typ angegeben werden eine <xref:System.Windows.ValidateValueCallback> , die in der Registrierung der Abhängigkeitseigenschaft bereitgestellt wird.  
  
 Diese Methode ruft <xref:System.Windows.DependencyProperty.IsValidType%2A> intern. Wenn die fragliche Abhängigkeitseigenschaft keine <xref:System.Windows.ValidateValueCallback>, dann ist beim Aufrufen dieser Methode entspricht dem Aufruf <xref:System.Windows.DependencyProperty.IsValidType%2A>. Wenn die Abhängigkeitseigenschaft besitzt eine <xref:System.Windows.ValidateValueCallback>, und, wenn <xref:System.Windows.DependencyProperty.IsValidType%2A> zurückgegeben hätte `true`, wird der Wert werden zurückgegeben, wie im Rückruf implementiert.  
  
 Ein null-Wert ist ein gültiger Wert für Abhängigkeitseigenschaften vom Referenztyp oder ein <xref:System.Nullable%601> Abhängigkeitseigenschaft und würde zurückgeben `true` für diese Fälle. In Fällen, in dem die Abhängigkeitseigenschaft weder ein Verweis ist, noch eine <xref:System.Nullable%601> Typ <xref:System.Windows.DependencyProperty.IsValidType%2A> zurück `false` für einen null-Wert anstelle von lösen eine Ausnahme.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyProperty.IsValidValue%2A> als eine Überprüfung vor dem Aufruf <xref:System.Windows.DependencyObject.SetValue%2A> auf die Abhängigkeitseigenschaft.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Abhängigkeitseigenschaft ab.</summary>
        <value>Den Namen der Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft den Namen als die `name` Parameter während der Registrierung der Abhängigkeitseigenschaft. Dieser Name ist unveränderlich und nicht mit `null` oder eine leere Zeichenfolge. Doppelter Name Registrierungen für den gleichen Besitzertyp sind nicht zulässig und löst eine Ausnahme aus, wenn Sie versuchen, das Duplikat zu registrieren.  
  
> [!IMPORTANT]
>  Die <xref:System.Windows.DependencyProperty.Name%2A> einer Abhängigkeit muss Eigenschaft verwenden üblicherweise stimmen mit dem Namen des Bezeichners der Abhängigkeitseigenschaft ohne das Suffix "Property". Weitere Informationen finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Das folgende Beispiel fragt die verschiedenen Eigenschaften der Bezeichner für eine Abhängigkeitseigenschaft, einschließlich der <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt alternative Metadaten für diese Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, im Gegensatz zu den Metadaten, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</param>
        <param name="typeMetadata">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</param>
        <summary>Gibt alternative Metadaten für diese Abhängigkeitseigenschaft an, wenn sie in Instanzen eines angegebenen Typs vorhanden ist. Dabei werden die Metadaten überschrieben, die für die Abhängigkeitseigenschaft bei der Vererbung von Basistypen vorhanden waren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadaten für die Abhängigkeitseigenschaft sollte überschrieben werden, bevor Sie das Eigenschaftensystem die Abhängigkeitseigenschaft verwendet. Dies entspricht der Zeit, die bestimmte Instanzen erstellt werden, mithilfe der Klasse, die die Abhängigkeitseigenschaft registriert. Aufrufe von <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als der `forType` Parameter dieser Methode oder über eine ähnliche Instanziierung. Versuchen, die Metadaten ändern, nachdem die Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, es wird jedoch führt zu inkonsistentem Verhalten im Eigenschaftensystem.  
  
 Nachdem Metadaten für einen bestimmten abgeleiteten Klasse überschreiben, die mit dieser Methode hergestellt wurde, werden nachfolgende Versuche, die Metadaten in dieser abgeleiteten Klasse überschreiben, eine Ausnahme ausgelöst.  
  
 Die angegebenen Metadaten werden mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist. Alle Eigenschaften, die in der ursprünglichen Basismetadaten angegeben wurden, werden beibehalten. nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale des grundlegenden Metadaten überschrieben. Einige Eigenschaften wie z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ersetzt werden, wenn in den neuen Metadaten angegeben. Andere, z. B. <xref:System.Windows.PropertyChangedCallback>, kombiniert werden. Letztlich Typ der Metadaten für die Außerkraftsetzung verwendet werden, damit das hier beschriebene Verhalten für die vorhandene Eigenschaft Metadatenklassen von verwendet wird der Merge-Verhalten hängt [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Abhängigkeitseigenschaften. Weitere Informationen finden Sie unter [Metadaten für die Abhängigkeitseigenschaft](~/docs/framework/wpf/advanced/dependency-property-metadata.md) und [Framework Eigenschaftsmetadaten](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft zu überschreiben (dieser Vorgang kann nicht mit dieser Signatur ausgeführt werden).</exception>
        <exception cref="T:System.ArgumentException">Metadaten wurden für die Abhängigkeitseigenschaft bereits festgelegt, wie im bereitgestellten Typ vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</param>
        <param name="typeMetadata">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</param>
        <param name="key">Der Zugriffsschlüssel für eine schreibgeschützte Abhängigkeitseigenschaft.</param>
        <summary>Stellt alternative Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, wodurch die Metadaten überschrieben werden, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden. Sie müssen den <see cref="T:System.Windows.DependencyPropertyKey" /> für die schreibgeschützte Abhängigkeitseigenschaft übergeben, um das Auslösen einer Ausnahme zu vermeiden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur stellt die zugrunde liegende Implementierung für Bezeichner für eine schreibgeschützte Abhängigkeitseigenschaft bereit (<xref:System.Windows.DependencyPropertyKey>) Methode. Wenn Metadaten für eine Abhängigkeitseigenschaft mit Lese-/ Schreibzugriff zu überschreiben, verwenden Sie <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Metadaten für die Abhängigkeitseigenschaft sollte überschrieben werden, bevor Sie das Eigenschaftensystem die Abhängigkeitseigenschaft verwendet. Dies entspricht der Zeit, die bestimmte Objekte erstellt werden, für die Klasse, die die Abhängigkeitseigenschaft registriert. Aufrufe von <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als der `forType` Parameter dieser Methode oder über eine ähnliche Instanziierung. Versuchen, die Metadaten ändern, nachdem die Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, es wird jedoch führt zu inkonsistentem Verhalten im Eigenschaftensystem.  
  
 Nachdem Metadaten für einen bestimmten abgeleiteten Klasse überschreiben, die mit dieser Methode hergestellt wurde, werden nachfolgende Versuche, die Metadaten in dieser abgeleiteten Klasse überschreiben, eine Ausnahme ausgelöst.  
  
 Die angegebenen Metadaten werden mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist. Alle Eigenschaften, die in der ursprünglichen Basismetadaten angegeben wurden, werden beibehalten. nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale des grundlegenden Metadaten überschrieben. Einige Eigenschaften wie z. B. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ersetzt werden, wenn in den neuen Metadaten angegeben. Andere, z. B. <xref:System.Windows.PropertyChangedCallback>, kombiniert werden. Der Merge-Verhalten hängt vom Typ der Metadaten für die Außerkraftsetzung verwendeten ab. Weitere Informationen finden Sie unter [Metadaten für die Abhängigkeitseigenschaft](~/docs/framework/wpf/advanced/dependency-property-metadata.md) und [Framework Eigenschaftsmetadaten](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Objekts ab, das die Abhängigkeitseigenschaft im Eigenschaftensystem registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</summary>
        <value>Der Typ des Objekts, das die Eigenschaft registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wurde während der Registrierung bereitgestellt. Die Besitzer werden entweder den ursprünglichen Registrierungstyp im Fall von einer <xref:System.Windows.DependencyProperty> Bezeichner generiert eine <xref:System.Windows.DependencyProperty.Register%2A> Aufruf oder der Typ, der sich selbst als Besitzer im Fall von hinzugefügt eine <xref:System.Windows.DependencyProperty> Bezeichner generiert eine <xref:System.Windows.DependencyProperty.AddOwner%2A> aufrufen.  
  
 Die <xref:System.Windows.DependencyProperty.OwnerType%2A> auf einem gegebenen <xref:System.Windows.DependencyProperty> ist unveränderlich und nicht mit `null` in eine gültige <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Besitzertyp basierend auf den Bezeichner für eine Abhängigkeitseigenschaft `dp`, und klicken Sie dann Ruft Metadaten für den Besitzertyp ab, dem gleichen Bezeichner. Dieser Vorgang entspricht dem Abrufen von <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> auf `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, den die Abhängigkeitseigenschaft für den Wert verwendet.</summary>
        <value>Der <see cref="T:System.Type" /> des Eigenschaftswerts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Typ der Wert der Eigenschaft, wie durch das von der Registrierung der ursprünglichen, deklariert den `propertyType` Parameter. Ähnlich wie die <xref:System.Windows.DependencyProperty.Name%2A>, der Eigenschaftentyp einer Abhängigkeitseigenschaft nach der Registrierung unveränderlich ist.  
  
   
  
## Examples  
 Das folgende Beispiel fragt die verschiedenen Eigenschaften der Bezeichner für eine Abhängigkeitseigenschaft, einschließlich der <xref:System.Windows.DependencyProperty.PropertyType%2A>. Die Zeichenfolge der Typ der <xref:System.Windows.DependencyProperty.PropertyType%2A> abgerufen wird von der zurückgegebenen <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die von dieser <see cref="T:System.Windows.DependencyProperty" />-Instanz angegebene Abhängigkeitseigenschaft eine schreibgeschützte Abhängigkeitseigenschaft ist.</summary>
        <value>
          <see langword="true" />, wenn die Abhängigkeitseigenschaft schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schreibgeschützte Abhängigkeitseigenschaften im Eigenschaftensystem registriert sind, durch Aufrufen der <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Methode im Gegensatz zu den <xref:System.Windows.DependencyProperty.Register%2A> Methode. Angefügte Eigenschaften können auch als schreibgeschützt registriert werden; finden Sie unter <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Von schreibgeschützten Abhängigkeitseigenschaften erfordern ein <xref:System.Windows.DependencyPropertyKey> Bezeichner anstelle eines <xref:System.Windows.DependencyProperty> Bezeichner auszuführenden Vorgänge mit Metadaten wie z. B. das Überschreiben der Metadaten oder Festlegen des Werts. Wenn Sie eine Auflistung von erworben haben <xref:System.Windows.DependencyProperty> Bezeichner durch einen Aufruf von <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> oder ein anderes [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] Bezeichner, Kontrollkästchen verfügbar macht die <xref:System.Windows.DependencyProperty.ReadOnly%2A> Wert vor dem Aufrufen <xref:System.Windows.DependencyObject.SetValue%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> verwenden, Bezeichner der Abhängigkeitseigenschaft als Eingabeparameter, um sicherzustellen, dass die Abhängigkeitseigenschaft, die den Bezeichner darstellt, nicht schreibgeschützt ist. Wenn der Wert der <xref:System.Windows.DependencyProperty.ReadOnly%2A> ist `true` auf eine Abhängigkeitseigenschaft, es ist keine programmgesteuerte Methode zum Abrufen eines Verweises auf die <xref:System.Windows.DependencyPropertyKey> Bezeichner der Abhängigkeitseigenschaft über die Metadaten oder aus der <xref:System.Windows.DependencyProperty> Bezeichner; der Bezeichner muss als statisches Feld verfügbar sein, um Aufrufen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> für eine schreibgeschützte Abhängigkeitseigenschaft.  
  
 Wenn Sie eine benutzerdefinierte Abhängigkeitseigenschaft erstellen und registrieren Sie ihn als schreibgeschützt, sollten Sie nur einen Get-Accessor für definieren die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Wrappereigenschaft. Andernfalls müssen die Klasse ein verwirrend Objektmodell für den Eigenschaftenwrapper im Vergleich zu den Zugriff auf die Sicherungsabhängigkeitseigenschaft. Weitere Informationen finden Sie unter [benutzerdefinierte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/custom-dependency-properties.md) oder [schreibgeschützte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Im folgenden Beispiel ermittelt das Standardmetadatum und den Bezeichner der Abhängigkeitseigenschaften-Eigenschaft aus verschiedenen Abhängigkeit Eigenschaftenfelder und verwendet die Informationen zum Auffüllen einer Tabelle, um eine "Metadatenbrowser" implementieren.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine Abhängigkeitseigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft. Der Name muss innerhalb des Registrierungsnamespace des Besitzertyps eindeutig sein.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <see langword="public static readonly" />-Feld in der Klasse verwendet werden sollte. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <see langword="public static readonly" />-Feld in der Klasse verwendet werden sollte. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <see langword="public static readonly" />-Feld in der Klasse verwendet werden sollte. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine Abhängigkeitseigenschaft, z. B. einen Validierungsrückruf (die Rückruf-Definition wird nicht angezeigt; Einzelheiten über die Rückruf-Definition finden Sie unter <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine angefügte Eigenschaft mit dem Eigenschaftensystem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <see langword="public static readonly" />-Feld in der Klasse verwendet werden sollte. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist eine Eigenschaftenkonzept von definierten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften. Da die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügte Eigenschaften Abhängigkeitseigenschaften, sie können Metadaten angewendet, die vom Eigenschaftensystem allgemeine für Vorgänge wie z. B. reporting Layouteigenschaften verwendet werden kann. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine angefügte Eigenschaft für eine abstrakte Klasse, die mit diesem <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Signatur.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft. Dies kann den Standardwert sowie andere Merkmale einschließen.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftenmetadaten.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <see langword="public static readonly" />-Feld in der Klasse verwendet werden sollte. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist eine Eigenschaftenkonzept von definierten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften. Da die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügte Eigenschaften Abhängigkeitseigenschaften, sie können Metadaten angewendet, die vom Eigenschaftensystem allgemeine für Vorgänge wie z. B. reporting Layouteigenschaften verwendet werden kann. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anstelle von <xref:System.Windows.DependencyProperty.Register%2A> dient zur Unterstützung der Vererbung von Eigenschaftenwerten. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.   Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft. Dies kann den Standardwert sowie andere Merkmale einschließen.</param>
        <param name="validateValueCallback">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und dem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <see langword="public static readonly" />-Feld in der Klasse verwendet werden sollte. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist eine Eigenschaftenkonzept von definierten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften. Da die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügte Eigenschaften Abhängigkeitseigenschaften, sie können Metadaten angewendet, die vom Eigenschaftensystem allgemeine für Vorgänge wie z. B. reporting Layouteigenschaften verwendet werden kann. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anstelle von <xref:System.Windows.DependencyProperty.Register%2A> dient zur Unterstützung der Vererbung von Eigenschaftenwerten. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.   Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine angefügte Eigenschaft für eine abstrakte Klasse, die mit diesem <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Signatur. Diese angefügte Eigenschaft ist eine Enumeration Type-Eigenschaft, und die Registrierung Fügt einen Validierungsrückruf, um sicherzustellen, dass der bereitgestellte Wert ein Wert aus der Enumeration ist.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine schreibgeschützte angefügte Eigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine schreibgeschützte angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>, wohingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <xref:System.Windows.DependencyPropertyKey> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind. Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` -Feld in der Klasse.  
  
 Schreibgeschützte angefügte Eigenschaften sind einem seltenen Fall, da das Hauptszenario für eine angefügte Eigenschaft die Verwendung in ist [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Ohne einen öffentlichen Setter kann keine angefügte Eigenschaft festgelegt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft als zur Unterstützung der Vererbung von Eigenschaftenwerten ist angefügt. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.   Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine schreibgeschützte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</summary>
        <returns>Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>, wohingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die den Typ darstellen <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <xref:System.Windows.DependencyPropertyKey> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind. Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` -Feld in der Klasse.  
  
 Schreibgeschützte angefügte Eigenschaften sind einem seltenen Fall, da das Hauptszenario für eine angefügte Eigenschaft die Verwendung in ist [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Ohne einen öffentlichen Setter kann keine angefügte Eigenschaft festgelegt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben  
 Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft registrieren, wie anstelle von angeschlossenen <xref:System.Windows.DependencyProperty.Register%2A> dient zur Unterstützung der Vererbung von Eigenschaftenwerten. Registrieren Sie erben von Abhängigkeitseigenschaften mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.   Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert. Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine Abhängigkeitseigenschaft als schreibgeschützte Abhängigkeitseigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>, wohingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <xref:System.Windows.DependencyPropertyKey> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind. Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` -Feld in der Klasse.  
  
 Schreibgeschützte Abhängigkeitseigenschaften sind eine Recht typische Szenario sowohl in der vorhandenen [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] und-Anpassungsszenarien, da andere [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Funktionen erfordern möglicherweise eine Abhängigkeitseigenschaft, auch wenn diese Eigenschaft nicht festgelegt werden, indem sein soll Aufrufer. Sie können den Wert einer schreibgeschützten Abhängigkeitseigenschaft als Grundlage für andere Systemoperationen, die eine Abhängigkeitseigenschaft, z. B. basieren eine <xref:System.Windows.Trigger> auf die Abhängigkeitseigenschaft in einem Format.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Das folgende Beispiel registriert eine `AquariumSize` Abhängigkeitseigenschaft als schreibgeschützt. Im Beispiel definiert `AquariumSizeKey` als interner Schlüssel (also, dass andere Klassen in der Assembly konnte Metadaten überschreiben) und der Bezeichner der Abhängigkeitseigenschaft auf diesen Schlüssel als basierend macht `AquariumSizeProperty`. Darüber hinaus wird ein Wrapper für erstellt `AquariumSize`, mit nur einem Get-Accessor.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</summary>
        <returns>Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Typ zurück <xref:System.Windows.DependencyPropertyKey>, wohingegen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> gibt den Typ zurück <xref:System.Windows.DependencyProperty>. In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <xref:System.Windows.DependencyPropertyKey> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind. Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als eine `public static readonly` -Feld in der Klasse.  
  
 Schreibgeschützte Abhängigkeitseigenschaften sind eine Recht typische Szenario. Sie können den Wert einer schreibgeschützten Abhängigkeitseigenschaft als Grundlage für andere Systemoperationen, die eine Abhängigkeitseigenschaft, z. B. basieren eine <xref:System.Windows.Trigger> auf die Abhängigkeitseigenschaft in einem Format.  
  
 Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <xref:System.Windows.DependencyProperty>.  
  
 Überprüfung auf eine schreibgeschützte Abhängigkeitseigenschaft möglicherweise weniger wichtig. Die nicht öffentliche Zugriffsebene, die Sie für den Schlüssel angeben, verringert die Wahrscheinlichkeit für beliebige ungültige Eingaben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichenfolgendarstellung der Abhängigkeitseigenschaft zurück.</summary>
        <returns>Die Zeichenfolgendarstellung der Abhängigkeitseigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung gibt die <xref:System.Windows.DependencyProperty.Name%2A> Eigenschaftswert.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen statischen Wert an, der vom [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem verwendet wird, und nicht <see langword="null" />, um anzugeben, dass die Eigenschaft vorhanden ist, der Wert jedoch nicht vom Eigenschaftensystem festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> ist ein Sentinelwert, die für Szenarios verwendet wird, in dem die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem kann einen angeforderten bestimmen <xref:System.Windows.DependencyProperty> Wert. <xref:System.Windows.DependencyProperty.UnsetValue> wird verwendet, anstatt `null`, da `null` konnte einen gültigen Eigenschaftswert als auch einen gültigen (und häufig verwendet werden) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> wird niemals zurückgegeben von <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Beim Aufruf <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> auf eine Abhängigkeitseigenschaft für eine <xref:System.Windows.DependencyObject> Instanz, eines der folgenden gilt:  
  
-   Eine Abhängigkeitseigenschaft hat einen Standardwert, der in den Metadaten eingerichtet, und dieser Wert wird zurückgegeben. Dieser Wert stammt möglicherweise aus <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Ein anderer Wert von dem Eigenschaftensystem hergestellt wurde, und der Standardwert ist nicht mehr relevant. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Festlegen einer <xref:System.Windows.PropertyMetadata.DefaultValue%2A> von <xref:System.Windows.DependencyProperty.UnsetValue> ist ausdrücklich nicht zulässig.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Gibt <xref:System.Windows.DependencyProperty.UnsetValue> Wenn die angeforderte Eigenschaft wurde nicht lokal festgelegt wurde.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung, wenn als den Rückgabewert verwendet eine <xref:System.Windows.CoerceValueCallback>. Weitere Informationen finden Sie unter [Rückrufen von Abhängigkeitseigenschaften und Validierung](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Wenn Sie in einer Datenbank binden, beachten Sie, dass <xref:System.Windows.DependencyProperty.UnsetValue> entspricht nicht dem <xref:System.DBNull.Value>, auf ähnliche Weise, wie Sie <xref:System.DBNull.Value> entspricht keinem NULL-Wert "true".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wertvalidierungsrückruf für die Abhängigkeitseigenschaft ab.</summary>
        <value>Der Wertvalidierungsrückruf für diese Abhängigkeitseigenschaft, wie für den <paramref name="validateValueCallback" />-Parameter in der ursprünglichen Registrierung der Abhängigkeitseigenschaft angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält `null` für jede Abhängigkeitseigenschaft ohne registrierten Validierungsrückruf.  
  
 Rückrufe werden, wie statische verwendet müssen Wert von Validate: Überprüfung angewendet wird, über die <xref:System.Windows.ValidateValueCallback> kann bestimmen, ob der angegebene Wert für eine bestimmte Instanz gültig ist. Der Rückruf kann nur festgelegt, ob alle Objekte, die die Abhängigkeitseigenschaft besitzen soll oder sollte den angegebenen Wert als gültig akzeptiert. Wenn müssen Sie die Überprüfung ausführen, der verwendet wird, erkennbar sein muss, die Werte der anderen Abhängigkeitseigenschaften in einer bestimmten Instanz, verwenden eine <xref:System.Windows.CoerceValueCallback> stattdessen. Die <xref:System.Windows.CoerceValueCallback> als Teil der Metadaten für Abhängigkeitseigenschaften, anstatt direkt im Bezeichner für die Abhängigkeitseigenschaft registriert wird. Weitere Informationen finden Sie unter [Rückrufen von Abhängigkeitseigenschaften und Validierung](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>