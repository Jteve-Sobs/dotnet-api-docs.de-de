<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4d6ef8dd83de8d7bfbde1c8bc054bd69486e958e" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86988103" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Eigenschaft dar, die durch Methoden festgelegt werden kann, z. B. Formatierung, Datenbindung, Animation und Vererbung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyProperty> unterstützt die folgenden Funktionen in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] :  
  
-   Die-Eigenschaft kann in einem Stil festgelegt werden. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](/dotnet/framework/wpf/controls/styling-and-templating).  
  
-   Die-Eigenschaft kann durch Datenbindung festgelegt werden. Weitere Informationen zu den Abhängigkeits Eigenschaften von Daten Bindungen finden Sie unter Gewusst [wie: Binden der Eigenschaften von zwei Steuerelementen](/dotnet/framework/wpf/data/how-to-bind-the-properties-of-two-controls).  
  
-   Die-Eigenschaft kann mit einem dynamischen Ressourcen Verweis festgelegt werden. Weitere Informationen finden Sie unter [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
-   Die-Eigenschaft kann ihren Wert automatisch von einem übergeordneten Element in der-Elementstruktur erben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](/dotnet/framework/wpf/advanced/property-value-inheritance).  
  
-   Die-Eigenschaft kann animiert werden. Weitere Informationen finden Sie unter [Übersicht über Animation](/dotnet/framework/wpf/graphics-multimedia/animation-overview).  
  
-   Die-Eigenschaft kann melden, wenn der vorherige Wert der-Eigenschaft geändert wurde und der-Eigenschafts Wert erzwungen werden kann. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](/dotnet/framework/wpf/advanced/dependency-property-callbacks-and-validation).  
  
-   Die-Eigenschaft meldet Informationen an, z. b. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ob beim Ändern eines Eigenschafts Werts das Layoutsystem eine Neukomposition der visuellen Elemente für ein Element erfordern muss.  
  
-   Die-Eigenschaft erhält Unterstützung in [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)] .  Beispielsweise kann die-Eigenschaft im **Eigenschaften** Fenster bearbeitet werden.  
  
 Weitere Informationen zu Abhängigkeits Eigenschaften finden Sie unter [Übersicht über Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/dependency-properties-overview). Wenn Sie möchten, dass Eigenschaften von benutzerdefinierten Typen die Funktionen in der vorangehenden Liste unterstützen, sollten Sie eine Abhängigkeits Eigenschaft erstellen.  Informationen zum Erstellen von benutzerdefinierten Abhängigkeits Eigenschaften finden Sie unter [benutzerdefinierte Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/custom-dependency-properties).  
  
 Eine angefügte Eigenschaft ist eine Eigenschaft, mit der jedes Objektinformationen an den Typ melden kann, der die angefügte Eigenschaft definiert. In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] kann jeder Typ, der von erbt, <xref:System.Windows.DependencyObject> eine angefügte-Eigenschaft verwenden, unabhängig davon, ob der Typ von dem Typ erbt, der die Eigenschaft definiert. Eine angefügte Eigenschaft ist eine Funktion der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sprache.  Verwenden Sie zum Festlegen einer angefügten Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] den *besitztyp*.* PropertyName* -Syntax. Ein Beispiel für eine angefügte Eigenschaft ist die- <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Eigenschaft. Wenn Sie eine Eigenschaft erstellen möchten, die für alle Typen verwendet werden kann <xref:System.Windows.DependencyObject> , sollten Sie eine angefügte Eigenschaft erstellen. Weitere Informationen zu angefügten Eigenschaften, einschließlich ihrer Erstellung, finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

- oder -

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

- oder -

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `dependencyPropertyName`  
 Eine Zeichenfolge, die den <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> der gewünschten Abhängigkeits Eigenschaft angibt. Diesem kann ein XML-Namespace Präfix vorangestellt werden, wenn sich die Eigenschaft nicht im XML-Standard Namespace befindet (Weitere Informationen finden Sie unter [XAML-Namespaces und Namespace Zuordnung für WPF-XAML](/dotnet/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml)).  
  
 `ownerType`.`dependencyPropertyName`  
 Eine Zeichenfolge, die den Besitzertyp einer Abhängigkeits Eigenschaft, einen Punkt (.) und dann den angibt <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> . `ownerType` Außerdem kann ein XML-Namespace Präfix vorangestellt werden. Diese Verwendung gilt insbesondere für spät gebundene Stile und Vorlagen, bei denen der Besitzer der Abhängigkeits Eigenschaft für den Kontext der Verwendung angegeben werden muss, da der `TargetType` noch nicht bekannt ist. Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](/dotnet/framework/wpf/controls/styling-and-templating).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Eine Zeichenfolge, die den Besitzer einer angefügten Eigenschaft, einen Punkt (.) und dann den Namen der angefügten Eigenschaft angibt. `attachedPropertyOwnerType` Außerdem kann ein XML-Namespace Präfix vorangestellt werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits für einen Typ registriert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Der Typ, der als ein Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</param>
        <summary>Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde.</summary>
        <returns>Ein Verweis auf den ursprünglichen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner, der die Abhängigkeitseigenschaft angibt. Dieser Bezeichner sollte von der hinzufügenden Klasse als <see langword="public static readonly" />-Feld verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht es dem Eigenschaften System, eine Abhängigkeits Eigenschaft für einen Typ zu erkennen, der diese bestimmte Abhängigkeits Eigenschaft nicht anfänglich registriert hat.  
  
 In der Regel <xref:System.Windows.DependencyProperty.AddOwner%2A> wird verwendet, um Abhängigkeits Eigenschaften zu Klassen hinzuzufügen, die diese Abhängigkeits Eigenschaft nicht bereits über die verwaltete Klassen Vererbung verfügbar machen (die Klassen Vererbung würde bewirken, dass die Wrapper Eigenschaften von der abgeleiteten Klasse geerbt werden und somit allgemeine Member-Table-Zugriff auf die Abhängigkeits Eigenschaft bereitstellen würde). <xref:System.Windows.DependencyProperty.AddOwner%2A> ermöglicht dem Eigenschaften System, eine Abhängigkeits Eigenschaft für einen Typ zu erkennen, der diese Abhängigkeits Eigenschaft nicht anfänglich registriert hat.  
  
 Diese Signatur lässt keine Angabe von Metadaten zu.  Wenn Sie diese Methode verwenden, werden die Metadaten automatisch für den neuen <xref:System.Windows.DependencyProperty> und dessen Besitzertyp generiert. Die automatisch generierten Metadaten sind das Ergebnis der zusammengeführten Metadaten aller Basis Typen, für die diese Eigenschaft definiert ist. Wenn keine zusammengeführten Metadaten verfügbar sind, werden die Standard Metadaten für die Eigenschaft verwendet. Wenn die Eigenschaft mithilfe der-Methode registriert wird <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , sind die Standard Metadaten identisch mit den Metadaten, die beim Aufruf von erstellt wurden <xref:System.Windows.DependencyProperty.RegisterAttached%2A> . Andernfalls wird das <xref:System.Windows.PropertyMetadata> -Objekt erstellt, wobei die <xref:System.Windows.PropertyMetadata.DefaultValue%2A> -Eigenschaft auf den Standardwert des Eigenschafts Typs und alle anderen Eigenschaften von <xref:System.Windows.PropertyMetadata> auf festgelegt ist `null` . Verwenden <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> Sie die Signatur, wenn Sie Metadaten für die Version der Abhängigkeits Eigenschaft bereitstellen möchten, die dem bereitgestellten Typ hinzugefügt wurde.  
  
 Der Rückgabewert dieser Methode wird normalerweise verwendet, um die Abhängigkeits Eigenschaft zu deklarieren und verfügbar zu machen, indem Sie einen Bezeichner der Abhängigkeits Eigenschaft Der Bezeichner ermöglicht den Zugriff auf die Abhängigkeits Eigenschaft, wenn Sie Eigenschaften System-APIs für die Abhängigkeits Eigenschaft aufrufen möchten, insbesondere, da Sie in der hinzugefügten Besitzer Klasse vorhanden ist. Der gleiche Eigenschaftsname für den ursprünglichen Besitzer und den hinzugefügten Besitzer sollte verwendet werden, um die ähnliche Funktionalität anzugeben. Sie sollten den Rückgabewert der-Methode verwenden, <xref:System.Windows.DependencyProperty> <xref:System.Windows.DependencyProperty.AddOwner%2A> um den Bezeichner der Abhängigkeits Eigenschaft zu definieren. Außerdem müssen Sie die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeits Eigenschaften deklarieren, die Typen mithilfe von hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A> .  
  
 Die <xref:System.Windows.DependencyProperty.AddOwner%2A> oben genannte Methodik wird verwendet, wenn die Abhängigkeits Eigenschaften erstellt werden, die in deklariert werden [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] . Beispiels <xref:System.Windows.Controls.Border> Weise definieren sowohl als auch <xref:System.Windows.Controls.Control> eine `BorderBrush` Abhängigkeits Eigenschaft, die über ähnliche Funktionen verfügen. <xref:System.Windows.Controls.Control> definiert seine- `BorderBrush` Eigenschaft für das Eigenschaften System durch Aufrufen von <xref:System.Windows.DependencyProperty.AddOwner%2A> basierend auf dem ursprünglichen Besitzer <xref:System.Windows.Controls.Border> und dessen registriertem Bezeichner der <xref:System.Windows.Controls.Border.BorderBrushProperty> Abhängigkeits Eigenschaft. Der <xref:System.Windows.DependencyProperty.AddOwner%2A> Rückgabewert wird dann verwendet, um ein neues statisches <xref:System.Windows.DependencyProperty> Feld ( <xref:System.Windows.Controls.Control.BorderBrushProperty> ) für diese Eigenschaft für den hinzugefügten Besitzer einzurichten `BorderBrush` . Außerdem wird ein Eigenschafts Wrapper deklariert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Der Typ, der als Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</param>
        <param name="typeMetadata">Die Metadaten, die die Abhängigkeitseigenschaft beschreiben, wie sie für den bereitgestellten Typ vorhanden sind.</param>
        <summary>Fügt einen anderen Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde. Dabei werden Abhängigkeitseigenschaft-Metadaten für die Abhängigkeitseigenschaft bereitgestellt, wie sie für den bereitgestellten Besitzertyp vorhanden sind.</summary>
        <returns>Ein Verweis auf den ursprünglichen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner, der die Abhängigkeitseigenschaft angibt. Dieser Bezeichner sollte von der hinzufügenden Klasse als <see langword="public static readonly" />-Feld verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht es dem Eigenschaften System, eine Abhängigkeits Eigenschaft für einen Typ zu erkennen, der diese bestimmte Abhängigkeits Eigenschaft nicht anfänglich registriert hat.  
  
 Der Rückgabewert dieser Methode wird verwendet, um die Abhängigkeits Eigenschaft zu deklarieren und verfügbar zu machen, insbesondere, da Sie in der hinzugefügten Besitzer Klasse vorhanden ist. Im Allgemeinen sollte derselbe Eigenschaftsname sowohl für den ursprünglichen Besitzer als auch für den hinzugefügten Besitzer verwendet werden, um die ähnliche Funktionalität anzugeben. Es wird empfohlen, die Bezeichner sowie die neuen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeits Eigenschaften verfügbar zu machen, die Typen mithilfe von hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A> .  
  
 Die <xref:System.Windows.DependencyProperty.AddOwner%2A> oben empfohlene Methodik wird beim Erstellen von in deklarierten APIs verwendet [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] . Beispiels <xref:System.Windows.Controls.Border> Weise definieren sowohl als auch <xref:System.Windows.Controls.Control> eine `BorderBrush` Abhängigkeits Eigenschaft, die über ähnliche Funktionen verfügen. <xref:System.Windows.Controls.Control> definiert `BorderBrush` die-Eigenschaft für das Eigenschaften System durch Aufrufen von <xref:System.Windows.DependencyProperty.AddOwner%2A> für den ursprünglichen Besitzer und den zugehörigen Bezeichner der <xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Border.BorderBrushProperty> Abhängigkeits Eigenschaft. Der <xref:System.Windows.DependencyProperty.AddOwner%2A> Rückgabewert wird dann verwendet, um ein statisches <xref:System.Windows.DependencyProperty> Feld ( <xref:System.Windows.Controls.Control.BorderBrushProperty> ) für diese Eigenschaft für den hinzugefügten Besitzer einzurichten, und ein `BorderBrush` Eigenschafts Wrapper wird ebenfalls deklariert.  
  
 Der Bezeichner der Abhängigkeits Eigenschaft des hinzugefügten Besitzers sollte für Vorgänge wie verwendet werden <xref:System.Windows.DependencyObject.GetValue%2A> . Typspezifische Vorgänge, die entweder Typen oder Instanzen der Klasse betreffen, die als Besitzer mit unterschiedlichen Metadaten hinzugefügt wurden, geben jedoch weiterhin die erwarteten Ergebnisse zurück, auch wenn der ursprüngliche Bezeichner der Abhängigkeits Eigenschaft (nicht der hinzugefügte Besitzer) in Aufrufen von Methoden wie oder angegeben wird <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyProperty.GetMetadata%2A> . Die Metadaten für den hinzugefügten Besitzer werden durch den eigentlichen Rückruf fortgeführt. es wird <xref:System.Windows.DependencyProperty.AddOwner%2A> nicht notwendigerweise ausschließlich durch das hinzugefügte Feld Bezeichner der Besitzer Klasse verwiesen. Trotzdem empfiehlt es sich, den Bezeichner sowie neue [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Eigenschaftenwrapper für Abhängigkeits Eigenschaften verfügbar zu machen, die Typen mithilfe von hinzugefügt werden <xref:System.Windows.DependencyProperty.AddOwner%2A> , da dadurch keine Unterschiede zwischen der [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] -und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] der-Darstellung der Eigenschaften entstehen.  
  
 Die angegebenen Metadaten werden mit den Eigenschafts Metadaten für die Abhängigkeits Eigenschaft zusammengeführt, so wie Sie auf dem Basis Besitzer vorhanden sind. Alle Eigenschaften, die in den ursprünglichen Basis Metadaten angegeben wurden, bleiben erhalten. Nur die Merkmale, die speziell in den neuen Metadaten geändert wurden, überschreiben die Eigenschaften der Basis Metadaten. Einige Merkmale, wie z <xref:System.Windows.PropertyMetadata.DefaultValue%2A> . b., werden ersetzt, wenn Sie in den neuen Metadaten angegeben werden. Andere, wie z <xref:System.Windows.PropertyChangedCallback> . b., werden kombiniert. Letztendlich hängt das Zusammensetzungs Verhalten vom Eigenschaftentyp ab, der für die Überschreibung verwendet wird, sodass das hier beschriebene Verhalten für die vorhandenen eigenschaftenmetadatenklassen ist, die von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Abhängigkeits Eigenschaften verwendet werden. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/dependency-property-metadata) und [Framework-Eigenschaften Metadaten](/dotnet/framework/wpf/advanced/framework-property-metadata).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardmetadaten der Abhängigkeitseigenschaft ab.</summary>
        <value>Die Standardmetadaten der Abhängigkeitseigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Metadaten sind die Eigenschafts Metadaten, die für das betreffende Objekt verfügbar sind, oder ein Objekt eines abgeleiteten Typs, bei dem keine alternativen Metadaten durch einen expliziten-oder-Befehl bereitgestellt wurden <xref:System.Windows.DependencyProperty.Register%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> .  
  
 Wenn der ursprüngliche Besitzer Metadaten auf den ersten-Befehl angewendet <xref:System.Windows.DependencyProperty.Register%2A> hat, der die Abhängigkeits Eigenschaft hergestellt hat, werden diese Metadaten als zurückgegeben <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> .  
  
 Wenn im ursprünglichen-Befehl keine Metadaten angewendet <xref:System.Windows.DependencyProperty.Register%2A> wurden, werden Standard Metadaten aus dem-Befehl generiert, <xref:System.Windows.DependencyProperty.Register%2A> und dieser Wert wird als zurückgegeben <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> .  
  
 Der Hauptzweck der Verwendung von Standard Metadaten, die einem zugeordnet sind <xref:System.Windows.DependencyProperty> , besteht darin, einen Standardwert für diese Eigenschaft für einen beliebigen <xref:System.Windows.DependencyObject> oder einen abgeleiteten Typ bereitzustellen.  
  
 Bei nicht angefügten Eigenschaften kann der von dieser Eigenschaft zurückgegebene Metadatentyp nicht in abgeleitete Typen vom Typ umgewandelt werden <xref:System.Windows.PropertyMetadata> , auch wenn die Eigenschaft ursprünglich mit einem abgeleiteten Metadatentyp registriert wurde. Wenn Sie die ursprünglich registrierten Metadaten einschließlich ihres ursprünglichen, möglicherweise abgeleiteten metadatentyps verwenden möchten, müssen Sie <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> stattdessen aufrufen und den ursprünglichen Registrierungs Typ als Parameter übergeben.  
  
 Für angefügte Eigenschaften entspricht der Typ der Metadaten, die von dieser Eigenschaft zurückgegeben werden, dem Typ, der in der ursprünglichen <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Registrierungsmethode angegeben ist.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für diese <see cref="T:System.Windows.DependencyProperty" /> zurück.</summary>
        <returns>Der Hashcode für diese <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das-Eigenschaften System verwendet einen eigenen eindeutigen Bezeichner <xref:System.Windows.DependencyProperty.GlobalIndex%2A> , und der Wert dieser Eigenschaft wird von zurückgegeben <xref:System.Windows.DependencyProperty.GetHashCode%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die dieser Abhängigkeitseigenschaft zugeordneten Metadaten zurück, wie sie für einen bestimmten Typ vorhanden sind. Dies kann der Typ sein, für den die Abhängigkeitseigenschaft zuerst registriert wurde, ein Typ, dem sie später hinzugefügt wurde, oder einen Typ, für den die Abhängigkeitseigenschaft über Vererbung abgerufen wurde, wobei die Metadaten jedoch ausdrücklich überschrieben wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Der spezifische Typ, von dem die Metadaten für die Abhängigkeitseigenschaft abgerufen werden sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen vorhanden Typ vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Angabe des Typs oder eines Objekt Verweises, der als Typ verwendet werden soll, ist erforderlich, da die Metadaten von der ursprünglichen Registrierung abhängig sein können, indem <xref:System.Windows.DependencyProperty.AddOwner%2A> oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> aufgerufen wird, die die Metadaten der Abhängigkeits Eigenschaft ändern, wie Sie für einen Typ vorhanden sind.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Metadaten für eine Abhängigkeits Eigenschaft basierend auf dem Typ abgerufen. Der-Typ wird mithilfe eines- `typeof` Operators abgerufen.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (dependencyObject As DependencyObject) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Ein Abhängigkeitsobjekt, dessen Typ überprüft wird, um zu ermitteln, von welcher typenspezifischen Version der Abhängigkeitseigenschaft die Metadaten stammen sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, da sie für die angegebene Objektinstanz vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Angabe des Typs oder eines Objekt Verweises ist erforderlich, da die Metadaten einer angegebenen Abhängigkeits Eigenschaft aufgrund von- <xref:System.Windows.DependencyProperty.AddOwner%2A> oder- <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> aufrufen, die die Eigenschafts Metadaten verfeinern können, wie Sie für einen Typ vorhanden sind, von der ursprünglichen Registrierung abweichen können.  
  
 Wenn Sie auf einer-Instanz basierende Eigenschafts Metadaten anfordern, übergeben Sie die-Instanz wirklich, damit ihr Typ intern ausgewertet werden kann. Die Metadaten für Abhängigkeits Eigenschaften variieren je nach Instanz nicht. Sie ist für eine beliebige typeigenschafts Kombination immer konsistent.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Metadaten für eine Abhängigkeits Eigenschaft basierend auf einer bestimmten- <xref:System.Windows.DependencyObject> Instanz abgerufen.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (dependencyObjectType As DependencyObjectType) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Ein bestimmtes Objekt, das den Abhängigkeitsobjekttyp aufzeichnet, von dem die Metadaten für die Abhängigkeitseigenschaft stammen sollen.</param>
        <summary>Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen Typ vorhanden sind.</summary>
        <returns>Ein Objekt für Eigenschaftenmetadaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Angabe des Typs oder eines Objekt Verweises ist erforderlich, da die Metadaten einer angegebenen Abhängigkeits Eigenschaft aufgrund von- <xref:System.Windows.DependencyProperty.AddOwner%2A> oder- <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> aufrufen, die die Eigenschafts Metadaten verfeinern können, wie Sie für einen Typ vorhanden sind, von der ursprünglichen Registrierung abweichen können.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Metadaten für eine Abhängigkeits Eigenschaft basierend auf dem-Element abgerufen <xref:System.Windows.DependencyObjectType> .  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen intern generierten Wert ab, der die Abhängigkeitseigenschaft eindeutig identifiziert.</summary>
        <value>Ein eindeutiger numerischer Bezeichner.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert ist eine ganze Zahl, keine Globally Unique Identifier (GUID). Im Allgemeinen ist die Verwendung dieses Indexwerts nicht erforderlich, und es ist kein Indexzugriff auf Tabellen aller Abhängigkeits Eigenschaften vorhanden. Auf Abhängigkeits Eigenschaften sollte stattdessen in ihren Bezeichnerfeldern verwiesen werden.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> wird intern für den schnelleren Zugriff auf Datenstrukturen verwendet, die <xref:System.Windows.DependencyProperty.GlobalIndex%2A> als Null basierten Array Index verwenden. Eine ähnliche Verwendung kann Anwendungen für Designer oder Tools enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Bestimmt, ob ein angegebener Wert für den Typ dieser Abhängigkeitseigenschaft akzeptiert wird, wie anhand des in der Registrierung der ursprünglichen Abhängigkeitseigenschaft angegebenen Eigenschaftentyps überprüft wurde.</summary>
        <returns><see langword="true" />, wenn der angegebene Wert der registrierte Eigenschaftentyp oder ein zulässiger abgeleiteter Typ ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `null` ist ein gültiger Typ für Verweistyp-Abhängigkeits Eigenschaften oder für eine <xref:System.Nullable%601> Abhängigkeits Eigenschaft und würde `true` für diese Fälle zurückgeben. In Fällen, in denen die Abhängigkeits Eigenschaft weder ein Verweis noch ein <xref:System.Nullable%601> Typ ist, <xref:System.Windows.DependencyProperty.IsValidType%2A> wird `false` für einen NULL-Wert zurückgegeben, anstatt eine Ausnahme aufzurichten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyProperty.IsValidType%2A> als Überprüfung verwendet, bevor <xref:System.Windows.DependencyObject.SetValue%2A> für die-Abhängigkeits Eigenschaft aufgerufen wird.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Bestimmt, ob der angegebene Wert für den Eigenschaftentyp durch eine einfache Typüberprüfung zulässig ist und ob er sich potenziell im zulässigen Wertebereich für den Typ befindet.</summary>
        <returns><see langword="true" />, wenn der Wert zulässig ist und den richtigen Typ oder einen abgeleiteten Typ aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für eine Abhängigkeits Eigenschaft kann ein zulässiger Wertebereich für diesen Typ über einen angegeben werden <xref:System.Windows.ValidateValueCallback> , der in der Registrierung der Abhängigkeits Eigenschaft bereitgestellt wird.  
  
 Diese Methode ruft <xref:System.Windows.DependencyProperty.IsValidType%2A> intern auf. Wenn die betreffende Abhängigkeits Eigenschaft über keinen verfügt <xref:System.Windows.ValidateValueCallback> , entspricht das Aufrufen dieser Methode tatsächlich dem Aufrufen von <xref:System.Windows.DependencyProperty.IsValidType%2A> . Wenn die Abhängigkeits Eigenschaft einen hat <xref:System.Windows.ValidateValueCallback> und wenn <xref:System.Windows.DependencyProperty.IsValidType%2A> zurückgegeben hätte `true` , wird der zurückgegebene Wert im Rückruf als implementiert.  
  
 Ein NULL-Wert ist ein gültiger Wert für Verweistyp-Abhängigkeits Eigenschaften oder für eine <xref:System.Nullable%601> Abhängigkeits Eigenschaft und würde `true` für diese Fälle zurückgeben. In Fällen, in denen die Abhängigkeits Eigenschaft weder ein Verweis noch ein <xref:System.Nullable%601> Typ ist, <xref:System.Windows.DependencyProperty.IsValidType%2A> wird `false` für einen NULL-Wert zurückgegeben, anstatt eine Ausnahme aufzurichten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyProperty.IsValidValue%2A> als Überprüfung verwendet, bevor <xref:System.Windows.DependencyObject.SetValue%2A> für die-Abhängigkeits Eigenschaft aufgerufen wird.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Abhängigkeitseigenschaft ab.</summary>
        <value>Den Namen der Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft den Namen ab, der `name` während der Registrierung der Abhängigkeits Eigenschaft als Parameter angegeben wird. Dieser Name ist unveränderlich und darf nicht `null` oder eine leere Zeichenfolge sein. Doppelte namens Registrierungen für denselben Besitzertyp sind nicht zulässig, und es wird eine Ausnahme ausgelöst, wenn Sie versuchen, das Duplikat zu registrieren.  
  
> [!IMPORTANT]
>  Der einer <xref:System.Windows.DependencyProperty.Name%2A> Abhängigkeits Eigenschaft muss der Konvention entsprechen, den Namen des Bezeichner der Abhängigkeits Eigenschaft minus dem Suffix "Property" zu finden. Weitere Informationen finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](/dotnet/framework/wpf/advanced/custom-dependency-properties).  
  
   
  
## Examples  
 Im folgenden Beispiel werden verschiedene Merkmale eines Bezeichners für eine Abhängigkeits Eigenschaft, einschließlich, abgefragt <xref:System.Windows.DependencyProperty.Name%2A> .  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt alternative Metadaten für diese Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, im Gegensatz zu den Metadaten, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</param>
        <param name="typeMetadata">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</param>
        <summary>Gibt alternative Metadaten für diese Abhängigkeitseigenschaft an, wenn sie in Instanzen eines angegebenen Typs vorhanden ist. Dabei werden die Metadaten überschrieben, die für die Abhängigkeitseigenschaft bei der Vererbung von Basistypen vorhanden waren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadaten für Abhängigkeits Eigenschaften sollten überschrieben werden, bevor das Eigenschaften System die Abhängigkeits Eigenschaft verwendet. Dies entspricht der Zeit, in der bestimmte Instanzen mithilfe der Klasse erstellt werden, die die Abhängigkeits Eigenschaft registriert. Aufrufe von <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sollten nur innerhalb der statischen Konstruktoren des Typs ausgeführt werden, der sich selbst als `forType` Parameter dieser Methode bereitstellt, oder durch eine ähnliche Instanziierung. Wenn Sie versuchen, die Metadaten zu ändern, nachdem Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, dies führt jedoch zu inkonsistenten Verhalten im Eigenschaften System.  
  
 Nachdem die Metadaten für eine bestimmte abgeleitete Klasse mit dieser Methode überschrieben wurden, wird bei nachfolgenden versuchen, Metadaten für diese abgeleitete Klasse zu überschreiben, eine Ausnahme ausgelöst.  
  
 Die angegebenen Metadaten werden mit den Eigenschafts Metadaten für die Abhängigkeits Eigenschaft zusammengeführt, so wie Sie auf dem Basis Besitzer vorhanden sind. Alle Eigenschaften, die in den ursprünglichen Basis Metadaten angegeben wurden, bleiben erhalten. nur die Merkmale, die speziell in den neuen Metadaten geändert wurden, überschreiben die Eigenschaften der Basis Metadaten. Einige Merkmale wie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> werden ersetzt, wenn Sie in den neuen Metadaten angegeben werden. Andere, wie z <xref:System.Windows.PropertyChangedCallback> . b., werden kombiniert. Letztendlich hängt das Zusammensetzungs Verhalten vom Eigenschaftentyp ab, der für die Überschreibung verwendet wird, sodass das hier beschriebene Verhalten für die vorhandenen eigenschaftenmetadatenklassen ist, die von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Abhängigkeits Eigenschaften verwendet werden. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/dependency-property-metadata) und [Framework-Eigenschaften Metadaten](/dotnet/framework/wpf/advanced/framework-property-metadata).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft zu überschreiben (dieser Vorgang kann nicht mit dieser Signatur ausgeführt werden).</exception>
        <exception cref="T:System.ArgumentException">Metadaten wurden für die Abhängigkeitseigenschaft bereits festgelegt, wie im bereitgestellten Typ vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</param>
        <param name="typeMetadata">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</param>
        <param name="key">Der Zugriffsschlüssel für eine schreibgeschützte Abhängigkeitseigenschaft.</param>
        <summary>Stellt alternative Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, wodurch die Metadaten überschrieben werden, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden. Sie müssen die <see cref="T:System.Windows.DependencyPropertyKey" /> für die schreibgeschützte Abhängigkeitseigenschaft übergeben, um das Auslösen einer Ausnahme zu vermeiden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur stellt die zugrunde liegende Implementierung für eine schreibgeschützte Abhängigkeits Eigenschaften- <xref:System.Windows.DependencyPropertyKey> bezeichnermethode () dar. Wenn Sie Metadaten für eine Abhängigkeits Eigenschaft mit Lese-und Schreibzugriff überschreiben, verwenden Sie <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>  
  
 Metadaten für Abhängigkeits Eigenschaften sollten überschrieben werden, bevor das Eigenschaften System die Abhängigkeits Eigenschaft verwendet. Dies entspricht der Zeit, in der bestimmte Objekte für die Klasse erstellt werden, die die Abhängigkeits Eigenschaft registriert. Aufrufe von <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sollten nur innerhalb der statischen Konstruktoren des Typs ausgeführt werden, der sich selbst als `forType` Parameter dieser Methode bereitstellt, oder durch eine ähnliche Instanziierung. Wenn Sie versuchen, die Metadaten zu ändern, nachdem Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, dies führt jedoch zu inkonsistenten Verhalten im Eigenschaften System.  
  
 Nachdem die Metadaten für eine bestimmte abgeleitete Klasse mit dieser Methode überschrieben wurden, wird bei nachfolgenden versuchen, Metadaten für diese abgeleitete Klasse zu überschreiben, eine Ausnahme ausgelöst.  
  
 Die angegebenen Metadaten werden mit den Eigenschafts Metadaten für die Abhängigkeits Eigenschaft zusammengeführt, so wie Sie auf dem Basis Besitzer vorhanden sind. Alle Eigenschaften, die in den ursprünglichen Basis Metadaten angegeben wurden, bleiben erhalten. nur die Merkmale, die speziell in den neuen Metadaten geändert wurden, überschreiben die Eigenschaften der Basis Metadaten. Einige Merkmale wie <xref:System.Windows.PropertyMetadata.DefaultValue%2A> werden ersetzt, wenn Sie in den neuen Metadaten angegeben werden. Andere, wie z <xref:System.Windows.PropertyChangedCallback> . b., werden kombiniert. Das Zusammensetzungs Verhalten hängt von dem Eigenschaftentyp ab, der für die Überschreibung verwendet wird. Weitere Informationen finden Sie unter [Metadaten für Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/dependency-property-metadata) und [Framework-Eigenschaften Metadaten](/dotnet/framework/wpf/advanced/framework-property-metadata).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Objekts ab, das die Abhängigkeitseigenschaft im Eigenschaftensystem registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</summary>
        <value>Der Typ des Objekts, das die Eigenschaft registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wurde während der Eigenschaften Registrierung bereitgestellt. Der Besitzer ist entweder der ursprüngliche registriungstyp im Fall eines Bezeichners <xref:System.Windows.DependencyProperty> , der von einem-Befehl generiert <xref:System.Windows.DependencyProperty.Register%2A> wurde, oder der Typ, der sich selbst als Besitzer hinzugefügt hat, wenn ein <xref:System.Windows.DependencyProperty> Bezeichner, der von einem-Befehl generiert wurde <xref:System.Windows.DependencyProperty.AddOwner%2A> .  
  
 Der <xref:System.Windows.DependencyProperty.OwnerType%2A> auf einem beliebigen <xref:System.Windows.DependencyProperty> ist unveränderlich und darf nicht `null` in einem gültigen sein <xref:System.Windows.DependencyProperty> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Besitzertyp basierend auf dem Bezeichner einer Abhängigkeits Eigenschaft abgerufen `dp` , und dann werden die Metadaten für den Besitzertyp für denselben Bezeichner abgerufen. Dieser Vorgang entspricht tatsächlich dem Abrufen <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> von `dp` .  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, den die Abhängigkeitseigenschaft für den Wert verwendet.</summary>
        <value>Der <see cref="T:System.Type" /> des Eigenschaftswerts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft meldet den Typ des Eigenschafts Werts, wie er von der ursprünglichen Eigenschaften Registrierung deklariert wurde, über den- `propertyType` Parameter. Ähnlich wie bei <xref:System.Windows.DependencyProperty.Name%2A> ist der Eigenschaftentyp einer Abhängigkeits Eigenschaft nach der Registrierung unveränderlich.  
  
   
  
## Examples  
 Im folgenden Beispiel werden verschiedene Merkmale eines Bezeichners für eine Abhängigkeits Eigenschaft, einschließlich, abgefragt <xref:System.Windows.DependencyProperty.PropertyType%2A> . Die Typnamen Zeichenfolge von <xref:System.Windows.DependencyProperty.PropertyType%2A> wird aus der zurückgegebenen abgerufen <xref:System.Type> .  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die von dieser <see cref="T:System.Windows.DependencyProperty" />-Instanz angegebene Abhängigkeitseigenschaft eine schreibgeschützte Abhängigkeitseigenschaft ist.</summary>
        <value><see langword="true" />, wenn die Abhängigkeitseigenschaft schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schreibgeschützte Abhängigkeits Eigenschaften werden innerhalb des-Eigenschaften Systems registriert, indem die- <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Methode im Gegensatz zur-Methode aufgerufen wird <xref:System.Windows.DependencyProperty.Register%2A> . Angefügte Eigenschaften können auch als schreibgeschützt registriert werden. siehe <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A> .  
  
 Schreibgeschützte Abhängigkeits Eigenschaften erfordern <xref:System.Windows.DependencyPropertyKey> anstelle eines Bezeichners einen Bezeichner <xref:System.Windows.DependencyProperty> , um Metadatenvorgänge wie das Überschreiben der Metadaten oder das Festlegen des Werts auszuführen. Wenn Sie eine Auflistung von <xref:System.Windows.DependencyProperty> Bezeichnern über einen Aufrufen von <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> oder eine andere API abgerufen haben, die Bezeichner verfügbar macht, überprüfen Sie den Wert, bevor Sie versuchen, den Bezeichner der <xref:System.Windows.DependencyProperty.ReadOnly%2A> <xref:System.Windows.DependencyObject.SetValue%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Abhängigkeits Eigenschaft als Eingabeparameter zu verwenden, um zu überprüfen, ob die Abhängigkeits Eigenschaft, die der Bezeichner darstellt, nicht schreibgeschützt ist. Wenn der Wert von <xref:System.Windows.DependencyProperty.ReadOnly%2A> `true` für eine Abhängigkeits Eigenschaft ist, gibt es keine programmgesteuerte Methode zum Abrufen eines Verweises auf den <xref:System.Windows.DependencyPropertyKey> Bezeichner der Abhängigkeits Eigenschaft aus den Metadaten oder dem <xref:System.Windows.DependencyProperty> Bezeichner. der Bezeichner muss als statisches Feld verfügbar sein, um für eine schreibgeschützte <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Abhängigkeits Eigenschaft aufzurufen.  
  
 Wenn Sie eine benutzerdefinierte Abhängigkeits Eigenschaft erstellen und Sie als schreibgeschützt registrieren, sollten Sie nur einen get-Accessor für die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Wrapper Eigenschaft definieren. Andernfalls verfügt die Klasse über ein verwirrendes Objektmodell für den Eigenschafts Wrapper im Vergleich zum Zugriff auf die Abhängigkeits Eigenschaft, die unterstützt. Weitere Informationen finden Sie unter [benutzerdefinierte Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/custom-dependency-properties) oder schreibgeschützte [Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/read-only-dependency-properties).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten und die Eigenschaften des bezeichnerbezeichnerbezeichners aus unterschiedlichen Abhängigkeits Eigenschafts Feldern abgerufen, und die Informationen werden verwendet, um eine Tabelle zum Implementieren eines "metadatenbrowsers" aufzufüllen.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine Abhängigkeitseigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft. Der Name muss innerhalb des Registrierungsnamespace des Besitzertyps eindeutig sein.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata, validateValueCallback As ValidateValueCallback) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Abhängigkeits Eigenschaft (einschließlich eines Validierungs Rückrufs) registriert (die Rückruf Definition wird nicht angezeigt; ausführliche Informationen zur Rückruf Definition finden Sie unter <xref:System.Windows.ValidateValueCallback> ).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine angefügte Eigenschaft mit dem Eigenschaftensystem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist ein Eigenschafts Konzept, das von definiert wird [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] . [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeits Eigenschaften. Da es sich bei den [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügten Eigenschaften um Abhängigkeits Eigenschaften handelt, können Metadaten angewendet werden, die vom allgemeinen Eigenschaften System für Vorgänge wie Berichts Layouteigenschaften verwendet werden können. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird mit dieser Signatur eine angefügte Eigenschaft für eine abstrakte Klasse registriert <xref:System.Windows.DependencyProperty.RegisterAttached%2A> .  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft. Dies kann den Standardwert sowie andere Merkmale einschließen.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftenmetadaten.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist ein Eigenschafts Konzept, das von definiert wird [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] . [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeits Eigenschaften. Da es sich bei den [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügten Eigenschaften um Abhängigkeits Eigenschaften handelt, können Metadaten angewendet werden, die vom allgemeinen Eigenschaften System für Vorgänge wie Berichts Layouteigenschaften verwendet werden können. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwenden von RegisterAttached für Wert erbende Abhängigkeits Eigenschaften  
 Ein bestimmtes Szenario zum Registrieren einer Abhängigkeits Eigenschaft mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anstelle von <xref:System.Windows.DependencyProperty.Register%2A> ist die Unterstützung der Vererbung von Eigenschafts Werten. Sie sollten Werte erben, die Abhängigkeits Eigenschaften mit erben <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Eigenschaftenwrapper Accessoren definiert, die die Abhängigkeits Eigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get *-und Set * static-Methoden zur Bereitstellung von echten Accessoren für angefügte Eigenschaften bereitzustellen.   Obwohl die Vererbung von Eigenschafts Werten für nicht angefügte Abhängigkeits Eigenschaften aussehen könnte, ist das Vererbungs Verhalten für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Laufzeitstruktur nicht definiert. Wenn die Eigenschaft als angefügt registriert wird, ist die angefügte Eigenschaft eine globale Eigenschaft für das Eigenschaften System und stellt sicher, dass die Vererbung von Eigenschafts Werten über alle Grenzen in einer Elementstruktur hinweg funktioniert. Verwenden <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Sie immer, um die Eigenschaften zu registrieren, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> die Sie in den Metadaten angeben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](/dotnet/framework/wpf/advanced/property-value-inheritance).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata, validateValueCallback As ValidateValueCallback) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft. Dies kann den Standardwert sowie andere Merkmale einschließen.</param>
        <param name="validateValueCallback">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und dem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</summary>
        <returns>Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts eines <see langword="public static readonly" />-Felds in der Klasse verwendet werden soll. Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine angefügte Eigenschaft ist ein Eigenschafts Konzept, das von definiert wird [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] . [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Eigenschaften als Abhängigkeits Eigenschaften. Da es sich bei den [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] angefügten Eigenschaften um Abhängigkeits Eigenschaften handelt, können Metadaten angewendet werden, die vom allgemeinen Eigenschaften System für Vorgänge wie Berichts Layouteigenschaften verwendet werden können. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwenden von RegisterAttached für Wert erbende Abhängigkeits Eigenschaften  
 Ein bestimmtes Szenario zum Registrieren einer Abhängigkeits Eigenschaft mit <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anstelle von <xref:System.Windows.DependencyProperty.Register%2A> ist die Unterstützung der Vererbung von Eigenschafts Werten. Sie sollten Werte erben, die Abhängigkeits Eigenschaften mit erben <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Eigenschaftenwrapper Accessoren definiert, die die Abhängigkeits Eigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get *-und Set * static-Methoden zur Bereitstellung von echten Accessoren für angefügte Eigenschaften bereitzustellen.   Obwohl die Vererbung von Eigenschafts Werten für nicht angefügte Abhängigkeits Eigenschaften aussehen könnte, ist das Vererbungs Verhalten für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Laufzeitstruktur nicht definiert. Wenn die Eigenschaft als angefügt registriert wird, ist die angefügte Eigenschaft eine globale Eigenschaft für das Eigenschaften System und stellt sicher, dass die Vererbung von Eigenschafts Werten über alle Grenzen in einer Elementstruktur hinweg funktioniert. Verwenden <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Sie immer, um die Eigenschaften zu registrieren, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> die Sie in den Metadaten angeben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](/dotnet/framework/wpf/advanced/property-value-inheritance).  
  
   
  
## Examples  
 Im folgenden Beispiel wird mit dieser Signatur eine angefügte Eigenschaft für eine abstrakte Klasse registriert <xref:System.Windows.DependencyProperty.RegisterAttached%2A> . Diese angefügte Eigenschaft ist eine Enumerationstyp-Eigenschaft, und die Registrierung fügt einen Validierungs Rückruf hinzu, um zu überprüfen, ob der angegebene Wert ein Wert der-Enumeration ist.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine schreibgeschützte angefügte Eigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine schreibgeschützte angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den-Typ zurück <xref:System.Windows.DependencyPropertyKey> , während <xref:System.Windows.DependencyProperty.RegisterAttached%2A> den-Typ zurückgibt <xref:System.Windows.DependencyProperty> . Normalerweise werden die Schlüssel, die schreibgeschützte Eigenschaften darstellen, nicht öffentlich gemacht, da die Schlüssel verwendet werden können, um den Wert der Abhängigkeits Eigenschaft festzulegen, indem aufgerufen wird <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> . Ihr Klassen Design wirkt sich auf Ihre Anforderungen aus. es wird jedoch im Allgemeinen empfohlen, den Zugriff und die Sichtbarkeit eines beliebigen <xref:System.Windows.DependencyPropertyKey> auf die Teile des Codes zu beschränken, die erforderlich sind, um diese Abhängigkeits Eigenschaft als Teil der Klassen-oder Anwendungslogik festzulegen. Außerdem wird empfohlen, dass Sie einen Bezeichner für die Abhängigkeits Eigenschaft für die schreibgeschützte Abhängigkeits Eigenschaft verfügbar machen, indem Sie den Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als `public static readonly` Feld für die Klasse verfügbar machen.  
  
 Schreibgeschützte angefügte Eigenschaften sind ein seltenen Szenario, da das primäre Szenario für eine angefügte Eigenschaft in verwendet wird [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] . Ohne einen öffentlichen Setter kann eine angefügte Eigenschaft nicht in der Syntax festgelegt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwenden von RegisterAttached für Wert erbende Abhängigkeits Eigenschaften  
 Ein bestimmtes Szenario zum Registrieren einer Abhängigkeits Eigenschaft als angefügt ist die Unterstützung der Vererbung von Eigenschafts Werten. Sie sollten Werte erben, die Abhängigkeits Eigenschaften mit erben <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Eigenschaftenwrapper Accessoren definiert, die die Abhängigkeits Eigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get *-und Set * static-Methoden zur Bereitstellung von echten Accessoren für angefügte Eigenschaften bereitzustellen.   Obwohl die Vererbung von Eigenschafts Werten für nicht angefügte Abhängigkeits Eigenschaften aussehen könnte, ist das Vererbungs Verhalten für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Laufzeitstruktur nicht definiert. Wenn die Eigenschaft als angefügt registriert wird, ist die angefügte Eigenschaft eine globale Eigenschaft für das Eigenschaften System und stellt sicher, dass die Vererbung von Eigenschafts Werten über alle Grenzen in einer Elementstruktur hinweg funktioniert. Verwenden <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Sie immer, um die Eigenschaften zu registrieren, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> die Sie in den Metadaten angeben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](/dotnet/framework/wpf/advanced/property-value-inheritance).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata, validateValueCallback As ValidateValueCallback) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="defaultMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine schreibgeschützte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</summary>
        <returns>Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den-Typ zurück <xref:System.Windows.DependencyPropertyKey> , während <xref:System.Windows.DependencyProperty.RegisterAttached%2A> den-Typ zurückgibt <xref:System.Windows.DependencyProperty> . In der Regel die Schlüssel, die den Typ darstellen <xref:System.Windows.DependencyProperty> . Normalerweise werden die Schlüssel, die schreibgeschützte Eigenschaften darstellen, nicht öffentlich gemacht, da die Schlüssel verwendet werden können, um den Wert der Abhängigkeits Eigenschaft festzulegen, indem aufgerufen wird <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> . Ihr Klassen Design wirkt sich auf Ihre Anforderungen aus. es wird jedoch im Allgemeinen empfohlen, den Zugriff und die Sichtbarkeit eines beliebigen <xref:System.Windows.DependencyPropertyKey> auf die Teile des Codes zu beschränken, die erforderlich sind, um diese Abhängigkeits Eigenschaft als Teil der Klassen-oder Anwendungslogik festzulegen. Außerdem wird empfohlen, dass Sie einen Bezeichner für die Abhängigkeits Eigenschaft für die schreibgeschützte Abhängigkeits Eigenschaft verfügbar machen, indem Sie den Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als `public static readonly` Feld für die Klasse verfügbar machen.  
  
 Schreibgeschützte angefügte Eigenschaften sind ein seltenen Szenario, da das primäre Szenario für eine angefügte Eigenschaft in verwendet wird [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] . Ohne einen öffentlichen Setter kann eine angefügte Eigenschaft nicht in der Syntax festgelegt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Verwenden von RegisterAttached für Wert erbende Abhängigkeits Eigenschaften  
 Ein bestimmtes Szenario zum Registrieren einer Abhängigkeits Eigenschaft als angefügt anstelle von <xref:System.Windows.DependencyProperty.Register%2A> ist die Unterstützung der Vererbung von Eigenschafts Werten. Sie sollten Werte erben, die Abhängigkeits Eigenschaften mit erben <xref:System.Windows.DependencyProperty.RegisterAttached%2A> , auch wenn die Klasse Eigenschaftenwrapper Accessoren definiert, die die Abhängigkeits Eigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get *-und Set * static-Methoden zur Bereitstellung von echten Accessoren für angefügte Eigenschaften bereitzustellen.   Obwohl die Vererbung von Eigenschafts Werten für nicht angefügte Abhängigkeits Eigenschaften aussehen könnte, ist das Vererbungs Verhalten für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Laufzeitstruktur nicht definiert. Wenn die Eigenschaft als angefügt registriert wird, ist die angefügte Eigenschaft eine globale Eigenschaft für das Eigenschaften System und stellt sicher, dass die Vererbung von Eigenschafts Werten über alle Grenzen in einer Elementstruktur hinweg funktioniert. Verwenden <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Sie immer, um die Eigenschaften zu registrieren, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> die Sie in den Metadaten angeben. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](/dotnet/framework/wpf/advanced/property-value-inheritance).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert eine Abhängigkeitseigenschaft als schreibgeschützte Abhängigkeitseigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft.</param>
        <summary>Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</summary>
        <returns>Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den-Typ zurück <xref:System.Windows.DependencyPropertyKey> , während <xref:System.Windows.DependencyProperty.RegisterAttached%2A> den-Typ zurückgibt <xref:System.Windows.DependencyProperty> . Normalerweise werden die Schlüssel, die schreibgeschützte Eigenschaften darstellen, nicht öffentlich gemacht, da die Schlüssel verwendet werden können, um den Wert der Abhängigkeits Eigenschaft festzulegen, indem aufgerufen wird <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> . Ihr Klassen Design wirkt sich auf Ihre Anforderungen aus. es wird jedoch im Allgemeinen empfohlen, den Zugriff und die Sichtbarkeit eines beliebigen <xref:System.Windows.DependencyPropertyKey> auf die Teile des Codes zu beschränken, die erforderlich sind, um diese Abhängigkeits Eigenschaft als Teil der Klassen-oder Anwendungslogik festzulegen. Außerdem wird empfohlen, dass Sie einen Bezeichner für die Abhängigkeits Eigenschaft für die schreibgeschützte Abhängigkeits Eigenschaft verfügbar machen, indem Sie den Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als `public static readonly` Feld für die Klasse verfügbar machen.  
  
 Schreibgeschützte Abhängigkeits Eigenschaften sind ein ziemlich typisches Szenario sowohl in der vorhandenen API als auch in Anpassungs Szenarien, da andere [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Funktionen möglicherweise eine Abhängigkeits Eigenschaft erfordern, auch wenn diese Eigenschaft nicht von Aufrufern festgelegt werden kann. Sie können den Wert einer schreibgeschützten Abhängigkeits Eigenschaft als Grundlage für andere Eigenschafts System Vorgänge verwenden, die eine Abhängigkeits Eigenschaft annehmen, z. b. das Erstellen eines <xref:System.Windows.Trigger> auf der Abhängigkeits Eigenschaft in einem Stil.  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `AquariumSize` Abhängigkeits Eigenschaft als schreibgeschützt registriert. Das Beispiel definiert `AquariumSizeKey` als internen Schlüssel (sodass andere Klassen in der Assembly Metadaten überschreiben könnten) und macht den Bezeichner der Abhängigkeits Eigenschaft auf Grundlage dieses Schlüssels als verfügbar `AquariumSizeProperty` . Außerdem wird ein Wrapper für erstellt `AquariumSize` , der nur über einen get-Accessor verfügt.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata, validateValueCallback As ValidateValueCallback) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu registrierenden Abhängigkeitseigenschaft.</param>
        <param name="propertyType">Den Typ der Eigenschaft.</param>
        <param name="ownerType">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</param>
        <param name="typeMetadata">Eigenschaftsmetadaten für die Abhängigkeitseigenschaft.</param>
        <param name="validateValueCallback">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</param>
        <summary>Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</summary>
        <returns>Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den-Typ zurück <xref:System.Windows.DependencyPropertyKey> , während <xref:System.Windows.DependencyProperty.RegisterAttached%2A> den-Typ zurückgibt <xref:System.Windows.DependencyProperty> . Normalerweise werden die Schlüssel, die schreibgeschützte Eigenschaften darstellen, nicht öffentlich gemacht, da die Schlüssel verwendet werden können, um den Wert der Abhängigkeits Eigenschaft festzulegen, indem aufgerufen wird <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> . Ihr Klassen Design wirkt sich auf Ihre Anforderungen aus. es wird jedoch im Allgemeinen empfohlen, den Zugriff und die Sichtbarkeit eines beliebigen <xref:System.Windows.DependencyPropertyKey> auf die Teile des Codes zu beschränken, die erforderlich sind, um diese Abhängigkeits Eigenschaft als Teil der Klassen-oder Anwendungslogik festzulegen. Außerdem wird empfohlen, dass Sie einen Bezeichner für die Abhängigkeits Eigenschaft für die schreibgeschützte Abhängigkeits Eigenschaft verfügbar machen, indem Sie den Wert von <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> als `public static readonly` Feld für die Klasse verfügbar machen.  
  
 Schreibgeschützte Abhängigkeits Eigenschaften sind ein ziemlich typisches Szenario. Sie können den Wert einer schreibgeschützten Abhängigkeits Eigenschaft als Grundlage für andere Eigenschafts System Vorgänge verwenden, die eine Abhängigkeits Eigenschaft annehmen, z. b. das Erstellen eines <xref:System.Windows.Trigger> auf der Abhängigkeits Eigenschaft in einem Stil.  
  
 Weitere Informationen zur Registrierung von Abhängigkeits Eigenschaften finden Sie unter <xref:System.Windows.DependencyProperty> .  
  
 Die Validierung für eine schreibgeschützte Abhängigkeits Eigenschaft ist möglicherweise weniger wichtig. Die nicht öffentliche Zugriffsebene, die Sie für den Schlüssel angeben, reduziert die Wahrscheinlichkeit für eine beliebige ungültige Eingabe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichenfolgendarstellung der Abhängigkeitseigenschaft zurück.</summary>
        <returns>Die Zeichenfolgendarstellung der Abhängigkeitseigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung gibt den <xref:System.Windows.DependencyProperty.Name%2A> Eigenschafts Wert zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen statischen Wert an, der vom [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaftensystem verwendet wird, und nicht <see langword="null" />, um anzugeben, dass die Eigenschaft vorhanden ist, der Wert jedoch nicht vom Eigenschaftensystem festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> ist ein Sentinelwert, der für Szenarios verwendet wird, in denen das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaften System einen angeforderten Wert nicht ermitteln kann <xref:System.Windows.DependencyProperty> . <xref:System.Windows.DependencyProperty.UnsetValue> wird anstelle von verwendet `null` , da `null` ein gültiger Eigenschafts Wert und ein gültiger (und häufig verwendeter) Wert sein könnte <xref:System.Windows.PropertyMetadata.DefaultValue%2A> .  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> wird nie von zurückgegeben <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> . Wenn Sie <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> für eine Abhängigkeits Eigenschaft in einer-Instanz aufzurufen <xref:System.Windows.DependencyObject> , gilt eine der folgenden Aktionen:  
  
-   Für eine Abhängigkeits Eigenschaft wird ein Standardwert in den Metadaten festgelegt, und dieser Wert wird zurückgegeben. Dieser Wert kann aus stammen <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> .  
  
-   Ein anderer Wert wurde durch das Eigenschaften System festgelegt, und der Standardwert ist nicht mehr relevant. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](/dotnet/framework/wpf/advanced/dependency-property-value-precedence).  
  
 Das Festlegen eines <xref:System.Windows.PropertyMetadata.DefaultValue%2A> von <xref:System.Windows.DependencyProperty.UnsetValue> ist ausdrücklich nicht zulässig.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Gibt zurück, <xref:System.Windows.DependencyProperty.UnsetValue> Wenn die angeforderte Eigenschaft nicht lokal festgelegt wurde.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung, wenn als Rückgabewert eines verwendet wird <xref:System.Windows.CoerceValueCallback> . Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/dependency-property-callbacks-and-validation).  
  
 Wenn Sie eine Bindung an eine Datenbank durchlaufen, beachten Sie, dass <xref:System.Windows.DependencyProperty.UnsetValue> nicht entspricht <xref:System.DBNull.Value> , und zwar auf ähnliche Weise, wie <xref:System.DBNull.Value> nicht mit einem true NULL-Wert identisch ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wertvalidierungsrückruf für die Abhängigkeitseigenschaft ab.</summary>
        <value>Der Wertvalidierungsrückruf für diese Abhängigkeitseigenschaft, wie für den <paramref name="validateValueCallback" />-Parameter in der ursprünglichen Registrierung der Abhängigkeitseigenschaft angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält `null` für jede Abhängigkeits Eigenschaft ohne registrierten Validierungs Rückruf.  
  
 Validierungswertrückrufe müssen statisch sein: die über das angewendete Validierung <xref:System.Windows.ValidateValueCallback> kann nicht bestimmen, ob der angegebene Wert für eine bestimmte Instanz gültig ist. Der Rückruf kann nur bestimmen, ob alle Objekte, die die Abhängigkeits Eigenschaft besitzen, den bereitgestellten Wert als gültig akzeptieren sollen oder nicht. Wenn Sie eine Validierung durchführen müssen, die die Werte anderer Abhängigkeits Eigenschaften für eine bestimmte Instanz kennt, verwenden Sie <xref:System.Windows.CoerceValueCallback> stattdessen eine. Der <xref:System.Windows.CoerceValueCallback> wird als Teil der Metadaten für Abhängigkeits Eigenschaften registriert, anstatt direkt innerhalb des Bezeichners für die Abhängigkeits Eigenschaft. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeits Eigenschaften](/dotnet/framework/wpf/advanced/dependency-property-callbacks-and-validation).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>
