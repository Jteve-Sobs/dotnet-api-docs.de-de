<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyProperty.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd5b6a2bc5d76e65fbad41cf01060484fb71b52e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd5b6a2bc5d76e65fbad41cf01060484fb71b52e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</source>
          <target state="translated">Stellt eine Eigenschaft dar, die durch Methoden festgelegt werden kann, z. B. Formatierung, Datenbindung, Animation und Vererbung.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> supports the following capabilities in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> unterstützt die folgenden neuen Funktionen in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set in a style.</source>
          <target state="translated">Die Eigenschaft kann in einem Format festgelegt werden.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Erstellen von Formaten und Vorlagen<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set through data binding.</source>
          <target state="translated">Die Eigenschaft kann über die Datenbindung festgelegt werden.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information about data binding dependency properties, see <bpt id="p1">[</bpt>How to: Bind the Properties of Two Controls<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Datenbindungseigenschaften Abhängigkeit, finden Sie unter <bpt id="p1">[</bpt>Vorgehensweise: Binden von Eigenschaften von zwei Steuerelementen<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set with a dynamic resource reference.</source>
          <target state="translated">Die Eigenschaft kann mit einem dynamischen Ressourcenverweis festgelegt werden.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>XAML-Ressourcen<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can inherit its value automatically from a parent element in the element tree.</source>
          <target state="translated">Die Eigenschaft kann den Wert automatisch von einem übergeordneten Element in der Elementstruktur erben.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Vererbung von Eigenschaftswerten<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be animated.</source>
          <target state="translated">Die Eigenschaft kann animiert werden.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Übersicht über Animation<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can report when the previous value of the property has been changed and the property value can be coerced.</source>
          <target state="translated">Die Eigenschaft kann melden, wenn der vorherige Wert der Eigenschaft geändert wurde und die Eigenschaftswert umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Rückrufe und Validierung von Abhängigkeitseigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property reports information to <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, such as whether changing a property value should require the layout system to recompose the visuals for an element.</source>
          <target state="translated">Die Eigenschaft werden Informationen zu <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, z. B., ob das Layoutsystem die visuellen Elemente nach einem Element neu aufzubauen Ändern eines Eigenschaftswerts benötigen sollte.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property receives support in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</source>
          <target state="translated">Die Eigenschaft empfängt Unterstützung in den <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For example, the property can be edited in the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window.</source>
          <target state="translated">Beispielsweise kann die Eigenschaft bearbeitet werden, der <bpt id="p1">**</bpt>Eigenschaften<ept id="p1">**</ept> Fenster.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about dependency properties, see <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Abhängigkeitseigenschaften finden Sie unter <bpt id="p1">[</bpt>Übersicht über Abhängigkeitseigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</source>
          <target state="translated">Wenn Sie Eigenschaften auf die benutzerdefinierten Typen zur Unterstützung von Funktionen in der vorangehenden Liste aufgeführt werden soll, sollten Sie eine Abhängigkeitseigenschaft erstellen.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn how to create custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Vorgehensweise: Erstellen von benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter <bpt id="p1">[</bpt>benutzerdefinierte Abhängigkeitseigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a property that enables any object to report information to the type that defines the attached property.</source>
          <target state="translated">Eine angefügte Eigenschaft ist eine Eigenschaft, die jedes Objekt auf die Informationen in den Typ ermöglicht, das die angefügte Eigenschaft definiert.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, any type that inherits from <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> can use an attached property regardless of whether the type inherits from the type that defines the property.</source>
          <target state="translated">In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, jeder Typ, der von erbt <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> können eine angefügte Eigenschaft unabhängig davon, ob der Typ vom Typ erbt, die die Eigenschaft definiert.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</source>
          <target state="translated">Eine angefügte Eigenschaft ist ein Feature von der <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Sprache.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To set an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, use the <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> syntax.</source>
          <target state="translated">Eine angefügte Eigenschaft festgelegt wird, <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, verwenden Sie die <bpt id="p1">*</bpt>Besitzertyp<ept id="p1">*</ept>.<bpt id="p2">*</bpt> PropertyName<ept id="p2">*</ept> Syntax.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An example of an attached property is the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Ein Beispiel für eine angefügte Eigenschaft ist die <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want to create a property that can be used on all <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, then you should create an attached property.</source>
          <target state="translated">Wenn eine Eigenschaft zu erstellen, die auf allen verwendet werden können sollen <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> eingibt, dann sollten Sie eine angefügte Eigenschaft erstellen.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about attached properties, including how to create them, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu angefügten Eigenschaften, einschließlich Informationen zum Erstellen, finden Sie unter <bpt id="p1">[</bpt>Eigenschaftenübersicht angefügt<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> of the desired dependency property.</source>
          <target state="translated">Eine Zeichenfolge, die angibt, die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> der gewünschten Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</source>
          <target state="translated">Dies kann vorangestellt werden ein XML-Namespacepräfix, wenn die Eigenschaft nicht in der XML-Standardnamespace ist (Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>XAML-Namespaces und Namespace-Zuordnung für WPF-XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></source>
          <target state="translated"><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies an owner type of a dependency property, a dot (.), then the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine Zeichenfolge, die eine Besitzertyp der Abhängigkeitseigenschaft, einen Punkt (.) gibt an, und klicken Sie dann die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`ownerType`</ph> kann auch ein XML-Namespacepräfix vorangestellt werden.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the <ph id="ph1">`TargetType`</ph> is not yet known.</source>
          <target state="translated">Diese Verwendung ist speziell für spät gebundene Stile und Vorlagen, die, in denen der Besitzer der Abhängigkeitseigenschaft angegeben werden, muss für die Analyse von Kontext, da die <ph id="ph1">`TargetType`</ph> noch nicht bekannt ist.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Erstellen von Formaten und Vorlagen<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</source>
          <target state="translated">Eine Zeichenfolge, die den Besitzer einer angefügten Eigenschaft, ein Punkt (.), und dann den Namen der angefügten Eigenschaft angibt.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> kann auch ein XML-Namespacepräfix vorangestellt werden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Adds another type as an owner of a dependency property that has already been registered to a type.</source>
          <target state="translated">Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits für einen Typ registriert wurde.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The type to add as an owner of this dependency property.</source>
          <target state="translated">Der Typ, der als ein Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Adds another type as an owner of a dependency property that has already been registered.</source>
          <target state="translated">Fügt einen weiteren Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Ein Verweis auf den ursprünglichen <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>-Bezeichner, der die Abhängigkeitseigenschaft angibt.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Dieser Bezeichner sollte von der hinzufügenden Klasse als <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld verfügbar gemacht werden.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Diese Methode ermöglicht das Eigenschaftensystem eine Abhängigkeitseigenschaft für einen Typ zu erkennen, die diese Abhängigkeitseigenschaft zunächst nicht registriert.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Typically, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</source>
          <target state="translated">In der Regel <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> wird verwendet, um die Abhängigkeitseigenschaften Klassen hinzufügen, die nicht bereits die Abhängigkeitseigenschaft über Vererbung der verwalteten Klasse verfügbar machen (klassenvererbung würde dazu führen, dass die Wrappereigenschaften, die von der abgeleiteten Klasse geerbt werden und somit würde allgemeine Membertabelle bietet Zugriff auf die Abhängigkeitseigenschaft bereits).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> ermöglicht es das Eigenschaftensystem eine Abhängigkeitseigenschaft für einen Typ zu erkennen, die dieser Abhängigkeitseigenschaft zunächst nicht registriert.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This signature does not allow for specifying metadata.</source>
          <target state="translated">Diese Signatur lässt keine Metadaten angeben.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>When you use this method, the metadata is automatically generated for the new <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> and its owner type.</source>
          <target state="translated">Wenn Sie diese Methode verwenden, wird die Metadaten automatisch für die neue generiert <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> und Besitzertyp.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</source>
          <target state="translated">Die automatisch generierten Metadaten ist das Ergebnis der zusammengeführten Metadaten von allen Basistypen, die diese Eigenschaft definiert haben.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If no merged metadata is available, then the default metadata for the property is used.</source>
          <target state="translated">Wenn keine zusammengeführten Metadaten verfügbar ist, wird das Standardmetadatum für die Eigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If the property is registered by using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, then the default metadata is the same as the metadata that is created when <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> was called.</source>
          <target state="translated">Wenn die Eigenschaft, mithilfe registriert ist der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> -Methode, und klicken Sie dann auf die Standardmetadaten ist identisch mit den Metadaten, die erstellt werden <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object is created with the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> property set to the property type's default and all other properties of the <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> is set to <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Hingegen die <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> -Objekt wird erstellt, mit der <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> Eigenschaftensatz an Standardeinstellung für den Eigenschaftentyp und alle anderen Eigenschaften von der <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> auf festgelegt ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> Signatur, wenn Metadaten für die Version der Abhängigkeitseigenschaft bereitgestellt, wie in den bereitgestellten Typ hinzugefügt werden sollen.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</source>
          <target state="translated">Der Rückgabewert dieser Methode dient normalerweise zum Deklarieren und Verfügbarmachen von der Abhängigkeitseigenschaft durch Speichern der Bezeichner für eine Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The identifier provides access to the dependency property if you want to call property system <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> against the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Der Bezeichner ermöglicht den Zugriff auf die Abhängigkeitseigenschaft, wenn Eigenschaftensystem aufgerufen werden soll <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> auf der hinzufügenden Besitzerklasse für die Abhängigkeitseigenschaft, insbesondere, wenn er vorhanden.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Der gleiche Name für den ursprünglichen Besitzer und hinzugefügten Benutzer sollte verwendet werden, um anzugeben, die ähnliche Funktionen.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> return value of the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> method to define the dependency property identifier, and also to declare <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Verwenden Sie die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Rückgabewert aus der <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Methode zum Definieren des Bezeichners der Abhängigkeitseigenschaft sowie zum Deklarieren <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating the dependency properties that are declared within <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Methodik oben empfohlen wird verwendet, wenn die Abhängigkeitseigenschaften erstellen, die innerhalb von deklariert werden <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Z. B. sowohl <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> definieren eine <ph id="ph3">`BorderBrush`</ph> Abhängigkeitseigenschaft, die ähnliche Funktionen haben.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> based on the original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> definiert die <ph id="ph2">`BorderBrush`</ph> Eigenschaft, um dem Eigenschaftensystem durch Aufrufen von <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> basierend auf dem ursprünglichen Besitzer <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> und seines registrierten <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> Abhängigkeit Eigenschaft Bezeichner.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a new static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> zurückgeben Wert wird dann verwendet, um ein neues statisches <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Feld (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) für diese Eigenschaft auf den hinzugefügten Besitzer und eine <ph id="ph4">`BorderBrush`</ph> Eigenschaftenwrapper auch deklariert wird.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The type to add as owner of this dependency property.</source>
          <target state="translated">Der Typ, der als Besitzer dieser Abhängigkeitseigenschaft hinzugefügt werden soll.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata that qualifies the dependency property as it exists on the provided type.</source>
          <target state="translated">Die Metadaten, die die Abhängigkeitseigenschaft beschreiben, wie sie für den bereitgestellten Typ vorhanden sind.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</source>
          <target state="translated">Fügt einen anderen Typ als Besitzer einer Abhängigkeitseigenschaft hinzu, die bereits registriert wurde. Dabei werden Abhängigkeitseigenschaft-Metadaten für die Abhängigkeitseigenschaft bereitgestellt, wie sie für den bereitgestellten Besitzertyp vorhanden sind.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Ein Verweis auf den ursprünglichen <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>-Bezeichner, der die Abhängigkeitseigenschaft angibt.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Dieser Bezeichner sollte von der hinzufügenden Klasse als <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld verfügbar gemacht werden.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Diese Methode ermöglicht das Eigenschaftensystem eine Abhängigkeitseigenschaft für einen Typ zu erkennen, die diese Abhängigkeitseigenschaft zunächst nicht registriert.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Der Rückgabewert dieser Methode wird zum Deklarieren und Verfügbarmachen von der Abhängigkeitseigenschaft verwendet, insbesondere, wie sie auf der hinzufügenden Besitzerklasse vorhanden ist.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Im Allgemeinen sollte der gleiche Name für den ursprünglichen Besitzer und hinzugefügten Benutzer verwendet werden, um anzugeben, die ähnliche Funktionen.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>It is good practice to expose the identifiers, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Es wird empfohlen, die Bezeichner, die als auch neue verfügbar zu machen <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> declared within <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Methodik oben empfohlen wird verwendet, für die Erstellung <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> deklariert innerhalb von <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Z. B. sowohl <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> definieren eine <ph id="ph3">`BorderBrush`</ph> Abhängigkeitseigenschaft, die ähnliche Funktionen haben.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> on original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> definiert die <ph id="ph2">`BorderBrush`</ph> Eigenschaft, um dem Eigenschaftensystem durch Aufrufen von <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> für den ursprünglichen Besitzer <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> und seines registrierten <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> Abhängigkeit Eigenschaft Bezeichner.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>)for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> zurückgeben Wert wird dann verwendet, um einen statischen herzustellen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Feld (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) für diese Eigenschaft auf den hinzugefügten Besitzer und eine <ph id="ph4">`BorderBrush`</ph> Eigenschaftenwrapper auch deklariert wird.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The added owner's dependency property identifier should be used for operations such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</source>
          <target state="translated">Bezeichner des Besitzers der hinzugefügten Abhängigkeitseigenschaft zu verwendende für Vorgänge wie z. B. <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</source>
          <target state="translated">Jedoch typspezifische Operationen mit Typen oder Instanzen der Klasse, die hinzugefügt wurde, als Besitzer über unterschiedliche Metadaten weiterhin zurück, der erwarteten Ergebnisse, selbst wenn die ursprüngliche (nicht die hinzugefügten Besitzers) in Abhängigkeitseigenschaftbezeichner angegeben ist Aufrufe von Methoden wie z. B. <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata for the added owner is perpetuated by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</source>
          <target state="translated">Die Metadaten für den hinzugefügten Besitzer wird aufrechterhalten, durch die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> aufrufen selbst, nicht unbedingt ausschließlich durch das Hinzufügen von Besitzer Bezeichner Klassenfeld verwiesen wird.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Nevertheless, it is good practice to expose the  identifier, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, because failing to do so creates disparity between the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> and <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> representations of your properties.</source>
          <target state="translated">Dennoch wird empfohlen, den Bezeichner, der als auch neue verfügbar zu machen <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> Eigenschaftenwrapper für Abhängigkeitseigenschaften, die mithilfe von Typen hinzugefügt werden <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, da Unterschiede zwischen unterlassen erstellt werden. die <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> und <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Darstellungen Ihrer Eigenschaften.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Die angegebenen Metadaten werden mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist.</source>
          <target state="translated">Alle Eigenschaften, die in der ursprünglichen Basismetadaten angegeben wurden, werden beibehalten.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale des grundlegenden Metadaten überschrieben.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics, such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are replaced if they are specified in the new metadata.</source>
          <target state="translated">Einige Eigenschaften, z. B. <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, ersetzt werden, wenn sie die neuen Metadaten angegeben werden.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Andere, z. B. <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, kombiniert werden.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Letztlich Typ der Metadaten für die Außerkraftsetzung verwendet werden, damit das hier beschriebene Verhalten für die vorhandene Eigenschaft Metadatenklassen von verwendet wird der Merge-Verhalten hängt <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Abhängigkeitseigenschaften.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Metadaten für die Abhängigkeitseigenschaft<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> und <bpt id="p2">[</bpt>Framework Eigenschaftsmetadaten<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>Gets the default metadata of the dependency property.</source>
          <target state="translated">Ruft die Standardmetadaten der Abhängigkeitseigenschaft ab.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata of the dependency property.</source>
          <target state="translated">Die Standardmetadaten der Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> call.</source>
          <target state="translated">Die Standardmetadaten, ist die Eigenschaftenmetadaten, die für dieses Objekt oder ein Objekt eines abgeleiteten Typs verfügbar ist, in denen keine alternative Metadaten angegeben wurden durch eine explizite <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If the original owner applied metadata to the first <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call that established the dependency property, then that metadata is returned as <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Wenn der ursprüngliche Besitzer Metadaten mit dem ersten angewendet <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> Aufruf, der die Abhängigkeitseigenschaft hergestellt wird, wird, die Metadaten als zurückgegeben <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If no metadata was applied in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, then default metadata is generated from within the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call and this value is returned as the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Wenn keine Metadaten im ursprünglichen besaß <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> aufrufen, wird das Standardmetadatum innerhalb generiert der <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> Aufruf und dieser Wert wird zurückgegeben, als der <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The main purpose of having default metadata associated with a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is to supply a default value for this property on any <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> or a derived type.</source>
          <target state="translated">Der Hauptzweck der Standardmetadaten an, die mit einem <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> ist, geben Sie einen Standardwert für diese Eigenschaft für ein beliebiges <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> oder eines abgeleiteten Typs.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type, even if the property was originally registered with a derived metadata type.</source>
          <target state="translated">Für nicht angefügte Eigenschaften der von dieser Eigenschaft zurückgegebene Metadatentyp keine Typumwandlung in abgeleiteten Typen <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> eingeben, auch wenn die Eigenschaft ursprünglich mit einem abgeleiteten Metadatentyp registriert wurde.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If you want the originally registered metadata including its original possibly derived metadata type, call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> instead, passing the original registering type as a parameter.</source>
          <target state="translated">Wenn Sie die ursprünglich registrierte Metadaten einschließlich seiner ursprünglichen möglicherweise abgeleiteten Metadatentyp möchten, rufen <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> stattdessen als Parameter eingeben und übergeben die ursprünglichen registrieren.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For attached properties, the type of the metadata returned by this property will match the type given in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> registration method.</source>
          <target state="translated">Für angefügte Eigenschaften entspricht der Typ der Metadaten, die von dieser Eigenschaft zurückgegebene den Typ in der ursprünglichen <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> Registrierungsmethode.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>Returns a hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Gibt einen Hashcode für diesen <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode für diese <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The property system uses its own unique identifier <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, and the value of that property is returned by <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Im Eigenschaftensystem verwendet seinen eigenen eindeutigen Bezeichner <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, und der Wert dieser Eigenschaft zurückgegebene <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Returns the metadata associated with this dependency property as it exists for a particular type.</source>
          <target state="translated">Gibt die dieser Abhängigkeitseigenschaft zugeordneten Metadaten zurück, wie sie für einen bestimmten Typ vorhanden sind.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</source>
          <target state="translated">Dies kann der Typ sein, für den die Abhängigkeitseigenschaft zuerst registriert wurde, ein Typ, dem sie später hinzugefügt wurde, oder einen Typ, für den die Abhängigkeitseigenschaft über Vererbung abgerufen wurde, wobei die Metadaten jedoch ausdrücklich überschrieben wurden.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The specific type from which to retrieve the dependency property metadata.</source>
          <target state="translated">Der spezifische Typ, von dem die Metadaten für die Abhängigkeitseigenschaft abgerufen werden sollen.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Returns the metadata for this dependency property as it exists on a specified existing type.</source>
          <target state="translated">Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen vorhanden Typ vorhanden sind.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>A property metadata object.</source>
          <target state="translated">Ein Objekt für Eigenschaftenmetadaten.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that alter the metadata of the dependency property as it exists on a type.</source>
          <target state="translated">Angeben, den Typ oder einen Objektverweis verwenden, wie der Typ ist erforderlich, da die Metadaten von der ursprünglichen Registrierung aufgrund von variieren kann <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> Aufrufe, die die Metadaten der Abhängigkeitseigenschaft geändert werden, weil sie für einen Typ vorhanden ist.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The following example gets metadata for a dependency property based on its type.</source>
          <target state="translated">Im folgende Beispiel ruft die Metadaten für eine Abhängigkeitseigenschaft, die auf Grundlage seines Typs ab.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The type is obtained by using a <ph id="ph1">`typeof`</ph> operator.</source>
          <target state="translated">Der Typ wird abgerufen, mit einem <ph id="ph1">`typeof`</ph> Operator.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</source>
          <target state="translated">Ein Abhängigkeitsobjekt, dessen Typ überprüft wird, um zu ermitteln, von welcher typenspezifischen Version der Abhängigkeitseigenschaft die Metadaten stammen sollen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Returns the metadata for this dependency property as it exists on the specified object instance.</source>
          <target state="translated">Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, da sie für die angegebene Objektinstanz vorhanden sind.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A property metadata object.</source>
          <target state="translated">Ein Objekt für Eigenschaftenmetadaten.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Angeben eines Typs oder ein Objektverweis ist notwendig, da die Metadaten einer angegebenen Abhängigkeitseigenschaft, von der ursprünglichen Registrierung aufgrund von variieren kann <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> Aufrufe, die die Eigenschaftenmetadaten optimieren können, wie sie für vorhanden ein Geben Sie ein.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</source>
          <target state="translated">Beim Anfordern von Metadaten der Eigenschaft basierend auf einer Instanz werden Sie die Instanz tatsächlich nur erfolgreich ausgeführt, damit dessen Typ intern ausgewertet werden kann.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</source>
          <target state="translated">Die Metadaten für Abhängigkeitseigenschaften variiert pro Instanz nicht; Es ist immer für eine beliebige Kombination von bestimmten Typeigenschaft konsistent.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>The following example gets metadata for a dependency property based on a specific <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
          <target state="translated">Im folgende Beispiel ruft Metadaten für eine Abhängigkeitseigenschaft, die anhand einer bestimmten <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A specific object that records the dependency object type from which the dependency property metadata is desired.</source>
          <target state="translated">Ein bestimmtes Objekt, das den Abhängigkeitsobjekttyp aufzeichnet, von dem die Metadaten für die Abhängigkeitseigenschaft stammen sollen.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Returns the metadata for this dependency property as it exists on a specified type.</source>
          <target state="translated">Gibt die Metadaten für diese Abhängigkeitseigenschaft zurück, wie sie für einen angegebenen Typ vorhanden sind.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A property metadata object.</source>
          <target state="translated">Ein Objekt für Eigenschaftenmetadaten.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Angeben eines Typs oder ein Objektverweis ist notwendig, da die Metadaten einer angegebenen Abhängigkeitseigenschaft, von der ursprünglichen Registrierung aufgrund von variieren kann <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> Aufrufe, die die Eigenschaftenmetadaten optimieren können, wie sie für vorhanden ein Geben Sie ein.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>The following example gets metadata for a dependency property based on its <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</source>
          <target state="translated">Im folgende Beispiel ruft Metadaten für eine Abhängigkeitseigenschaft, die basierend auf seiner <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Gets an internally generated value that uniquely identifies the dependency property.</source>
          <target state="translated">Ruft einen intern generierten Wert ab, der die Abhängigkeitseigenschaft eindeutig identifiziert.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A unique numeric identifier.</source>
          <target state="translated">Ein eindeutiger numerischer Bezeichner.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>This value is an integer, not a <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]</ph>.</source>
          <target state="translated">Dieser Wert ist eine ganze Zahl ein <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</source>
          <target state="translated">Im Allgemeinen die Verwendung dieses Werts Index ist nicht erforderlich, und es gibt keinen Indexzugriff auf Tabellen aller Abhängigkeitseigenschaften.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Dependency properties should instead be referenced by their identifier fields.</source>
          <target state="translated">Abhängigkeitseigenschaften sollte stattdessen über ihre Bezeichnerfelder verwiesen werden.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> is used internally for faster access to data structures that use the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> as a zero-based array index.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> wird intern verwendet, für einen schnelleren Zugriff auf Datenstrukturen, mit denen die <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> als Arrayindex nullbasierte.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A similar usage might have applications for designers or tools.</source>
          <target state="translated">Eine ähnliche Verwendung verfügen möglicherweise über Anwendungen für den Designer oder -Tools.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Der zu überprüfende Wert.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</source>
          <target state="translated">Bestimmt, ob ein angegebener Wert für den Typ dieser Abhängigkeitseigenschaft akzeptiert wird, wie anhand des in der Registrierung der ursprünglichen Abhängigkeitseigenschaft angegebenen Eigenschaftentyps überprüft wurde.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is the registered property type or an acceptable derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der angegebene Wert der registrierte Eigenschaftentyp oder ein zulässiger abgeleiteter Typ ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>A value of <ph id="ph1">`null`</ph> is a valid type for reference type dependency properties, or for a <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph3">`true`</ph> for these cases.</source>
          <target state="translated">Der Wert <ph id="ph1">`null`</ph> ist ein gültiger Typ für Abhängigkeitseigenschaften vom Referenztyp oder für eine <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> Abhängigkeitseigenschaft und würde zurückgeben <ph id="ph3">`true`</ph> in diesen Fällen.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">In Fällen, in dem die Abhängigkeitseigenschaft weder ein Verweis ist, noch eine <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> Typ <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> zurück <ph id="ph3">`false`</ph> für einen null-Wert anstelle von lösen eine Ausnahme.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> als eine Überprüfung vor dem Aufruf <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> auf die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Der zu überprüfende Wert.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</source>
          <target state="translated">Bestimmt, ob der angegebene Wert für den Eigenschaftentyp durch eine einfache Typüberprüfung zulässig ist und ob er sich potenziell im zulässigen Wertebereich für den Typ befindet.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value is acceptable and is of the correct type or a derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Wert zulässig ist und den richtigen Typ oder einen abgeleiteten Typ aufweist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>For a dependency property, an allowed range of values for that type can be specified through a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> that is provided in the dependency property registration.</source>
          <target state="translated">Für eine Abhängigkeitseigenschaft kann über einen zulässigen Wertebereichs für diesen Typ angegeben werden eine <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> , die in der Registrierung der Abhängigkeitseigenschaft bereitgestellt wird.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>This method calls <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> internally.</source>
          <target state="translated">Diese Methode ruft <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> intern.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property in question has no <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>,then calling this method is effectively equivalent to calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</source>
          <target state="translated">Wenn die fragliche Abhängigkeitseigenschaft keine <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, dann ist beim Aufrufen dieser Methode entspricht dem Aufruf <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property does have a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, and if <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> would have returned <ph id="ph3">`true`</ph>, then the value returned will be as implemented in the callback.</source>
          <target state="translated">Wenn die Abhängigkeitseigenschaft besitzt eine <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, und, wenn <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> zurückgegeben hätte <ph id="ph3">`true`</ph>, wird der Wert werden zurückgegeben, wie im Rückruf implementiert.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>A null value is a valid value for reference type dependency properties, or for a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph2">`true`</ph> for these cases.</source>
          <target state="translated">Ein null-Wert ist ein gültiger Wert für Abhängigkeitseigenschaften vom Referenztyp oder ein <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> Abhängigkeitseigenschaft und würde zurückgeben <ph id="ph2">`true`</ph> für diese Fälle.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">In Fällen, in dem die Abhängigkeitseigenschaft weder ein Verweis ist, noch eine <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> Typ <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> zurück <ph id="ph3">`false`</ph> für einen null-Wert anstelle von lösen eine Ausnahme.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> als eine Überprüfung vor dem Aufruf <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> auf die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.Name">
          <source>Gets the name of the dependency property.</source>
          <target state="translated">Ruft den Namen der Abhängigkeitseigenschaft ab.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The name of the property.</source>
          <target state="translated">Den Namen der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This property gets the name provided as the <ph id="ph1">`name`</ph> parameter during dependency property registration.</source>
          <target state="translated">Diese Eigenschaft ruft den Namen als die <ph id="ph1">`name`</ph> Parameter während der Registrierung der Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This name is immutable, and cannot be <ph id="ph1">`null`</ph> or an empty string.</source>
          <target state="translated">Dieser Name ist unveränderlich und nicht mit <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</source>
          <target state="translated">Doppelter Name Registrierungen für den gleichen Besitzertyp sind nicht zulässig und löst eine Ausnahme aus, wenn Sie versuchen, das Duplikat zu registrieren.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> einer Abhängigkeit muss Eigenschaft verwenden üblicherweise stimmen mit dem Namen des Bezeichners der Abhängigkeitseigenschaft ohne das Suffix "Property".</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Benutzerdefinierte Abhängigkeitseigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel fragt die verschiedenen Eigenschaften der Bezeichner für eine Abhängigkeitseigenschaft, einschließlich der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Stellt alternative Metadaten für diese Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, im Gegensatz zu den Metadaten, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</source>
          <target state="translated">Gibt alternative Metadaten für diese Abhängigkeitseigenschaft an, wenn sie in Instanzen eines angegebenen Typs vorhanden ist. Dabei werden die Metadaten überschrieben, die für die Abhängigkeitseigenschaft bei der Vererbung von Basistypen vorhanden waren.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Metadaten für die Abhängigkeitseigenschaft sollte überschrieben werden, bevor Sie das Eigenschaftensystem die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This equates to the time that specific instances are created using the class that registers the dependency property.</source>
          <target state="translated">Dies entspricht der Zeit, die bestimmte Instanzen erstellt werden, mithilfe der Klasse, die die Abhängigkeitseigenschaft registriert.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Aufrufe von <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als der <ph id="ph2">`forType`</ph> Parameter dieser Methode oder über eine ähnliche Instanziierung.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Versuchen, die Metadaten ändern, nachdem die Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, es wird jedoch führt zu inkonsistentem Verhalten im Eigenschaftensystem.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Nachdem Metadaten für einen bestimmten abgeleiteten Klasse überschreiben, die mit dieser Methode hergestellt wurde, werden nachfolgende Versuche, die Metadaten in dieser abgeleiteten Klasse überschreiben, eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Die angegebenen Metadaten werden mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Alle Eigenschaften, die in der ursprünglichen Basismetadaten angegeben wurden, werden beibehalten. nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale des grundlegenden Metadaten überschrieben.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Einige Eigenschaften wie z. B. <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> ersetzt werden, wenn in den neuen Metadaten angegeben.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Andere, z. B. <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, kombiniert werden.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Letztlich Typ der Metadaten für die Außerkraftsetzung verwendet werden, damit das hier beschriebene Verhalten für die vorhandene Eigenschaft Metadatenklassen von verwendet wird der Merge-Verhalten hängt <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Abhängigkeitseigenschaften.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Metadaten für die Abhängigkeitseigenschaft<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> und <bpt id="p2">[</bpt>Framework Eigenschaftsmetadaten<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</source>
          <target state="translated">Es wurde versucht, die Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft zu überschreiben (dieser Vorgang kann nicht mit dieser Signatur ausgeführt werden).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the dependency property as it exists on the provided type.</source>
          <target state="translated">Metadaten wurden für die Abhängigkeitseigenschaft bereits festgelegt, wie im bereitgestellten Typ vorhanden.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Der Typ, bei dem diese Abhängigkeitseigenschaft geerbt wird und bei dem die bereitgestellten alternativen Metadaten angewendet werden.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Die Metadaten, die auf die Abhängigkeitseigenschaft im überschreibenden Typ angewendet werden sollen.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The access key for a read-only dependency property.</source>
          <target state="translated">Der Zugriffsschlüssel für eine schreibgeschützte Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Stellt alternative Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft bereit, wenn sie in Instanzen eines angegebenen Typs vorhanden ist, wodurch die Metadaten überschrieben werden, die bei der ersten Registrierung der Abhängigkeitseigenschaft bereitgestellt wurden.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>You must pass the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> for the read-only dependency property to avoid raising an exception.</source>
          <target state="translated">Sie müssen den <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> für die schreibgeschützte Abhängigkeitseigenschaft übergeben, um das Auslösen einer Ausnahme zu vermeiden.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This signature provides underlying implementation for a read-only dependency property identifier (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) method.</source>
          <target state="translated">Diese Signatur stellt die zugrunde liegende Implementierung für Bezeichner für eine schreibgeschützte Abhängigkeitseigenschaft bereit (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) Methode.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>If overriding metadata for a read-write dependency property, use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Wenn Metadaten für eine Abhängigkeitseigenschaft mit Lese-/ Schreibzugriff zu überschreiben, verwenden Sie <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Metadaten für die Abhängigkeitseigenschaft sollte überschrieben werden, bevor Sie das Eigenschaftensystem die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This equates to the time that specific objects are created for the class that registers the dependency property.</source>
          <target state="translated">Dies entspricht der Zeit, die bestimmte Objekte erstellt werden, für die Klasse, die die Abhängigkeitseigenschaft registriert.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Aufrufe von <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als der <ph id="ph2">`forType`</ph> Parameter dieser Methode oder über eine ähnliche Instanziierung.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Versuchen, die Metadaten ändern, nachdem die Instanzen des Besitzertyps vorhanden sind, werden keine Ausnahmen ausgelöst, es wird jedoch führt zu inkonsistentem Verhalten im Eigenschaftensystem.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Nachdem Metadaten für einen bestimmten abgeleiteten Klasse überschreiben, die mit dieser Methode hergestellt wurde, werden nachfolgende Versuche, die Metadaten in dieser abgeleiteten Klasse überschreiben, eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Die angegebenen Metadaten werden mit die Eigenschaftenmetadaten für die Abhängigkeitseigenschaft zusammengeführt, wie sie auf der Basis Besitzer vorhanden ist.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Alle Eigenschaften, die in der ursprünglichen Basismetadaten angegeben wurden, werden beibehalten. nur die Merkmale, die insbesondere in den neuen Metadaten geändert wurden, werden die Merkmale des grundlegenden Metadaten überschrieben.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Einige Eigenschaften wie z. B. <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> ersetzt werden, wenn in den neuen Metadaten angegeben.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Andere, z. B. <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, kombiniert werden.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The merge behavior depends on the property metadata type being used for the override.</source>
          <target state="translated">Der Merge-Verhalten hängt vom Typ der Metadaten für die Außerkraftsetzung verwendeten ab.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Metadaten für die Abhängigkeitseigenschaft<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> und <bpt id="p2">[</bpt>Framework Eigenschaftsmetadaten<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</source>
          <target state="translated">Ruft den Typ des Objekts ab, das die Abhängigkeitseigenschaft im Eigenschaftensystem registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The type of the object that registered the property or added itself as owner of the property.</source>
          <target state="translated">Der Typ des Objekts, das die Eigenschaft registriert oder sich selbst als Besitzer der Eigenschaft hinzugefügt hat.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This value was provided during property registration.</source>
          <target state="translated">Dieser Wert wurde während der Registrierung bereitgestellt.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The owner will be either the original registering type in the case of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, or the type that added itself as owner in the case of a <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from an <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
          <target state="translated">Die Besitzer werden entweder den ursprünglichen Registrierungstyp im Fall von einer <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner generiert eine <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> Aufruf oder der Typ, der sich selbst als Besitzer im Fall von hinzugefügt eine <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner generiert eine <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> on any given <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is immutable, and cannot be <ph id="ph3">`null`</ph> in a valid <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> auf einem gegebenen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> ist unveränderlich und nicht mit <ph id="ph3">`null`</ph> in eine gültige <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The following example gets the owner type based on a dependency property identifier <ph id="ph1">`dp`</ph>, and then gets metadata on the owner type for that same identifier.</source>
          <target state="translated">Das folgende Beispiel ruft den Besitzertyp basierend auf den Bezeichner für eine Abhängigkeitseigenschaft <ph id="ph1">`dp`</ph>, und klicken Sie dann Ruft Metadaten für den Besitzertyp ab, dem gleichen Bezeichner.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This operation is actually equivalent to getting <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> on <ph id="ph2">`dp`</ph>.</source>
          <target state="translated">Dieser Vorgang entspricht dem Abrufen von <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> auf <ph id="ph2">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Gets the type that the dependency property uses for its value.</source>
          <target state="translated">Ruft den Typ ab, den die Abhängigkeitseigenschaft für den Wert verwendet.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the property value.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des Eigenschaftswerts.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>This property reports the type of the property's value as declared by the original property registration, through the <ph id="ph1">`propertyType`</ph> parameter.</source>
          <target state="translated">Diese Eigenschaft gibt den Typ der Wert der Eigenschaft, wie durch das von der Registrierung der ursprünglichen, deklariert den <ph id="ph1">`propertyType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Similar to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, the property type of a dependency property is immutable after registration.</source>
          <target state="translated">Ähnlich wie die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, der Eigenschaftentyp einer Abhängigkeitseigenschaft nach der Registrierung unveränderlich ist.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel fragt die verschiedenen Eigenschaften der Bezeichner für eine Abhängigkeitseigenschaft, einschließlich der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The type name string of the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> is obtained from the returned <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Die Zeichenfolge der Typ der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> abgerufen wird von der zurückgegebenen <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Gets a value that indicates whether the dependency property identified by this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> instance is a read-only dependency property.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die von dieser <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>-Instanz angegebene Abhängigkeitseigenschaft eine schreibgeschützte Abhängigkeitseigenschaft ist.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Abhängigkeitseigenschaft schreibgeschützt ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties are registered within the property system by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> method as opposed to the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method.</source>
          <target state="translated">Schreibgeschützte Abhängigkeitseigenschaften im Eigenschaftensystem registriert sind, durch Aufrufen der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> Methode im Gegensatz zu den <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Attached properties can also be registered as read-only; see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated">Angefügte Eigenschaften können auch als schreibgeschützt registriert werden; finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties require a <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier rather than a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier to perform metadata operations such as overriding the metadata or setting the value.</source>
          <target state="translated">Von schreibgeschützten Abhängigkeitseigenschaften erfordern ein <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> Bezeichner anstelle eines <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner auszuführenden Vorgänge mit Metadaten wie z. B. das Überschreiben der Metadaten oder Festlegen des Werts.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If you obtained a collection of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers through a call to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> or another <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> that exposes identifiers, check the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> value before attempting to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> or <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</source>
          <target state="translated">Wenn Sie eine Auflistung von erworben haben <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner durch einen Aufruf von <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> oder ein anderes <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> Bezeichner, Kontrollkästchen verfügbar macht die <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> Wert vor dem Aufrufen <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> oder <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> verwenden, Bezeichner der Abhängigkeitseigenschaft als Eingabeparameter, um sicherzustellen, dass die Abhängigkeitseigenschaft, die den Bezeichner darstellt, nicht schreibgeschützt ist.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If the value of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> is <ph id="ph2">`true`</ph> on a dependency property, there is no programmatic way to obtain a reference to the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier of that dependency property, from the metadata or from the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier; the identifier must be available as a static field in order to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> against a read-only dependency property.</source>
          <target state="translated">Wenn der Wert der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> ist <ph id="ph2">`true`</ph> auf eine Abhängigkeitseigenschaft, es ist keine programmgesteuerte Methode zum Abrufen eines Verweises auf die <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> Bezeichner der Abhängigkeitseigenschaft über die Metadaten oder aus der <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner; der Bezeichner muss als statisches Feld verfügbar sein, um Aufrufen <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> für eine schreibgeschützte Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper property.</source>
          <target state="translated">Wenn Sie eine benutzerdefinierte Abhängigkeitseigenschaft erstellen und registrieren Sie ihn als schreibgeschützt, sollten Sie nur einen Get-Accessor für definieren die <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> Wrappereigenschaft.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</source>
          <target state="translated">Andernfalls müssen die Klasse ein verwirrend Objektmodell für den Eigenschaftenwrapper im Vergleich zu den Zugriff auf die Sicherungsabhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> or <bpt id="p2">[</bpt>Read-Only Dependency Properties<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>benutzerdefinierte Abhängigkeitseigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> oder <bpt id="p2">[</bpt>schreibgeschützte Abhängigkeitseigenschaften<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Im folgenden Beispiel ermittelt das Standardmetadatum und den Bezeichner der Abhängigkeitseigenschaften-Eigenschaft aus verschiedenen Abhängigkeit Eigenschaftenfelder und verwendet die Informationen zum Auffüllen einer Tabelle, um eine "Metadatenbrowser" implementieren.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property.</source>
          <target state="translated">Registriert eine Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name must be unique within the registration namespace of the owner type.</source>
          <target state="translated">Der Name muss innerhalb des Registrierungsnamespace des Besitzertyps eindeutig sein.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>Registers a dependency property with the specified property name, property type, and owner type.</source>
          <target state="translated">Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld in der Klasse verwendet werden sollte.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld in der Klasse verwendet werden sollte.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</source>
          <target state="translated">Registriert eine Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld in der Klasse verwendet werden sollte.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</source>
          <target state="translated">Das folgende Beispiel registriert eine Abhängigkeitseigenschaft, z. B. einen Validierungsrückruf (die Rückruf-Definition wird nicht angezeigt; Einzelheiten über die Rückruf-Definition finden Sie unter <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers an attached property with the property system.</source>
          <target state="translated">Registriert eine angefügte Eigenschaft mit dem Eigenschaftensystem.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Registers an attached property with the specified property name, property type, and owner type.</source>
          <target state="translated">Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld in der Klasse verwendet werden sollte.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Eine angefügte Eigenschaft ist eine Eigenschaftenkonzept von definierten <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Da die <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> angefügte Eigenschaften Abhängigkeitseigenschaften, sie können Metadaten angewendet, die vom Eigenschaftensystem allgemeine für Vorgänge wie z. B. reporting Layouteigenschaften verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Übersicht über angefügte Eigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">Das folgende Beispiel registriert eine angefügte Eigenschaft für eine abstrakte Klasse, die mit diesem <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> Signatur.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Dies kann den Standardwert sowie andere Merkmale einschließen.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers an attached property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftsnamen, Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftenmetadaten.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld in der Klasse verwendet werden sollte.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Eine angefügte Eigenschaft ist eine Eigenschaftenkonzept von definierten <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Da die <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> angefügte Eigenschaften Abhängigkeitseigenschaften, sie können Metadaten angewendet, die vom Eigenschaftensystem allgemeine für Vorgänge wie z. B. reporting Layouteigenschaften verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Übersicht über angefügte Eigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft mit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anstelle von <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> dient zur Unterstützung der Vererbung von Eigenschaftenwerten.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Registrieren Sie erben von Abhängigkeitseigenschaften mit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Verwenden Sie immer <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zum Registrieren von Eigenschaften in dem Sie angeben <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in den Metadaten.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Vererbung von Eigenschaftswerten<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Dies kann den Standardwert sowie andere Merkmale einschließen.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ein Verweis auf einen Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</source>
          <target state="translated">Registriert eine angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und dem angegebenen Wertvalidierungsrückruf für die Eigenschaft.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Ein Bezeichner für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>-Feld in der Klasse verwendet werden sollte.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Dieser Bezeichner wird dann später in Vorgängen (z. B. beim programmgesteuerten Festlegen des Werts oder beim Abrufen von Metadaten) zum Verweisen auf die Abhängigkeitseigenschaft verwendet.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Eine angefügte Eigenschaft ist eine Eigenschaftenkonzept von definierten <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementiert angefügte Eigenschaften als Abhängigkeitseigenschaften.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Da die <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> angefügte Eigenschaften Abhängigkeitseigenschaften, sie können Metadaten angewendet, die vom Eigenschaftensystem allgemeine für Vorgänge wie z. B. reporting Layouteigenschaften verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Übersicht über angefügte Eigenschaften<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft mit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anstelle von <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> dient zur Unterstützung der Vererbung von Eigenschaftenwerten.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Registrieren Sie erben von Abhängigkeitseigenschaften mit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Verwenden Sie immer <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zum Registrieren von Eigenschaften in dem Sie angeben <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in den Metadaten.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Vererbung von Eigenschaftswerten<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">Das folgende Beispiel registriert eine angefügte Eigenschaft für eine abstrakte Klasse, die mit diesem <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> Signatur.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</source>
          <target state="translated">Diese angefügte Eigenschaft ist eine Enumeration Type-Eigenschaft, und die Registrierung Fügt einen Validierungsrückruf, um sicherzustellen, dass der bereitgestellte Wert ein Wert aus der Enumeration ist.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a read-only attached property.</source>
          <target state="translated">Registriert eine schreibgeschützte angefügte Eigenschaft.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Registriert eine schreibgeschützte angefügte Eigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Diese Methode gibt den Typ zurück <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, wohingegen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> gibt den Typ zurück <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> als eine <ph id="ph2">`public static readonly`</ph> -Feld in der Klasse.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Schreibgeschützte angefügte Eigenschaften sind einem seltenen Fall, da das Hauptszenario für eine angefügte Eigenschaft die Verwendung in ist <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Ohne einen öffentlichen Setter kann keine angefügte Eigenschaft festgelegt werden <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Syntax.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property as attached is to support property value inheritance.</source>
          <target state="translated">Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft als zur Unterstützung der Vererbung von Eigenschaftenwerten ist angefügt.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Registrieren Sie erben von Abhängigkeitseigenschaften mit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Verwenden Sie immer <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zum Registrieren von Eigenschaften in dem Sie angeben <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in den Metadaten.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Vererbung von Eigenschaftswerten<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Registriert eine schreibgeschützte Eigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Diese Methode gibt den Typ zurück <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, wohingegen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> gibt den Typ zurück <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent the type <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">In der Regel die Schlüssel, die den Typ darstellen <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> als eine <ph id="ph2">`public static readonly`</ph> -Feld in der Klasse.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Schreibgeschützte angefügte Eigenschaften sind einem seltenen Fall, da das Hauptszenario für eine angefügte Eigenschaft die Verwendung in ist <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Ohne einen öffentlichen Setter kann keine angefügte Eigenschaft festgelegt werden <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Syntax.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Verwendung von RegisterAttached für Abhängigkeitseigenschaften erben</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property as attached instead of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Ein bestimmtes Szenario für eine Abhängigkeitseigenschaft registrieren, wie anstelle von angeschlossenen <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> dient zur Unterstützung der Vererbung von Eigenschaftenwerten.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Registrieren Sie erben von Abhängigkeitseigenschaften mit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> , auch wenn die Klasse Wrapper Eigenschaftenaccessoren definiert, die die Abhängigkeitseigenschaft verfügbar machen, und auch wenn Sie nicht beabsichtigen, Get * und * Satz statische Methoden zur Bereitstellung verfügbar machen "true" angefügt Support-Eigenschaftenaccessoren.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Obwohl Vererbung von Eigenschaftenwerten Laufzeitstruktur Abhängigkeitseigenschaften funktionieren scheint, ist das Verhalten der Vererbung für eine nicht angefügte Eigenschaft über bestimmte Elementgrenzen in der Common Language Runtime-Struktur nicht definiert.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Beim Registrieren der Eigenschaft, wie effektiv angeschlossenen macht der angefügten Eigenschaft eine globale Eigenschaft im Eigenschaftensystem und gewährleistet, dass die Vererbung von Eigenschaftenwerten über alle Grenzen in eine Elementstruktur funktioniert.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Verwenden Sie immer <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> zum Registrieren von Eigenschaften in dem Sie angeben <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in den Metadaten.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Vererbung von Eigenschaftswerten<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property as a read-only dependency property.</source>
          <target state="translated">Registriert eine Abhängigkeitseigenschaft als schreibgeschützte Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp und Besitzertyp sowie den angegebenen Eigenschaftsmetadaten.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Ein Abhängigkeitseigenschaftsschlüssel, der dazu verwendet werden soll, den Wert eines statischen schreibgeschützten Felds in Ihrer Klasse festzulegen, die dann dazu verwendet wird, auf die Abhängigkeitseigenschaft zu verweisen.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Diese Methode gibt den Typ zurück <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, wohingegen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> gibt den Typ zurück <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> als eine <ph id="ph2">`public static readonly`</ph> -Feld in der Klasse.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only dependency properties are a fairly typical scenario both in the existing <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> and for customization scenarios, because other <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features might require a dependency property even if that property is not intended to be settable by callers.</source>
          <target state="translated">Schreibgeschützte Abhängigkeitseigenschaften sind eine Recht typische Szenario sowohl in der vorhandenen <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> und-Anpassungsszenarien, da andere <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Funktionen erfordern möglicherweise eine Abhängigkeitseigenschaft, auch wenn diese Eigenschaft nicht festgelegt werden, indem sein soll Aufrufer.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Sie können den Wert einer schreibgeschützten Abhängigkeitseigenschaft als Grundlage für andere Systemoperationen, die eine Abhängigkeitseigenschaft, z. B. basieren eine <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> auf die Abhängigkeitseigenschaft in einem Format.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The following example registers an <ph id="ph1">`AquariumSize`</ph> dependency property as read-only.</source>
          <target state="translated">Das folgende Beispiel registriert eine <ph id="ph1">`AquariumSize`</ph> Abhängigkeitseigenschaft als schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The example defines <ph id="ph1">`AquariumSizeKey`</ph> as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as <ph id="ph2">`AquariumSizeProperty`</ph>.</source>
          <target state="translated">Im Beispiel definiert <ph id="ph1">`AquariumSizeKey`</ph> als interner Schlüssel (also, dass andere Klassen in der Assembly konnte Metadaten überschreiben) und der Bezeichner der Abhängigkeitseigenschaft auf diesen Schlüssel als basierend macht <ph id="ph2">`AquariumSizeProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Also, a wrapper is created for <ph id="ph1">`AquariumSize`</ph>, with only a get accessor.</source>
          <target state="translated">Darüber hinaus wird ein Wrapper für erstellt <ph id="ph1">`AquariumSize`</ph>, mit nur einem Get-Accessor.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Der Name der zu registrierenden Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Den Typ der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Der Besitzertyp, von dem die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Eigenschaftenmetadaten für die Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ein Verweis auf einen benutzerdefinierten Rückruf, der eine beliebige benutzerdefinierte Validierung des Werts der Abhängigkeitseigenschaft über die normale Validierung hinaus durchführen soll.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Registriert eine schreibgeschützte Abhängigkeitseigenschaft mit dem angegebenen Eigenschaftstyp, Besitzertyp, den angegebenen Eigenschaftsmetadaten und einem Validierungsrückruf.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Ein Schlüssel für eine Abhängigkeitseigenschaft, der zum Festlegen des Werts für ein statisches schreibgeschütztes Feld in der Klasse verwendet werden sollte. Mit diesem wird dann später auf die Abhängigkeitseigenschaft verwiesen.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Diese Methode gibt den Typ zurück <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, wohingegen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> gibt den Typ zurück <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In der Regel die Schlüssel, die schreibgeschützten Eigenschaften darstellen sind nicht öffentlich gemacht, da der Schlüssel können, zum Festlegen des Werts der Abhängigkeitseigenschaft verwendet werden durch Aufrufen <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Entwurfs Klasse wirkt sich die Anforderungen, aber es wird im Allgemeinen empfohlen, die Zugriffsrechte und die Sichtbarkeit aller beschränken <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> nur die Teile des Codes, die zum Festlegen dieser Abhängigkeitseigenschaft als Teil der Klasse oder eine Anwendung Logik erforderlich sind.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Es wird empfohlen, dass für die schreibgeschützte Abhängigkeitseigenschaft Bezeichner für eine Abhängigkeitseigenschaft verfügbar machen, indem der Wert der <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> als eine <ph id="ph2">`public static readonly`</ph> -Feld in der Klasse.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only dependency properties are a fairly typical scenario.</source>
          <target state="translated">Schreibgeschützte Abhängigkeitseigenschaften sind eine Recht typische Szenario.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Sie können den Wert einer schreibgeschützten Abhängigkeitseigenschaft als Grundlage für andere Systemoperationen, die eine Abhängigkeitseigenschaft, z. B. basieren eine <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> auf die Abhängigkeitseigenschaft in einem Format.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Registrierung von Abhängigkeitseigenschaften finden Sie unter <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Validation on a read-only dependency property might be less important.</source>
          <target state="translated">Überprüfung auf eine schreibgeschützte Abhängigkeitseigenschaft möglicherweise weniger wichtig.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</source>
          <target state="translated">Die nicht öffentliche Zugriffsebene, die Sie für den Schlüssel angeben, verringert die Wahrscheinlichkeit für beliebige ungültige Eingaben.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>Returns the string representation of the dependency property.</source>
          <target state="translated">Gibt die Zeichenfolgendarstellung der Abhängigkeitseigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>The string representation of the dependency property.</source>
          <target state="translated">Die Zeichenfolgendarstellung der Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.ToString">
          <source>This implementation returns the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> property value.</source>
          <target state="translated">Diese Implementierung gibt die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> Eigenschaftswert.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Specifies a static value that is used by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system rather than <ph id="ph2">&lt;see langword="null" /&gt;</ph> to indicate that the property exists, but does not have its value set by the property system.</source>
          <target state="translated">Gibt einen statischen Wert an, der vom <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>-Eigenschaftensystem verwendet wird, und nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um anzugeben, dass die Eigenschaft vorhanden ist, der Wert jedoch nicht vom Eigenschaftensystem festgelegt wird.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is a sentinel value that is used for scenarios where the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system is unable to determine a requested <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ist ein Sentinelwert, die für Szenarios verwendet wird, in dem die <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Eigenschaftensystem kann einen angeforderten bestimmen <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Wert.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is used rather than <ph id="ph2">`null`</ph>, because <ph id="ph3">`null`</ph> could be a valid property value, as well as a valid (and frequently used) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> wird verwendet, anstatt <ph id="ph2">`null`</ph>, da <ph id="ph3">`null`</ph> konnte einen gültigen Eigenschaftswert als auch einen gültigen (und häufig verwendet werden) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is never returned out of <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> wird niemals zurückgegeben von <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> on a dependency property on a <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, one of the following applies:</source>
          <target state="translated">Beim Aufruf <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> auf eine Abhängigkeitseigenschaft für eine <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> Instanz, eines der folgenden gilt:</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>A dependency property has a default value established in metadata and that value is returned.</source>
          <target state="translated">Eine Abhängigkeitseigenschaft hat einen Standardwert, der in den Metadaten eingerichtet, und dieser Wert wird zurückgegeben.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>This value might come from <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Dieser Wert stammt möglicherweise aus <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Some other value was established by the property system, and the default value is no longer relevant.</source>
          <target state="translated">Ein anderer Wert von dem Eigenschaftensystem hergestellt wurde, und der Standardwert ist nicht mehr relevant.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Priorität von Abhängigkeitseigenschaftswerten<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is specifically disallowed.</source>
          <target state="translated">Festlegen einer <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> von <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ist ausdrücklich nicht zulässig.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> when the requested property has not been locally set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> Gibt <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> Wenn die angeforderte Eigenschaft wurde nicht lokal festgelegt wurde.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has a special meaning when used as the return value of a <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> hat eine besondere Bedeutung, wenn als den Rückgabewert verwendet eine <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Rückrufen von Abhängigkeitseigenschaften und Validierung<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>If you are binding to a database, note that <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is not equivalent to <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, in a similar way to how <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> is not equivalent to a true null.</source>
          <target state="translated">Wenn Sie in einer Datenbank binden, beachten Sie, dass <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> entspricht nicht dem <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, auf ähnliche Weise, wie Sie <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> entspricht keinem NULL-Wert "true".</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Gets the value validation callback for the dependency property.</source>
          <target state="translated">Ruft den Wertvalidierungsrückruf für die Abhängigkeitseigenschaft ab.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The value validation callback for this dependency property, as provided for the <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> parameter in the original dependency property registration.</source>
          <target state="translated">Der Wertvalidierungsrückruf für diese Abhängigkeitseigenschaft, wie für den <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph>-Parameter in der ursprünglichen Registrierung der Abhängigkeitseigenschaft angegeben.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>This property will contain <ph id="ph1">`null`</ph> for any dependency property with no registered validation callback.</source>
          <target state="translated">Diese Eigenschaft enthält <ph id="ph1">`null`</ph> für jede Abhängigkeitseigenschaft ohne registrierten Validierungsrückruf.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Validate value callbacks must act in a static sense: validation applied through the <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> cannot determine whether the provided value is valid for any particular instance.</source>
          <target state="translated">Rückrufe werden, wie statische verwendet müssen Wert von Validate: Überprüfung angewendet wird, über die <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> kann bestimmen, ob der angegebene Wert für eine bestimmte Instanz gültig ist.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</source>
          <target state="translated">Der Rückruf kann nur festgelegt, ob alle Objekte, die die Abhängigkeitseigenschaft besitzen soll oder sollte den angegebenen Wert als gültig akzeptiert.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> instead.</source>
          <target state="translated">Wenn müssen Sie die Überprüfung ausführen, der verwendet wird, erkennbar sein muss, die Werte der anderen Abhängigkeitseigenschaften in einer bestimmten Instanz, verwenden eine <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> stattdessen.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> als Teil der Metadaten für Abhängigkeitseigenschaften, anstatt direkt im Bezeichner für die Abhängigkeitseigenschaft registriert wird.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Rückrufen von Abhängigkeitseigenschaften und Validierung<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>