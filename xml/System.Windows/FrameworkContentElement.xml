<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkContentElement.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b891ec5d-4b60-42d7-ac21-95eab9e3ef82615425e7a431643682b3286cc26cb17aa80cb9d4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">615425e7a431643682b3286cc26cb17aa80cb9d4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">058bfa0b75b777d3171411d35da8f11617fc06b0</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/04/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is the WPF framework-level implementation and expansion of the <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> base class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> stellt die Implementierung auf WPF-Frameworkebene und die Erweiterung der <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph>-Basisklasse dar.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> bietet Unterstützung für zusätzliche Eingabe-APIs (einschließlich QuickInfos und Kontextmenüs), Storyboards, Datenkontexte für die Datenbindung, Formatvorlagen und APIs für Hilfsprogramme für logische Strukturen.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> does not yet define its own rendering behavior; instantiating an actual <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> class instance in code or markup is possible but displays nothing in a <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> eigene Renderingverhalten definieren nicht noch; Instanziieren ein tatsächliches <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> Klasseninstanz im Code oder Markup ist möglich, aber zeigt "nothing" in einem <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Anwendung <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Rendering logic must be provided by classes that take <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> child elements as part of their content model, or in <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes.</source>
          <target state="translated">Renderinglogik muss angegeben werden, von Klassen, <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> untergeordneten Elemente als Teil ihrer Inhaltsmodell oder in <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> abgeleitete Klassen.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> deliberately parallels many of the same <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> as <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> Viele der gleichen absichtlich codenavigation <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> als <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Note that certain <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> found on <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> will not have a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> equivalent.</source>
          <target state="translated">Beachten Sie, dass bestimmte <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> finden Sie auf <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> keine <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> entspricht.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Several of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> are for functionality such as geometry representation or layout, which are not relevant for a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Einige der <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> sind für Funktionen wie die Darstellung von Geometrie oder das Layout, die für nicht relevant sind eine <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>The majority of existing <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes will be found in the <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> namespace.</source>
          <target state="translated">Die meisten vorhandenen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> abgeleitete Klassen befinden sich der <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> Namespace.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Many of these derived classes implement elements for the flow document model.</source>
          <target state="translated">Viele dieser abgeleiteten Klassen implementieren Elemente für die flussdokumentmodells.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Certain derived classes such as <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> have some control-like functionality, but are derived from <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> such that the control-like elements can still participate in the flow document model.</source>
          <target state="translated">Bestimmte abgeleiteten Klassen, z. B. <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> einige Steuerelement-ähnliche Funktionalität, sondern abgeleitet sind <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> , dass das Steuerelement in das Flussdokumentmodell mit einbezogen werden können.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>The child element to be added.</source>
          <target state="translated">Das untergeordnete Element, das hinzugefügt werden soll.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Adds the provided element as a child of this element.</source>
          <target state="translated">Fügt das bereitgestellte Element als untergeordnetes Element dieses Elements hinzu.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>This method can throw an exception if called at a time when the logical tree is being iterated by another process.</source>
          <target state="translated">Diese Methode kann eine Ausnahme ausgelöst, wenn Sie zu einem Zeitpunkt aufgerufen wird, wenn die logische Struktur von einem anderen Prozess durchlaufen wird.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">Die meisten <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> abgeleitete Klassen verfügbar zu machen, dedizierte Auflistungen, die für die Kapselung verantwortlich sind (z. B. <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> auf die <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> Klasse. <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> auf die <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> Klasse).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</source>
          <target state="translated">Sie können in der Regel vermeiden, indem der logischen Struktur direkt zu bearbeiten, wenn Sie von diesen Klassen ableiten.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that acts as the parent rendering element (content host).</source>
          <target state="translated">Arbeiten mit der logischen Struktur für Inhaltselemente ist, die einen speziellen Parser oder ein spezieller benötigen möglicherweise erweiterte Szenario <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , fungiert als übergeordnetes Rendering-Element (Inhaltshost).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>For more information about how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Strukturen in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Called before an element is initialized.</source>
          <target state="translated">Wird aufgerufen, bevor ein Element initialisiert wird.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Override this method to provide special handling that should occur before your element is initialized during the element loading process.</source>
          <target state="translated">Überschreiben Sie diese Methode, um eine besondere Behandlung bereitstellen, die ausgeführt werden soll, bevor das Element während der Prozess des Ladens Element initialisiert wird.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Die Implementierung sollte die basisimplementierung aufrufen, da die Implementierung Base (Standard) einige interne Flags Initialisierung des festlegt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>The base implementation will throw an exception if <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> is called more than one time on the same element prior to reaching <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</source>
          <target state="translated">Die grundlegende Implementierung löst eine Ausnahme aus, wenn <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> heißt für dasselbe Element vor dem Erreichen von mehr als einmal <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The storyboard to begin.</source>
          <target state="translated">Das zu startende Storyboard.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Für die Signaturen, die keine verwenden die <ph id="ph1">`isControllable`</ph>, Parameter, oder wenn dieser Parameter angegeben wird <ph id="ph2">`false`</ph>, der Animation zugeordneten Uhren auf der Zeitachse werden entfernt, sobald sie den Zeitraum "Fill" erreicht.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Die Animation kann nicht aus diesem Grund neu gestartet werden, nach der einmal ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Beachten Sie, dass eine Animation steuern auch erfordert, dass das Storyboard benannt oder als eine Instanz im Code zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The storyboard to begin.</source>
          <target state="translated">Das zu startende Storyboard.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</source>
          <target state="translated">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist. Die angegebenen Optionen legen fest, welche Aktion ausgeführt werden soll, wenn die Eigenschaft bereits animiert ist.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Für die Signaturen, die keine verwenden die <ph id="ph1">`isControllable`</ph>, Parameter, oder wenn dieser Parameter angegeben wird <ph id="ph2">`false`</ph>, der Animation zugeordneten Uhren auf der Zeitachse werden entfernt, sobald sie den Zeitraum "Fill" erreicht.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Die Animation kann nicht aus diesem Grund neu gestartet werden, nach der einmal ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Beachten Sie, dass eine Animation steuern auch erfordert, dass das Storyboard benannt oder als eine Instanz im Code zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Mit dem Verfassen HandoffBehavior</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">Beim Anwenden einer <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> auf eine Eigenschaft mit der <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, stellen alle <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> zuvor mit dieser Eigenschaft zugewiesenen Objekte weiter an Systemressourcen beanspruchen, das Timing-System verwendet wird Entfernen Sie die Uhren nicht automatisch.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mit anwenden <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, Sie sollten zusammengesetzte Uhren aus der animierten Eigenschaft nach dem Abschluss entfernen.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Verwenden Sie zum Entfernen aller Uhren aus einer Eigenschaft der <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> -Methode des animierten Objekts.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Geben Sie die Eigenschaft als erster Parameter animierten und <ph id="ph1">`null`</ph> als das zweite.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">Dadurch werden alle Animationsuhren aus der Eigenschaft entfernt.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Zum Entfernen einer bestimmten <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> , aus einer Liste von Uhren verwenden die <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> Eigenschaft der <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> abgerufen eine <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, rufen Sie anschließend die <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> Methode der <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Dies erfolgt in der Regel in der <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> -Ereignishandler für eine Uhr.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Beachten Sie, dass nur Stammuhren von gesteuert werden, können eine <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; das <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> Eigenschaft einer untergeordneten Uhr gibt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Beachten Sie auch, dass die <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> Ereignis wird nicht ausgelöst, wenn die effektive Dauer der Uhr endlos ist.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">In diesem Fall muss der Benutzer bestimmen beim Aufrufen <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">Wenn ein Objekt Garbage Collection durchgeführt wird, wird die Uhren werden auch getrennt, und Sammlung veralteter Objekte aufgenommen.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Uhr Objekten finden Sie unter <bpt id="p1">[</bpt>Animationen und zeitlichen Steuerung Systemübersicht<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>The storyboard to begin.</source>
          <target state="translated">Das zu startende Storyboard.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</source>
          <target state="translated">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Declares whether the animation is controllable (can be paused) after it is started.</source>
          <target state="translated">Bestimmt, ob die Animation steuerbar ist (angehalten werden kann), nachdem sie gestartet wurde.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</source>
          <target state="translated">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist, im angegebenen Zustand für das Steuerelement der Animation nach deren Start.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Für die Signaturen, die keine verwenden die <ph id="ph1">`isControllable`</ph>, Parameter, oder wenn dieser Parameter angegeben wird <ph id="ph2">`false`</ph>, der Animation zugeordneten Uhren auf der Zeitachse werden entfernt, sobald sie den Zeitraum "Fill" erreicht.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Die Animation kann nicht aus diesem Grund neu gestartet werden, nach der einmal ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Beachten Sie, dass eine Animation steuern auch erfordert, dass das Storyboard benannt oder als eine Instanz im Code zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Mit dem Verfassen HandoffBehavior</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</source>
          <target state="translated">Beim Anwenden einer <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> auf eine Eigenschaft mit der <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, stellen alle <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> zuvor mit dieser Eigenschaft zugewiesenen Objekte weiter an Systemressourcen beanspruchen, das Timing-System verwendet wird Diese Uhren nicht automatisch entfernt werden.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mit anwenden <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, Sie sollten zusammengesetzte Uhren aus der animierten Eigenschaft nach dem Abschluss entfernen.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Verwenden Sie zum Entfernen aller Uhren aus einer Eigenschaft der <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> -Methode des animierten Objekts.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Geben Sie die Eigenschaft als erster Parameter animierten und <ph id="ph1">`null`</ph> als das zweite.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">Dadurch werden alle Animationsuhren aus der Eigenschaft entfernt.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Zum Entfernen einer bestimmten <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> , aus einer Liste von Uhren verwenden die <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> Eigenschaft der <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> abgerufen eine <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, rufen Sie anschließend die <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> Methode der <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Dies erfolgt in der Regel in der <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> -Ereignishandler für eine Uhr.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Beachten Sie, dass nur Stammuhren von gesteuert werden, können eine <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; das <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> Eigenschaft einer untergeordneten Uhr gibt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Beachten Sie auch, dass die <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> Ereignis wird nicht ausgelöst, wenn die effektive Dauer der Uhr endlos ist.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">In diesem Fall muss der Benutzer bestimmen beim Aufrufen <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">Wenn ein Objekt Garbage Collection durchgeführt wird, wird die Uhren werden auch getrennt, und Sammlung veralteter Objekte aufgenommen.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Uhr Objekten finden Sie unter <bpt id="p1">[</bpt>Animationen und zeitlichen Steuerung Systemübersicht<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Ruft die für das Element verwendete <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> ab oder legt diese fest.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Die für das Element verwendete <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> can be used to validate the values of multiple properties of an object.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> zum Überprüfen der Werte von mehreren Eigenschaften eines Objekts verwendet werden können.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, suppose that an application prompts the user to enter an address and then populates an object of type <ph id="ph1">`Address`</ph>, which has the properties <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, and <ph id="ph5">`Country`</ph>, with the values that the user provided.</source>
          <target state="translated">Nehmen wir beispielsweise an, dass eine Anwendung den Benutzer fordert auf eine Adresse eingeben, und dann ein Objekt des Typs füllt <ph id="ph1">`Address`</ph>, die über die Eigenschaften verfügt <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, und <ph id="ph5">`Country`</ph>, mit den Werten, die der Benutzer bereitgestellt.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The application has a panel that contains four <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to one of the object’s properties.</source>
          <target state="translated">Die Anwendung verfügt über einen Bereich, vier enthält <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> Steuerelemente, von denen jedes an eine der Eigenschaften des Objekts gebunden ist.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>You can use a <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> to validate the <ph id="ph3">`Address`</ph> object.</source>
          <target state="translated">Können Sie eine <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in einem <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> zum Überprüfen der <ph id="ph3">`Address`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> can ensure that the zip code is valid for the country of the address.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> können sicherstellen, dass die Postleitzahl für das Land der Adresse gültig ist.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Child elements inherit the <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> from their parent elements, just as with any other inheritable property.</source>
          <target state="translated">Untergeordnete Elemente erben die <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> von den übergeordneten Elementen, genauso wie bei jeder anderen vererbbare Eigenschaft.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Metadata properties set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept></source>
          <target state="translated">Festgelegte Metadateneigenschaften <bpt id="p1">**</bpt>"true"<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.BindingGroupProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>By calling this method, you effectively will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element (the parent may very well be a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, not a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</source>
          <target state="translated">Durch Aufruf dieser Methode, rufen Sie <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> für alle übergeordneten Bereich mit verschiebbarem Fensterinhalt mit dem Element (das übergeordnete Element ist möglicherweise sehr gut eine <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, sondern eine <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</source>
          <target state="translated">Wenn dieses Element nicht in einem bildlauffähigen Bereich enthalten ist, das Ereignis weiterhin ausgelöst, aber es werden keine Auswirkung.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Gets or sets the context menu element that should appear whenever the context menu is requested via <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> from within this element.</source>
          <target state="translated">Ruft das Kontextmenüelement ab, das angezeigt werden soll, wenn das Kontextmenü in diesem Element über die <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> angefordert wird, oder legt das Element fest.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The context menu that this element uses.</source>
          <target state="translated">Das Kontextmenü, das dieses Element verwendet.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>None</source>
          <target state="translated">Keiner</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The following example places a <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> on a <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird eine <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> auf eine <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Occurs just before any context menu on the element is closed.</source>
          <target state="translated">Tritt unmittelbar vor dem Schließen eines Kontextmenüs für ein Element auf.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To suppress closing context menus, handlers of the event should mark it as handled.</source>
          <target state="translated">Um schließende unterdrücken sollte Kontextmenüs, die Handler des Ereignisses es als behandelt markiert.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">Verwenden Sie dieses Ereignis als ein <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in einem Format müssen Sie auf den zugrunde liegenden Dienst Ereignisbezeichner verweisen:</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(Diese Verwendung ist erforderlich, da die Implementierung von Ereignissen auf <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> , macht die zugrunde liegenden Dienstereignis nicht richtig zugeordnet ist die <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> Bezeichner für die Verwendung in Triggern).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routed Event Information</source>
          <target state="translated">Informationen zum Routingereignis</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routing strategy</source>
          <target state="translated">Routing-Strategie</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Bubbling</source>
          <target state="translated">Bubbling</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The following example implements a handler that changes the cursor over a named region <ph id="ph1">`DisplayArea`</ph> (not shown).</source>
          <target state="translated">Das folgende Beispiel implementiert einen Handler, der den Cursor über ein benannter Bereich ändert <ph id="ph1">`DisplayArea`</ph> (nicht dargestellt).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The comment hints at a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> usage, but in fact this sample would be identical if <ph id="ph2">`DisplayArea`</ph> were a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Der Kommentar verweist auf eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> Verwendung "," tatsächlich wäre in diesem Beispiel identisch, aber wenn <ph id="ph2">`DisplayArea`</ph> wurden eine <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Übersicht über Routingereignisse<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Ereignis-ID-Objekte werden erstellt, wenn Routingereignisse registriert werden (finden Sie unter <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) und kann dann verwendet werden, um Klassenhandler hinzuzufügen (finden Sie unter <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Bezeichnerobjekte enthalten einen kennzeichnenden Namen, Besitzertyp, Handlertyp, Routingstrategie und eine Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Occurs when any context menu on the element is opened.</source>
          <target state="translated">Tritt ein, wenn ein Kontextmenü des Elements geöffnet wird.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To manually open context menus, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Zum manuellen Öffnen des Kontextmenüs kennzeichnen Handler für die Ereignisse das betreffende Ereignis als behandelt.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Otherwise, the existing value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">Andernfalls, den vorhandenen Wert von der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> Eigenschaft wird verwendet, um automatisch ein Kontextmenü geöffnet.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Das Ereignis als behandelt markiert wird die Standardaktion tatsächlich abgebrochen, und möglicherweise Gelegenheit, den Wert zurückgesetzt, die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> Eigenschaft, und öffnen Sie die neue <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>However, there is a timing issue you should be aware of.</source>
          <target state="translated">Es ist jedoch ein Problem der zeitlichen Steuerung, die Sie beachten sollten.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>In order to completely replace the context menu through a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> handler, the initial context menu must not be null / empty.</source>
          <target state="translated">Um vollständig ersetzen Sie im Kontextmenü den Befehl über eine <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> Handler auf, die ursprüngliche Kontextmenü darf nicht null / leer sein.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Alternatively, you might need to handle the event and then manually open a new context menu.</source>
          <target state="translated">Alternativ müssen Sie das Ereignis zu behandeln und dann manuell ein neues Kontextmenü geöffnet.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>For details, see <bpt id="p1">[</bpt>How to: Handle the ContextMenuOpening Event<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>wie: Behandeln Sie das ContextMenuOpening-Ereignis<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">Verwenden Sie dieses Ereignis als ein <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in einem Format müssen Sie auf den zugrunde liegenden Dienst Ereignisbezeichner verweisen:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(Diese Verwendung ist erforderlich, da die Implementierung von Ereignissen auf <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> , macht die zugrunde liegenden Dienstereignis nicht richtig zugeordnet ist die <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> Bezeichner für die Verwendung in Triggern).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routed Event Information</source>
          <target state="translated">Informationen zum Routingereignis</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routing strategy</source>
          <target state="translated">Routing-Strategie</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Bubbling</source>
          <target state="translated">Bubbling</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Übersicht über Routingereignisse<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Ereignis-ID-Objekte werden erstellt, wenn Routingereignisse registriert werden (finden Sie unter <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) und kann dann verwendet werden, um Klassenhandler hinzuzufügen (finden Sie unter <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Bezeichnerobjekte enthalten einen kennzeichnenden Namen, Besitzertyp, Handlertyp, Routingstrategie und eine Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Gets or sets the cursor that displays when the mouse pointer is over this element.</source>
          <target state="translated">Ruft den Cursor ab bzw. legt den Cursor fest, der angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The cursor to display.</source>
          <target state="translated">Der anzuzeigende Cursor.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The default value is defined as <ph id="ph1">&lt;see langword="null" /&gt;</ph> per this dependency property.</source>
          <target state="translated">Der Standardwert ist gemäß dieser Abhängigkeitseigenschaft als <ph id="ph1">&lt;see langword="null" /&gt;</ph> definiert.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>However, the practical default at run time will come from a variety of factors.</source>
          <target state="translated">Der zur Laufzeit angewendete Standardwert resultiert jedoch aus einer Vielzahl von Faktoren.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor relies on type conversion for the <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class to evaluate the string.</source>
          <target state="translated">Beim Festlegen dieser Eigenschaft <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Prozessor basiert auf typkonvertierung für die <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> Klasse, um die Zeichenfolge ergeben.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The provided string should evaluate to a <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> value.</source>
          <target state="translated">Die bereitgestellte Zeichenfolge ergeben sollten eine <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> Wert.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> for details.</source>
          <target state="translated">Ausführliche Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> property.</source>
          <target state="translated">Ob der von dieser Eigenschaft festgelegte Cursor werden oder wird nicht angezeigt, wenn der Mauszeiger über diesem Element befindet ist auch abhängig von den Wert der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</source>
          <target state="translated">Darüber hinaus wirkt ereignisbezogene Faktoren, z. B. ein aktives ziehen, Mauseingaben aufzufangen, Textbearbeitung-Modi im Steuerelemente usw., den Cursor mit einer höheren Priorität als der Wert sich auch, die Sie in dieser Eigenschaft angeben.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>To revert the behavior of setting this property to the eventual default, set it to <ph id="ph1">`null`</ph> again.</source>
          <target state="translated">Wenn Sie das Verhalten der Einstellung dieser Eigenschaft auf den tatsächlichen Standardwert zurücksetzen möchten, legen Sie es auf <ph id="ph1">`null`</ph> erneut aus.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The <ph id="ph1">`null`</ph> default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</source>
          <target state="translated">Die <ph id="ph1">`null`</ph> Standard wirklich bedeutet, dass Bestimmung des Werts praktische Cursor hier verzögert, und von einer anderen Stelle abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If presented with no programmatic values from any source, the default cursor over a <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> application will be an arrow.</source>
          <target state="translated">Wenn keine programmgesteuerte Werte aus einer Quelle, den Standardcursor angezeigt, über eine <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> Anwendung wird ein Pfeil sein.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Each movement of the mouse over a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application raises a <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> event.</source>
          <target state="translated">Jeder Bewegung der Maus über ein <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Anwendung löst eine <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</source>
          <target state="translated">Die Ereignis-Blasen und jedes Element entlang der Route erhält die Möglichkeit, die für die Ereignisbehandlung und zum Festlegen des Werts, der den Cursor über die Argumente für dieses Ereignis.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> property at any level, unless <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> is set.</source>
          <target state="translated">Wenn dies der Fall ist, hat die Tatsache, dass das Ereignis behandelt wird und einen geänderten Wert in den Argumenten hat Vorrang vor den Wert des der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> Eigenschaft auf jeder Ebene, es sei denn, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> festgelegt ist.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If not creating a custom cursor, typically you set this property to a static property value of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> class.</source>
          <target state="translated">Wenn Sie einen benutzerdefinierten Cursor nicht erstellt werden, in der Regel Sie legen Sie diese Eigenschaft auf eine statische Eigenschaft-Wert, der die <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> to a custom value is not enabled in partial trust.</source>
          <target state="translated">Festlegen der <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> auf einen benutzerdefinierten Wert ist bei teilweiser Vertrauenswürdigkeit nicht aktiviert.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>For more information on custom cursors, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu benutzerdefinierten Cursor finden Sie unter <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>None</source>
          <target state="translated">Keiner</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The following example sets the cursor to a custom value.</source>
          <target state="translated">Im folgenden Beispiel wird den Cursor auf einen benutzerdefinierten Wert.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.CursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Gets or sets the data context for an element when it participates in data binding.</source>
          <target state="translated">Dient zum Abrufen oder Festlegen des Datenkontexts für ein Element fest, wenn das Element an Datenbindungen beteiligt ist.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The object to use as data context.</source>
          <target state="translated">Das Objekt, das als Datenkontext verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>Data context<ept id="p1">*</ept> is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</source>
          <target state="translated"><bpt id="p1">*</bpt>Datenkontext<ept id="p1">*</ept> ist ein Konzept, das kann Elemente Informationen von ihren übergeordneten Elementen Bindungsquelle erben, die für die Bindung als auch andere Merkmale der Bindung wie des Pfads verwendet wird.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Data context can be set directly to a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> object, with the bindings evaluating to properties of that object.</source>
          <target state="translated">Datenkontext kann direkt festgelegt werden, ein <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> Objekt, mit den Bindungen, die als Eigenschaften des betreffenden Objekts bewertet.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can set the data context to a <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> object.</source>
          <target state="translated">Alternativ können Sie den Datenkontext festlegen, um eine <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Diese Abhängigkeitseigenschaft erbt Eigenschaftswerte.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Wenn kein anderer Wert für untergeordnete Elemente vorhanden sind <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> hergestellt, über lokale Werte oder Stile, das Eigenschaftensystem wird legen Sie den Wert, der <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> Wert des nächsten übergeordneten Elements mit diesem Wert zugewiesen.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can use one of the following properties of the <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> class to specify the binding source explicitly: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</source>
          <target state="translated">Alternativ können Sie eine der folgenden Eigenschaften von der <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> Klasse, um die Bindungsquelle explizit anzugeben: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, oder <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Specify the Binding Source<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Vorgehensweise: Angeben der Bindungsquelle<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> is most commonly set to as a <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaration.</source>
          <target state="translated">In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> am häufigsten auf festgelegt ist, als ein <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> Deklaration.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can use either property element syntax or attribute syntax.</source>
          <target state="translated">Sie können Eigenschaftenelementsyntax oder Attributsyntax verwenden.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Attribute syntax is shown in the example on this page.</source>
          <target state="translated">Die Attributsyntax wird im Beispiel auf dieser Seite angezeigt.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can also set <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> in code.</source>
          <target state="translated">Sie können auch festlegen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> im Code.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Property Element Usage</source>
          <target state="translated">Verwendung von XAML-Eigenschaftenelementen</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A directly embedded object that serves as data context for any bindings within the parent element.</source>
          <target state="translated">Eine direkte eingebettetes Objekt, das als Datenkontext für alle Bindungen innerhalb des übergeordneten Elements dient.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Typically, this object is a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> or another <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> subclass.</source>
          <target state="translated">Dieses Objekt in der Regel ist eine <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> oder ein anderes <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> Unterklasse.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, raw data of any <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> object type intended for binding may be placed here, with the actual bindings defined later.</source>
          <target state="translated">Alternativ können Sie unformatierten Daten eines beliebigen <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> Objekttyp vorgesehen für die Bindung mit den tatsächlichen Bindungen später definiert hier platziert werden kann.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A binding usage that evaluates to an appropriate data context.</source>
          <target state="translated">Eine Bindungsverwendung, die einen entsprechenden Datenkontext ergibt.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For details, see <bpt id="p1">[</bpt>Binding Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Binding als Markuperweiterung<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>One of the following: <ph id="ph1">`StaticResource`</ph>, or <ph id="ph2">`DynamicResource`</ph>.</source>
          <target state="translated">Eines der folgenden: <ph id="ph1">`StaticResource`</ph>, oder <ph id="ph2">`DynamicResource`</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This usage is used when referring to raw data defined as an object in resources.</source>
          <target state="translated">Diese Verwendung wird verwendet, bei Bezugnahme auf unformatierten Daten als ein Objekt in Ressourcen definiert.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>XAML-Ressourcen<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The key identifier for the object being requested from within a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Der Schlüsselbezeichner für das Objekt, das angefordert wird, innerhalb einer <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">Im folgenden Beispiel wird eine Bindung auf einen <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Element, durch das Erstellen eines neuen benutzerdefinierten Daten-Objekts, das Objekt als herstellen <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, und den Bindungspfad auf eine Eigenschaft darin festlegen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>Occurs when this element's data context changes.</source>
          <target state="translated">Tritt ein, wenn sich der Datenkontext dieses Elements ändert.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>For an explanation of data contexts and data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Eine Erläuterung der Datenkontexten und Datenbindung, finden Sie unter <bpt id="p1">[</bpt>Übersicht zur Datenbindung<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>When an element's <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> changes, all data-bound properties on this element are potentially affected.</source>
          <target state="translated">Wenn ein Element <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> ändert sich, alle datengebundenen Eigenschaften für dieses Element sind möglicherweise betroffen.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</source>
          <target state="translated">Dies gilt für alle Elemente, Nachfolgerelemente des aktuellen Elements an, die den Datenkontext zu erben, und auch das aktuelle Element selbst.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>All such bindings re-interpret the new <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> to reflect the new value in bindings.</source>
          <target state="translated">Alle solchen Bindungen interpretieren erneut das neue <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> entsprechend den neuen Wert im Bindungen.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>There is no guarantee made about the order of these changes relative to the raising of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> event.</source>
          <target state="translated">Es gibt keine Garantie, die hinsichtlich der Reihenfolge dieser Änderungen auf das Auslösen von der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>The changes can occur before the event, after the event, or in any mixture.</source>
          <target state="translated">Die Änderungen können vor dem Ereignis nach dem Ereignis oder eine beliebige Mischung auftreten.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DataContextProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Gets or sets the key to use to find the style template for this control in themes.</source>
          <target state="translated">Ruft den Schlüssel ab, der bei diesem Steuerelement zum Suchen der Stilvorlage in Designs verwendet wird, oder legt den Schlüssel fest.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The style key.</source>
          <target state="translated">Der Formatvorlagenschlüssel.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>To work correctly as part of theme style lookup, this value is expected to be the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the element being styled.</source>
          <target state="translated">Dieser Wert soll vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des formatierten Elements sein, damit er bei der Suche des Designstils korrekt verwendet wird.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is an accepted value for a certain case.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> ist ein zulässiger Wert für einen bestimmten Fall.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>This property is typically not set through any of its direct setters.</source>
          <target state="translated">Diese Eigenschaft wird in der Regel nicht über einen ihrer direkten Eigenschaftensetter festgelegt.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</source>
          <target state="translated">Stattdessen wird der typspezifische Metadaten dieser Abhängigkeitseigenschaft überschreiben, jedes Mal, wenn Sie eine neue Unterklasse erstellen.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>When you subclass, call the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method against the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> identifier, within the static constructor of the control subclass.</source>
          <target state="translated">Wenn haben, rufen Sie eine Unterklasse der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> Methode für die <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> Bezeichner im statischen Konstruktor der Steuerelementunterklasse.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>For instance, an inline class such as <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> actually has very little implementation beyond overriding the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> metadata in its static constructor, and exposing several instance constructors.</source>
          <target state="translated">Beispielsweise ein Inlineklasse, wie etwa <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> tatsächlich hat kaum Implementierung mehr als eine Überschreibung der <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> Metadaten im statischen Konstruktor und das Verfügbarmachen von mehreren Instanzkonstruktoren.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The fact that elements surrounded by the <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> tag gain a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> property of <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> is implemented within the theme style that was referenced by setting the default value of <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> to <ph id="ph5">`typeof(Bold)`</ph>.</source>
          <target state="translated">Die Tatsache, dass die Elemente von umgeben der <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> -Tag ein <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> Eigenschaft <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> wird implementiert, innerhalb der Designstil, auf die verwiesen wurde, durch Festlegen den Wert von <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> auf <ph id="ph5">`typeof(Bold)`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>If you want your element or control to deliberately not use theme styles, set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Wenn Sie ein Element oder Steuerelement Designformatvorlagen absichtlich nicht verwenden möchten, legen Sie die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> Eigenschaft <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Called immediately after an element is initialized.</source>
          <target state="translated">Wird unmittelbar nach der Initialisierung eines Elements aufgerufen.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</source>
          <target state="translated">Implementieren Sie diese Methode, um eine besondere Behandlung bereitstellen, die ausgeführt werden soll, wenn das Element während der Prozess des Ladens Element initialisiert wird.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Die Implementierung sollte die basisimplementierung aufrufen, da die Implementierung Base (Standard) einige interne Flags Initialisierung des festlegt.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was previously called, the base implementation will raise the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> event.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> zuvor aufgerufen wurde, die Base Implementierung löst die <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Otherwise, if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was not called or it could not be determined whether <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was called, the event is not raised.</source>
          <target state="translated">Andernfalls gilt: Wenn <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> nicht aufgerufen wurde, oder es konnte nicht bestimmt, ob <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> wurde aufgerufen, wird das Ereignis nicht ausgelöst.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Name of the element to search for.</source>
          <target state="translated">Der Name des zu suchenden Elements.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Finds an element that has the provided identifier name.</source>
          <target state="translated">Sucht ein Element mit dem Namen des bereitgestellten Bezeichners.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The requested element.</source>
          <target state="translated">Das angeforderte Element.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching element was found.</source>
          <target state="translated">Kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein, wenn kein übereinstimmendes Element gefunden wurde.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>If this element has child elements, these child elements are all searched recursively for the requested named element.</source>
          <target state="translated">Wenn dieses Element über untergeordnete Elemente verfügt, werden diese untergeordneten Elemente rekursiv nach dem angeforderten benannten Element durchsucht.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The following example sets a property on an element found by name within a referenced <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> on a page.</source>
          <target state="translated">Im folgenden Beispiel wird eine Eigenschaft für ein Element gefunden wird, namentlich in einem <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> auf einer Seite.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">Der Schlüsselbezeichner der zu findenden Ressource.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</source>
          <target state="translated">Sucht nach einer Ressource mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The found resource, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching resource was found (but will also throw an exception if <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</source>
          <target state="translated">Die gefundene Ressource, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn keine übereinstimmende Ressource gefunden wurde (zusätzlich wird bei <ph id="ph2">&lt;see langword="null" /&gt;</ph> eine Ausnahme ausgelöst).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you call this method for a key that cannot be found, an exception is thrown.</source>
          <target state="translated">Wenn Sie diese Methode für einen Schlüssel, die nicht gefunden werden kann aufrufen, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you do not want to handle exceptions for this case, you should instead call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht, um Ausnahmen für diesen Fall zu behandeln möchten, sollten Sie stattdessen Aufrufen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> returns <ph id="ph2">`null`</ph> when no resource is found, and does not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> Gibt <ph id="ph2">`null`</ph> Wenn keine Ressource gefunden wird, und löst keine Ausnahme.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</source>
          <target state="translated">Wenn die Ressource für das aufrufende Element nicht gefunden wird, die übergeordnete Struktur wird mit der logischen Struktur durchsucht, auf die gleiche Weise, die die Struktur wäre gesuchte Wenn eine Ressource mit Schlüssel zur Laufzeit angefordert wurden.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">In der Regel würden Sie sofort den Rückgabewert in den Typ der Eigenschaft umgewandelt, den Sie mit den zurückgegebenen Ressourcenwert festgelegt wurden.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">Das folgende Beispiel sucht nach einer Ressource, wie im Markup definierte und wendet sie auf eine bestimmte Eigenschaft eines Elements in Reaktion auf ein Routingereignis.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The requested resource key was not found.</source>
          <target state="translated">Der angeforderte Ressourcenschlüssel wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</source>
          <target state="translated">Dient zum Abrufen oder Festlegen eines Objekts, das die Anpassung von Darstellung, Effekten oder anderen Formateigenschaften ermöglicht, die auf dieses Element angewendet werden, wenn es den Tastaturfokus erhält.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The desired style to apply on focus.</source>
          <target state="translated">Die gewünschte Formatvorlage, die angewendet wird, wenn das Element den Fokus erhält.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The default value as declared in the dependency property is an empty static <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</source>
          <target state="translated">Der in der Abhängigkeitseigenschaft deklarierte Standardwert ein leerer statischer <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</source>
          <target state="translated">Der tatsächliche Wert zur Laufzeit ist jedoch häufig (aber nicht immer) eine Formatvorlage, die von der Designunterstützung für Steuerelemente bereitgestellt wird.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</source>
          <target state="translated">Beim Festlegen dieser Eigenschaft <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>Stile werden fast immer als eine Ressource, statt Inline als Element definiert und, dass die Ressource in der Regel ist auf die verwiesen wird als eine <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Note that this property affects visual appearance but does not report so in metadata.</source>
          <target state="translated">Beachten Sie, dass diese Eigenschaft wirkt sich auf die visuelle Darstellung, aber keine über dies in den Metadaten Auskunft gibt.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</source>
          <target state="translated">Dies ist, da die visuelle Darstellung ereignisgesteuerte möglicherweise nicht immer gelten, und ist somit nicht in der Regel Visualisierung oder Layout Informationen in den Metadaten gemeldet sollten.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</source>
          <target state="translated">Grundsätzlich sollte das visuelle Verhalten des Fokus auf ein Steuerelement angewendet kohärente von Element zu Element sein.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</source>
          <target state="translated">Die sinnvollste zum Erzwingen von Kohärenz besteht darin, den visuellen Stil der Fokus nur ändern, wenn Sie ein vollständiges Design erstellen.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</source>
          <target state="translated">Festlegen dieser Eigenschaft auf einzelne Formatvorlagen und nicht als Teil eines Designs ist nicht die beabsichtigte Verwendung dieser Eigenschaft, da sie zu einer verwirrend Benutzeroberfläche hinsichtlich des Tastaturfokus führen kann.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, and to do so in a way that does not visually interfere with any existing focus visual style.</source>
          <target state="translated">Wenn Sie Elements prozessinternes spezifisches Verhalten, die absichtlich nicht kohärent ist beabsichtigt, wird ein viel besserer Ansatz im Stile für einzelne Eingabestatus-Eigenschaften, z. B. Verwenden von Triggern <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, und klicken Sie auf eine Weise dazu, die nicht der Fall ist beeinträchtigen Sie mit den visuellen Stil des vorhandenen Fokus visuell.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>For more information on the design intention of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> and alternative focus properties, see <bpt id="p1">[</bpt>Styling for Focus in Controls, and FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</source>
          <target state="translated">Weitere Informationen über den Entwurf der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> sowie die alternativen Eigenschaften zu konzentrieren, finden Sie unter <bpt id="p1">[</bpt>Formatierung für den Fokus in Steuerelementen und FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Property Element Usage</source>
          <target state="translated">Verwendung von XAML-Eigenschaftenelementen</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>One of the following: , or .</source>
          <target state="translated">Eines der folgenden:, oder.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>XAML-Ressourcen<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">Der Schlüssel, der den angeforderten Stil identifiziert.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Der Schlüssel verweist auf eine vorhandene Ressource in einem <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Eigenschaftenelementsyntax ist technisch zwar möglich, aber nicht empfehlenswert.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>Inlinestile und Vorlagen<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Eine Bindung verwendet oder <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> ist auch möglich, aber ungewöhnlich.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>None</source>
          <target state="translated">Keiner</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Gets or sets a value indicating whether this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> should force the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> to render the cursor as declared by this instance's <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> property.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob dieses <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> das Rendern des Cursors in der <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> gemäß der Deklaration in dieser Instanz der <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph>-Eigenschaft erzwingen soll, oder legt diesen Wert fest.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn für die Darstellung des Cursors bei Positionierung über diesem Element die Cursoreinstellungen dieser Instanz (einschließlich aller untergeordneten Elemente) erzwungen werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting this property to <ph id="ph1">`true`</ph> will override the cursor preferences established by child elements.</source>
          <target state="translated">Wenn diese Eigenschaft auf <ph id="ph1">`true`</ph> überschreibt die Cursor-Voreinstellungen, die durch die untergeordneten Elemente.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Doing so in general application <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> might be confusing for the user, particularly if child elements are attempting to specify cursors.</source>
          <target state="translated">Dies ist daher im Allgemeinen Anwendung <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> sind möglicherweise für den Benutzer verwirrend, insbesondere, wenn untergeordnete Cursor angeben möchten.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is more appropriate in control subclassing or compositing scenarios.</source>
          <target state="translated">Festlegen von <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> Unterklassen oder Compositing Szenarios besser geeignet ist.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>None</source>
          <target state="translated">Keiner</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The following example forces the cursor while over the element.</source>
          <target state="translated">Im folgenden Beispiel wird den Cursor über dem Element.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ForceCursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The target <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> from which to get the binding.</source>
          <target state="translated">Die Ziel-<ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>, aus der die Bindung abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> for the specified property's binding.</source>
          <target state="translated">Ruft die <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> für die Bindung der angegebenen Eigenschaft ab.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> if the target is data bound; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Gibt eine <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> zurück, wenn das Ziel datengebunden ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The following example retrieves a binding by querying a property.</source>
          <target state="translated">Im folgende Beispiel ruft eine Bindung durch Abfragen einer Eigenschaft ab.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns an alternative logical parent for this element if there is no visual parent.</source>
          <target state="translated">Gibt ein alternatives logisches übergeordnetes Element für dieses Element zurück, wenn kein visuelles übergeordnetes Element vorhanden ist.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>In this case, a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> parent is always the same value as the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> property.</source>
          <target state="translated">In diesem Fall ist ein übergeordnetes <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> immer identisch mit dem Wert der <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph>-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns something other than <ph id="ph1">&lt;see langword="null" /&gt;</ph> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</source>
          <target state="translated">Gibt immer dann einen Wert ungleich <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurück, wenn eine auf WPF-Frameworkebene vorgenommene Implementierung dieser Methode eine nicht visuelle übergeordnete Verbindung hat.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>The default implementation returns the expected single visual parent.</source>
          <target state="translated">Die Standardimplementierung gibt die erwartete einzelne visuelle übergeordnetes Element zurück.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Custom implementations might return alternate parent relationships.</source>
          <target state="translated">Benutzerdefinierte Implementierungen möglicherweise alternative übergeordnete Beziehungen zurück.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Occurs when this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is initialized.</source>
          <target state="translated">Tritt ein, wenn dieses <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> initialisiert wird.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This coincides with cases where the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> property changes from <ph id="ph2">&lt;see langword="false" /&gt;</ph> (or undefined) to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Dieses Ereignis geht mit Fällen einher, in denen sich der Wert der <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph>-Eigenschaft von <ph id="ph2">&lt;see langword="false" /&gt;</ph> (oder nicht definiert) in <ph id="ph3">&lt;see langword="true" /&gt;</ph> ändert.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This event will be raised whenever the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> methods are called.</source>
          <target state="translated">Dieses Ereignis wird ausgelöst, wenn die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Calls to these methods could have been made by deliberate code, or by the <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> loading process.</source>
          <target state="translated">Aufrufe dieser Methoden können vorgenommen wurden mit absichtliche Code oder durch die <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> Prozess des Ladens.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Gets or sets the context for input used by this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Ruft den Kontext für die von diesem <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> verwendete Eingabe ab oder legt diesen Kontext fest.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The input scope, which modifies how input from alternative input methods is interpreted.</source>
          <target state="translated">Der Eingabebereich, der bestimmt, wie Eingaben von alternativen Eingabemethoden interpretiert werden.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The default value is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (which results in a default handling of commands).</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="null" /&gt;</ph> (und führt zu einer Standardbehandlung von Befehlen).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Diese Abhängigkeitseigenschaft erbt Eigenschaftswerte.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Wenn kein anderer Wert für untergeordnete Elemente vorhanden sind <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> hergestellt, über lokale Werte oder Stile, das Eigenschaftensystem wird legen Sie den Wert, der <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> Wert des nächsten übergeordneten Elements mit diesem Wert zugewiesen.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Although a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax usage is listed and is syntactically allowed, setting this property in <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> is not common.</source>
          <target state="translated">Obwohl eine <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Syntax Verwendung aufgelistet ist und syntaktisch zulässig ist, wird durch Festlegen dieser Eigenschaft <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> ist nicht üblich.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.InputScopeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>Gets a value indicating whether this element has been initialized, either by being loaded as <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, or by explicitly having its <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> method called.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element durch das Laden als <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> oder durch einen expliziten Aufruf der entsprechenden <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>-Methode initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is initialized per the aforementioned loading or method calls; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Element wie zuvor beschrieben durch Laden oder durch einen Methodenaufruf initialisiert wird, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>This property may also be <ph id="ph1">`true`</ph> if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</source>
          <target state="translated">Diese Eigenschaft ist möglicherweise auch <ph id="ph1">`true`</ph> , wenn dieses Element in der Elementstruktur verschoben wurde, dass er ein neues übergeordnetes Element aufweist und deshalb neu geladen werden muss.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>Gets a value indicating whether this element has been loaded for presentation.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element für die Darstellung geladen wurde.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current element is attached to an element tree and has been rendered; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the element has never been attached to a loaded element tree.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das aktuelle Element an eine Elementstruktur angefügt ist und gerendert wurde, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn das Element noch nie an eine geladene Elementstruktur angefügt wurde.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>From a newly constructed instance, this property starts off <ph id="ph1">`false`</ph>, and remains <ph id="ph2">`true`</ph> once it is set to <ph id="ph3">`true`</ph>, even if subsequently removed by  code.</source>
          <target state="translated">Einer neu erstellten Instanz startet diese Eigenschaft deaktiviert <ph id="ph1">`false`</ph>, und bleibt <ph id="ph2">`true`</ph> sobald er, um festgelegt ist <ph id="ph3">`true`</ph>, selbst wenn anschließend durch Code entfernt.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>The following example code uses <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> as a conditional check to assure that a function <ph id="ph2">`displayData`</ph> (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</source>
          <target state="translated">Der folgende Beispielcode verwendet <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> als eine bedingte Überprüfung, um sicherzustellen, dass eine Funktion <ph id="ph2">`displayData`</ph> (nicht dargestellt) werden gültige Elemente geladen haben auf der Seite berücksichtigt werden sollen, als Teil eines ereignishandlers bei Bedarf zu funktionieren.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>That same logic is run as an event handler for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</source>
          <target state="translated">Dass dieselbe Logik, wie ein Ereignishandler für ausgeführt wird <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Gets or sets localization/globalization language information that applies to an individual element.</source>
          <target state="translated">Ruft die Sprachinformationen für die Lokalisierung/Globalisierung eines einzelnen Elements ab oder legt diese Informationen fest.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The culture information for this element.</source>
          <target state="translated">Die Kulturinformationen für dieses Element.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The default value is an <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> instance with its <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> value set to the string "en-US".</source>
          <target state="translated">Der Standardwert ist eine <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph>-Instanz, deren <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph>-Wert auf die Zeichenfolge "en-US" festgelegt ist.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The string formats follow the RFC 3066 standard.</source>
          <target state="translated">Die Zeichenfolgenformate unterliegen dem RFC 3066-Standard.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>For example, U.S. English is "en-US".</source>
          <target state="translated">Z. B. USA Englisch ist "En-US".</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> for more information on the values and format.</source>
          <target state="translated">Finden Sie unter <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> Weitere Informationen zu den Werten und Format.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Diese Abhängigkeitseigenschaft erbt Eigenschaftswerte.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Wenn kein anderer Wert für untergeordnete Elemente vorhanden sind <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> hergestellt, über lokale Werte oder Stile, das Eigenschaftensystem wird legen Sie den Wert, der <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> Wert des nächsten übergeordneten Elements mit diesem Wert zugewiesen.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LanguageProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Occurs when the element is laid out, rendered, and ready for interaction.</source>
          <target state="translated">Tritt auf, wenn das Element ausgerichtet und gerendert sowie zur Interaktion vorbereitet wurde.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">Direkte Routingereignisse führen Sie eine Route nicht ausgeführt, sie sind nur innerhalb des gleichen Elements in dem sie ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Direkte Routingereignisse unterstützen andere Verhalten Routingereignis: sie unterstützen eine Auflistung zugegriffen werden kann, Handler und dient als ein <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in einem Format.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routed Event Information</source>
          <target state="translated">Informationen zum Routingereignis</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routing strategy</source>
          <target state="translated">Routing-Strategie</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct</source>
          <target state="translated">Direkt</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Übersicht über Routingereignisse<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Ereignis-ID-Objekte werden erstellt, wenn Routingereignisse registriert werden (finden Sie unter <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) und kann dann verwendet werden, um Klassenhandler hinzuzufügen (finden Sie unter <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Bezeichnerobjekte enthalten einen kennzeichnenden Namen, Besitzertyp, Handlertyp, Routingstrategie und eine Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>Gets an enumerator for the logical child elements of this element.</source>
          <target state="translated">Ruft einen Enumerator für die logischen untergeordneten Elemente dieses Elements ab.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>An enumerator for logical child elements of this element.</source>
          <target state="translated">Ein Enumerator für die logischen untergeordneten Elemente dieses Elements.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Strukturen in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction that focus is to be moved, as a value of the enumeration.</source>
          <target state="translated">Die Richtung, in die der Fokus verschoben werden soll, als Wert der Enumeration.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Moves the keyboard focus from this element to another element.</source>
          <target state="translated">Verschiebt den Tastaturfokus von diesem Element auf ein anderes Element.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if focus is moved successfully; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the target element in direction as specified does not exist.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der Fokus erfolgreich verschoben wurde. <ph id="ph2">&lt;see langword="false" /&gt;</ph> wird zurückgegeben, wenn das Zielelement in der angegebenen Richtung nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Gets or sets the identifying name of the element.</source>
          <target state="translated">Dient zum Abrufen oder Festlegen des Elementnamens.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Der Name stellt einen Instanzverweis bereit, sodass CodeBehind, wie z. B. Ereignishandlercode, auf ein Element verweisen kann, sobald es während der Verarbeitung durch <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> erstellt wurde.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name of the element.</source>
          <target state="translated">Der Name des Elements.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The most common usage of this property is when specifying a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element name in markup.</source>
          <target state="translated">Die häufigste Verwendung dieser Eigenschaft ist beim Angeben einer <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Elementname im Markup.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>This property essentially provides a WPF framework-level convenience property to set the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</source>
          <target state="translated">Diese Eigenschaft bietet im Wesentlichen eine WPF-Frameworkebene benutzerfreundliche-Eigenschaft zum Festlegen der <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>X: Name-Direktive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Getting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</source>
          <target state="translated">Abrufen einer <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> aus Code ist nicht üblich, da Sie bereits den entsprechenden Verweis im Code haben, Sie nur Methoden aufrufen können und Eigenschaften für das Element verweisen Elementverweises der <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Eine Ausnahme ist, wenn die Zeichenfolge eine überladene Bedeutung aufweist, z. B. ist es hilfreich, wenn diese Namen in <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code if the original <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> was set from markup is also not recommended, and changing the property will not change the object reference.</source>
          <target state="translated">Festlegen einer <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> aus Code Wenn die ursprüngliche <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> wurde Markup festgelegt wird ebenfalls nicht empfohlen, und ändern die Eigenschaft ändert sich nicht auf den Objektverweis.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Such object references are created only when the underlying namescopes are explicitly created during <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> loading.</source>
          <target state="translated">Solche Objektverweise werden nur erstellt, wenn die zugrunde liegenden Namescopes während explizit erstellt werden <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> laden.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>You must specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> to make an effective change on the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> property of an already loaded element.</source>
          <target state="translated">Sie müssen ausdrücklich Aufrufen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> auf eine effektive Änderung vornehmen der <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> Eigenschaft eines Elements bereits geladen.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>One notable case where setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from  code is important is for naming elements that storyboards will run against.</source>
          <target state="translated">Eine wichtige Fall, in dem das Festlegen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> aus Code ist wichtig für das Benennen von Elementen, für die storyboards für ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Before you can register a name, might also need to instantiate and assign a <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instance.</source>
          <target state="translated">Bevor Sie einen Namen registrieren können, müssen u. u. auch instanziieren und Zuweisen einer <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>See the Example section, or <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Finden Sie im Beispielabschnitt oder <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</source>
          <target state="translated">Festlegen von <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> aus Code verfügt über eingeschränkten Anwendungen jedoch die Suche nach einem Element anhand des Namens ist eher üblich, insbesondere, wenn Sie ein Navigationsmodell für Einzelseiten Dokumentationssatzes, wobei Seiten in der Anwendung zu laden und -Laufzeitcode ist nicht notwendigerweise Code-Behind, Seite "jeweiligen".</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The utility method <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, which is available from any <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, can find any element by <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> in that element's logical tree recursively.</source>
          <target state="translated">Die Hilfsprogrammmethode <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, kann über eine <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, finde beliebiges Element durch <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> in die logische Struktur rekursiv des Elements.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Or you can use the <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> static method of <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, which also takes the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> string as an argument.</source>
          <target state="translated">Oder Sie können die <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> statische Methode der <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, dem nimmt auch die <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> Zeichenfolge als Argument.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Commonly used root elements (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> for example) implement the interface <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Häufig verwendete Stammelemente (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> z. B.) implementieren die Schnittstelle <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Implementations of this interface are expected to enforce that names be unambiguous within their scope.</source>
          <target state="translated">Implementierungen dieser Schnittstelle werden erwartet, um zu erzwingen, dass Namen innerhalb des Bereichs eindeutig sein.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.NameProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Stellt Daten über das Ereignis bereit.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Der Aufruf erfolgt immer dann, wenn das <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph>-Routingereignis diese Klasse auf der Route erreicht.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Diese Methode hat keine Standardimplementierung.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch die basisimplementierung aufrufen.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Der Zweck dieser Methode ist zumindest ähneln <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</source>
          <target state="translated">Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, mit denen Handler aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Aus diesem Grund Ihrer Implementierung müssen Sie die Argumente berücksichtigen (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen).</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Unterklassen des <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Eine mögliche Szenario besteht darin die Argumente des Ereignisses und absichtlich markiert das Ereignis als behandelt, um die Route zu verkürzen.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Die Ereignisdaten für das Ereignis.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Der Aufruf erfolgt immer dann, wenn das <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph>-Routingereignis diese Klasse auf der Route erreicht.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Diese Methode hat keine Standardimplementierung.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch base() aufrufen.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Der Zweck dieser Methode ist zumindest ähneln <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit Ihre Implementierung die Quelle für die Ereignisargumente werden muss Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen).</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Unterklassen des <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Eine mögliche Szenario besteht darin die Argumente des Ereignisses und absichtlich markiert das Ereignis als behandelt, um die Route zu verkürzen.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Die Ereignisdaten für das Ereignis.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Class handler for the <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> event.</source>
          <target state="translated">Der Klassenhandler für das <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph>-Ereignis.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This class handler sets appropriate focus behavior on this element if the event originated from this element.</source>
          <target state="translated">Diese Klassenhandler festlegt entsprechenden Fokusverhalten für dieses Element, wenn das Ereignis aus diesem Element ausgelöst wurde.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If the event's source was another element in the tree, the handler does nothing.</source>
          <target state="translated">Wenn die Quelle des Ereignisses ein anderes Element in der Struktur wurde, wird der Handler keine Aktion ausgeführt.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Override this method in order to change these default focusing behavior on your element.</source>
          <target state="translated">Überschreiben Sie diese Methode, um diese Standardeinstellung Fokussierung Verhalten auf das Element zu ändern.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Die Ereignisdaten für das Ereignis.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> event.</source>
          <target state="translated">Löst das <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph>-Ereignis aus.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>This method is invoked whenever <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Diese Methode wird immer dann aufgerufen, wenn <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> auf <ph id="ph2">&lt;see langword="true" /&gt;</ph> festgelegt wird.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>The default implementation of this virtual method raises the event as described earlier in this topic.</source>
          <target state="translated">Die Standardimplementierung dieser virtuellen Methode löst das Ereignis aus, wie weiter oben in diesem Thema beschrieben.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Overrides should call base() to preserve this behavior.</source>
          <target state="translated">Bei überschreibungen sollte base(), um dieses Verhalten beizubehalten aufgerufen.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> property is read-only.</source>
          <target state="translated">Beachten Sie, dass die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Therefore, you cannot set it to force initialization behavior that way.</source>
          <target state="translated">Aus diesem Grund kann nicht die Initialisierungsverhalten auf diese Weise erzwingen festgelegt werden.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Initialization setting is intended to be done only by the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</source>
          <target state="translated">Festlegen der Initialisierung sollte nur von erfolgen die <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> Framework.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The event data that describes the property that changed, including the old and new values.</source>
          <target state="translated">Die Ereignisdaten, die die geänderte Eigenschaft beschreiben, einschließlich der alten und neuen Werte.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> has been updated.</source>
          <target state="translated">Wird immer dann aufgerufen, wenn der tatsächliche Wert einer Abhängigkeitseigenschaft für diese <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> aktualisiert wurde.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the arguments parameter.</source>
          <target state="translated">Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</source>
          <target state="translated">Überschreibt <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect property changes or invalidations.</source>
          <target state="translated">Diese Methode dient nicht in der Regel eigenschaftenänderungen oder Außerkraftsetzungen aufgewendet erkennen.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</source>
          <target state="translated">Sie dient stattdessen für Änderungen des als Muster verwendeten allgemeinen invalidierungstypen verfügbar, wenn bestimmte Informationen über wide Klassifizierungen Eigenschaften bekannt ist.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is potentially invoked many times during the life of an object.</source>
          <target state="translated">Diese Methode wird möglicherweise mehrere Male während der Lebensdauer eines Objekts aufgerufen.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">Aus diesem Grund können Sie eine bessere Leistung erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und Sie dann fügen <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> Funktionen für die einzelnen Eigenschaften.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">Allerdings würden Sie diese Methode verwenden, wenn eine <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> enthält eine signifikante Anzahl Wert verknüpft Abhängigkeitseigenschaften, oder wenn es die Logik enthält, wie z. B. Renderingverhalten, die erneut ausgeführt werden, muss mehrere Fälle der Ungültigkeitserklärungen beziehen.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Note that there is an identically named <ph id="ph1">`OnPropertyChanged`</ph> method with a different signature (the parameter type is <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) that can appear on a number of classes.</source>
          <target state="translated">Beachten Sie, dass ein identisch mit dem Namen <ph id="ph1">`OnPropertyChanged`</ph> Methode mit einer anderen Signatur (der Parametertyp ist <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>), die auf eine Reihe von Klassen angezeigt werden können.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>That <ph id="ph1">`OnPropertyChanged`</ph> is used for data object notifications, and is part of the contract for <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</source>
          <target state="translated">Dass <ph id="ph1">`OnPropertyChanged`</ph> für Daten Objekt Benachrichtigungen verwendet wird, und ist Teil des Vertrags für <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation, as the first operation in your implementation.</source>
          <target state="translated">Rufen Sie immer die grundlegende Implementierung als erster Vorgang in Ihrer Implementierung.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, which causes incorrect values to be reported.</source>
          <target state="translated">Dies versäumt wird die gesamte erheblich deaktiviert <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> Eigenschaftensystem, wodurch falsche Werte gemeldet werden.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The old style.</source>
          <target state="translated">Der alte Stil.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The new style.</source>
          <target state="translated">Der neue Stil.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Invoked when the style that is in use on this element changes.</source>
          <target state="translated">Wird aufgerufen, wenn sich der aktuell verwendete Stil dieses Elements ändert.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>This method has a default implementation that sets an internal flag noting the style changed condition.</source>
          <target state="translated">Diese Methode hat eine Standardimplementierung, die ein internes, beachten Sie die Formatvorlage geändert Bedingung Flag festlegt.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Always call the base implementation, otherwise styles cannot be applied.</source>
          <target state="translated">Rufen Sie immer die grundlegende Implementierung, die andernfalls Stile können nicht angewendet werden kann.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</source>
          <target state="translated">Szenarien für das Überschreiben dieser Methode können enthalten, wenn die abgeleitete Klasse ist eine spezielle Stilauswahl Stilwerte.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Theme changes will potentially invoke this method.</source>
          <target state="translated">Design ändert, werden möglicherweise mit dieser Methode aufgerufen.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Stellt Daten über das Ereignis bereit.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Der Aufruf erfolgt immer dann, wenn das <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph>-Routingereignis diese Klasse auf der Route erreicht.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Diese Methode hat keine Standardimplementierung.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch base() aufrufen.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Der Zweck dieser Methode ist zumindest ähneln <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit Ihre Implementierung die Quelle für die Ereignisargumente werden muss Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen).</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Unterklassen des <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Eine mögliche Szenario besteht darin die Argumente des Ereignisses und absichtlich markiert das Ereignis als behandelt, um die Route zu verkürzen.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Stellt Daten über das Ereignis bereit.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Der Aufruf erfolgt immer dann, wenn das <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph>-Routingereignis diese Klasse auf der Route erreicht.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Diese Methode hat keine Standardimplementierung.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie dennoch base() aufrufen.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Der Zweck dieser Methode ist zumindest ähneln <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> -Ereignismuster auf * Methoden: DSC bietet die Möglichkeit zum Behandeln des übereinstimmenden Ereignis von abgeleiteten Klassen mit einem Klassenhandler statt einem Instanzhandler.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da das Routingereignis von einem untergeordneten Element, nicht unbedingt das Element ausgelöst worden sein kann, die Handler aufgerufen wird, damit die Implementierung die Ereignisargumente Quelle durchführen müssen Eigenschaften berücksichtigt (und sollten nicht versuchen, erneut Auslösen des Ereignisses in den meisten Fällen).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Unterklassen des <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> wählen Sie mit der konnte Ereignishandlermethoden private Klasse aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Eine mögliche Szenario besteht darin die Argumente des Ereignisses und absichtlich markiert das Ereignis als behandelt, um die Route zu verkürzen.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Gets or sets a value indicating whether this element incorporates style properties from theme styles.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element Stileigenschaften aus Designstilen enthält, oder legt diesen Wert fest.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieses Element keine Designstileigenschaften verwendet, alle auf Stile zurückgehenden Eigenschaften aus den Stilen lokaler Anwendungen stammen und die Designstileigenschaften nicht angewendet werden.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn Anwendungsstile vor Designstilen auf Eigenschaften angewendet werden, die in Anwendungsstilen nicht explizit festgelegt wurden.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</source>
          <target state="translated">Die häufigste Verwendung dieser Eigenschaft ist eine indirekte Verwendung innerhalb der Setter eines Formats, der einen Designstil bereitstellt.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Gets the parent in the logical tree for this element.</source>
          <target state="translated">Ruft das übergeordnete Element in der logischen Struktur dieses Elements ab.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The logical parent for this element.</source>
          <target state="translated">Das logische übergeordnete Element dieses Elements.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</source>
          <target state="translated">Beachten Sie, dass sich das logische übergeordnete Element eines Elements möglicherweise je nach den Funktionen der Anwendung geändert und den Wert dieser Eigenschaft diese Änderung nicht widerspiegelt.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>You typically should get the value immediately before you need it.</source>
          <target state="translated">In der Regel sollten Sie den Wert abrufen, unmittelbar bevor Sie ihn benötigen.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>See <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>Strukturen in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> für Weitere Informationen zu durchlaufen, logischen Strukturen und die Szenarien, in denen dieser Ansatz für Element-Ermittlung geeignet ist.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</source>
          <target state="translated">Im Eigenschaftensystem wird möglicherweise neu berechnen alle Eigenschaftswerte eines Elements, wenn er erneut übergeordnet ist, da einige Eigenschaften Werte in der logischen Struktur erben.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> that applies for bindings can also change when elements are reparented.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> , die gilt für Bindungen können auch ändern, wenn Elemente erneut übergeordnet werden.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</source>
          <target state="translated">Ändern eines Elements in der Regel nur erfolgt durch die Bearbeitung von Auflistungen, mithilfe von dedizierten hinzufügen oder entfernen-Methoden, oder durch Festlegen von Inhaltseigenschaften von Elementen.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The most typical scenario for using the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> property is to obtain a reference and then get various <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> property values from the parent.</source>
          <target state="translated">Das häufigste Szenario für die Verwendung der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> Eigenschaft wird zum Abrufen eines Verweises und rufen Sie anschließend auf verschiedenen <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> Eigenschaftswerte aus dem übergeordneten Element.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>For templates, the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of the template eventually will be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Bei Vorlagen der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> der Vorlage schließlich werden <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>To get past this point and extend into the logical tree where the template is actually applied, use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</source>
          <target state="translated">Über diesen Punkt hinaus, und erweitern in der logischen Struktur, in dem die Vorlage tatsächlich angewendet wird, verwenden Sie <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The following example checks to see whether the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is of a particular type.</source>
          <target state="translated">Das folgende Beispiel überprüft, um festzustellen, ob die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> von einem <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> verfügt über einen bestimmten Typ.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction for which a prospective focus change should be determined.</source>
          <target state="translated">Die Richtung, für die eine mögliche Fokusänderung bestimmt werden soll.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</source>
          <target state="translated">Bestimmt das nächste Element, das relativ zu diesem Element den Fokus in einer angegebenen Fokusverschiebungsrichtung erhalten würde, verschiebt den Fokus jedoch nicht.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>This method is sealed and cannot be overridden.</source>
          <target state="translated">Diese Methode ist versiegelt und kann nicht überschrieben werden.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The next element that focus would move to if focus were actually traversed.</source>
          <target state="translated">Das nächste Element, auf das der Fokus verschoben würde, wenn der Fokus tatsächlich durchlaufen würde.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>May return <ph id="ph1">&lt;see langword="null" /&gt;</ph> if focus cannot be moved relative to this element for the provided direction.</source>
          <target state="translated">Kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgeben, wenn der Fokus für die bereitgestellte Richtung nicht relativ zu diesem Element verschoben werden kann.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> is the related method that actually does move focus.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> ist die entsprechende Methode, die tatsächlich Fokus.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Specified one of the following directions in the <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</source>
          <target state="translated">Gibt eine der folgenden Richtungen im <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph> an: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>These directions are not legal for <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (but they are legal for <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</source>
          <target state="translated">Diese Richtungen sind für <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> unzulässig (aber für <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph> zulässig).</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Name to use for the specified name-object mapping.</source>
          <target state="translated">Name für die angegebene Namensobjektzuordnung.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Object for the mapping.</source>
          <target state="translated">Objekt für die Zuordnung.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Provides an accessor that simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> registration method.</source>
          <target state="translated">Stellt einen Accessor bereit, der Zugriff auf die <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>-Registrierungsmethode vereinfacht.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine bequeme Methode zum Aufrufen <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>The implementation will check successive parent elements until it finds the applicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementation, which is found by finding an element that implements <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Die Implementierung überprüft aufeinander folgenden übergeordneten Elemente, bis die entsprechende <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> -Implementierung, die gefunden wird, mit einer Suche nach einem Element, das implementiert <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information about namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Namescopes finden Sie unter <bpt id="p1">[</bpt>WPF-XAML-Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> is necessary in order to correctly hook up animation storyboards for applications when created in code.</source>
          <target state="translated">Aufrufen von <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> ist erforderlich, um die Animationsstoryboards für Anwendungen, wenn im Code erstellt, ordnungsgemäß zu verknüpfen.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is because one of the key storyboard properties, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, uses a run-time name lookup instead of being able to take a reference to a target element.</source>
          <target state="translated">Dies ist, da einer der Schlüsselwerte storyboard-Eigenschaften, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, eine Namenssuche zur Laufzeit verwendet, statt einen Verweis auf ein Target-Element erstellen.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is true even if that element is accessible by reference from the code.</source>
          <target state="translated">Dies gilt auch, wenn dieses Element als Verweis aus dem Code zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information on why you need to register names for storyboard targets, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen darüber, warum die Namen für die Storyboardziele registriert werden müssen, finden Sie unter <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Animations for content elements are less common than animations on controls, the <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> concentrates on control scenarios.</source>
          <target state="translated">Animationen für Inhaltselemente sind weniger gebräuchlich als Animationen für Steuerelemente, die <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> konzentriert sich auf Szenarien für das Steuerelement.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>The element to remove.</source>
          <target state="translated">Das zu entfernende Element.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Removes the specified element from the logical tree for this element.</source>
          <target state="translated">Entfernt das angegebene Element aus der logischen Struktur dieses Elements.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>This <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> is mainly relevant for class deriving scenarios, when adding support for child collections.</source>
          <target state="translated">Dies <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> ist hauptsächlich für die abgeleitete Klasse Szenarien beim Hinzufügen von Unterstützung für untergeordnete Sammlungen relevant.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">Die meisten <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> abgeleitete Klassen verfügbar zu machen, dedizierte Auflistungen, die für die Kapselung verantwortlich sind (z. B. <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> auf die <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> Klasse. <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> auf die <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> Klasse).</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</source>
          <target state="translated">Ableiten von dieser Klassen in der Regel kann die Notwendigkeit zur logische Struktur direkt bearbeiten vermeiden.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Gets or sets the current locally-defined resource dictionary.</source>
          <target state="translated">Ruft das aktuelle lokal definierte Ressourcenwörterbuch ab oder legt es fest.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The current locally-defined resources.</source>
          <target state="translated">Die aktuellen lokal definierten Ressourcen.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is a dictionary of resources, where resources within the dictionary are accessed by key.</source>
          <target state="translated">Dies ist ein Wörterbuch von Ressourcen, wobei auf Ressourcen innerhalb des Wörterbuchs über Schlüssel zugegriffen wird.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resource dictionaries that can be defined completely or partially in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> are typically created as a property element, and are typically on the root element for any individual page or for the application.</source>
          <target state="translated">Ressourcenwörterbücher, die vollständig oder teilweise in definierbaren <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> werden in der Regel als ein Eigenschaftenelement erstellt und sind in der Regel für das Stammelement für die einzelnen Seiten oder für die Anwendung.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</source>
          <target state="translated">Platzieren das Ressourcenwörterbuch auf dieser Ebene erleichtert es, aus der einzelnen untergeordneten Elemente auf der Seite (oder eine andere Seite, in die Anwendung Groß-/Kleinschreibung) zu suchen.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</source>
          <target state="translated">In den meisten Anwendungsszenarios wird empfohlen, Stile als Objektelemente in einem Ressourcenwörterbuch definiert werden oder als externe Ressourcen definiert werden, damit die gesamte Stilressource eigenständig sein kann (dieser Ansatz hilft separate-Designer Zuständigkeiten von Entwickleraufgaben durch die Trennung von physischen Dateien, die bearbeitet werden müssen).</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Note that this property returns only the resource dictionary declared directly within that element.</source>
          <target state="translated">Beachten Sie, dass diese Eigenschaft gibt nur das Ressourcenwörterbuch direkt in dieses Element deklariert.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</source>
          <target state="translated">Dies ist anders als die eigentliche Ressource Lookup-Prozess, in dem ein untergeordnetes Element in jedem übergeordneten Element, die Suche rekursiv nach oben definierten Ressourcen zugreifen können.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resources can also be referenced by code from within the collection, but be aware that resources created in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will definitely not be accessible until after <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> is raised by the element that declares the dictionary.</source>
          <target state="translated">Ressourcen können auch aus Code innerhalb der Auflistung verwiesen werden, aber beachten Sie, dass Ressourcen in erstellt <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> kann definitiv nicht zugegriffen werden erst nach dem <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> wird ausgelöst, indem Sie das Element, das das Wörterbuch deklariert.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In fact, resources are parsed asynchronously, and not even the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> event is an assurance that you can reference a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resource.</source>
          <target state="translated">In der Tat Ressourcen werden asynchron analysiert, und auch nicht die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> Ereignis ist eine Zusicherung, die Sie referenzieren können eine <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Ressource definiert.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For this reason you should generally only access <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resources as part of run-time code, or through other <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> techniques such as styles or resource extension references for attribute values.</source>
          <target state="translated">Aus diesem Grund sollten Sie in der Regel nur auf zugreifen <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> definierten Ressourcen als Teil des Codes zur Laufzeit oder über andere <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> Techniken z. B. Stile oder ressourcenerweiterungsparameter für Attributwerte.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>When you access resources through code, it is essentially equivalent to a  reference made from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Zugriff auf Ressourcen über Code entspricht im Wesentlichen um einen Verweis, die von <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The underlying <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> supports the methods required to add, remove, or query resources from within the collection by using code.</source>
          <target state="translated">Die zugrunde liegende <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> unterstützt die Methoden zum Hinzufügen, entfernen oder Abfragen von Ressourcen in der Auflistung mithilfe von Code erforderlich.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> Eigenschaft kann festgelegt werden, unterstützt das Szenario für die Ressourcen-Auflistung, der ein Element kann ein neues oder anderes werden vollständig zu ersetzen <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Notice that the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax shown does not include an element for the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Beachten Sie, dass die <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> gezeigte Syntax enthält kein Element für die <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</source>
          <target state="translated">Dies ist ein Beispiel für implizite Auflistungssyntax; Ein Tag, das das Auflistungselement darstellt, kann ausgelassen werden.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The elements that are added as items to the collection are specified instead.</source>
          <target state="translated">Die Elemente, die als Elemente der Auflistung hinzugefügt werden, werden stattdessen angegeben.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For more information about implicit collections and <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu impliziten Sammlungen und <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, finden Sie unter <bpt id="p1">[</bpt>XAML-Syntax im Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One case where a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Einen Fall, in dem ein <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> wird immer noch explizit angegeben, wie ein Element ist, wenn Sie ein zusammengeführtes Wörterbuch einführen, in diesem Fall stehen in der Regel keine untergeordneten Elemente für diesen <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For details, see <bpt id="p1">[</bpt>Merged Resource Dictionaries<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Ressourcenverzeichnis zusammengeführt<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Property Element Usage</source>
          <target state="translated">Verwendung von XAML-Eigenschaftenelementen</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One or more object elements, each of which defines a resource.</source>
          <target state="translated">Ein oder mehrere Objektelemente, von die jede eine Ressource definiert werden.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Each resource property element within each <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a unique value for the <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, which serves as the unique key when values are retrieved from the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Jede Ressource Property-Element innerhalb der einzelnen <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> benötigen Sie einen eindeutigen Wert für die <bpt id="p1">[</bpt>X: Key-Anweisung<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, die als eindeutiger Schlüssel fungiert, beim Abrufen der Werte aus den <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> Auflistung auf eine <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> Root-Element.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> is a typical choice because it is one of the few <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> eine normale Auswahl ist, da sie eine der wenigen ist <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> Klassen, die sinnvoll als Stammelement und Ressourcen werden im Allgemeinen gespeichert, auf der Stammebene Seite oder sogar ein noch höheres Ebenen z. B. in der Anwendung.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Attaches a binding to this element for the specified dependency property.</source>
          <target state="translated">Ordnet eine Bindung zu diesem Element für die angegebene Abhängigkeitseigenschaft zu.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Identifies the bound property.</source>
          <target state="translated">Bezeichnet die gebundene Eigenschaft.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The source property name or the path to the property used for the binding.</source>
          <target state="translated">Der Name der Quelleigenschaft oder der Pfad zu der für die Bindung verwendeten Eigenschaft.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</source>
          <target state="translated">Fügt auf der Grundlage des bereitgestellten Namens der Quelleigenschaft als Pfadangabe zur Datenquelle eine Bindung an dieses Element an.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Zeichnet die Bedingungen der Bindung auf.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, and creates a new <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> based on the provided <ph id="ph4">`path`</ph> parameter.</source>
          <target state="translated">Diese Methode ist eine bequeme Methode zum Aufrufen <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, wiederum übergibt die aktuelle Instanz als der <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, und erstellt einen neuen <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> auf Grundlage der bereitgestellten <ph id="ph4">`path`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This signature is more convenient if you are establishing a simple default binding.</source>
          <target state="translated">Diese Signatur ist einfacher, wenn Sie eine einfache standardbindung herstellen.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>If you need to specify any binding properties to non-default conditions, or want to use a <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>,you should use the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> signature.</source>
          <target state="translated">Wenn Sie müssen Bindungseigenschaften nicht standardmäßige Bedingungen angeben, oder verwenden möchten eine <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> oder <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, verwenden Sie die <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> Signatur.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">Im folgenden Beispiel wird eine Bindung auf einen <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Element, durch das Erstellen eines neuen benutzerdefinierten Daten-Objekts, das Objekt als herstellen <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, und den Bindungspfad auf eine Eigenschaft darin festlegen.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Identifies the bound property.</source>
          <target state="translated">Bezeichnet die gebundene Eigenschaft.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Represents a data binding.</source>
          <target state="translated">Stellt eine Datenbindung dar.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Attaches a binding to this element, based on the provided binding object.</source>
          <target state="translated">Fügt auf der Grundlage des bereitgestellten Bindungsobjekts eine Bindung an dieses Element an.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Zeichnet die Bedingungen der Bindung auf.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine bequeme Methode zum Aufrufen <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, die die aktuelle Instanz als übergibt die <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> and setting the source to a newly built <ph id="ph3">`DateTime`</ph> object.</source>
          <target state="translated">Im folgenden Beispiel wird eine Bindung auf einen <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Element, durch Erstellen eines neuen <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> und indem Sie die Quelle ein neu erstelltes <ph id="ph3">`DateTime`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The property to which the resource is bound.</source>
          <target state="translated">Die Eigenschaft, an die die Ressource gebunden ist.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The name of the resource.</source>
          <target state="translated">Der Name der Ressource.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</source>
          <target state="translated">Sucht eine Ressource mit dem angegebenen Namen und richtet einen entsprechenden Ressourcenverweis für die angegebene Eigenschaft ein.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>A resource reference is similar to the use of a <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> in markup.</source>
          <target state="translated">Ein Ressourcenverweis ist vergleichbar mit der Verwendung von einem <bpt id="p1">[</bpt>DynamicResource Markuperweiterung<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> im Markup.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</source>
          <target state="translated">Der Ressourcenverweis erstellt einen internen Ausdruck, der den Wert der angegebenen Eigenschaft für zurückgestellten zur Laufzeit bereitstellt.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</source>
          <target state="translated">Der Ausdruck wird erneut ausgewertet werden, immer das Ressourcenwörterbuch geänderte Wert über interne Ereignisse gibt an, oder, wenn das aktuelle Element erneut übergeordnet ist (eine Änderung des übergeordneten würde das Wörterbuch Suche Pfad ändern).</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Gibt zurück, ob in Serialisierungsprozessen der Inhalt der <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph>-Eigenschaft für Instanzen dieser Klasse serialisiert werden soll.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph>-Eigenschaftswert serialisiert werden soll, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>This will return <ph id="ph1">`true`</ph> so long as there is at least one keyed resource in the local <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</source>
          <target state="translated">Dieser Befehl zurück <ph id="ph1">`true`</ph> solange es mindestens eine Ressource in der lokalen ist <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Gibt zurück, ob in Serialisierungsprozessen der Inhalt der <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph>-Eigenschaft für Instanzen dieser Klasse serialisiert werden soll.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph>-Eigenschaftswert serialisiert werden soll, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>This will return <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> is locally set.</source>
          <target state="translated">Dieser Befehl zurück <ph id="ph1">`true`</ph> Wenn die <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> lokal festgelegt ist.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>Occurs when any associated data source participating in a binding on this element changes.</source>
          <target state="translated">Tritt ein, wenn sich eine zugeordnete Datenquelle, die an einer Bindung dieses Elements teilnimmt, ändert.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Dieses Ereignis begleitet die <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> Ereignis, das ausgelöst wird, von einer <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> mit diesem Element verknüpft sind.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Gets or sets the style to be used by this element.</source>
          <target state="translated">Ruft den Stil ab, der von diesem Element verwendet werden soll, oder legt ihn fest.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The applied, nondefault style for the element, if present.</source>
          <target state="translated">Der übernommene und nicht dem Standardstil entsprechende Stil für das Element, wenn ein Stil vorhanden ist.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The default for a default-constructed <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert für ein mit den Standardwerten konstruiertes <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</source>
          <target state="translated">Das aktuelle Format wird häufig von einem Standardformat aus Designumgebung oder Formatvorlagen, die in der Regel auf Objekte dieses Typs angewendet, indem Ressourcen auf Seiten- oder Anwendungsebene (ein impliziter Stil) bereitgestellt.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</source>
          <target state="translated">Diese Eigenschaft ist nicht festgelegt oder return-Standard (Designformatvorlagen), aber es gibt zurück, die implizite oder explizite Stil.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</source>
          <target state="translated">Bei impliziten oder expliziten Stilen spielt es keine, ob das Format als Ressource zugegriffen oder lokal definiert ist.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Setting the styles has some restrictions.</source>
          <target state="translated">Das Festlegen von den Formaten bestehen einige Einschränkungen.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>You can reset the entire <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property to a new <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> at any time, which will force a layout recomposition.</source>
          <target state="translated">Sie können die gesamte zurücksetzen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> Eigenschaft, um ein neues <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> erzwingt die zu irgendeinem Zeitpunkt ein Layout zurücksetzen.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>However, as soon as that style is placed in use by a loaded element, the <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> should be considered sealed.</source>
          <target state="translated">Jedoch so bald wie diesem Format verwendet von einem geladenen Element platziert wird die <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> angesehen wird, versiegelt.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) causes an exception to be thrown.</source>
          <target state="translated">Bei dem Versuch, eine einzelne Eigenschaft eines Stils in Gebrauch ändern (z. B. alle Elemente in der Auflistung der <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) bewirkt, dass eine Ausnahme ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</source>
          <target state="translated">Ein Format, das im Markup definierte gilt verwendet werden, sobald dies aus einem Ressourcenwörterbuch (für Ressourcen erfolgt) oder die Seite enthalten ist (für Inlineformatvorlagen) geladen ist.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is a dependency property with special precedence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> ist eine Abhängigkeitseigenschaft mit besonderer Rangfolge.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The locally set style generally operates at the highest precedence in the property system.</source>
          <target state="translated">Der lokal festgelegten Stil mit der höchsten Priorität in der Regel im Eigenschaftensystem arbeitet.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> null festgelegt ist, wird beim Laden der Eigenschaft wird überprüft, ob impliziten Stilen als definierten Ressourcen, die diesen Typ angeben.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property value.</source>
          <target state="translated">Wenn das Format immer noch null nach diesem Schritt ist wird der Stil ergibt sich aus den Standardstil (Design), jedoch das Standardformat nicht, in zurückgegeben wird der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> Eigenschaftswert.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>One of the following: , or .</source>
          <target state="translated">Eines der folgenden:, oder.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>XAML-Ressourcen<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">Der Schlüssel, der den angeforderten Stil identifiziert.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Der Schlüssel verweist auf eine vorhandene Ressource in einem <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Eigenschaftenelementsyntax ist technisch zwar möglich, aber nicht empfehlenswert.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>Inlinestile und Vorlagen<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Eine Bindung verwendet oder <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> ist auch möglich, aber ungewöhnlich.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element and then references it as a resource as a specific style for a <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> Auflistung auf eine <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> "Root"-Element und anschließend darauf verweist, als Ressource für ein bestimmtes Format für einen <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.StyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>The name of the requested ambient property.</source>
          <target state="translated">Der Name der angeforderten Ambient-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>For a description of this member, see the <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> method.</source>
          <target state="translated">Eine Beschreibung dieses Members finden Sie unter der <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> is available; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> verfügbar ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Gets or sets an arbitrary object value that can be used to store custom information about this element.</source>
          <target state="translated">Ruft einen beliebigen Objektwert ab, der zum Speichern von benutzerdefinierten Informationen zu diesem Element verwendet werden kann, bzw. legt diesen fest.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>The intended value.</source>
          <target state="translated">Der vorgesehene Wert.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property has no default value.</source>
          <target state="translated">Diese Eigenschaft hat keinen Standardwert.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</source>
          <target state="translated">Diese Eigenschaft ist analog zu Eigenschaften von Tags in anderen Microsoft-Programmiermodelle, z. B. Visual Basic for Applications oder Windows Forms.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</source>
          <target state="translated">Es soll einen bereits vorhandenen Ort zum Speichern von einige grundlegende benutzerdefinierte Informationen über jedes Element, ohne dass Anwendungsentwickler Unterklasse verfügbar zu machen.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Because this property takes an object, you need to use the property element usage in order to set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</source>
          <target state="translated">Da diese Eigenschaft ein Objekt akzeptiert, müssen Sie die Verwendung des Elements verwenden, um festzulegen der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> Eigenschaft in XAML zu etwas anderes als ein Objekt mit einem bekannten und integrierten Typkonverter, z. B. eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</source>
          <target state="translated">Objekte, die auf diese Weise verwendet sind nicht in der Regel innerhalb der standard-WPF-Namespaces und erfordern daher möglicherweise Namespacezuordnung für den externen Namespace um als XAML-Elementen eingeführt werden.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>None</source>
          <target state="translated">Keiner</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.TagProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>Occurs when any associated target property participating in a binding on this element changes.</source>
          <target state="translated">Tritt auf, wenn eine zugeordnete Zieleigenschaft, die Teil einer Bindung dieses Elements ist, geändert wird.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Dieses Ereignis begleitet die <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> Ereignis, das ausgelöst wird, von einer <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> mit diesem Element verknüpft sind.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</source>
          <target state="translated">Dies bedeutet normalerweise, dass die betreffende Bindung eine bidirektionale Bindung ist und dass die gebundene Abhängigkeitseigenschaft bestätigt eine Ungültigkeit des Werts der vorherigen pro eine Überprüfung oder dem Schema, das die Eigenschaft unterstützt.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>The event arguments of this event will inform you which bound property was changed.</source>
          <target state="translated">Die Ereignisargumente dieses Ereignisses informiert, dass Sie die gebundene Eigenschaft geändert wurde.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Gets a reference to the template parent of this element.</source>
          <target state="translated">Ruft einen Verweis auf die übergeordnete Vorlage dieses Elements ab.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This property is not relevant if the element was not created through a template.</source>
          <target state="translated">Diese Eigenschaft ist nicht relevant, wenn das Element nicht durch eine Vorlage erstellt wurde.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>The element whose <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> caused this element to be created.</source>
          <target state="translated">Das Element, dessen <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph> <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> verursacht dieses Element erstellt werden soll.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This value is frequently <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Wert ist häufig <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Templates are actually shared objects, where the contents of the template are created only once.</source>
          <target state="translated">Vorlagen sind eigentlich freigegebene Objekte, in dem der Inhalt der Vorlage nur einmal erstellt werden.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</source>
          <target state="translated">Aus diesem Grund, wenn Sie einen Objektverweis auf ein Element, die aus einer Vorlage abrufen, können Sie feststellen, dass die offensichtliche logische Struktur nicht in das Stammverzeichnis Seite erreicht.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>In order to connect such a template reference to the page's logical tree, you should get the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> value and continue to navigate that element tree as desired.</source>
          <target state="translated">Um einen solchen Vorlage Verweis auf die Seite logische Struktur eine Verbindung herzustellen, erhalten Sie die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> -Wert und den Vorgang fortzusetzen, um die Navigation durch die Elementstruktur nach Bedarf.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> will frequently be <ph id="ph2">`null`</ph> for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> Häufig werden <ph id="ph2">`null`</ph> für gemeinsame Objekte, da Sie einen Objektverweis aus einer Seite in der Anwendung erhalten haben, dieses Element möglicherweise nicht aus einer Vorlage erstellt wurde.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> might not be <ph id="ph2">`null`</ph> would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</source>
          <target state="translated">Fälle, in denen <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> möglicherweise nicht <ph id="ph2">`null`</ph> zählen Vorgänge wie das Ereignis Treffertests, für bestimmte Eingabeereignisse Behandlung von oder Arbeiten mit Enumeratoren, die möglicherweise von Vorlagen stammt Elemente zurückgegeben.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Gets or sets the tool-tip object that is displayed for this element in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Ruft das QuickInfo-Objekt ab, das für dieses Element in der <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> angezeigt wird, oder legt dieses Objekt fest.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The tooltip object.</source>
          <target state="translated">Das QuickInfo-Objekt.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value of this property is of type <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, then that is the tool-tip that will be used in the <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Wenn der Wert dieser Eigenschaft vom Typ <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, klicken Sie dann die QuickInfo, die in verwendet werden, also die <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value is of any other type, then that value will be used as the <bpt id="p1">*</bpt>content<ept id="p1">*</ept> for a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> provided (constructed) by the system.</source>
          <target state="translated">Wenn der Wert eines anderen Typs ist, wird dieser Wert verwendet werden die <bpt id="p1">*</bpt>Inhalt<ept id="p1">*</ept> für eine <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> bereitgestellt (erstellt), vom System.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>For more information see <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The service class provides attached properties that can be used to further customize a tool-tip.</source>
          <target state="translated">Die Dienstklasse enthält angefügte Eigenschaften, die verwendet werden können, um eine QuickInfo weiter anpassen.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Attribute Usage</source>
          <target state="translated">Verwendung von XAML-Attributen</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Property Element Usage</source>
          <target state="translated">Verwendung von XAML-Eigenschaftenelementen</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Values</source>
          <target state="translated">XAML-Werte</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>A string that becomes the display text for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</source>
          <target state="translated">Eine Zeichenfolge, die den Anzeigetext für wird die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Some object, provided in object element form, that should be used as the content for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</source>
          <target state="translated">Ein Objekt, das in Objektelementform, das als Inhalt für die zu verwendende bereitgestellten der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Typically this would be a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or some other element that creates layout compositing for the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, eventually containing text content within the compositing.</source>
          <target state="translated">In der Regel wäre dies eine <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> oder ein anderes Element, das Layout für die Zusammensetzung der <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, letztendlich mit Textinhalt in der Zusammensetzung.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>In this usage, the <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> element is created implicitly from the parsed <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, and the <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> content is set as its <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Bei dieser Verwendung der <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> Element erstellt implizit aus dem analysierten <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, und die <bpt id="p1">*</bpt>ToolTipObjectContent<ept id="p1">*</ept> Inhalt festgelegt ist, als die <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</source>
          <target state="translated"><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> … / &gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Dependency Property Information</source>
          <target state="translated">Informationen zur Abhängigkeitseigenschaft</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Metadaten-Eigenschaften festgelegt auf. <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>None</source>
          <target state="translated">Keiner</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The following example sets the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property directly to a string.</source>
          <target state="translated">Im folgenden Beispiel wird den Wert, der die <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> Eigenschaft direkt in eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Occurs just before any tooltip on the element is closed.</source>
          <target state="translated">Tritt unmittelbar vor dem Schließen einer QuickInfo über dem Element ein.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>To suppress closing the tooltip, handlers of the event should mark it as handled.</source>
          <target state="translated">Zum Schließen der QuickInfo zu unterdrücken, sollte der Handler des Ereignisses es als behandelt markiert.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Dieses Ereignis nicht mit einem <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in einem Format.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">Dies ist, da die Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst erneut verwendet, die keine hinzufügen/entfernen-Methoden für das Ereignis verfügbar macht.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routed Event Information</source>
          <target state="translated">Informationen zum Routingereignis</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routing strategy</source>
          <target state="translated">Routing-Strategie</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Direct</source>
          <target state="translated">Direkt</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Übersicht über Routingereignisse<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Ereignis-ID-Objekte werden erstellt, wenn Routingereignisse registriert werden (finden Sie unter <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) und kann dann verwendet werden, um Klassenhandler hinzuzufügen (finden Sie unter <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Bezeichnerobjekte enthalten einen kennzeichnenden Namen, Besitzertyp, Handlertyp, Routingstrategie und eine Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Occurs when any tooltip on the element is opened.</source>
          <target state="translated">Tritt beim Öffnen einer QuickInfo im Element auf.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>To manually open tooltips, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Zum manuellen Öffnen des QuickInfos kennzeichnen Handler für die Ereignisse das betreffende Ereignis als behandelt.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Otherwise, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">Andernfalls den Wert der <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> Eigenschaft wird verwendet, um automatisch ein Kontextmenü geöffnet.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Das Ereignis als behandelt markiert wird die Standardaktion tatsächlich abgebrochen, und möglicherweise Gelegenheit, den Wert zurückgesetzt, die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> Eigenschaft, und öffnen Sie die neue <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Note that this event will not be raised if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> is a null reference or otherwise unset.</source>
          <target state="translated">Beachten Sie, dass dieses Ereignis nicht ausgelöst, wird Wenn <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> ist ein null-Verweis oder auf andere Weise nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Dieses Ereignis nicht mit einem <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in einem Format.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">Dies ist, da die Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst erneut verwendet, die keine hinzufügen/entfernen-Methoden für das Ereignis verfügbar macht.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routed Event Information</source>
          <target state="translated">Informationen zum Routingereignis</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routing strategy</source>
          <target state="translated">Routing-Strategie</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Direct</source>
          <target state="translated">Direkt</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Übersicht über Routingereignisse<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Ereignis-ID-Objekte werden erstellt, wenn Routingereignisse registriert werden (finden Sie unter <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) und kann dann verwendet werden, um Klassenhandler hinzuzufügen (finden Sie unter <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Bezeichnerobjekte enthalten einen kennzeichnenden Namen, Besitzertyp, Handlertyp, Routingstrategie und eine Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> dependency property.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph>-Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">Der Schlüsselbezeichner der zu findenden Ressource.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Searches for a resource with the specified key, and returns that resource if found.</source>
          <target state="translated">Sucht nach einer Ressource mit dem angegebenen Schlüssel und gibt diese Ressource zurück, sofern sie gefunden wurde.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The found resource.</source>
          <target state="translated">Die gefundene Ressource.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If no resource was found, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn keine Ressource gefunden wurde, wird <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</source>
          <target state="translated">Wenn die Ressource für das aufrufende Element nicht gefunden wird, ist die übergeordnete Struktur die gleiche Weise, die die Struktur die logische Struktur durchsucht durchsucht, wenn der Schlüssel zur Laufzeit ein dynamischen Ressourcenverweis angefordert wurden.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">In der Regel würden Sie sofort den Rückgabewert in den Typ der Eigenschaft umgewandelt, den Sie mit den zurückgegebenen Ressourcenwert festgelegt wurden.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> Methode verhält sich ähnlich, außer dass Sie zu einer Ausnahme im Fall von keine Ressource mit dem angegebenen Schlüssel gefunden wird.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">Das folgende Beispiel sucht nach einer Ressource, wie im Markup definierte und wendet sie auf eine bestimmte Eigenschaft eines Elements in Reaktion auf ein Routingereignis.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Occurs when the element is removed from an element tree of loaded elements.</source>
          <target state="translated">Tritt ein, wenn das Element aus einer Elementstruktur geladener Elemente entfernt wird.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">Direkte Routingereignisse führen Sie eine Route nicht ausgeführt, sie sind nur innerhalb des gleichen Elements in dem sie ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Direkte Routingereignisse unterstützen andere Verhalten Routingereignis: sie unterstützen eine Auflistung zugegriffen werden kann, Handler und dient als ein <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in einem Format.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routed Event Information</source>
          <target state="translated">Informationen zum Routingereignis</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Identifier field</source>
          <target state="translated">Bezeichnerfeld</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routing strategy</source>
          <target state="translated">Routing-Strategie</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct</source>
          <target state="translated">Direkt</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Bezeichnet die <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Übersicht über Routingereignisse<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Ereignis-ID-Objekte werden erstellt, wenn Routingereignisse registriert werden (finden Sie unter <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) und kann dann verwendet werden, um Klassenhandler hinzuzufügen (finden Sie unter <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Bezeichnerobjekte enthalten einen kennzeichnenden Namen, Besitzertyp, Handlertyp, Routingstrategie und eine Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Name of the name-object pair to remove from the current scope.</source>
          <target state="translated">Der Name des Name/Objekt-Paars, der aus dem aktuellen Bereich entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> de-registration method.</source>
          <target state="translated">Vereinfacht den Zugriff auf die <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>-Methode zum Aufheben der Registrierung.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>You only need to un-register names if you intend to re-register another element with that same name.</source>
          <target state="translated">Sie müssen nur zum Aufheben der Registrierung Namen, wenn Sie beabsichtigen, ein anderes Element mit demselben Namen erneut zu registrieren.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle">
          <source>Reapplies the default style to the current <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Wendet erneut den Standardstil auf den aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> an.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>