<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6cabf0226e5328d882a648978aa80fc000a7a9ad" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86985061" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface ISupportInitialize&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.RuntimeNameProperty("Name")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.RuntimeNameProperty("Name")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Windows.Markup.UsableDuringInitialization(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.UsableDuringInitialization(true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.XmlLangProperty("Language")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.XmlLangProperty("Language")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="156f2-101"><see cref="T:System.Windows.FrameworkContentElement" /> stellt die Implementierung auf WPF-Frameworkebene und die Erweiterung der <see cref="T:System.Windows.ContentElement" />-Basisklasse dar.</span><span class="sxs-lookup"><span data-stu-id="156f2-101"><see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span></span> <span data-ttu-id="156f2-102"><see cref="T:System.Windows.FrameworkContentElement" /> bietet Unterstützung für zusätzliche Eingabe-APIs (einschließlich QuickInfos und Kontextmenüs), Storyboards, Datenkontexte für die Datenbindung, Formatvorlagen und APIs für Hilfsprogramme für logische Strukturen.</span><span class="sxs-lookup"><span data-stu-id="156f2-102"><see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-103"><xref:System.Windows.FrameworkContentElement> definiert noch kein eigenes Renderingverhalten. das Instanziieren einer tatsächlichen <xref:System.Windows.FrameworkContentElement> Klasseninstanz im Code oder Markup ist möglich, zeigt jedoch nichts in einer- [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendung an [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="156f2-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="156f2-104">Renderinglogik muss von Klassen bereitgestellt werden, die untergeordnete <xref:System.Windows.FrameworkContentElement> Elemente als Teil ihres Inhalts Modells oder in <xref:System.Windows.FrameworkContentElement> abgeleiteten Klassen akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="156f2-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="156f2-105"><xref:System.Windows.FrameworkContentElement> gibt absichtlich eine parallele Beziehung zu vielen der gleichen APIs wie <xref:System.Windows.FrameworkElement> .</span><span class="sxs-lookup"><span data-stu-id="156f2-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same APIs as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="156f2-106">Beachten Sie, dass bestimmte APIs, die auf gefunden <xref:System.Windows.FrameworkElement> werden, nicht <xref:System.Windows.FrameworkContentElement> gleichwertig sind.</span><span class="sxs-lookup"><span data-stu-id="156f2-106">Note that certain APIs found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="156f2-107">Einige der <xref:System.Windows.FrameworkElement> APIs sind für Funktionen wie die Geometrie Darstellung oder das Layout vorgesehen, die für nicht relevant sind <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="156f2-107">Several of the <xref:System.Windows.FrameworkElement> APIs are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="156f2-108">Die Mehrzahl vorhandener <xref:System.Windows.FrameworkContentElement> abgeleiteter Klassen finden Sie im- <xref:System.Windows.Documents> Namespace.</span><span class="sxs-lookup"><span data-stu-id="156f2-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="156f2-109">Viele dieser abgeleiteten Klassen implementieren Elemente für das Fluss Dokument Modell.</span><span class="sxs-lookup"><span data-stu-id="156f2-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="156f2-110">Bestimmte abgeleitete Klassen, wie z. b. <xref:System.Windows.Documents.Hyperlink> , verfügen über einige Steuerelement ähnliche Funktionen, werden jedoch von so abgeleitet, <xref:System.Windows.FrameworkContentElement> dass die Steuerelement ähnlichen Elemente weiterhin am Fluss Dokument Modell teilnehmen können.</span><span class="sxs-lookup"><span data-stu-id="156f2-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-111">Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkContentElement" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="156f2-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="156f2-112">Das untergeordnete Element, das hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-112">The child element to be added.</span></span></param>
        <summary><span data-ttu-id="156f2-113">Fügt das bereitgestellte Element als untergeordnetes Element dieses Elements hinzu.</span><span class="sxs-lookup"><span data-stu-id="156f2-113">Adds the provided element as a child of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-114">Diese Methode kann eine Ausnahme auslösen, wenn Sie zu einem Zeitpunkt aufgerufen wird, wenn die logische Struktur von einem anderen Prozess durchlaufen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="156f2-115">Die meisten <xref:System.Windows.FrameworkContentElement> abgeleiteten Klassen machen dedizierte Auflistungen verfügbar, die für die Kapselung verantwortlich sind (z <xref:System.Windows.Documents.Span.Inlines%2A> . b. für die- <xref:System.Windows.Documents.Span> Klasse <xref:System.Windows.Documents.Section.Blocks%2A> <xref:System.Windows.Documents.Section> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="156f2-116">Sie können in der Regel vermeiden, dass Sie die logische Struktur direkt bearbeiten müssen, wenn Sie stattdessen von diesen Klassen ableiten.</span><span class="sxs-lookup"><span data-stu-id="156f2-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="156f2-117">Das Arbeiten mit der logischen Struktur für Inhaltselemente ist ein erweitertes Szenario, das möglicherweise einen spezialisierten Parser oder einen spezialisierten Parser erfordert <xref:System.Windows.FrameworkElement> , der als übergeordnetes renderingelement (Inhalts Host) fungiert.</span><span class="sxs-lookup"><span data-stu-id="156f2-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="156f2-118">Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> und finden Sie <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A> Unterstrukturen [in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="156f2-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-119">Wird aufgerufen, bevor ein Element initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-119">Called before an element is initialized.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="156f2-120">Überschreiben Sie diese Methode, um eine spezielle Verarbeitung bereitzustellen, die vor dem Initialisieren des Elements während des Ladevorgangs des Elements erfolgen sollte.</span><span class="sxs-lookup"><span data-stu-id="156f2-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span></span>  
  
<span data-ttu-id="156f2-121">Ihre Implementierung sollte die Basis Implementierung aufzurufen, da die Basis Implementierung (Standard) einige interne Flags festlegt, um die Initialisierung nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="156f2-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
<span data-ttu-id="156f2-122">Die Basis Implementierung löst eine Ausnahme <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> aus, wenn mehr als einmal für das gleiche Element vor dem erreichen von aufgerufen wird <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> .</span><span class="sxs-lookup"><span data-stu-id="156f2-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="156f2-123">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-123">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="156f2-124">Das zu startende Storyboard.</span><span class="sxs-lookup"><span data-stu-id="156f2-124">The storyboard to begin.</span></span></param>
        <summary><span data-ttu-id="156f2-125">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-125">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-126">Bei den Signaturen, die den-Parameter, den-Parameter oder den-Parameter nicht verwenden, `isControllable` `false` werden die der Animation zugeordneten Zeitachsen Uhren entfernt, sobald der "Fill"-Zeitraum erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="156f2-127">Daher kann die Animation nicht neu gestartet werden, nachdem Sie einmal ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="156f2-128">Beachten Sie, dass das Steuern einer Animation auch erfordert, dass das Storyboard als eine Instanz im Code benannt oder zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="156f2-129">Das zu startende Storyboard.</span><span class="sxs-lookup"><span data-stu-id="156f2-129">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="156f2-130">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span></span></param>
        <summary><span data-ttu-id="156f2-131">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist. Die angegebenen Optionen legen fest, welche Aktion ausgeführt werden soll, wenn die Eigenschaft bereits animiert ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-132">Bei den Signaturen, die den-Parameter, den-Parameter oder den-Parameter nicht verwenden, `isControllable` `false` werden die der Animation zugeordneten Zeitachsen Uhren entfernt, sobald der "Fill"-Zeitraum erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="156f2-133">Daher kann die Animation nicht neu gestartet werden, nachdem Sie einmal ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="156f2-134">Beachten Sie, dass das Steuern einer Animation auch erfordert, dass das Storyboard als eine Instanz im Code benannt oder zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="156f2-135">Verwenden von Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="156f2-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="156f2-136">Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt die Uhren nicht automatisch.</span><span class="sxs-lookup"><span data-stu-id="156f2-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="156f2-137">Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden.</span><span class="sxs-lookup"><span data-stu-id="156f2-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="156f2-138">Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:</span><span class="sxs-lookup"><span data-stu-id="156f2-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="156f2-139">Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts.</span><span class="sxs-lookup"><span data-stu-id="156f2-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="156f2-140">Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an.</span><span class="sxs-lookup"><span data-stu-id="156f2-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="156f2-141">Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.</span><span class="sxs-lookup"><span data-stu-id="156f2-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="156f2-142">Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> .</span><span class="sxs-lookup"><span data-stu-id="156f2-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="156f2-143">Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr.</span><span class="sxs-lookup"><span data-stu-id="156f2-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="156f2-144">Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` .</span><span class="sxs-lookup"><span data-stu-id="156f2-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="156f2-145">Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht ausgelöst wird, wenn die effektive Dauer der Uhr ewig ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="156f2-146">In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="156f2-147">Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.</span><span class="sxs-lookup"><span data-stu-id="156f2-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="156f2-148">Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.</span><span class="sxs-lookup"><span data-stu-id="156f2-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="156f2-149">Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-149">For more information about clock objects, see [Animation and Timing System Overview](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="156f2-150">Das zu startende Storyboard.</span><span class="sxs-lookup"><span data-stu-id="156f2-150">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="156f2-151">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span></span></param>
        <param name="isControllable"><span data-ttu-id="156f2-152">Bestimmt, ob die Animation steuerbar ist (angehalten werden kann), nachdem sie gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-152">Declares whether the animation is controllable (can be paused) after it is started.</span></span></param>
        <summary><span data-ttu-id="156f2-153">Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist, im angegebenen Zustand für das Steuerelement der Animation nach deren Start.</span><span class="sxs-lookup"><span data-stu-id="156f2-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-154">Bei den Signaturen, die den-Parameter, den-Parameter oder den-Parameter nicht verwenden, `isControllable` `false` werden die der Animation zugeordneten Zeitachsen Uhren entfernt, sobald der "Fill"-Zeitraum erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="156f2-155">Daher kann die Animation nicht neu gestartet werden, nachdem Sie einmal ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="156f2-156">Beachten Sie, dass das Steuern einer Animation auch erfordert, dass das Storyboard als eine Instanz im Code benannt oder zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="156f2-157">Verwenden von Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="156f2-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="156f2-158">Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt diese Uhren nicht automatisch.</span><span class="sxs-lookup"><span data-stu-id="156f2-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="156f2-159">Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden.</span><span class="sxs-lookup"><span data-stu-id="156f2-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="156f2-160">Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:</span><span class="sxs-lookup"><span data-stu-id="156f2-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="156f2-161">Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts.</span><span class="sxs-lookup"><span data-stu-id="156f2-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="156f2-162">Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an.</span><span class="sxs-lookup"><span data-stu-id="156f2-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="156f2-163">Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.</span><span class="sxs-lookup"><span data-stu-id="156f2-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="156f2-164">Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> .</span><span class="sxs-lookup"><span data-stu-id="156f2-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="156f2-165">Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr.</span><span class="sxs-lookup"><span data-stu-id="156f2-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="156f2-166">Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` .</span><span class="sxs-lookup"><span data-stu-id="156f2-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="156f2-167">Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht ausgelöst wird, wenn die effektive Dauer der Uhr ewig ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="156f2-168">In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="156f2-169">Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.</span><span class="sxs-lookup"><span data-stu-id="156f2-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="156f2-170">Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.</span><span class="sxs-lookup"><span data-stu-id="156f2-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="156f2-171">Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-171">For more information about clock objects, see [Animation and Timing System Overview](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-172">Ruft die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" /> ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></summary>
        <value><span data-ttu-id="156f2-173">Die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-174"><xref:System.Windows.Data.BindingGroup>Kann verwendet werden, um die Werte mehrerer Eigenschaften eines Objekts zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="156f2-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="156f2-175">Angenommen, eine Anwendung fordert den Benutzer auf, eine Adresse einzugeben, und füllt dann ein Objekt vom Typ `Address` mit den Eigenschaften `Street` , `City` , `ZipCode` und `Country` mit den vom Benutzer bereitgestellten Werten.</span><span class="sxs-lookup"><span data-stu-id="156f2-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="156f2-176">Die Anwendung verfügt über einen Bereich, der vier Steuer <xref:System.Windows.Controls.TextBox> Elemente enthält, von denen jede an eine der Eigenschaften des Objekts gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object's properties.</span></span> <span data-ttu-id="156f2-177">Sie können einen <xref:System.Windows.Controls.ValidationRule> in einem verwenden <xref:System.Windows.Data.BindingGroup> , um das Objekt zu validieren `Address` .</span><span class="sxs-lookup"><span data-stu-id="156f2-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="156f2-178">So kann beispielsweise <xref:System.Windows.Controls.ValidationRule> sichergestellt werden, dass die Postleitzahl für das Land/die Region der Adresse gültig ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country/region of the address.</span></span>  
  
 <span data-ttu-id="156f2-179">Untergeordnete Elemente erben die <xref:System.Windows.Data.BindingGroup> von ihren übergeordneten Elementen, ebenso wie jede andere vererbbare Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-180">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-181">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="156f2-182">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-182">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-183">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-184">Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-185">Durch Aufrufen dieser Methode rufen Sie effektiv <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> für jeden übergeordneten scrollfähigen Bereich auf, der das Element enthält (das übergeordnete Element ist möglicherweise sehr gut <xref:System.Windows.FrameworkElement> , nicht ein <xref:System.Windows.FrameworkContentElement> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="156f2-186">Wenn dieses Element nicht in einem Bild lauffähigen Bereich enthalten ist, wird das Ereignis immer noch ausgelöst, aber es gibt keine Auswirkung.</span><span class="sxs-lookup"><span data-stu-id="156f2-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)"><span data-ttu-id="156f2-187">Gewusst wie: Erstellen eines ScrollViewer</span><span class="sxs-lookup"><span data-stu-id="156f2-187">How to: Create a ScrollViewer</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-188">Ruft das Kontextmenüelement ab, das angezeigt werden soll, wenn das Kontextmenü in diesem Element über die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] angefordert wird, oder legt das Element fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-188">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span></span></summary>
        <value><span data-ttu-id="156f2-189">Das Kontextmenü, das dieses Element verwendet.</span><span class="sxs-lookup"><span data-stu-id="156f2-189">The context menu that this element uses.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-190">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-190">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-191">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-191">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="156f2-192">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-192">Metadata properties set to `true`</span></span>|<span data-ttu-id="156f2-193">Keine</span><span class="sxs-lookup"><span data-stu-id="156f2-193">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-194">Im folgenden Beispiel wird ein <xref:System.Windows.Controls.ContextMenu> für einen platziert <xref:System.Windows.Documents.Paragraph> .</span><span class="sxs-lookup"><span data-stu-id="156f2-194">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-195">Tritt unmittelbar vor dem Schließen eines Kontextmenüs für ein Element auf.</span><span class="sxs-lookup"><span data-stu-id="156f2-195">Occurs just before any context menu on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-196">Um das Schließen von Kontextmenüs zu unterdrücken, sollten Handler des Ereignisses ihn als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="156f2-196">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="156f2-197">Um dieses Ereignis als <xref:System.Windows.EventTrigger> in einem Stil zu verwenden, müssen Sie auf den zugrunde liegenden Dienst Ereignis Bezeichner verweisen:</span><span class="sxs-lookup"><span data-stu-id="156f2-197">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="156f2-198">(Diese Verwendung ist erforderlich, da die Ereignis Implementierung von <xref:System.Windows.FrameworkContentElement> , die das zugrunde liegende Dienst Ereignis verfügbar macht, den Bezeichner nicht ordnungsgemäß <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> für die Verwendung in Triggern zuordnet).</span><span class="sxs-lookup"><span data-stu-id="156f2-198">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="156f2-199">Informationen zum Routingereignis</span><span class="sxs-lookup"><span data-stu-id="156f2-199">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-200">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-200">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="156f2-201">Routing Strategie</span><span class="sxs-lookup"><span data-stu-id="156f2-201">Routing strategy</span></span>|<span data-ttu-id="156f2-202">Blasen</span><span class="sxs-lookup"><span data-stu-id="156f2-202">Bubbling</span></span>|  
|<span data-ttu-id="156f2-203">Delegat</span><span class="sxs-lookup"><span data-stu-id="156f2-203">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-204">Im folgenden Beispiel wird ein Handler implementiert, der den Cursor über einen benannten Bereich ändert `DisplayArea` (nicht dargestellt).</span><span class="sxs-lookup"><span data-stu-id="156f2-204">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="156f2-205">Der Kommentar deutet auf eine <xref:System.Windows.UIElement> Verwendung hin, aber tatsächlich wäre dieses Beispiel identisch, wenn `DisplayArea` ein wäre <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="156f2-205">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-206">Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Übersicht über Routingereignisse](/dotnet/framework/wpf/advanced/routed-events-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-206">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-207">Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-207">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="156f2-208">Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-208">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-209">Tritt ein, wenn ein Kontextmenü des Elements geöffnet wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-209">Occurs when any context menu on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-210">Um Kontextmenüs manuell zu öffnen, sollten die Handler der Ereignisse das relevante Ereignis als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="156f2-210">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="156f2-211">Andernfalls wird der vorhandene Wert der- <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Eigenschaft verwendet, um automatisch ein Kontextmenü zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="156f2-211">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="156f2-212">Wenn das Ereignis behandelt wird, wird die Standardaktion effektiv abgebrochen, und es kann eine Gelegenheit sein, den Wert der Eigenschaft zurückzusetzen <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> und dann die neue zu öffnen <xref:System.Windows.Controls.ContextMenu> .</span><span class="sxs-lookup"><span data-stu-id="156f2-212">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="156f2-213">Es gibt jedoch ein Problem mit der zeitlichen Steuerung, das Sie kennen sollten.</span><span class="sxs-lookup"><span data-stu-id="156f2-213">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="156f2-214">Um das Kontextmenü durch einen Handler vollständig zu ersetzen <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> , darf das anfängliche Kontextmenü nicht NULL/leer sein.</span><span class="sxs-lookup"><span data-stu-id="156f2-214">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="156f2-215">Alternativ dazu müssen Sie möglicherweise das-Ereignis behandeln und dann manuell ein neues Kontextmenü öffnen.</span><span class="sxs-lookup"><span data-stu-id="156f2-215">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="156f2-216">Weitere Informationen finden Sie unter Gewusst [wie: Behandeln des ContextMenuOpening-Ereignisses](/dotnet/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event).</span><span class="sxs-lookup"><span data-stu-id="156f2-216">For details, see [How to: Handle the ContextMenuOpening Event](/dotnet/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event).</span></span>  
  
 <span data-ttu-id="156f2-217">Um dieses Ereignis als <xref:System.Windows.EventTrigger> in einem Stil zu verwenden, müssen Sie auf den zugrunde liegenden Dienst Ereignis Bezeichner verweisen:</span><span class="sxs-lookup"><span data-stu-id="156f2-217">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="156f2-218">(Diese Verwendung ist erforderlich, da die Ereignis Implementierung von <xref:System.Windows.FrameworkContentElement> , die das zugrunde liegende Dienst Ereignis verfügbar macht, den Bezeichner nicht ordnungsgemäß <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> für die Verwendung in Triggern zuordnet).</span><span class="sxs-lookup"><span data-stu-id="156f2-218">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="156f2-219">Informationen zum Routingereignis</span><span class="sxs-lookup"><span data-stu-id="156f2-219">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-220">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-220">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="156f2-221">Routing Strategie</span><span class="sxs-lookup"><span data-stu-id="156f2-221">Routing strategy</span></span>|<span data-ttu-id="156f2-222">Blasen</span><span class="sxs-lookup"><span data-stu-id="156f2-222">Bubbling</span></span>|  
|<span data-ttu-id="156f2-223">Delegat</span><span class="sxs-lookup"><span data-stu-id="156f2-223">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-224">Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Übersicht über Routingereignisse](/dotnet/framework/wpf/advanced/routed-events-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-224">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-225">Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-225">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="156f2-226">Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-226">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-227">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-227">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-228">Ruft den Cursor ab bzw. legt den Cursor fest, der angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet.</span><span class="sxs-lookup"><span data-stu-id="156f2-228">Gets or sets the cursor that displays when the mouse pointer is over this element.</span></span></summary>
        <value><span data-ttu-id="156f2-229">Der anzuzeigende Cursor.</span><span class="sxs-lookup"><span data-stu-id="156f2-229">The cursor to display.</span></span> <span data-ttu-id="156f2-230">Der Standardwert ist gemäß dieser Abhängigkeitseigenschaft als <see langword="null" /> definiert.</span><span class="sxs-lookup"><span data-stu-id="156f2-230">The default value is defined as <see langword="null" /> per this dependency property.</span></span> <span data-ttu-id="156f2-231">Der zur Laufzeit angewendete Standardwert resultiert jedoch aus einer Vielzahl von Faktoren.</span><span class="sxs-lookup"><span data-stu-id="156f2-231">However, the practical default at run time will come from a variety of factors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-232">Wenn diese Eigenschaft in festgelegt [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wird, [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] stützt der Prozessor die Typkonvertierung für die- <xref:System.Windows.Input.Cursor> Klasse, um die Zeichenfolge auszuwerten.</span><span class="sxs-lookup"><span data-stu-id="156f2-232">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="156f2-233">Die bereitgestellte Zeichenfolge sollte zu einem Wert ausgewertet werden <xref:System.Windows.Input.CursorType> .</span><span class="sxs-lookup"><span data-stu-id="156f2-233">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="156f2-234">Einzelheiten dazu finden Sie unter <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="156f2-234">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="156f2-235">Ob der Cursor, wie durch diese Eigenschaft festgelegt, angezeigt wird oder nicht angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet, hängt auch vom Wert der- <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> Eigenschaft ab.</span><span class="sxs-lookup"><span data-stu-id="156f2-235">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="156f2-236">Außerdem wirken sich ereignisbezogene Überlegungen, wie z. b. eine aktive Drag-, Maus-und Text Bearbeitungsmodi innerhalb von Steuerelementen, auch auf den Cursor mit höherer Priorität als dem Wert aus, den Sie in dieser Eigenschaft angeben.</span><span class="sxs-lookup"><span data-stu-id="156f2-236">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="156f2-237">Um das Verhalten für das Festlegen dieser Eigenschaft auf den Standardwert zurückzusetzen, legen Sie ihn `null` erneut fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-237">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="156f2-238">Der `null` Standardwert bedeutet, dass die Bestimmung des praktischen Cursor Werts hier verzögert wird und von anderen Orten abgerufen werden sollte.</span><span class="sxs-lookup"><span data-stu-id="156f2-238">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="156f2-239">Wenn ohne programmgesteuerte Werte aus einer beliebigen Quelle angezeigt wird, ist der Standard Cursor für eine- [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Anwendung ein Pfeil.</span><span class="sxs-lookup"><span data-stu-id="156f2-239">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="156f2-240">Jede Bewegung des Mauszeigers über eine- [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendung löst ein- <xref:System.Windows.ContentElement.QueryCursor> Ereignis aus.</span><span class="sxs-lookup"><span data-stu-id="156f2-240">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="156f2-241">Die Ereignis Blasen, und jedes Element entlang der Route hat die Möglichkeit, das Ereignis zu behandeln und den Wert des Cursors über die Argumente dieses Ereignisses festzulegen.</span><span class="sxs-lookup"><span data-stu-id="156f2-241">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="156f2-242">Wenn dies der Fall ist, hat die Tatsache, dass das Ereignis behandelt wird und einen geänderten Wert in den Argumenten hat, Vorrang vor dem Wert der <xref:System.Windows.FrameworkContentElement.Cursor%2A> Eigenschaft auf jeder Ebene, es sei denn, <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> wird festgelegt.</span><span class="sxs-lookup"><span data-stu-id="156f2-242">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="156f2-243">Wenn kein benutzerdefinierter Cursor erstellt wird, legen Sie diese Eigenschaft in der Regel auf einen statischen Eigenschafts Wert der- <xref:System.Windows.Input.Cursors> Klasse fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-243">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="156f2-244">Das Festlegen <xref:System.Windows.Input.Cursor> von auf einen benutzerdefinierten Wert ist in teilweiser Vertrauenswürdigkeit nicht aktiviert.</span><span class="sxs-lookup"><span data-stu-id="156f2-244">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="156f2-245">Weitere Informationen zu benutzerdefinierten Cursorn finden Sie unter Übersicht über die [Eingabe](/dotnet/framework/wpf/advanced/input-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-245">For more information on custom cursors, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-246">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-246">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-247">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-247">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="156f2-248">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-248">Metadata properties set to `true`</span></span>|<span data-ttu-id="156f2-249">Keine</span><span class="sxs-lookup"><span data-stu-id="156f2-249">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-250">Im folgenden Beispiel wird der Cursor auf einen benutzerdefinierten Wert festgelegt.</span><span class="sxs-lookup"><span data-stu-id="156f2-250">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-251">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.Cursor" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-251">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-252">Dient zum Abrufen oder Festlegen des Datenkontexts für ein Element fest, wenn das Element an Datenbindungen beteiligt ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-252">Gets or sets the data context for an element when it participates in data binding.</span></span></summary>
        <value><span data-ttu-id="156f2-253">Das Objekt, das als Datenkontext verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-253">The object to use as data context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-254">Der *Datenkontext* ist ein Konzept, mit dem Elemente Informationen von ihren übergeordneten Elementen über die Bindungs Quelle, die für die Bindung verwendet wird, sowie andere Merkmale der Bindung, wie z. b. den Pfad, erben können.</span><span class="sxs-lookup"><span data-stu-id="156f2-254">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="156f2-255">Der Datenkontext kann direkt auf ein-Objekt festgelegt werden [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] , wobei die Bindungen für die Eigenschaften dieses Objekts ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-255">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="156f2-256">Alternativ können Sie den Datenkontext auf ein- <xref:System.Windows.Data.DataSourceProvider> Objekt festlegen.</span><span class="sxs-lookup"><span data-stu-id="156f2-256">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="156f2-257">Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte.</span><span class="sxs-lookup"><span data-stu-id="156f2-257">This dependency property inherits property values.</span></span> <span data-ttu-id="156f2-258">Wenn untergeordnete Elemente vorhanden sind, für die kein anderer Wert <xref:System.Windows.FrameworkContentElement.DataContext%2A> durch lokale Werte oder Stile festgelegt wurde, wird der Wert vom-Eigenschaften System auf den <xref:System.Windows.FrameworkContentElement.DataContext%2A> Wert des nächsten übergeordneten Elements festgelegt, dem dieser Wert zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-258">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="156f2-259">Alternativ können Sie eine der folgenden Eigenschaften der- <xref:System.Windows.Data.Binding> Klasse verwenden, um die Bindungs Quelle explizit anzugeben: <xref:System.Windows.Data.Binding.ElementName%2A> , <xref:System.Windows.Data.Binding.Source%2A> oder <xref:System.Windows.Data.Binding.RelativeSource%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-259">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="156f2-260">Weitere Informationen finden Sie unter Gewusst [wie: Angeben der Bindungs Quelle](/dotnet/framework/wpf/data/how-to-specify-the-binding-source).</span><span class="sxs-lookup"><span data-stu-id="156f2-260">For more information, see [How to: Specify the Binding Source](/dotnet/framework/wpf/data/how-to-specify-the-binding-source).</span></span>  
  
 <span data-ttu-id="156f2-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] <xref:System.Windows.FrameworkContentElement.DataContext%2A> wird am häufigsten als Deklaration festgelegt <xref:System.Windows.Data.Binding> .</span><span class="sxs-lookup"><span data-stu-id="156f2-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="156f2-262">Sie können entweder die Syntax des Eigenschafts Elements oder die Attribut Syntax verwenden.</span><span class="sxs-lookup"><span data-stu-id="156f2-262">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="156f2-263">Die Attribut Syntax wird im Beispiel auf dieser Seite angezeigt.</span><span class="sxs-lookup"><span data-stu-id="156f2-263">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="156f2-264">Sie können auch <xref:System.Windows.FrameworkContentElement.DataContext%2A> im Code festlegen.</span><span class="sxs-lookup"><span data-stu-id="156f2-264">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="156f2-265">Verwendung von XAML-Eigenschaftenelementen</span><span class="sxs-lookup"><span data-stu-id="156f2-265">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="156f2-266">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="156f2-266">XAML Attribute Usage</span></span>  
  
```xaml
<object DataContext="bindingUsage"/>  
```

<span data-ttu-id="156f2-267">- oder -</span><span class="sxs-lookup"><span data-stu-id="156f2-267">-or-</span></span>

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```

<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="156f2-268">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="156f2-268">XAML Values</span></span>  
 <span data-ttu-id="156f2-269">*datacontextobject*</span><span class="sxs-lookup"><span data-stu-id="156f2-269">*dataContextObject*</span></span>  
 <span data-ttu-id="156f2-270">Ein direkt eingebettetes Objekt, das als Datenkontext für alle Bindungen innerhalb des übergeordneten Elements fungiert.</span><span class="sxs-lookup"><span data-stu-id="156f2-270">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="156f2-271">In der Regel ist dieses Objekt eine <xref:System.Windows.Data.Binding> oder eine andere <xref:System.Windows.Data.BindingBase> Unterklasse.</span><span class="sxs-lookup"><span data-stu-id="156f2-271">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="156f2-272">Alternativ können Rohdaten eines beliebigen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Objekttyps, der für die Bindung bestimmt ist, hier platziert werden, wobei die eigentlichen Bindungen später definiert werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-272">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="156f2-273">*bindingusage*</span><span class="sxs-lookup"><span data-stu-id="156f2-273">*bindingUsage*</span></span>  
 <span data-ttu-id="156f2-274">Eine Bindungs Verwendung, die zu einem geeigneten Datenkontext ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-274">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="156f2-275">Weitere Informationen finden Sie unter [Binding als Markuperweiterung](/dotnet/framework/wpf/advanced/binding-markup-extension).</span><span class="sxs-lookup"><span data-stu-id="156f2-275">For details, see [Binding Markup Extension](/dotnet/framework/wpf/advanced/binding-markup-extension).</span></span>  
  
 <span data-ttu-id="156f2-276">*resourceextension*</span><span class="sxs-lookup"><span data-stu-id="156f2-276">*resourceExtension*</span></span>  
 <span data-ttu-id="156f2-277">Eines der folgenden: `StaticResource` , oder `DynamicResource` .</span><span class="sxs-lookup"><span data-stu-id="156f2-277">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="156f2-278">Diese Verwendung wird verwendet, wenn auf Rohdaten verwiesen wird, die als Objekt in Ressourcen definiert sind.</span><span class="sxs-lookup"><span data-stu-id="156f2-278">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="156f2-279">Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).</span><span class="sxs-lookup"><span data-stu-id="156f2-279">See [XAML Resources](/dotnet/framework/wpf/advanced/xaml-resources).</span></span>  
  
 <span data-ttu-id="156f2-280">*contextresourcekey*</span><span class="sxs-lookup"><span data-stu-id="156f2-280">*contextResourceKey*</span></span>  
 <span data-ttu-id="156f2-281">Der Schlüssel Bezeichner für das Objekt, das in einem angefordert wird <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-281">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-282">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-282">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-283">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-283">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="156f2-284">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-284">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-285">Im folgenden Beispiel wird eine Bindung für ein- <xref:System.Windows.Documents.Paragraph> Element festgelegt, indem ein neues benutzerdefiniertes Datenobjekt erstellt, das Objekt als festgelegt <xref:System.Windows.FrameworkContentElement.DataContext%2A> wird und der Bindungs Pfad auf eine Eigenschaft innerhalb des-Objekts festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-285">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-286">Tritt ein, wenn sich der Datenkontext dieses Elements ändert.</span><span class="sxs-lookup"><span data-stu-id="156f2-286">Occurs when this element's data context changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-287">Eine Erläuterung der Daten Kontexte und der Datenbindung finden Sie unter [Übersicht über die Datenbindung](/dotnet/framework/wpf/data/data-binding-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-287">For an explanation of data contexts and data binding, see [Data Binding Overview](/dotnet/framework/wpf/data/data-binding-overview).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="156f2-288">Wenn sich die Änderungen eines Elements <xref:System.Windows.FrameworkContentElement.DataContext%2A> ändern, werden alle Daten gebundenen Eigenschaften für dieses Element potenziell beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="156f2-288">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="156f2-289">Dies gilt für alle Elemente, die Nachfolger Elemente des aktuellen Elements sind, das den Datenkontext erbt, und auch das aktuelle Element selbst.</span><span class="sxs-lookup"><span data-stu-id="156f2-289">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="156f2-290">Alle diese Bindungen interpretieren die neue erneut <xref:System.Windows.FrameworkContentElement.DataContext%2A> , um den neuen Wert in Bindungen widerzuspiegeln.</span><span class="sxs-lookup"><span data-stu-id="156f2-290">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="156f2-291">Es gibt keine Garantie für die Reihenfolge dieser Änderungen in Bezug auf die Erhöhung des <xref:System.Windows.FrameworkContentElement.DataContextChanged> Ereignisses.</span><span class="sxs-lookup"><span data-stu-id="156f2-291">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="156f2-292">Die Änderungen können vor dem Ereignis, nach dem Ereignis oder in einer beliebigen Mischung auftreten.</span><span class="sxs-lookup"><span data-stu-id="156f2-292">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-293">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.DataContext" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-293">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-294">Ruft den Schlüssel ab, der bei diesem Steuerelement zum Suchen der Stilvorlage in Designs verwendet wird, oder legt den Schlüssel fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-294">Gets or sets the key to use to find the style template for this control in themes.</span></span></summary>
        <value><span data-ttu-id="156f2-295">Der Formatvorlagenschlüssel.</span><span class="sxs-lookup"><span data-stu-id="156f2-295">The style key.</span></span> <span data-ttu-id="156f2-296">Dieser Wert soll vom <see cref="T:System.Type" /> des formatierten Elements sein, damit er bei der Suche des Designstils korrekt verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-296">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span></span> <span data-ttu-id="156f2-297"><see langword="null" /> ist ein akzeptierter Wert für einen bestimmten Fall.</span><span class="sxs-lookup"><span data-stu-id="156f2-297"><see langword="null" /> is an accepted value for a certain case.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-298">Diese Eigenschaft wird in der Regel nicht über einen ihrer direkten Setter festgelegt.</span><span class="sxs-lookup"><span data-stu-id="156f2-298">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="156f2-299">Stattdessen überschreiben Sie jedes Mal, wenn Sie eine neue Unterklasse erstellen, die typspezifischen Metadaten dieser Abhängigkeits Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-299">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="156f2-300">Bei der Unterklasse wird die- <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Methode für den <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> Bezeichner im statischen Konstruktor der Steuerelement-Unterklasse aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-300">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="156f2-301">Beispielsweise verfügt eine Inline Klasse wie <xref:System.Windows.Documents.Bold> tatsächlich über das Überschreiben der <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> Metadaten in Ihrem statischen Konstruktor und das verfügbar machen mehrerer Instanzkonstruktoren über eine sehr geringe Implementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-301">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="156f2-302">Die Tatsache, dass Elemente, die mit dem- <xref:System.Windows.Documents.Bold> Tag umgeben sind, eine <xref:System.Windows.Documents.TextElement.FontWeight%2A> Eigenschaft von erhalten, <xref:System.Windows.FontWeights.Bold%2A> wird innerhalb des Design Stils implementiert, auf den durch Festlegen des Standardwerts von auf verwiesen wurde <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> `typeof(Bold)` .</span><span class="sxs-lookup"><span data-stu-id="156f2-302">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="156f2-303">Wenn Sie möchten, dass das Element oder Steuerelement absichtlich keine Designstile verwendet, legen Sie die- <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> Eigenschaft auf fest `true` .</span><span class="sxs-lookup"><span data-stu-id="156f2-303">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-304">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-304">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-305">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-305">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="156f2-306">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-306">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-307">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-307">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-308">Wird unmittelbar nach der Initialisierung eines Elements aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-308">Called immediately after an element is initialized.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-309">Implementieren Sie diese Methode, um eine spezielle Verarbeitung bereitzustellen, die auftreten sollte, wenn das Element während des Ladevorgangs des Elements initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-309">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="156f2-310">Ihre Implementierung sollte die Basis Implementierung aufzurufen, da die Basis Implementierung (Standard) einige interne Flags festlegt, um die Initialisierung nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="156f2-310">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="156f2-311">Wenn <xref:System.Windows.FrameworkContentElement.BeginInit%2A> zuvor aufgerufen wurde, wird das-Ereignis von der Basis Implementierung aufgerufen <xref:System.Windows.FrameworkContentElement.Initialized> .</span><span class="sxs-lookup"><span data-stu-id="156f2-311">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="156f2-312">Andernfalls <xref:System.Windows.FrameworkContentElement.BeginInit%2A> wird das-Ereignis nicht ausgelöst, wenn nicht aufgerufen wurde oder nicht ermittelt werden konnte <xref:System.Windows.FrameworkContentElement.BeginInit%2A> , ob aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-312">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="156f2-313">Der Name des zu suchenden Elements.</span><span class="sxs-lookup"><span data-stu-id="156f2-313">Name of the element to search for.</span></span></param>
        <summary><span data-ttu-id="156f2-314">Sucht ein Element mit dem Namen des bereitgestellten Bezeichners.</span><span class="sxs-lookup"><span data-stu-id="156f2-314">Finds an element that has the provided identifier name.</span></span></summary>
        <returns><span data-ttu-id="156f2-315">Das angeforderte Element.</span><span class="sxs-lookup"><span data-stu-id="156f2-315">The requested element.</span></span> <span data-ttu-id="156f2-316">Kann <see langword="null" /> sein, wenn kein übereinstimmendes Element gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-316">May be <see langword="null" /> if no matching element was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-317">Wenn dieses Element über untergeordnete Elemente verfügt, werden diese untergeordneten Elemente für das angeforderte benannte Element rekursiv durchsucht.</span><span class="sxs-lookup"><span data-stu-id="156f2-317">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-318">Im folgenden Beispiel wird eine-Eigenschaft für ein Element festgelegt, das in einer auf eine Seite verwiesen wird, auf die verwiesen wird <xref:System.Windows.Documents.FlowDocument> .</span><span class="sxs-lookup"><span data-stu-id="156f2-318">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="156f2-319">Der Schlüsselbezeichner der zu findenden Ressource.</span><span class="sxs-lookup"><span data-stu-id="156f2-319">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="156f2-320">Sucht nach einer Ressource mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-320">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span></span></summary>
        <returns><span data-ttu-id="156f2-321">Die gefundene Ressource oder <see langword="null" />, wenn keine übereinstimmende Ressource gefunden wurde (bei <see langword="null" /> wird ebenfalls eine Ausnahme ausgelöst).</span><span class="sxs-lookup"><span data-stu-id="156f2-321">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="156f2-322">Wenn Sie diese Methode für einen Schlüssel aufgerufen haben, der nicht gefunden werden kann, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="156f2-322">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="156f2-323">Wenn Sie in diesem Fall keine Ausnahmen behandeln möchten, sollten Sie stattdessen ausführen <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-323">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="156f2-324"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Gibt zurück `null` , wenn keine Ressource gefunden wird und keine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="156f2-324"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="156f2-325">Wenn die Ressource im aufrufenden Element nicht gefunden wird, wird die übergeordnete Struktur mithilfe der logischen Struktur durchsucht, und zwar auf dieselbe Weise, wie die Struktur durchsucht wird, wenn eine Ressource zur Laufzeit von einem Schlüssel angefordert wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-325">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="156f2-326">In der Regel würden Sie den Rückgabewert sofort in den Typ der Eigenschaft umwandeln, die Sie mit dem zurückgegebenen Ressourcen Wert festlegen wollten.</span><span class="sxs-lookup"><span data-stu-id="156f2-326">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-327">Im folgenden Beispiel wird eine Ressource wie in Markup definiert gefunden und auf eine bestimmte Eigenschaft eines Elements als Reaktion auf ein Routing Ereignis angewendet.</span><span class="sxs-lookup"><span data-stu-id="156f2-327">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><span data-ttu-id="156f2-328">Der angeforderte Ressourcenschlüssel wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="156f2-328">The requested resource key was not found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="156f2-329"><paramref name="resourceKey" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-329"><paramref name="resourceKey" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-330">Dient zum Abrufen oder Festlegen eines Objekts, das die Anpassung von Darstellung, Effekten oder anderen Formateigenschaften ermöglicht, die auf dieses Element angewendet werden, wenn es den Tastaturfokus erhält.</span><span class="sxs-lookup"><span data-stu-id="156f2-330">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span></span></summary>
        <value><span data-ttu-id="156f2-331">Die gewünschte Formatvorlage, die angewendet wird, wenn das Element den Fokus erhält.</span><span class="sxs-lookup"><span data-stu-id="156f2-331">The desired style to apply on focus.</span></span> <span data-ttu-id="156f2-332">Der in der Abhängigkeitseigenschaft deklarierte Standardwert ist eine leere statische <see cref="T:System.Windows.Style" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-332">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span></span> <span data-ttu-id="156f2-333">Der tatsächliche Wert zur Laufzeit ist jedoch häufig (aber nicht immer) eine Formatvorlage, die von der Designunterstützung für Steuerelemente bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-333">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-334">Beim Festlegen dieser Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] werden Stile fast immer als Ressource definiert, nicht als Inline als Element, und auf diese Ressource wird normalerweise als verwiesen <xref:System.Windows.StaticResourceExtension> .</span><span class="sxs-lookup"><span data-stu-id="156f2-334">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="156f2-335">Beachten Sie, dass sich diese Eigenschaft auf die visuelle Darstellung auswirkt, aber nicht in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="156f2-335">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="156f2-336">Dies liegt daran, dass die visuelle Darstellung des Erscheinungs Bilds ereignisgesteuert ist und möglicherweise nicht immer angewendet wird und daher nicht in der Regel alle visuellen Informationen und Layoutinformationen in den Metadaten melden sollte.</span><span class="sxs-lookup"><span data-stu-id="156f2-336">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="156f2-337">Konzeptionell sollte das visuelle Verhalten von Fokus, das auf ein Steuerelement angewendet wird, von Element zu Element kohärent sein.</span><span class="sxs-lookup"><span data-stu-id="156f2-337">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="156f2-338">Die sinnvollste Methode zum Erzwingen von Kohärenz besteht darin, nur den visuellen Fokus Stil zu ändern, wenn Sie ein ganzes Design erstellen.</span><span class="sxs-lookup"><span data-stu-id="156f2-338">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="156f2-339">Das Festlegen dieser Eigenschaft in einzelnen Formaten und nicht als Teil eines Designs ist nicht die beabsichtigte Verwendung dieser Eigenschaft, da dies zu einer verwirrenden Benutzer Darstellung in Bezug auf den Tastaturfokus führen kann.</span><span class="sxs-lookup"><span data-stu-id="156f2-339">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="156f2-340">Wenn Sie ein Element spezifisches Verhalten haben, das in einem Design absichtlich nicht kohärent ist, empfiehlt es sich, Trigger in Stilen für einzelne Eingabe Zustands Eigenschaften (z. b. oder) zu verwenden <xref:System.Windows.UIElement.IsFocused%2A> <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> und dies auf eine Weise zu tun, die den visuellen Stil des visuellen Fokus nicht visuell beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="156f2-340">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="156f2-341">Weitere Informationen zu den Entwurfs Absichten <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> und alternativen Fokus Eigenschaften finden Sie unter Formatieren [für den Fokus in Steuerelementen und liegt VisualStyle](/dotnet/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle).</span><span class="sxs-lookup"><span data-stu-id="156f2-341">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](/dotnet/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="156f2-342">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="156f2-342">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="156f2-343">Verwendung von XAML-Eigenschaftenelementen</span><span class="sxs-lookup"><span data-stu-id="156f2-343">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="156f2-344">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="156f2-344">XAML Values</span></span>  
 <span data-ttu-id="156f2-345">*resourceextension*</span><span class="sxs-lookup"><span data-stu-id="156f2-345">*resourceExtension*</span></span>  
 <span data-ttu-id="156f2-346">Eines der folgenden:, oder.</span><span class="sxs-lookup"><span data-stu-id="156f2-346">One of the following: , or .</span></span> <span data-ttu-id="156f2-347">Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).</span><span class="sxs-lookup"><span data-stu-id="156f2-347">See [XAML Resources](/dotnet/framework/wpf/advanced/xaml-resources).</span></span>  
  
 <span data-ttu-id="156f2-348">*styleresourcekey*</span><span class="sxs-lookup"><span data-stu-id="156f2-348">*styleResourceKey*</span></span>  
 <span data-ttu-id="156f2-349">Der Schlüssel, der den angeforderten Stil bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="156f2-349">The key that identifies the style being requested.</span></span> <span data-ttu-id="156f2-350">Der Schlüssel verweist auf eine vorhandene Ressource in einer <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-350">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="156f2-351">Die Syntax von Eigenschafts Elementen ist technisch möglich, wird jedoch nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="156f2-351">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="156f2-352">Weitere Informationen finden Sie unter [Inline Stile und Vorlagen](/dotnet/framework/wpf/advanced/inline-styles-and-templates).</span><span class="sxs-lookup"><span data-stu-id="156f2-352">See [Inline Styles and Templates](/dotnet/framework/wpf/advanced/inline-styles-and-templates).</span></span>  <span data-ttu-id="156f2-353">Ein Bindungs Verweis mit [TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension) oder <xref:System.Windows.Data.Binding> ist ebenfalls möglich, aber nicht üblich.</span><span class="sxs-lookup"><span data-stu-id="156f2-353">A binding reference using [TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension) or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-354">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-354">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-355">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-355">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="156f2-356">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-356">Metadata properties set to `true`</span></span>|<span data-ttu-id="156f2-357">Keine</span><span class="sxs-lookup"><span data-stu-id="156f2-357">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-358">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-358">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-359">Ruft einen Wert ab, mit dem angegeben wird, ob dieses <see cref="T:System.Windows.FrameworkContentElement" /> das Rendern des Cursors in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] gemäß der Deklaration in dieser Instanz der <see cref="P:System.Windows.FrameworkContentElement.Cursor" />-Eigenschaft erzwingen soll, oder legt diesen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-359">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span></span></summary>
        <value><span data-ttu-id="156f2-360"><see langword="true" />, wenn für die Darstellung des Cursors bei Positionierung über diesem Element die Cursoreinstellungen dieser Instanz (einschließlich aller untergeordneten Elemente) erzwungen werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-360"><see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span></span> <span data-ttu-id="156f2-361">Standardwert: <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-361">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-362">Wenn diese Eigenschaft auf festgelegt `true` wird, werden die von untergeordneten Elementen eingerichteten Cursor Einstellungen überschrieben.</span><span class="sxs-lookup"><span data-stu-id="156f2-362">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="156f2-363">Dies [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] kann für den Benutzer verwirrend sein, insbesondere dann, wenn untergeordnete Elemente versuchen, Cursor anzugeben.</span><span class="sxs-lookup"><span data-stu-id="156f2-363">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="156f2-364">Die Einstellung <xref:System.Windows.FrameworkElement.ForceCursor%2A> eignet sich besser für die Steuerung von Unterklassen-oder Kompositions Szenarien.</span><span class="sxs-lookup"><span data-stu-id="156f2-364">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-365">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-365">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-366">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-366">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="156f2-367">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-367">Metadata properties set to `true`</span></span>|<span data-ttu-id="156f2-368">Keine</span><span class="sxs-lookup"><span data-stu-id="156f2-368">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-369">Im folgenden Beispiel wird der Cursor während des-Elements erzwungen.</span><span class="sxs-lookup"><span data-stu-id="156f2-369">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-370">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-370">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="156f2-371">Die Ziel-<see cref="T:System.Windows.DependencyProperty" />, aus der die Bindung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-371">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span></span></param>
        <summary><span data-ttu-id="156f2-372">Ruft die <see cref="T:System.Windows.Data.BindingExpression" /> für die Bindung der angegebenen Eigenschaft ab.</span><span class="sxs-lookup"><span data-stu-id="156f2-372">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span></span></summary>
        <returns><span data-ttu-id="156f2-373">Gibt eine <see cref="T:System.Windows.Data.BindingExpression" /> zurück, wenn das Ziel datengebunden ist, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-373">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="156f2-374">Im folgenden Beispiel wird eine Bindung abgerufen, indem eine-Eigenschaft abgefragt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-374">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-375">Gibt ein alternatives logisches übergeordnetes Element für dieses Element zurück, wenn kein visuelles übergeordnetes Element vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-375">Returns an alternative logical parent for this element if there is no visual parent.</span></span> <span data-ttu-id="156f2-376">In diesem Fall ist ein übergeordnetes <see cref="T:System.Windows.FrameworkContentElement" /> immer identisch mit dem Wert der <see cref="P:System.Windows.FrameworkContentElement.Parent" />-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-376">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span></span></summary>
        <returns><span data-ttu-id="156f2-377">Gibt immer dann einen Wert ungleich <see langword="null" /> zurück, wenn eine auf WPF-Frameworkebene vorgenommene Implementierung dieser Methode eine nicht visuelle übergeordnete Verbindung hat.</span><span class="sxs-lookup"><span data-stu-id="156f2-377">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-378">Die Standard Implementierung gibt das erwartete visuelle übergeordnete Element zurück.</span><span class="sxs-lookup"><span data-stu-id="156f2-378">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="156f2-379">Benutzerdefinierte Implementierungen können alternative übergeordnete Beziehungen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="156f2-379">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-380">Tritt ein, wenn dieses <see cref="T:System.Windows.FrameworkContentElement" /> initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-380">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span></span> <span data-ttu-id="156f2-381">Dieses Ereignis geht mit Fällen einher, in denen sich der Wert der <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" />-Eigenschaft von <see langword="false" /> (oder nicht definiert) in <see langword="true" /> ändert.</span><span class="sxs-lookup"><span data-stu-id="156f2-381">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-382">Dieses Ereignis wird immer dann ausgelöst, wenn die- <xref:System.Windows.FrameworkContentElement.EndInit%2A> Methode oder die- <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-382">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="156f2-383">Aufrufe dieser Methoden können von einem absichtlichen Code oder vom Ladevorgang durchgeführt worden sein [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="156f2-383">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-384">Dient zum Abrufen oder Festlegen des Kontexts für die von diesem <see cref="T:System.Windows.FrameworkContentElement" /> verwendete Eingabe.</span><span class="sxs-lookup"><span data-stu-id="156f2-384">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <value><span data-ttu-id="156f2-385">Der Eingabebereich, der bestimmt, wie Eingaben von alternativen Eingabemethoden interpretiert werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-385">The input scope, which modifies how input from alternative input methods is interpreted.</span></span> <span data-ttu-id="156f2-386">Der Standardwert ist <see langword="null" /> (führt zu einer Standardbehandlung von Befehlen).</span><span class="sxs-lookup"><span data-stu-id="156f2-386">The default value is <see langword="null" /> (which results in a default handling of commands).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-387">Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte.</span><span class="sxs-lookup"><span data-stu-id="156f2-387">This dependency property inherits property values.</span></span> <span data-ttu-id="156f2-388">Wenn untergeordnete Elemente vorhanden sind, für die kein anderer Wert <xref:System.Windows.FrameworkElement.InputScope%2A> durch lokale Werte oder Stile festgelegt wurde, wird der Wert vom-Eigenschaften System auf den <xref:System.Windows.FrameworkElement.InputScope%2A> Wert des nächsten übergeordneten Elements festgelegt, dem dieser Wert zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-388">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="156f2-389">Obwohl eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax Verwendung aufgelistet und syntaktisch zulässig ist, wird das Festlegen dieser Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nicht häufig verwendet.</span><span class="sxs-lookup"><span data-stu-id="156f2-389">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-390">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-390">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-391">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-391">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="156f2-392">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-392">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-393">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.InputScope" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-393">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-394">Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element durch das Laden als [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] oder durch einen expliziten Aufruf der entsprechenden <see cref="M:System.Windows.FrameworkContentElement.EndInit" />-Methode initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-394">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span></span></summary>
        <value><span data-ttu-id="156f2-395"><see langword="true" />, wenn das Element wie zuvor beschrieben durch Laden oder durch einen Methodenaufruf initialisiert wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-395"><see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-396">Diese Eigenschaft kann auch sein `true` , wenn dieses Element in der Elementstruktur so verschoben wurde, dass es über ein neues übergeordnetes Element verfügt und daher erneut geladen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-396">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-397">Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element für die Darstellung geladen wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-397">Gets a value indicating whether this element has been loaded for presentation.</span></span></summary>
        <value><span data-ttu-id="156f2-398"><see langword="true" />, wenn das aktuelle Element an eine Elementstruktur angefügt ist und gerendert wurde, <see langword="false" />, wenn das Element noch nie an eine geladene Elementstruktur angefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-398"><see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-399">Aus einer neu erstellten Instanz startet diese Eigenschaft `false` und bleibt, `true` sobald Sie auf festgelegt ist `true` , auch dann, wenn Sie später durch Code entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-399">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-400">Im folgenden Beispielcode <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> wird als bedingte Prüfung verwendet, um sicherzustellen, dass eine Funktion `displayData` (nicht dargestellt) gültige Elemente enthält, die auf der Seite als Teil eines bedarfsgesteuerten Handlers geladen werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-400">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="156f2-401">Die gleiche Logik wird als Ereignishandler für ausgeführt <xref:System.Windows.FrameworkContentElement.Loaded> .</span><span class="sxs-lookup"><span data-stu-id="156f2-401">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-402">Ruft die Sprachinformationen für die Lokalisierung/Globalisierung eines einzelnen Elements ab oder legt diese Informationen fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-402">Gets or sets localization/globalization language information that applies to an individual element.</span></span></summary>
        <value><span data-ttu-id="156f2-403">Die Kulturinformationen für dieses Element.</span><span class="sxs-lookup"><span data-stu-id="156f2-403">The culture information for this element.</span></span> <span data-ttu-id="156f2-404">Der Standardwert ist eine <see cref="T:System.Windows.Markup.XmlLanguage" />-Instanz, deren <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />-Wert auf die Zeichenfolge „en-US“ festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-404">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-405">Die Zeichen folgen Formate folgen dem Standard RFC 3066.</span><span class="sxs-lookup"><span data-stu-id="156f2-405">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="156f2-406">US-Englisch lautet z. b. "en-US".</span><span class="sxs-lookup"><span data-stu-id="156f2-406">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="156f2-407"><xref:System.Windows.Markup.XmlLanguage>Weitere Informationen zu den Werten und zum Format finden Sie unter.</span><span class="sxs-lookup"><span data-stu-id="156f2-407">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="156f2-408">Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte.</span><span class="sxs-lookup"><span data-stu-id="156f2-408">This dependency property inherits property values.</span></span> <span data-ttu-id="156f2-409">Wenn untergeordnete Elemente vorhanden sind, für die kein anderer Wert <xref:System.Windows.FrameworkElement.Language%2A> durch lokale Werte oder Stile festgelegt wurde, wird der Wert vom-Eigenschaften System auf den <xref:System.Windows.FrameworkElement.Language%2A> Wert des nächsten übergeordneten Elements festgelegt, dem dieser Wert zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-409">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-410">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-410">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-411">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-411">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="156f2-412">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-412">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-413">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.Language" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-413">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-414">Tritt auf, wenn das Element ausgerichtet und gerendert sowie zur Interaktion vorbereitet wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-414">Occurs when the element is laid out, rendered, and ready for interaction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-415">Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-415">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="156f2-416">Direkt geroutete Ereignisse unterstützen andere Routing Ereignis Verhalten: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-416">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="156f2-417">Informationen zum Routingereignis</span><span class="sxs-lookup"><span data-stu-id="156f2-417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-418">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-418">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="156f2-419">Routing Strategie</span><span class="sxs-lookup"><span data-stu-id="156f2-419">Routing strategy</span></span>|<span data-ttu-id="156f2-420">Direkt</span><span class="sxs-lookup"><span data-stu-id="156f2-420">Direct</span></span>|  
|<span data-ttu-id="156f2-421">Delegat</span><span class="sxs-lookup"><span data-stu-id="156f2-421">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-422">Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Übersicht über Routingereignisse](/dotnet/framework/wpf/advanced/routed-events-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-422">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-423">Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-423">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="156f2-424">Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-424">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-425">Ruft einen Enumerator für die logischen untergeordneten Elemente dieses Elements ab.</span><span class="sxs-lookup"><span data-stu-id="156f2-425">Gets an enumerator for the logical child elements of this element.</span></span></summary>
        <value><span data-ttu-id="156f2-426">Ein Enumerator für die logischen untergeordneten Elemente dieses Elements.</span><span class="sxs-lookup"><span data-stu-id="156f2-426">An enumerator for logical child elements of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-427">Weitere Informationen zur Verwendung von und finden Sie Unterstrukturen <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A> [in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="156f2-427">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="156f2-428">Die Richtung, in die der Fokus verschoben werden soll, als Wert der Enumeration.</span><span class="sxs-lookup"><span data-stu-id="156f2-428">The direction that focus is to be moved, as a value of the enumeration.</span></span></param>
        <summary><span data-ttu-id="156f2-429">Verschiebt den Tastaturfokus von diesem Element auf ein anderes Element.</span><span class="sxs-lookup"><span data-stu-id="156f2-429">Moves the keyboard focus from this element to another element.</span></span></summary>
        <returns><span data-ttu-id="156f2-430">Gibt <see langword="true" /> zurück, wenn der Fokus erfolgreich verschoben wurde. <see langword="false" /> wird zurückgegeben, wenn das Zielelement in der angegebenen Richtung nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-430">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.MergableProperty(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.MergableProperty(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-431">Dient zum Abrufen oder Festlegen des Elementnamens.</span><span class="sxs-lookup"><span data-stu-id="156f2-431">Gets or sets the identifying name of the element.</span></span> <span data-ttu-id="156f2-432">Der Name stellt einen Instanzverweis bereit, sodass programmgesteuerter Code-Behind, z. B. Ereignishandlercode, während der Analyse von [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] auf ein Element verweisen kann, sobald es erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-432">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span></summary>
        <value><span data-ttu-id="156f2-433">Der Name des Elements.</span><span class="sxs-lookup"><span data-stu-id="156f2-433">The name of the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-434">Die häufigste Verwendung dieser Eigenschaft ist die Angabe eines [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Element namens im Markup.</span><span class="sxs-lookup"><span data-stu-id="156f2-434">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="156f2-435">Diese Eigenschaft bietet im Wesentlichen eine Eigenschaft der WPF-Frameworkebene zum Festlegen der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name-Direktive](/dotnet/framework/xaml-services/x-name-directive).</span><span class="sxs-lookup"><span data-stu-id="156f2-435">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](/dotnet/framework/xaml-services/x-name-directive).</span></span>  
  
 <span data-ttu-id="156f2-436">Das <xref:System.Windows.FrameworkContentElement.Name%2A> Abrufen eines aus dem Code ist nicht üblich, denn wenn Sie bereits über den entsprechenden Verweis im Code verfügen, können Sie einfach Methoden und Eigenschaften für den Element Verweis und nicht in der Regel benötigen <xref:System.Windows.FrameworkContentElement.Name%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-436">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="156f2-437">Eine Ausnahme ist, wenn die Zeichenfolge über eine überladene Bedeutung verfügt, beispielsweise, wenn es sinnvoll ist, den Namen in anzuzeigen [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="156f2-437">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="156f2-438">Das Festlegen eines <xref:System.Windows.FrameworkContentElement.Name%2A> aus dem Code, wenn das Original <xref:System.Windows.FrameworkContentElement.Name%2A> aus Markup festgelegt wurde, wird ebenfalls nicht empfohlen, und durch Ändern der-Eigenschaft wird der Objekt Verweis nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="156f2-438">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="156f2-439">Solche Objekt Verweise werden nur erstellt, wenn die zugrunde liegenden Namescopes beim Laden explizit erstellt werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="156f2-439">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="156f2-440">Sie müssen ausdrücklich aufzurufen <xref:System.Windows.FrameworkContentElement.RegisterName%2A> , um eine effektive Änderung der- <xref:System.Windows.FrameworkContentElement.Name%2A> Eigenschaft eines bereits geladenen Elements vorzunehmen.</span><span class="sxs-lookup"><span data-stu-id="156f2-440">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="156f2-441">Ein wichtiger Fall, bei dem <xref:System.Windows.FrameworkContentElement.Name%2A> die Einstellung aus dem Code wichtig ist, ist das Benennen von Elementen, für die Storyboards ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-441">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="156f2-442">Bevor Sie einen Namen registrieren können, müssen Sie möglicherweise auch eine-Instanz instanziieren und zuweisen <xref:System.Windows.NameScope> .</span><span class="sxs-lookup"><span data-stu-id="156f2-442">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="156f2-443">Weitere Informationen finden Sie im Beispiel Abschnitt oder in der [Übersicht über Storyboards](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-443">See the Example section, or [Storyboards Overview](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).</span></span>  
  
 <span data-ttu-id="156f2-444">Das Festlegen <xref:System.Windows.FrameworkContentElement.Name%2A> von Code weist eingeschränkte Anwendungen auf, aber das Suchen nach einem Element anhand des Namens ist eher üblich, insbesondere wenn Sie ein Navigations Modell verwenden, bei dem Seiten in die Anwendung neu geladen werden und der Lauf Zeit Code nicht notwendigerweise der Code Behind der entsprechenden Seite ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-444">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="156f2-445">Die hilfsprogrammmethode <xref:System.Windows.FrameworkContentElement.FindName%2A> , die von einem beliebigen verfügbar ist <xref:System.Windows.FrameworkContentElement> , kann jedes Element durch <xref:System.Windows.FrameworkContentElement.Name%2A> rekursiv in der logischen Struktur dieses Elements finden.</span><span class="sxs-lookup"><span data-stu-id="156f2-445">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="156f2-446">Oder Sie können die <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statische Methode von verwenden <xref:System.Windows.LogicalTreeHelper> , die auch die <xref:System.Windows.FrameworkContentElement.Name%2A> Zeichenfolge als Argument annimmt.</span><span class="sxs-lookup"><span data-stu-id="156f2-446">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="156f2-447">Häufig verwendete Stamm Elemente ( <xref:System.Windows.Window> <xref:System.Windows.Controls.Page> z. b.) implementieren die-Schnittstelle <xref:System.Windows.Markup.INameScope> .</span><span class="sxs-lookup"><span data-stu-id="156f2-447">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="156f2-448">Bei Implementierungen dieser Schnittstelle wird erwartet, dass die Namen innerhalb ihres Bereichs eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="156f2-448">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-449">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-449">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-450">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-450">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="156f2-451">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-451">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-452">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.Name" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-452">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-453">Stellt Daten über das Ereignis bereit.</span><span class="sxs-lookup"><span data-stu-id="156f2-453">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="156f2-454">Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />-Routingereignis diese Klasse auf der Route erreicht.</span><span class="sxs-lookup"><span data-stu-id="156f2-454">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="156f2-455">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="156f2-455">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-456">Diese Methode hat keine Standard Implementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-456">This method has no default implementation.</span></span> <span data-ttu-id="156f2-457">Sie sollten die Basis Implementierung weiterhin für den Fall aufzurufen, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat.</span><span class="sxs-lookup"><span data-stu-id="156f2-457">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="156f2-458">Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei \*-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="156f2-458">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="156f2-459">In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-459">In this case the matching event is a routed event.</span></span> <span data-ttu-id="156f2-460">Das Implementierungs Muster der on \*-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise von einem untergeordneten-Element ausgelöst wurde, nicht notwendigerweise vom Element, das Handler aufruft.</span><span class="sxs-lookup"><span data-stu-id="156f2-460">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="156f2-461">Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszuführen).</span><span class="sxs-lookup"><span data-stu-id="156f2-461">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="156f2-462">Unterklassen von <xref:System.Windows.FrameworkContentElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-462">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="156f2-463">Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.</span><span class="sxs-lookup"><span data-stu-id="156f2-463">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-464">Die Ereignisdaten für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-464">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="156f2-465">Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />-Routingereignis diese Klasse auf der Route erreicht.</span><span class="sxs-lookup"><span data-stu-id="156f2-465">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="156f2-466">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="156f2-466">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-467">Diese Methode hat keine Standard Implementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-467">This method has no default implementation.</span></span> <span data-ttu-id="156f2-468">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie weiterhin Base () aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-468">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="156f2-469">Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei \*-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="156f2-469">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="156f2-470">In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="156f2-471">Das Implementierungs Muster der on \*-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen).</span><span class="sxs-lookup"><span data-stu-id="156f2-471">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="156f2-472">Unterklassen von <xref:System.Windows.FrameworkContentElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-472">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="156f2-473">Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.</span><span class="sxs-lookup"><span data-stu-id="156f2-473">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-474">Die Ereignisdaten für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-474">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="156f2-475">Der Klassenhandler für das <see cref="E:System.Windows.ContentElement.GotFocus" />-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-475">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-476">Dieser Klassen Handler legt das entsprechende Fokus Verhalten für dieses Element fest, wenn das Ereignis von diesem Element stammt.</span><span class="sxs-lookup"><span data-stu-id="156f2-476">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="156f2-477">Wenn die Quelle des Ereignisses ein anderes Element in der Struktur war, führt der Handler keine Aktion aus.</span><span class="sxs-lookup"><span data-stu-id="156f2-477">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="156f2-478">Überschreiben Sie diese Methode, um dieses standardmäßige Fokus Verhalten für Ihr Element zu ändern.</span><span class="sxs-lookup"><span data-stu-id="156f2-478">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-479">Die Ereignisdaten für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-479">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="156f2-480">Löst das <see cref="E:System.Windows.FrameworkContentElement.Initialized" />-Ereignis aus.</span><span class="sxs-lookup"><span data-stu-id="156f2-480">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span></span> <span data-ttu-id="156f2-481">Diese Methode wird immer dann aufgerufen, wenn <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> auf <see langword="true" /> festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-481">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-482">Die Standard Implementierung dieser virtuellen Methode löst das-Ereignis aus, wie zuvor in diesem Thema beschrieben.</span><span class="sxs-lookup"><span data-stu-id="156f2-482">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="156f2-483">Über schreibungen sollten Base () aufgerufen werden, um dieses Verhalten beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="156f2-483">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="156f2-484">Beachten Sie, dass die <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> -Eigenschaft schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-484">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="156f2-485">Daher können Sie Sie nicht so festlegen, dass das Initialisierungs Verhalten auf diese Weise erzwungen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-485">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="156f2-486">Die Initialisierungs Einstellung ist nur für das [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="156f2-486">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-487">Die Ereignisdaten, die die geänderte Eigenschaft beschreiben, einschließlich der alten und neuen Werte.</span><span class="sxs-lookup"><span data-stu-id="156f2-487">The event data that describes the property that changed, including the old and new values.</span></span></param>
        <summary><span data-ttu-id="156f2-488">Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.FrameworkContentElement" /> aktualisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-488">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span></span> <span data-ttu-id="156f2-489">Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet.</span><span class="sxs-lookup"><span data-stu-id="156f2-489">The specific dependency property that changed is reported in the arguments parameter.</span></span> <span data-ttu-id="156f2-490">Überschreibt <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-490">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-491">Diese Methode ist nicht dafür vorgesehen, Eigenschafts Änderungen oder-Invalidierungen in der Regel zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="156f2-491">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="156f2-492">Er ist stattdessen für Änderungen des allgemeinen invalidierungsmusters vorgesehen, wenn bestimmte Informationen über breite Klassifizierungen von Eigenschaften bekannt sind.</span><span class="sxs-lookup"><span data-stu-id="156f2-492">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="156f2-493">Diese Methode wird möglicherweise mehrmals während der Lebensdauer eines Objekts aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-493">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="156f2-494">Aus diesem Grund können Sie eine bessere Leistung erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und dann eine Verbindung mit den <xref:System.Windows.CoerceValueCallback> <xref:System.Windows.PropertyChangedCallback> einzelnen Eigenschaften anfügen.</span><span class="sxs-lookup"><span data-stu-id="156f2-494">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="156f2-495">Sie verwenden diese Methode jedoch, wenn eine <xref:System.Windows.FrameworkContentElement> eine beträchtliche Anzahl von Wert abhängigen Abhängigkeits Eigenschaften enthält, oder wenn Sie eine Logik wie das Renderingverhalten enthält, das für mehrere verwandte Fälle von Eigenschafts Invalidierungen erneut ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="156f2-495">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="156f2-496">Beachten Sie, dass es eine identisch benannte `OnPropertyChanged` Methode mit einer anderen Signatur gibt (der Parametertyp ist <xref:System.ComponentModel.PropertyChangedEventArgs> ), die für eine Reihe von Klassen angezeigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="156f2-496">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="156f2-497">Wird `OnPropertyChanged` für Datenobjekt Benachrichtigungen verwendet und ist Teil des Vertrags für <xref:System.ComponentModel.INotifyPropertyChanged> .</span><span class="sxs-lookup"><span data-stu-id="156f2-497">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="156f2-498">Nennen Sie die Basis Implementierung immer als ersten Vorgang in der Implementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-498">Always call the base implementation, as the first operation in your implementation.</span></span> <span data-ttu-id="156f2-499">Wenn dies nicht der Fall ist, wird das gesamte [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaften System erheblich deaktiviert, was dazu führt, dass falsche Werte gemeldet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-499">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle"><span data-ttu-id="156f2-500">Der alte Stil.</span><span class="sxs-lookup"><span data-stu-id="156f2-500">The old style.</span></span></param>
        <param name="newStyle"><span data-ttu-id="156f2-501">Der neue Stil.</span><span class="sxs-lookup"><span data-stu-id="156f2-501">The new style.</span></span></param>
        <summary><span data-ttu-id="156f2-502">Wird aufgerufen, wenn sich der aktuell verwendete Stil dieses Elements ändert.</span><span class="sxs-lookup"><span data-stu-id="156f2-502">Invoked when the style that is in use on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-503">Diese Methode verfügt über eine Standard Implementierung, die ein internes Flag festlegt, das die Formatvorlagen Änderung angibt.</span><span class="sxs-lookup"><span data-stu-id="156f2-503">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="156f2-504">Ruft immer die Basis Implementierung auf, andernfalls können Stile nicht angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-504">Always call the base implementation, otherwise styles cannot be applied.</span></span> <span data-ttu-id="156f2-505">Szenarios zum Überschreiben dieser Methode können einschließen, wenn die abgeleitete Klasse über einen spezialisierten stilselektor verfügt oder Stil Werte zwischenspeichert.</span><span class="sxs-lookup"><span data-stu-id="156f2-505">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span></span> <span data-ttu-id="156f2-506">Designänderungen können diese Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-506">Theme changes will potentially invoke this method.</span></span></para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-507">Stellt Daten über das Ereignis bereit.</span><span class="sxs-lookup"><span data-stu-id="156f2-507">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="156f2-508">Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" />-Routingereignis diese Klasse auf der Route erreicht.</span><span class="sxs-lookup"><span data-stu-id="156f2-508">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="156f2-509">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="156f2-509">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-510">Diese Methode hat keine Standard Implementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-510">This method has no default implementation.</span></span> <span data-ttu-id="156f2-511">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie weiterhin Base () aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-511">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="156f2-512">Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei \*-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="156f2-512">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="156f2-513">In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-513">In this case the matching event is a routed event.</span></span> <span data-ttu-id="156f2-514">Das Implementierungs Muster der on \*-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen).</span><span class="sxs-lookup"><span data-stu-id="156f2-514">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="156f2-515">Unterklassen von <xref:System.Windows.FrameworkContentElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-515">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="156f2-516">Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.</span><span class="sxs-lookup"><span data-stu-id="156f2-516">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="156f2-517">Stellt Daten über das Ereignis bereit.</span><span class="sxs-lookup"><span data-stu-id="156f2-517">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="156f2-518">Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" />-Routingereignis diese Klasse auf der Route erreicht.</span><span class="sxs-lookup"><span data-stu-id="156f2-518">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="156f2-519">Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="156f2-519">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-520">Diese Methode hat keine Standard Implementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-520">This method has no default implementation.</span></span> <span data-ttu-id="156f2-521">Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie weiterhin Base () aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="156f2-521">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="156f2-522">Der Zweck dieser Methode ähnelt dem [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei \*-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="156f2-522">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="156f2-523">In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-523">In this case the matching event is a routed event.</span></span> <span data-ttu-id="156f2-524">Das Implementierungs Muster der on \*-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszulösen).</span><span class="sxs-lookup"><span data-stu-id="156f2-524">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="156f2-525">Unterklassen von <xref:System.Windows.FrameworkContentElement> könnten private Klassen Handler-Methoden aufzurufen, wenn das Ereignis entlang der Route empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-525">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="156f2-526">Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.</span><span class="sxs-lookup"><span data-stu-id="156f2-526">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-527">Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element Stileigenschaften aus Designstilen enthält, oder legt diesen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-527">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span></span></summary>
        <value><span data-ttu-id="156f2-528"><see langword="true" />, wenn dieses Element keine Designstileigenschaften verwendet, alle auf Stile zurückgehenden Eigenschaften aus den Stilen lokaler Anwendungen stammen und die Designstileigenschaften nicht angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-528"><see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span></span> <span data-ttu-id="156f2-529"><see langword="false" />, wenn Anwendungsstile vor Designstilen auf Eigenschaften angewendet werden, die in Anwendungsstilen nicht explizit festgelegt wurden.</span><span class="sxs-lookup"><span data-stu-id="156f2-529"><see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-530">Die häufigste Verwendung dieser Eigenschaft ist eine indirekte Verwendung innerhalb des Setter eines Stils, der einen Stil mit Design bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="156f2-530">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-531">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-531">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-532">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-532">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="156f2-533">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-533">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-534">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-534">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-535">Ruft das übergeordnete Element in der logischen Struktur dieses Elements ab.</span><span class="sxs-lookup"><span data-stu-id="156f2-535">Gets the parent in the logical tree for this element.</span></span></summary>
        <value><span data-ttu-id="156f2-536">Das logische übergeordnete Element dieses Elements.</span><span class="sxs-lookup"><span data-stu-id="156f2-536">The logical parent for this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-537">Beachten Sie, dass das logische übergeordnete Element eines Elements je nach Anwendungs Funktionalität geändert werden kann, und wenn der Wert dieser Eigenschaft beibehalten wird, wird diese Änderung nicht widerspiegelt.</span><span class="sxs-lookup"><span data-stu-id="156f2-537">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="156f2-538">Sie sollten den Wert in der Regel direkt vor dem Bedarf erhalten.</span><span class="sxs-lookup"><span data-stu-id="156f2-538">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="156f2-539">Weitere Informationen zum Durchlaufen von logischen Strukturen finden Sie Unterstrukturen [in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf) und in den Szenarien, in denen diese Vorgehensweise bei der Ermittlung von Elementen sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-539">See [Trees in WPF](/dotnet/framework/wpf/advanced/trees-in-wpf) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="156f2-540">Das Eigenschaften System berechnet möglicherweise alle Eigenschaftswerte eines Elements neu, wenn es neu erstellt wird, da einige Eigenschaften Werte über die logische Struktur erben.</span><span class="sxs-lookup"><span data-stu-id="156f2-540">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="156f2-541">Das <xref:System.Windows.FrameworkContentElement.DataContext%2A> , das für Bindungen gilt, kann sich auch ändern, wenn Elemente neu zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-541">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="156f2-542">Das übergeordnete Element eines Elements wird in der Regel nur durch die Bearbeitung von Auflistungen, durch die Verwendung von dedizierten Add-und Remove-Methoden oder durch Festlegen von Inhalts Eigenschaften von Elementen erreicht</span><span class="sxs-lookup"><span data-stu-id="156f2-542">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="156f2-543">Das typische Szenario für die Verwendung der- <xref:System.Windows.FrameworkContentElement.Parent%2A> Eigenschaft ist das Abrufen eines Verweises und das anschließende Abrufen verschiedener <xref:System.Windows.FrameworkContentElement> Eigenschaftswerte aus dem übergeordneten Element.</span><span class="sxs-lookup"><span data-stu-id="156f2-543">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="156f2-544">Bei Vorlagen ist die <xref:System.Windows.FrameworkContentElement.Parent%2A> der Vorlage schließlich `null` .</span><span class="sxs-lookup"><span data-stu-id="156f2-544">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="156f2-545">Um diesen Punkt zu erreichen und in die logische Struktur auszudehnen, in der die Vorlage tatsächlich angewendet wird, verwenden Sie <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-545">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-546">Im folgenden Beispiel wird überprüft, ob der von einem <xref:System.Windows.FrameworkContentElement.Parent%2A> <xref:System.Windows.Documents.TextPointer> bestimmten Typ ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-546">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="156f2-547">Die Richtung, für die eine mögliche Fokusänderung bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-547">The direction for which a prospective focus change should be determined.</span></span></param>
        <summary><span data-ttu-id="156f2-548">Bestimmt das nächste Element, das relativ zu diesem Element den Fokus in einer angegebenen Fokusverschiebungsrichtung erhalten würde, verschiebt den Fokus jedoch nicht.</span><span class="sxs-lookup"><span data-stu-id="156f2-548">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span></span> <span data-ttu-id="156f2-549">Diese Methode ist versiegelt und kann nicht überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-549">This method is sealed and cannot be overridden.</span></span></summary>
        <returns><span data-ttu-id="156f2-550">Das nächste Element, auf das der Fokus verschoben würde, wenn der Fokus tatsächlich durchlaufen würde.</span><span class="sxs-lookup"><span data-stu-id="156f2-550">The next element that focus would move to if focus were actually traversed.</span></span> <span data-ttu-id="156f2-551">Kann <see langword="null" /> zurückgeben, wenn der Fokus für die bereitgestellte Richtung nicht relativ zu diesem Element verschoben werden kann.</span><span class="sxs-lookup"><span data-stu-id="156f2-551">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-552"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> ist die verwandte Methode, die den Fokus tatsächlich verschiebt.</span><span class="sxs-lookup"><span data-stu-id="156f2-552"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="156f2-553">Gibt eine der folgenden Richtungen im <see cref="T:System.Windows.Input.TraversalRequest" /> an: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-553">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span></span> <span data-ttu-id="156f2-554">Diese Richtungen sind für <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> unzulässig (aber für <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> zulässig).</span><span class="sxs-lookup"><span data-stu-id="156f2-554">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="156f2-555">Name für die angegebene Namensobjektzuordnung.</span><span class="sxs-lookup"><span data-stu-id="156f2-555">Name to use for the specified name-object mapping.</span></span></param>
        <param name="scopedElement"><span data-ttu-id="156f2-556">Objekt für die Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="156f2-556">Object for the mapping.</span></span></param>
        <summary><span data-ttu-id="156f2-557">Stellt einen Accessor bereit, der Zugriff auf die <see cref="T:System.Windows.NameScope" />-Registrierungsmethode vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="156f2-557">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-558">Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.NameScope.RegisterName%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-558">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="156f2-559">Die-Implementierung prüft aufeinander folgende übergeordnete Elemente, bis die entsprechende- <xref:System.Windows.NameScope> Implementierung gefunden wird, indem ein Element gefunden wird, das implementiert <xref:System.Windows.Markup.INameScope> .</span><span class="sxs-lookup"><span data-stu-id="156f2-559">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="156f2-560">Weitere Informationen zu Namescopes finden Sie unter [WPF-XAML-Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).</span><span class="sxs-lookup"><span data-stu-id="156f2-560">For more information about namescopes, see [WPF XAML Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).</span></span>  
  
 <span data-ttu-id="156f2-561"><xref:System.Windows.FrameworkContentElement.RegisterName%2A>Der Aufruf von ist erforderlich, um Animations Storyboards für Anwendungen ordnungsgemäß zu verbinden, wenn Sie im Code erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-561">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="156f2-562">Dies liegt daran, dass eine der Schlüssel Storyboard-Eigenschaften, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> , eine Lauf Zeit Namenssuche verwendet, anstatt einen Verweis auf ein Ziel Element zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="156f2-562">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="156f2-563">Dies gilt auch dann, wenn auf dieses Element durch einen Verweis aus dem Code zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="156f2-563">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="156f2-564">Weitere Informationen dazu, warum Sie Namen für Storyboard-Ziele registrieren müssen, finden Sie unter [Übersicht über Storyboards](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-564">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview).</span></span> <span data-ttu-id="156f2-565">Animationen für Inhaltselemente sind weniger häufig als Animationen für Steuerelemente, die [Übersicht über Storyboards](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview) konzentriert sich auf Steuerungs Szenarios.</span><span class="sxs-lookup"><span data-stu-id="156f2-565">Animations for content elements are less common than animations on controls, the [Storyboards Overview](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="156f2-566">Das zu entfernende Element.</span><span class="sxs-lookup"><span data-stu-id="156f2-566">The element to remove.</span></span></param>
        <summary><span data-ttu-id="156f2-567">Entfernt das angegebene Element aus der logischen Struktur dieses Elements.</span><span class="sxs-lookup"><span data-stu-id="156f2-567">Removes the specified element from the logical tree for this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-568">Diese API ist hauptsächlich für Klassen abgeleitete Szenarien relevant, wenn Unterstützung für untergeordnete Sammlungen hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-568">This API is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="156f2-569">Die meisten <xref:System.Windows.FrameworkContentElement> abgeleiteten Klassen machen dedizierte Auflistungen verfügbar, die für die Kapselung verantwortlich sind (z <xref:System.Windows.Documents.Span.Inlines%2A> . b. für die- <xref:System.Windows.Documents.Span> Klasse <xref:System.Windows.Documents.Section.Blocks%2A> <xref:System.Windows.Documents.Section> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-569">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="156f2-570">Das Ableiten von solchen Klassen kann in der Regel vermeiden, dass die logische Struktur direkt manipuliert werden muss.</span><span class="sxs-lookup"><span data-stu-id="156f2-570">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Windows.Markup.Ambient]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.Ambient&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-571">Ruft das aktuelle lokal definierte Ressourcenwörterbuch ab oder legt es fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-571">Gets or sets the current locally-defined resource dictionary.</span></span></summary>
        <value><span data-ttu-id="156f2-572">Die aktuellen lokal definierten Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="156f2-572">The current locally-defined resources.</span></span> <span data-ttu-id="156f2-573">Dies ist ein Wörterbuch von Ressourcen, wobei auf Ressourcen innerhalb des Wörterbuchs über Schlüssel zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-573">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-574">Ressourcen Wörterbücher, die vollständig oder teilweise in definiert werden können [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] , werden in der Regel als Eigenschafts Element erstellt und befinden sich in der Regel im Stamm Element für jede einzelne Seite oder für die Anwendung.</span><span class="sxs-lookup"><span data-stu-id="156f2-574">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="156f2-575">Wenn Sie das Ressourcen Wörterbuch auf dieser Ebene platzieren, ist es leichter, von einzelnen untergeordneten Elementen auf der Seite zu suchen (oder von einer beliebigen Seite im Anwendungsfall).</span><span class="sxs-lookup"><span data-stu-id="156f2-575">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="156f2-576">In den meisten Anwendungsszenarien empfiehlt es sich, Stile als Objekt Elemente innerhalb eines Ressourcen Wörterbuchs zu definieren oder als externe Ressourcen festgelegt zu werden, damit die gesamte Stil Ressource eigenständig sein kann (dieser Ansatz hilft bei der Trennung der Designer Zuständigkeiten von Entwickler Zuständigkeiten durch die Trennung der physischen Dateien, die bearbeitet werden müssen).</span><span class="sxs-lookup"><span data-stu-id="156f2-576">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="156f2-577">Beachten Sie, dass diese Eigenschaft nur das direkt in diesem Element deklarierte Ressourcen Wörterbuch zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="156f2-577">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="156f2-578">Dies unterscheidet sich von dem tatsächlichen Ressourcen Suchprozess, bei dem ein untergeordnetes Element auf alle Ressourcen zugreifen kann, die in den einzelnen übergeordneten Elementen definiert sind, wobei die Suche rekursiv nach oben erfolgt.</span><span class="sxs-lookup"><span data-stu-id="156f2-578">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="156f2-579">Auf Ressourcen kann auch durch Code aus der Auflistung verwiesen werden, aber beachten Sie, dass die in erstellten Ressourcen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] auf jeden Fall erst zugänglich sind, nachdem <xref:System.Windows.FrameworkContentElement.Loaded> das Element, das das Wörterbuch deklariert, ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-579">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="156f2-580">Tatsächlich werden Ressourcen asynchron analysiert, und nicht einmal das <xref:System.Windows.FrameworkContentElement.Loaded> Ereignis ist eine Zusicherung, dass Sie auf eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definierte Ressource verweisen können.</span><span class="sxs-lookup"><span data-stu-id="156f2-580">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="156f2-581">Aus diesem Grund sollten Sie im Allgemeinen nur [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] im Rahmen des Lauf Zeit Codes oder über andere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Techniken wie Stile oder Ressourcen Erweiterungs Verweise für Attributwerte auf definierte Ressourcen zugreifen.</span><span class="sxs-lookup"><span data-stu-id="156f2-581">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="156f2-582">Wenn Sie über Code auf Ressourcen zugreifen, entspricht dies im Wesentlichen einem [DynamicResource](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) -Verweis aus [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="156f2-582">When you access resources through code, it is essentially equivalent to a [DynamicResource](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="156f2-583">Der zugrunde liegende <xref:System.Windows.ResourceDictionary> unterstützt die Methoden, die zum Hinzufügen, entfernen oder Abfragen von Ressourcen innerhalb der Sammlung mithilfe von Code erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="156f2-583">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="156f2-584">Die- <xref:System.Windows.FrameworkContentElement.Resources%2A> Eigenschaft kann festgelegt werden, um das Szenario zu unterstützen, mit dem die Ressourcen Auflistung eines Elements vollständig ersetzt werden kann <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-584">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="156f2-585">Beachten Sie, dass die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] angezeigte Syntax kein-Element für enthält <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-585">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="156f2-586">Dies ist ein Beispiel für eine implizite Auflistungs Syntax. ein Tag, das das Auflistungs Element darstellt, kann weggelassen werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-586">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="156f2-587">Stattdessen werden die Elemente angegeben, die der Auflistung als Elemente hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-587">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="156f2-588">Weitere Informationen zu impliziten Auflistungen und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] finden Sie [in der XAML-Syntax im Detail](/dotnet/framework/wpf/advanced/xaml-syntax-in-detail).</span><span class="sxs-lookup"><span data-stu-id="156f2-588">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](/dotnet/framework/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="156f2-589">Ein Fall, bei dem a <xref:System.Windows.ResourceDictionary> weiterhin explizit als Element angegeben wird, ist, wenn Sie ein zusammen geführtes Wörterbuch einführen. in diesem Fall gibt es in der Regel keine untergeordneten Elemente <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-589">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="156f2-590">Weitere Informationen finden Sie unter [zusammengeführte Ressourcen Wörterbücher](/dotnet/framework/wpf/advanced/merged-resource-dictionaries).</span><span class="sxs-lookup"><span data-stu-id="156f2-590">For details, see [Merged Resource Dictionaries](/dotnet/framework/wpf/advanced/merged-resource-dictionaries).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="156f2-591">Verwendung von XAML-Eigenschaftenelementen</span><span class="sxs-lookup"><span data-stu-id="156f2-591">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="156f2-592">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="156f2-592">XAML Values</span></span>  
 <span data-ttu-id="156f2-593">*oneormoreresourceelements*</span><span class="sxs-lookup"><span data-stu-id="156f2-593">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="156f2-594">Ein oder mehrere Objekt Elemente, von denen jede eine Ressource definiert.</span><span class="sxs-lookup"><span data-stu-id="156f2-594">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="156f2-595">Jedes Ressourcen Eigenschaften Element <xref:System.Windows.ResourceDictionary> muss über einen eindeutigen Wert für die [x:Key-Direktive](/dotnet/framework/xaml-services/x-key-directive)verfügen, der als eindeutiger Schlüssel fungiert, wenn Werte aus dem abgerufen werden <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-595">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](/dotnet/framework/xaml-services/x-key-directive), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-596">Im folgenden Beispiel wird eine-Auflistung <xref:System.Windows.FrameworkContentElement.Resources%2A> für ein root-Element festgelegt <xref:System.Windows.Documents.FlowDocument> .</span><span class="sxs-lookup"><span data-stu-id="156f2-596">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="156f2-597"><xref:System.Windows.Documents.FlowDocument> ist eine typische Wahl, da es sich hierbei um eine der wenigen <xref:System.Windows.FrameworkContentElement> Klassen handelt, die als Stamm Element sinnvoll sind, und Ressourcen werden im Allgemeinen im Seiten Stamm oder auf noch höheren Ebenen wie in der Anwendung gespeichert.</span><span class="sxs-lookup"><span data-stu-id="156f2-597"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="156f2-598">Ordnet eine Bindung zu diesem Element für die angegebene Abhängigkeitseigenschaft zu.</span><span class="sxs-lookup"><span data-stu-id="156f2-598">Attaches a binding to this element for the specified dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="156f2-599">Bezeichnet die gebundene Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-599">Identifies the bound property.</span></span></param>
        <param name="path"><span data-ttu-id="156f2-600">Der Name der Quelleigenschaft oder der Pfad zu der für die Bindung verwendeten Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-600">The source property name or the path to the property used for the binding.</span></span></param>
        <summary><span data-ttu-id="156f2-601">Fügt auf der Grundlage des bereitgestellten Namens der Quelleigenschaft als Pfadangabe zur Datenquelle eine Bindung an dieses Element an.</span><span class="sxs-lookup"><span data-stu-id="156f2-601">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span></span></summary>
        <returns><span data-ttu-id="156f2-602">Zeichnet die Bedingungen der Bindung auf.</span><span class="sxs-lookup"><span data-stu-id="156f2-602">Records the conditions of the binding.</span></span> <span data-ttu-id="156f2-603">Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="156f2-603">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-604">Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType> , die die aktuelle-Instanz als übergibt <xref:System.Windows.DependencyObject> und eine neue auf <xref:System.Windows.Data.Binding> der Grundlage des bereitgestellten `path` Parameters erstellt.</span><span class="sxs-lookup"><span data-stu-id="156f2-604">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="156f2-605">Diese Signatur ist bequemer, wenn Sie eine einfache Standard Bindung einrichten.</span><span class="sxs-lookup"><span data-stu-id="156f2-605">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="156f2-606">Wenn Sie Bindungseigenschaften für nicht standardmäßige Bedingungen angeben müssen oder oder verwenden möchten <xref:System.Windows.Data.MultiBinding> <xref:System.Windows.Data.PriorityBinding> , sollten Sie die <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> Signatur verwenden.</span><span class="sxs-lookup"><span data-stu-id="156f2-606">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-607">Im folgenden Beispiel wird eine Bindung für ein- <xref:System.Windows.Documents.Paragraph> Element festgelegt, indem ein neues benutzerdefiniertes Datenobjekt erstellt, das Objekt als festgelegt <xref:System.Windows.FrameworkContentElement.DataContext%2A> wird und der Bindungs Pfad auf eine Eigenschaft innerhalb des-Objekts festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-607">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="156f2-608">Bezeichnet die gebundene Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-608">Identifies the bound property.</span></span></param>
        <param name="binding"><span data-ttu-id="156f2-609">Stellt eine Datenbindung dar.</span><span class="sxs-lookup"><span data-stu-id="156f2-609">Represents a data binding.</span></span></param>
        <summary><span data-ttu-id="156f2-610">Fügt auf der Grundlage des bereitgestellten Bindungsobjekts eine Bindung an dieses Element an.</span><span class="sxs-lookup"><span data-stu-id="156f2-610">Attaches a binding to this element, based on the provided binding object.</span></span></summary>
        <returns><span data-ttu-id="156f2-611">Zeichnet die Bedingungen der Bindung auf.</span><span class="sxs-lookup"><span data-stu-id="156f2-611">Records the conditions of the binding.</span></span> <span data-ttu-id="156f2-612">Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="156f2-612">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-613">Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType> , die die aktuelle-Instanz als übergibt <xref:System.Windows.DependencyObject> .</span><span class="sxs-lookup"><span data-stu-id="156f2-613">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-614">Im folgenden Beispiel wird eine Bindung für ein- <xref:System.Windows.Documents.Paragraph> Element festgelegt, indem ein neuer erstellt <xref:System.Windows.Data.Binding> und die Quelle auf ein neu erstelltes Objekt festgelegt wird `DateTime` .</span><span class="sxs-lookup"><span data-stu-id="156f2-614">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="156f2-615">Die Eigenschaft, an die die Ressource gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-615">The property to which the resource is bound.</span></span></param>
        <param name="name"><span data-ttu-id="156f2-616">Der Name der Ressource.</span><span class="sxs-lookup"><span data-stu-id="156f2-616">The name of the resource.</span></span></param>
        <summary><span data-ttu-id="156f2-617">Sucht eine Ressource mit dem angegebenen Namen und richtet einen entsprechenden Ressourcenverweis für die angegebene Eigenschaft ein.</span><span class="sxs-lookup"><span data-stu-id="156f2-617">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-618">Ein Ressourcen Verweis ähnelt der Verwendung einer [dynamikresource-Markup Erweiterung](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) im Markup.</span><span class="sxs-lookup"><span data-stu-id="156f2-618">A resource reference is similar to the use of a [DynamicResource Markup Extension](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) in markup.</span></span> <span data-ttu-id="156f2-619">Der Ressourcen Verweis erstellt einen internen Ausdruck, der den Wert der angegebenen Eigenschaft für eine verzögerte Laufzeit bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="156f2-619">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="156f2-620">Der Ausdruck wird immer dann erneut ausgewertet, wenn das Ressourcen Wörterbuch einen geänderten Wert durch interne Ereignisse angibt oder wenn das aktuelle Element neu erstellt wird (eine übergeordnete Änderung würde den Pfad für die Wörterbuchsuche ändern).</span><span class="sxs-lookup"><span data-stu-id="156f2-620">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-621">Gibt zurück, ob in Serialisierungsprozessen der Inhalt der <see cref="P:System.Windows.FrameworkContentElement.Resources" />-Eigenschaft für Instanzen dieser Klasse serialisiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-621">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="156f2-622"><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkContentElement.Resources" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-622"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-623">Dies wird zurückgegeben, solange mindestens eine Schlüssel gebundene `true` Ressource im lokalen vorhanden ist <xref:System.Windows.FrameworkContentElement.Resources%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-623">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-624">Gibt zurück, ob in Serialisierungsprozessen der Inhalt der <see cref="P:System.Windows.FrameworkContentElement.Style" />-Eigenschaft für Instanzen dieser Klasse serialisiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-624">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="156f2-625"><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkContentElement.Style" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-625"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-626">Dies wird zurückgegeben, `true` Wenn <xref:System.Windows.Style> lokal festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-626">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-627">Tritt ein, wenn sich eine zugeordnete Datenquelle, die an einer Bindung dieses Elements teilnimmt, ändert.</span><span class="sxs-lookup"><span data-stu-id="156f2-627">Occurs when any associated data source participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-628">Dieses Ereignis zeigt das <xref:System.Windows.Data.Binding.SourceUpdated> Ereignis an, das von einem beliebigen ausgelöst wird, <xref:System.Windows.Data.Binding> das diesem Element zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-628">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="156f2-629">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="156f2-629">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-630">Ruft den Stil ab, der von diesem Element verwendet werden soll, oder legt ihn fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-630">Gets or sets the style to be used by this element.</span></span></summary>
        <value><span data-ttu-id="156f2-631">Der übernommene und nicht dem Standardstil entsprechende Stil für das Element, wenn ein Stil vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-631">The applied, nondefault style for the element, if present.</span></span> <span data-ttu-id="156f2-632">Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-632">Otherwise, <see langword="null" />.</span></span> <span data-ttu-id="156f2-633">Der Standardwert für ein mit den Standardwerten konstruiertes <see cref="T:System.Windows.FrameworkContentElement" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-633">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-634">Der aktuelle Stil wird häufig von einem Standardstil aus Design oder von Stilen bereitgestellt, die in der Regel durch Ressourcen auf der Seiten-oder Anwendungsebene (ein implizites Format) auf Objekte dieses Typs angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-634">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="156f2-635">Diese Eigenschaft legt Standard Stile (Theme) nicht fest oder gibt Sie zurück, aber Sie gibt den impliziten Stil oder einen expliziten Stil zurück.</span><span class="sxs-lookup"><span data-stu-id="156f2-635">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="156f2-636">Im Fall impliziter oder expliziter Stile spielt es keine Rolle, ob auf den Stil als Ressource zugegriffen oder lokal definiert ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-636">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="156f2-637">Das Festlegen der Stile hat einige Einschränkungen.</span><span class="sxs-lookup"><span data-stu-id="156f2-637">Setting the styles has some restrictions.</span></span> <span data-ttu-id="156f2-638">Sie können die gesamte <xref:System.Windows.FrameworkContentElement.Style%2A> Eigenschaft zu einem beliebigen Zeitpunkt auf einen neuen zurücksetzen <xref:System.Windows.Style> , wodurch eine Neukomposition des Layouts erzwungen wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-638">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="156f2-639">Sobald dieser Stil jedoch von einem geladenen Element verwendet wird, <xref:System.Windows.Style> sollte als versiegelt angesehen werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-639">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="156f2-640">Der Versuch, eine Änderung an einer einzelnen Eigenschaft eines in Gebrauch verwendeten Stils vorzunehmen (z. b. in der Auflistung von <xref:System.Windows.Style.Setters%2A> ), bewirkt, dass eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-640">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="156f2-641">Ein Stil, der im Markup definiert ist, wird als in Gebrauch betrachtet, sobald er aus einem Ressourcen Wörterbuch (für Ressourcen) geladen wird, oder wenn die in enthaltene Seite geladen wird (für Inline Stile).</span><span class="sxs-lookup"><span data-stu-id="156f2-641">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="156f2-642"><xref:System.Windows.FrameworkContentElement.Style%2A> ist eine Abhängigkeits Eigenschaft mit spezieller Rangfolge.</span><span class="sxs-lookup"><span data-stu-id="156f2-642"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="156f2-643">Der lokal festgelegte Stil arbeitet im Allgemeinen mit der höchsten Rangfolge im Eigenschaften System.</span><span class="sxs-lookup"><span data-stu-id="156f2-643">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="156f2-644">Wenn <xref:System.Windows.FrameworkContentElement.Style%2A> an dieser Stelle NULL ist, prüft beim Laden des Eigenschaften Systems beim Laden auf implizite Stile als definierte Ressourcen, die diesen Typ angeben.</span><span class="sxs-lookup"><span data-stu-id="156f2-644">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="156f2-645">Wenn der Stil nach diesem Schritt immer noch NULL ist, wird der Stil aus dem Standardformat (Design) abgeleitet, aber der Standardstil wird nicht im <xref:System.Windows.FrameworkContentElement.Style%2A> Eigenschafts Wert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="156f2-645">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="156f2-646">Siehe [Wert Rangfolge der Abhängigkeits Eigenschaft](/dotnet/framework/wpf/advanced/dependency-property-value-precedence).</span><span class="sxs-lookup"><span data-stu-id="156f2-646">See [Dependency Property Value Precedence](/dotnet/framework/wpf/advanced/dependency-property-value-precedence).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="156f2-647">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="156f2-647">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="156f2-648">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="156f2-648">XAML Values</span></span>  
 <span data-ttu-id="156f2-649">*resourceextension*</span><span class="sxs-lookup"><span data-stu-id="156f2-649">*resourceExtension*</span></span>  
 <span data-ttu-id="156f2-650">Eines der folgenden:, oder.</span><span class="sxs-lookup"><span data-stu-id="156f2-650">One of the following: , or .</span></span> <span data-ttu-id="156f2-651">Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).</span><span class="sxs-lookup"><span data-stu-id="156f2-651">See [XAML Resources](/dotnet/framework/wpf/advanced/xaml-resources).</span></span>  
  
 <span data-ttu-id="156f2-652">*styleresourcekey*</span><span class="sxs-lookup"><span data-stu-id="156f2-652">*styleResourceKey*</span></span>  
 <span data-ttu-id="156f2-653">Der Schlüssel, der den angeforderten Stil bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="156f2-653">The key that identifies the style being requested.</span></span> <span data-ttu-id="156f2-654">Der Schlüssel verweist auf eine vorhandene Ressource in einer <xref:System.Windows.ResourceDictionary> .</span><span class="sxs-lookup"><span data-stu-id="156f2-654">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="156f2-655">Die Syntax von Eigenschafts Elementen ist technisch möglich, wird jedoch nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="156f2-655">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="156f2-656">Weitere Informationen finden Sie unter [Inline Stile und Vorlagen](/dotnet/framework/wpf/advanced/inline-styles-and-templates).</span><span class="sxs-lookup"><span data-stu-id="156f2-656">See [Inline Styles and Templates](/dotnet/framework/wpf/advanced/inline-styles-and-templates).</span></span>  <span data-ttu-id="156f2-657">Ein Bindungs Verweis mit [TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension) oder <xref:System.Windows.Data.Binding> ist ebenfalls möglich, aber nicht üblich.</span><span class="sxs-lookup"><span data-stu-id="156f2-657">A binding reference using [TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension) or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-658">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-658">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-659">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-659">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="156f2-660">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-660">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-661">Im folgenden Beispiel wird eine <xref:System.Windows.FrameworkContentElement.Resources%2A> -Auflistung für ein <xref:System.Windows.Documents.FlowDocument> root-Element erstellt und dann als eine Ressource in einem bestimmten Stil für ein-Element darauf verwiesen <xref:System.Windows.Documents.Paragraph> .</span><span class="sxs-lookup"><span data-stu-id="156f2-661">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-662">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.Style" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-662">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="frameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName"><span data-ttu-id="156f2-663">Der Name der angeforderten Ambient-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-663">The name of the requested ambient property.</span></span></param>
        <summary><span data-ttu-id="156f2-664">Eine Beschreibung dieses Members finden Sie unter der <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />-Methode.</span><span class="sxs-lookup"><span data-stu-id="156f2-664">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span></span></summary>
        <returns><span data-ttu-id="156f2-665"><see langword="true" />, wenn <paramref name="propertyName" /> verfügbar ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-665"><see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-666">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-666">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="156f2-667">Er kann nur verwendet werden, wenn die <xref:System.Windows.FrameworkContentElement>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-667">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-668">Ruft einen beliebigen Objektwert ab, der zum Speichern von benutzerdefinierten Informationen zu diesem Element verwendet werden kann, bzw. legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-668">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span></span></summary>
        <value><span data-ttu-id="156f2-669">Der vorgesehene Wert.</span><span class="sxs-lookup"><span data-stu-id="156f2-669">The intended value.</span></span> <span data-ttu-id="156f2-670">Diese Eigenschaft hat keinen Standardwert.</span><span class="sxs-lookup"><span data-stu-id="156f2-670">This property has no default value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-671">Diese Eigenschaft entspricht den Tageigenschaften in anderen Microsoft-Programmier Modellen, wie z. b. Visual Basic for Applications oder Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="156f2-671">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="156f2-672">Es soll eine bereits vorhandene Stelle bereitstellen, um einige grundlegende benutzerdefinierte Informationen zu einem Element zu speichern, ohne dass Anwendungsentwickler zu einer Unterklasse gezwungen werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-672">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="156f2-673">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="156f2-673">XAML Values</span></span>  
 <span data-ttu-id="156f2-674">Da diese Eigenschaft ein Objekt annimmt, müssen Sie die Verwendung des Eigenschafts Elements verwenden, um die <xref:System.Windows.FrameworkContentElement.Tag%2A> -Eigenschaft in XAML auf einen anderen Wert als ein Objekt mit einem bekannten und integrierten Typkonverter (z. b. eine Zeichenfolge) festzulegen.</span><span class="sxs-lookup"><span data-stu-id="156f2-674">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="156f2-675">Objekte, die auf diese Weise verwendet werden, befinden sich in der Regel nicht innerhalb der standardmäßigen WPF-Namespaces und erfordern daher möglicherweise eine Namespace Zuordnung zum externen Namespace, um als XAML-Elemente eingeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-675">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-676">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-676">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-677">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-677">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="156f2-678">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-678">Metadata properties set to `true`</span></span>|<span data-ttu-id="156f2-679">Keine</span><span class="sxs-lookup"><span data-stu-id="156f2-679">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-680">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.Tag" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-680">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-681">Tritt auf, wenn eine zugeordnete Zieleigenschaft, die Teil einer Bindung dieses Elements ist, geändert wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-681">Occurs when any associated target property participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-682">Dieses Ereignis zeigt das <xref:System.Windows.Data.Binding.TargetUpdated> Ereignis an, das von einem beliebigen ausgelöst wird, <xref:System.Windows.Data.Binding> das diesem Element zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-682">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="156f2-683">Dies bedeutet in der Regel, dass es sich bei der fraglichen Bindung um eine bidirektionale Bindung handelt und dass die gebundene Abhängigkeits Eigenschaft jede Validierung oder jedes zwischen Speicherungs Schema, die von der-Eigenschaft unterstützt wird, als ungültig erklärt.</span><span class="sxs-lookup"><span data-stu-id="156f2-683">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="156f2-684">Die Ereignis Argumente dieses Ereignisses informieren Sie darüber, welche gebundene Eigenschaft geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-684">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="156f2-685">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="156f2-685">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-686">Ruft einen Verweis auf die übergeordnete Vorlage dieses Elements ab.</span><span class="sxs-lookup"><span data-stu-id="156f2-686">Gets a reference to the template parent of this element.</span></span> <span data-ttu-id="156f2-687">Diese Eigenschaft ist nicht relevant, wenn das Element nicht durch eine Vorlage erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-687">This property is not relevant if the element was not created through a template.</span></span></summary>
        <value><span data-ttu-id="156f2-688">Das Element, dessen <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> die Erstellung dieses Elements verursacht hat.</span><span class="sxs-lookup"><span data-stu-id="156f2-688">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span></span> <span data-ttu-id="156f2-689">Dieser Wert ist häufig <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="156f2-689">This value is frequently <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-690">Vorlagen sind tatsächlich freigegebene Objekte, bei denen der Inhalt der Vorlage nur einmal erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-690">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="156f2-691">Wenn Sie also einen Objekt Verweis auf ein Element erhalten, das aus einer Vorlage stammt, können Sie feststellen, dass die sichtbare logische Struktur nicht zum Seiten Stamm gelangt.</span><span class="sxs-lookup"><span data-stu-id="156f2-691">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="156f2-692">Um einen solchen Vorlagen Verweis mit der logischen Struktur der Seite zu verbinden, sollten Sie den Wert erhalten <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> und weiterhin in der gewünschten Elementstruktur navigieren.</span><span class="sxs-lookup"><span data-stu-id="156f2-692">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="156f2-693"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> wird häufig `null` für gängige Objekte verwendet, denn wenn Sie einen Objekt Verweis von einer Seite in der Anwendung über das übliche Mittel erhalten haben, wurde dieses Element wahrscheinlich nicht aus einer Vorlage erstellt.</span><span class="sxs-lookup"><span data-stu-id="156f2-693"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="156f2-694">Fälle, in denen <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> möglicherweise keine `null` Vorgänge wie z. b. Treffer Tests, Ereignis Behandlung für bestimmte Low-Level-Eingabeereignisse oder die Arbeit mit Enumeratoren enthalten, die möglicherweise Elemente zurückgegeben haben, die aus Vorlagen stammen.</span><span class="sxs-lookup"><span data-stu-id="156f2-694">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Bindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Category("Appearance")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Appearance")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-695">Ruft das QuickInfo-Objekt ab, das für dieses Element in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] angezeigt wird, oder legt dieses Objekt fest.</span><span class="sxs-lookup"><span data-stu-id="156f2-695">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="156f2-696">Das QuickInfo-Objekt.</span><span class="sxs-lookup"><span data-stu-id="156f2-696">The tooltip object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-697">Wenn der Wert dieser Eigenschaft vom Typ ist <xref:System.Windows.Controls.ToolTip> , dann ist dies die QuickInfo, die in der verwendet wird [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="156f2-697">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="156f2-698">Wenn der Wert eines beliebigen anderen Typs ist, wird dieser Wert als *Inhalt* für eine <xref:System.Windows.Controls.ToolTip> bereitgestellte (erstellte) vom System verwendet.</span><span class="sxs-lookup"><span data-stu-id="156f2-698">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="156f2-699">Weitere Informationen finden Sie unter <xref:System.Windows.Controls.ToolTipService>.</span><span class="sxs-lookup"><span data-stu-id="156f2-699">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="156f2-700">Die Dienstklasse stellt angefügte Eigenschaften bereit, die verwendet werden können, um eine QuickInfo weiter anzupassen.</span><span class="sxs-lookup"><span data-stu-id="156f2-700">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="156f2-701">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="156f2-701">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="156f2-702">Verwendung von XAML-Eigenschaftenelementen</span><span class="sxs-lookup"><span data-stu-id="156f2-702">XAML Property Element Usage</span></span>  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
```

<span data-ttu-id="156f2-703">- oder -</span><span class="sxs-lookup"><span data-stu-id="156f2-703">-or-</span></span>

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```

<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="156f2-704">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="156f2-704">XAML Values</span></span>  
 <span data-ttu-id="156f2-705">*tooltipcontent*</span><span class="sxs-lookup"><span data-stu-id="156f2-705">*toolTipContent*</span></span>  
 <span data-ttu-id="156f2-706">Eine Zeichenfolge, die zum Anzeige Text für die wird <xref:System.Windows.FrameworkContentElement.ToolTip%2A> .</span><span class="sxs-lookup"><span data-stu-id="156f2-706">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="156f2-707">*tooltipobjectcontent*</span><span class="sxs-lookup"><span data-stu-id="156f2-707">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="156f2-708">Ein im Objekt Element Formular bereitgestelltes Objekt, das als Inhalt für den verwendet werden soll <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="156f2-708">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="156f2-709">In der Regel handelt es sich dabei um ein- <xref:System.Windows.FrameworkElement> Element oder ein anderes Element, das layoutcompositing für den erstellt <xref:System.Windows.FrameworkContentElement.ToolTip%2A> und schließlich Textinhalte innerhalb der Zusammensetzung enthält.</span><span class="sxs-lookup"><span data-stu-id="156f2-709">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="156f2-710">In dieser Verwendung wird das <xref:System.Windows.Controls.ToolTip> Element implizit aus dem analysierten erstellt [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , und der *tooltipobjectcontent* -Inhalt wird als seine-Eigenschaft festgelegt <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="156f2-710">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="156f2-711"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="156f2-711"><`ToolTip` .../></span></span>  
 <span data-ttu-id="156f2-712">Siehe <xref:System.Windows.Controls.ToolTip>.</span><span class="sxs-lookup"><span data-stu-id="156f2-712">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="156f2-713">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="156f2-713">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-714">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-714">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="156f2-715">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="156f2-715">Metadata properties set to `true`</span></span>|<span data-ttu-id="156f2-716">Keine</span><span class="sxs-lookup"><span data-stu-id="156f2-716">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="156f2-717">Im folgenden Beispiel wird der Wert der- <xref:System.Windows.FrameworkElement.ToolTip%2A> Eigenschaft direkt auf eine Zeichenfolge festgelegt.</span><span class="sxs-lookup"><span data-stu-id="156f2-717">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-718">Tritt unmittelbar vor dem Schließen einer QuickInfo über dem Element ein.</span><span class="sxs-lookup"><span data-stu-id="156f2-718">Occurs just before any tooltip on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-719">Um das Schließen der QuickInfo zu unterdrücken, sollten Handler des Ereignisses ihn als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="156f2-719">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="156f2-720">Dieses Ereignis darf nicht <xref:System.Windows.EventTrigger> in einem Stil sein.</span><span class="sxs-lookup"><span data-stu-id="156f2-720">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="156f2-721">Dies liegt daran, dass das Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst wieder verwendet, der keine Add/Remove-Methoden für das Ereignis verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="156f2-721">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="156f2-722">Informationen zum Routingereignis</span><span class="sxs-lookup"><span data-stu-id="156f2-722">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-723">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-723">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="156f2-724">Routing Strategie</span><span class="sxs-lookup"><span data-stu-id="156f2-724">Routing strategy</span></span>|<span data-ttu-id="156f2-725">Direkt</span><span class="sxs-lookup"><span data-stu-id="156f2-725">Direct</span></span>|  
|<span data-ttu-id="156f2-726">Delegat</span><span class="sxs-lookup"><span data-stu-id="156f2-726">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-727">Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Übersicht über Routingereignisse](/dotnet/framework/wpf/advanced/routed-events-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-727">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-728">Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-728">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="156f2-729">Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-729">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-730">Tritt beim Öffnen einer QuickInfo im Element auf.</span><span class="sxs-lookup"><span data-stu-id="156f2-730">Occurs when any tooltip on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-731">Um Quick Infos manuell zu öffnen, sollten die Handler der Ereignisse das relevante Ereignis als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="156f2-731">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="156f2-732">Andernfalls wird der Wert der- <xref:System.Windows.FrameworkContentElement.ToolTip%2A> Eigenschaft verwendet, um automatisch ein Kontextmenü zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="156f2-732">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="156f2-733">Wenn das Ereignis behandelt wird, wird die Standardaktion effektiv abgebrochen, und es kann eine Gelegenheit sein, den Wert der Eigenschaft zurückzusetzen <xref:System.Windows.FrameworkContentElement.ToolTip%2A> und dann die neue zu öffnen <xref:System.Windows.Controls.ContextMenu> .</span><span class="sxs-lookup"><span data-stu-id="156f2-733">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="156f2-734">Beachten Sie, dass dieses Ereignis nicht ausgelöst wird, wenn <xref:System.Windows.FrameworkContentElement.ToolTip%2A> ein NULL-Verweis oder anderweitig nicht festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="156f2-734">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="156f2-735">Dieses Ereignis darf nicht <xref:System.Windows.EventTrigger> in einem Stil sein.</span><span class="sxs-lookup"><span data-stu-id="156f2-735">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="156f2-736">Dies liegt daran, dass das Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst wieder verwendet, der keine Add/Remove-Methoden für das Ereignis verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="156f2-736">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="156f2-737">Informationen zum Routingereignis</span><span class="sxs-lookup"><span data-stu-id="156f2-737">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-738">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-738">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="156f2-739">Routing Strategie</span><span class="sxs-lookup"><span data-stu-id="156f2-739">Routing strategy</span></span>|<span data-ttu-id="156f2-740">Direkt</span><span class="sxs-lookup"><span data-stu-id="156f2-740">Direct</span></span>|  
|<span data-ttu-id="156f2-741">Delegat</span><span class="sxs-lookup"><span data-stu-id="156f2-741">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-742">Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Übersicht über Routingereignisse](/dotnet/framework/wpf/advanced/routed-events-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-742">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-743">Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-743">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="156f2-744">Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-744">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-745">Bezeichnet die <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="156f2-745">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="156f2-746">Der Schlüsselbezeichner der zu findenden Ressource.</span><span class="sxs-lookup"><span data-stu-id="156f2-746">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="156f2-747">Sucht nach einer Ressource mit dem angegebenen Schlüssel und gibt diese Ressource zurück, sofern sie gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="156f2-747">Searches for a resource with the specified key, and returns that resource if found.</span></span></summary>
        <returns><span data-ttu-id="156f2-748">Die gefundene Ressource.</span><span class="sxs-lookup"><span data-stu-id="156f2-748">The found resource.</span></span> <span data-ttu-id="156f2-749">Wenn keine Ressource gefunden wurde, wird <see langword="null" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="156f2-749">If no resource was found, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-750">Wenn die Ressource im aufrufenden Element nicht gefunden wird, wird die übergeordnete Struktur mithilfe der logischen Struktur durchsucht, und zwar auf dieselbe Weise, in der die Struktur durchsucht wird, wenn zur Laufzeit ein dynamischer Ressourcen Verweis von einem Schlüssel angefordert wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-750">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="156f2-751">In der Regel würden Sie den Rückgabewert sofort in den Typ der Eigenschaft umwandeln, die Sie mit dem zurückgegebenen Ressourcen Wert festlegen wollten.</span><span class="sxs-lookup"><span data-stu-id="156f2-751">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="156f2-752">Die- <xref:System.Windows.FrameworkContentElement.FindResource%2A> Methode weist ein ähnliches Verhalten auf, mit dem Unterschied, dass eine Ausnahme ausgelöst wird, wenn keine Ressource mit dem angegebenen Schlüssel gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-752">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="156f2-753">Im folgenden Beispiel wird eine Ressource wie in Markup definiert gefunden und auf eine bestimmte Eigenschaft eines Elements als Reaktion auf ein Routing Ereignis angewendet.</span><span class="sxs-lookup"><span data-stu-id="156f2-753">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-754">Tritt ein, wenn das Element aus einer Elementstruktur geladener Elemente entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="156f2-754">Occurs when the element is removed from an element tree of loaded elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-755">Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-755">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="156f2-756">Direkt geroutete Ereignisse unterstützen andere Routing Ereignis Verhalten: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="156f2-756">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="156f2-757">Informationen zum Routingereignis</span><span class="sxs-lookup"><span data-stu-id="156f2-757">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="156f2-758">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="156f2-758">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="156f2-759">Routing Strategie</span><span class="sxs-lookup"><span data-stu-id="156f2-759">Routing strategy</span></span>|<span data-ttu-id="156f2-760">Direkt</span><span class="sxs-lookup"><span data-stu-id="156f2-760">Direct</span></span>|  
|<span data-ttu-id="156f2-761">Delegat</span><span class="sxs-lookup"><span data-stu-id="156f2-761">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="156f2-762">Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Übersicht über Routingereignisse](/dotnet/framework/wpf/advanced/routed-events-overview).</span><span class="sxs-lookup"><span data-stu-id="156f2-762">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-763">Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A> ).</span><span class="sxs-lookup"><span data-stu-id="156f2-763">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="156f2-764">Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="156f2-764">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="156f2-765">Der Name des Name/Objekt-Paars, der aus dem aktuellen Bereich entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="156f2-765">Name of the name-object pair to remove from the current scope.</span></span></param>
        <summary><span data-ttu-id="156f2-766">Vereinfacht den Zugriff auf die <see cref="T:System.Windows.NameScope" />-Methode zum Aufheben der Registrierung.</span><span class="sxs-lookup"><span data-stu-id="156f2-766">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="156f2-767">Wenn Sie ein anderes Element mit demselben Namen erneut registrieren möchten, müssen Sie die Registrierung von Namen aufheben.</span><span class="sxs-lookup"><span data-stu-id="156f2-767">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="156f2-768">Wendet erneut den Standardstil auf den aktuellen <see cref="T:System.Windows.FrameworkContentElement" /> an.</span><span class="sxs-lookup"><span data-stu-id="156f2-768">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
