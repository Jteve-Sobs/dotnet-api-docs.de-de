<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e4f9b89c1e78b976a214addf4e8d3fdefb105004" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75179810" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> stellt die Implementierung auf WPF-Frameworkebene und die Erweiterung der <see cref="T:System.Windows.ContentElement" />-Basisklasse dar. <see cref="T:System.Windows.FrameworkContentElement" /> bietet Unterstützung für zusätzliche Eingabe-APIs (einschließlich QuickInfos und Kontextmenüs), Storyboards, Datenkontexte für die Datenbindung, Formatvorlagen und APIs für Hilfsprogramme für logische Strukturen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> definiert noch kein eigenes Renderingverhalten. das Instanziieren einer tatsächlichen <xref:System.Windows.FrameworkContentElement>-Klasseninstanz im Code oder Markup ist möglich, zeigt jedoch in einem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendungs [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]nichts an. Renderinglogik muss von Klassen bereitgestellt werden, die <xref:System.Windows.FrameworkContentElement> untergeordnete Elemente als Teil ihres Inhalts Modells oder in <xref:System.Windows.FrameworkContentElement> abgeleiteten Klassen übernehmen.  
  
 <xref:System.Windows.FrameworkContentElement> absichtlich eine parallele Beziehung zwischen vielen der gleichen APIs wie <xref:System.Windows.FrameworkElement>. Beachten Sie, dass bestimmte APIs, die auf <xref:System.Windows.FrameworkElement> gefunden werden, nicht über <xref:System.Windows.FrameworkContentElement> Äquivalent verfügen. Einige der <xref:System.Windows.FrameworkElement>-APIs sind für Funktionen wie die Geometrie Darstellung oder das Layout vorgesehen, die für eine <xref:System.Windows.FrameworkContentElement>nicht relevant sind.  
  
 Die Mehrzahl vorhandener <xref:System.Windows.FrameworkContentElement> abgeleiteter Klassen finden Sie im <xref:System.Windows.Documents>-Namespace. Viele dieser abgeleiteten Klassen implementieren Elemente für das Fluss Dokument Modell. Bestimmte abgeleitete Klassen, z. b. <xref:System.Windows.Documents.Hyperlink>, verfügen über einige Steuerungs ähnliche Funktionen, werden jedoch von <xref:System.Windows.FrameworkContentElement> abgeleitet, sodass die Steuerelement ähnlichen Elemente weiterhin am Fluss Dokument Modell teilnehmen können.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkContentElement" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das untergeordnete Element, das hinzugefügt werden soll.</param>
        <summary>Fügt das bereitgestellte Element als untergeordnetes Element dieses Elements hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann eine Ausnahme auslösen, wenn Sie zu einem Zeitpunkt aufgerufen wird, wenn die logische Struktur von einem anderen Prozess durchlaufen wird.  
  
 Die meisten <xref:System.Windows.FrameworkContentElement> abgeleiteten Klassen machen dedizierte Auflistungen verfügbar, die für die Kapselung verantwortlich sind (z. b. <xref:System.Windows.Documents.Span.Inlines%2A> in der <xref:System.Windows.Documents.Span> Klasse, <xref:System.Windows.Documents.Section.Blocks%2A> der <xref:System.Windows.Documents.Section> Klasse). Sie können in der Regel vermeiden, dass Sie die logische Struktur direkt bearbeiten müssen, wenn Sie stattdessen von diesen Klassen ableiten. Das Arbeiten mit der logischen Struktur für Inhaltselemente ist ein erweitertes Szenario, das möglicherweise einen spezialisierten Parser oder einen spezialisierten <xref:System.Windows.FrameworkElement> erfordert, der als übergeordnetes renderingelement (Inhalts Host) fungiert.  
  
 Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> und <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>finden Sie Unterstrukturen [in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, bevor ein Element initialisiert wird.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Überschreiben Sie diese Methode, um eine spezielle Verarbeitung bereitzustellen, die vor dem Initialisieren des Elements während des Ladevorgangs des Elements erfolgen sollte.  
  
Ihre Implementierung sollte die Basis Implementierung aufzurufen, da die Basis Implementierung (Standard) einige interne Flags festlegt, um die Initialisierung nachzuverfolgen.  
  
Die Basis Implementierung löst eine Ausnahme aus, wenn <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> vor dem erreichen <see cref="M:System.Windows.FrameworkContentElement.EndInit" />mehrmals auf demselben Element aufgerufen wird.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den Signaturen, die nicht die `isControllable`, den Parameter oder den Parameter `false`angeben, werden die der Animation zugeordneten Zeitachsen Uhren entfernt, sobald Sie den "Fill"-Zeitraum erreicht. Daher kann die Animation nicht neu gestartet werden, nachdem Sie einmal ausgeführt wurde. Beachten Sie, dass das Steuern einer Animation auch erfordert, dass das Storyboard als eine Instanz im Code benannt oder zugänglich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <param name="handoffBehavior">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist. Die angegebenen Optionen legen fest, welche Aktion ausgeführt werden soll, wenn die Eigenschaft bereits animiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den Signaturen, die nicht die `isControllable`, den Parameter oder den Parameter `false`angeben, werden die der Animation zugeordneten Zeitachsen Uhren entfernt, sobald Sie den "Fill"-Zeitraum erreicht. Daher kann die Animation nicht neu gestartet werden, nachdem Sie einmal ausgeführt wurde. Beachten Sie, dass das Steuern einer Animation auch erfordert, dass das Storyboard als eine Instanz im Code benannt oder zugänglich ist.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie mithilfe der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>eine <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft anwenden, verbrauchen alle <xref:System.Windows.Media.Animation.Clock> Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt die Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>anwenden, sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>-oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter an, und `null` als Sekunde. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um eine bestimmte <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden Sie die <xref:System.Windows.Media.Animation.Clock.Controller%2A>-Eigenschaft des <xref:System.Windows.Media.Animation.AnimationClock>, um eine <xref:System.Windows.Media.Animation.ClockController>abzurufen, und rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A>-Methode des <xref:System.Windows.Media.Animation.ClockController>auf. Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem <xref:System.Windows.Media.Animation.ClockController>gesteuert werden können. die <xref:System.Windows.Media.Animation.Clock.Controller%2A>-Eigenschaft einer untergeordneten Uhr gibt `null`zurück. Beachten Sie auch, dass das <xref:System.Windows.Media.Animation.Clock.Completed>-Ereignis nicht ausgelöst wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann <xref:System.Windows.Media.Animation.ClockController.Remove%2A>aufgerufen werden soll.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Das zu startende Storyboard.</param>
        <param name="handoffBehavior">Ein Wert der Enumeration zum Beschreiben der auszuführenden Aktion, wenn eine im Storyboard beschriebene Eigenschaft bereits animiert ist.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (angehalten werden kann), nachdem sie gestartet wurde.</param>
        <summary>Startet die Sequenz von Aktionen, die im bereitgestellten Storyboard enthalten ist, im angegebenen Zustand für das Steuerelement der Animation nach deren Start.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den Signaturen, die nicht die `isControllable`, den Parameter oder den Parameter `false`angeben, werden die der Animation zugeordneten Zeitachsen Uhren entfernt, sobald Sie den "Fill"-Zeitraum erreicht. Daher kann die Animation nicht neu gestartet werden, nachdem Sie einmal ausgeführt wurde. Beachten Sie, dass das Steuern einer Animation auch erfordert, dass das Storyboard als eine Instanz im Code benannt oder zugänglich ist.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie mithilfe der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>eine <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft anwenden, verbrauchen alle <xref:System.Windows.Media.Animation.Clock> Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. Diese Uhren werden vom Zeit Steuerungssystem nicht automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>anwenden, sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen:  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>-oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter an, und `null` als Sekunde. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um eine bestimmte <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden Sie die <xref:System.Windows.Media.Animation.Clock.Controller%2A>-Eigenschaft des <xref:System.Windows.Media.Animation.AnimationClock>, um eine <xref:System.Windows.Media.Animation.ClockController>abzurufen, und rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A>-Methode des <xref:System.Windows.Media.Animation.ClockController>auf. Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem <xref:System.Windows.Media.Animation.ClockController>gesteuert werden können. die <xref:System.Windows.Media.Animation.Clock.Controller%2A>-Eigenschaft einer untergeordneten Uhr gibt `null`zurück. Beachten Sie auch, dass das <xref:System.Windows.Media.Animation.Clock.Completed>-Ereignis nicht ausgelöst wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann <xref:System.Windows.Media.Animation.ClockController.Remove%2A>aufgerufen werden soll.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" /> ab oder legt diese fest.</summary>
        <value>Die für das Element verwendete <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Data.BindingGroup> kann verwendet werden, um die Werte mehrerer Eigenschaften eines Objekts zu überprüfen. Angenommen, eine Anwendung fordert den Benutzer auf, eine Adresse einzugeben, und füllt dann ein Objekt vom Typ `Address`mit den Eigenschaften `Street`, `City`, `ZipCode`und `Country`mit den vom Benutzer bereitgestellten Werten. Die Anwendung verfügt über einen Bereich, der vier <xref:System.Windows.Controls.TextBox> Steuerelemente enthält, die jeweils an eine der Eigenschaften des Objekts gebunden sind. Sie können eine <xref:System.Windows.Controls.ValidationRule> in einem <xref:System.Windows.Data.BindingGroup> verwenden, um das `Address` Objekt zu validieren. Beispielsweise kann der <xref:System.Windows.Controls.ValidationRule> sicherstellen, dass die Postleitzahl für das Land/die Region der Adresse gültig ist.  
  
 Untergeordnete Elemente erben die <xref:System.Windows.Data.BindingGroup> von ihren übergeordneten Elementen, ebenso wie jede andere vererbbare Eigenschaft.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, dieses Element in einem der bildlauffähigen Bereiche anzuzeigen, in denen es enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Methode aufrufen, rufen Sie <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> in jedem übergeordneten scrollbaren Bereich auf, der das Element enthält (das übergeordnete Element ist möglicherweise ein <xref:System.Windows.FrameworkElement>, nicht ein <xref:System.Windows.FrameworkContentElement>). Wenn dieses Element nicht in einem Bild lauffähigen Bereich enthalten ist, wird das Ereignis immer noch ausgelöst, aber es gibt keine Auswirkung.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Gewusst wie: Erstellen eines ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Kontextmenüelement ab, das angezeigt werden soll, wenn das Kontextmenü in diesem Element über die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] angefordert wird, oder legt das Element fest.</summary>
        <value>Das Kontextmenü, das dieses Element verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.ContextMenu> auf einem <xref:System.Windows.Documents.Paragraph>platziert.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar vor dem Schließen eines Kontextmenüs für ein Element auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Schließen von Kontextmenüs zu unterdrücken, sollten Handler des Ereignisses ihn als behandelt markieren.  
  
 Wenn Sie dieses Ereignis als <xref:System.Windows.EventTrigger> in einem Stil verwenden möchten, müssen Sie auf den zugrunde liegenden Dienst Ereignis Bezeichner verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Diese Verwendung ist erforderlich, da die Ereignis Implementierung auf <xref:System.Windows.FrameworkContentElement>, die das zugrunde liegende Dienst Ereignis verfügbar macht, den <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> Bezeichner nicht ordnungsgemäß für die Verwendung in Triggern zuordnet).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Handler implementiert, der den Cursor über einen benannten Bereich `DisplayArea` (nicht dargestellt) ändert. Der Kommentar deutet auf eine <xref:System.Windows.UIElement> Verwendung hin, aber tatsächlich wäre dieses Beispiel identisch, wenn `DisplayArea` ein <xref:System.Windows.FrameworkContentElement>wären.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Kontextmenü des Elements geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Kontextmenüs manuell zu öffnen, sollten die Handler der Ereignisse das relevante Ereignis als behandelt markieren. Andernfalls wird der vorhandene Wert der <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>-Eigenschaft verwendet, um automatisch ein Kontextmenü zu öffnen. Wenn das Ereignis behandelt wird, wird die Standardaktion effektiv abgebrochen, und es kann eine Gelegenheit sein, den Wert der <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>-Eigenschaft zurückzusetzen und dann die neue <xref:System.Windows.Controls.ContextMenu>zu öffnen. Es gibt jedoch ein Problem mit der zeitlichen Steuerung, das Sie kennen sollten. Um das Kontextmenü vollständig durch einen <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> Handler zu ersetzen, darf das anfängliche Kontextmenü nicht NULL/leer sein. Alternativ dazu müssen Sie möglicherweise das-Ereignis behandeln und dann manuell ein neues Kontextmenü öffnen. Weitere Informationen finden Sie unter Gewusst [wie: Behandeln des ContextMenuOpening-Ereignisses](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Wenn Sie dieses Ereignis als <xref:System.Windows.EventTrigger> in einem Stil verwenden möchten, müssen Sie auf den zugrunde liegenden Dienst Ereignis Bezeichner verweisen:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Diese Verwendung ist erforderlich, da die Ereignis Implementierung auf <xref:System.Windows.FrameworkContentElement>, die das zugrunde liegende Dienst Ereignis verfügbar macht, den <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> Bezeichner nicht ordnungsgemäß für die Verwendung in Triggern zuordnet).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab bzw. legt den Cursor fest, der angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet.</summary>
        <value>Der anzuzeigende Cursor. Der Standardwert ist gemäß dieser Abhängigkeitseigenschaft als <see langword="null" /> definiert. Der zur Laufzeit angewendete Standardwert resultiert jedoch aus einer Vielzahl von Faktoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Festlegen dieser Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]stützt der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Prozessor die Typkonvertierung für die <xref:System.Windows.Input.Cursor>-Klasse, um die Zeichenfolge auszuwerten. Die angegebene Zeichenfolge sollte zu einem <xref:System.Windows.Input.CursorType> Wert ausgewertet werden. Ausführliche Informationen finden Sie unter <xref:System.Windows.Input.Cursor>.  
  
 Ob der Cursor, wie durch diese Eigenschaft festgelegt, angezeigt wird oder nicht angezeigt wird, wenn sich der Mauszeiger über diesem Element befindet, hängt auch vom Wert der <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>-Eigenschaft ab. Außerdem wirken sich ereignisbezogene Überlegungen, wie z. b. eine aktive Drag-, Maus-und Text Bearbeitungsmodi innerhalb von Steuerelementen, auch auf den Cursor mit höherer Priorität als dem Wert aus, den Sie in dieser Eigenschaft angeben.  
  
 Um das Verhalten für das Festlegen dieser Eigenschaft auf den Standardwert zurückzusetzen, legen Sie ihn erneut auf `null` fest.  
  
 Der `null` Standard bedeutet, dass die Bestimmung des praktischen Cursor Werts hier verzögert wird und von einem anderen Ort abgerufen werden sollte. Wenn ohne programmgesteuerte Werte aus einer beliebigen Quelle angezeigt wird, ist der Standard Cursor für eine [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Anwendung ein Pfeil.  
  
 Jede Bewegung des Mauszeigers über eine [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Anwendung löst ein <xref:System.Windows.ContentElement.QueryCursor> Ereignis aus. Die Ereignis Blasen, und jedes Element entlang der Route hat die Möglichkeit, das Ereignis zu behandeln und den Wert des Cursors über die Argumente dieses Ereignisses festzulegen. Wenn dies der Fall ist, hat die Tatsache, dass das Ereignis behandelt wird und einen geänderten Wert in den Argumenten hat, Vorrang vor dem Wert der <xref:System.Windows.FrameworkContentElement.Cursor%2A>-Eigenschaft auf jeder Ebene, es sei denn, <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> festgelegt ist.  
  
 Wenn Sie keinen benutzerdefinierten Cursor erstellen, legen Sie diese Eigenschaft in der Regel auf einen statischen Eigenschafts Wert der <xref:System.Windows.Input.Cursors>-Klasse fest.  
  
 Das Festlegen der <xref:System.Windows.Input.Cursor> auf einen benutzerdefinierten Wert ist in teilweiser Vertrauenswürdigkeit nicht aktiviert. Weitere Informationen zu benutzerdefinierten Cursorn finden Sie unter Übersicht über die [Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Cursor auf einen benutzerdefinierten Wert festgelegt.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.Cursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Datenkontexts für ein Element fest, wenn das Element an Datenbindungen beteiligt ist.</summary>
        <value>Das Objekt, das als Datenkontext verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der *Datenkontext* ist ein Konzept, mit dem Elemente Informationen von ihren übergeordneten Elementen über die Bindungs Quelle, die für die Bindung verwendet wird, sowie andere Merkmale der Bindung, wie z. b. den Pfad, erben können.  
  
 Der Datenkontext kann direkt auf ein [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Objekt festgelegt werden, wobei die Bindungen die Eigenschaften dieses Objekts auswerten. Alternativ können Sie den Datenkontext auf ein <xref:System.Windows.Data.DataSourceProvider>-Objekt festlegen.  
  
 Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte. Wenn untergeordnete Elemente ohne anderen Wert für <xref:System.Windows.FrameworkContentElement.DataContext%2A> über lokale Werte oder Stile festgelegt sind, legt das Eigenschaften System den Wert auf den <xref:System.Windows.FrameworkContentElement.DataContext%2A> Wert des nächsten übergeordneten Elements fest, dem dieser Wert zugewiesen ist.  
  
 Alternativ können Sie eine der folgenden Eigenschaften der <xref:System.Windows.Data.Binding>-Klasse verwenden, um die Bindungs Quelle explizit anzugeben: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>oder <xref:System.Windows.Data.Binding.RelativeSource%2A>. Weitere Informationen finden Sie unter Gewusst [wie: Angeben der Bindungs Quelle](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]wird <xref:System.Windows.FrameworkContentElement.DataContext%2A> am häufigsten als <xref:System.Windows.Data.Binding> Deklaration festgelegt. Sie können entweder die Syntax des Eigenschafts Elements oder die Attribut Syntax verwenden. Die Attribut Syntax wird im Beispiel auf dieser Seite angezeigt. Sie können auch <xref:System.Windows.FrameworkContentElement.DataContext%2A> im Code festlegen.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```xaml
<object DataContext="bindingUsage"/>  
```

- oder -

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```

<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *datacontextobject*  
 Ein direkt eingebettetes Objekt, das als Datenkontext für alle Bindungen innerhalb des übergeordneten Elements fungiert. In der Regel ist dieses Objekt eine <xref:System.Windows.Data.Binding> oder eine andere <xref:System.Windows.Data.BindingBase> Unterklasse. Alternativ können Rohdaten eines beliebigen [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Objekttyps, der für die Bindung bestimmt ist, hier platziert werden, wobei die eigentlichen Bindungen später definiert werden.  
  
 *bindingusage*  
 Eine Bindungs Verwendung, die zu einem geeigneten Datenkontext ausgewertet wird. Weitere Informationen finden Sie unter [Binding als Markuperweiterung](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceextension*  
 Eines der folgenden: `StaticResource`oder `DynamicResource`. Diese Verwendung wird verwendet, wenn auf Rohdaten verwiesen wird, die als Objekt in Ressourcen definiert sind. Siehe [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextresourcekey*  
 Der Schlüssel Bezeichner für das Objekt, das in einem <xref:System.Windows.ResourceDictionary>angefordert wird.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Bindung für ein <xref:System.Windows.Documents.Paragraph> Element festgelegt, indem ein neues benutzerdefiniertes Datenobjekt erstellt, das Objekt als <xref:System.Windows.FrameworkContentElement.DataContext%2A>festgelegt und der Bindungs Pfad auf eine Eigenschaft innerhalb der Eigenschaft festgelegt wird.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Datenkontext dieses Elements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Erläuterung der Daten Kontexte und der Datenbindung finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Wenn die <xref:System.Windows.FrameworkContentElement.DataContext%2A> eines Elements geändert wird, sind möglicherweise alle Daten gebundenen Eigenschaften für dieses Element betroffen. Dies gilt für alle Elemente, die Nachfolger Elemente des aktuellen Elements sind, das den Datenkontext erbt, und auch das aktuelle Element selbst. Alle diese Bindungen interpretieren den neuen <xref:System.Windows.FrameworkContentElement.DataContext%2A> erneut, um den neuen Wert in Bindungen widerzuspiegeln. Es gibt keine Garantie für die Reihenfolge dieser Änderungen im Verhältnis zur Erhöhung des <xref:System.Windows.FrameworkContentElement.DataContextChanged> Ereignisses.  Die Änderungen können vor dem Ereignis, nach dem Ereignis oder in einer beliebigen Mischung auftreten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.DataContext" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Schlüssel ab, der bei diesem Steuerelement zum Suchen der Stilvorlage in Designs verwendet wird, oder legt den Schlüssel fest.</summary>
        <value>Der Formatvorlagenschlüssel. Dieser Wert soll vom <see cref="T:System.Type" /> des formatierten Elements sein, damit er bei der Suche des Designstils korrekt verwendet wird. <see langword="null" /> ist ein akzeptierter Wert für einen bestimmten Fall.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird in der Regel nicht über einen ihrer direkten Setter festgelegt. Stattdessen überschreiben Sie jedes Mal, wenn Sie eine neue Unterklasse erstellen, die typspezifischen Metadaten dieser Abhängigkeits Eigenschaft. Wenn Sie eine Unterklasse haben, können Sie die <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>-Methode für den <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> Bezeichner innerhalb des statischen Konstruktors der Steuerelement-Unterklasse aufzurufen.  
  
 Beispielsweise verfügt eine Inline Klasse wie <xref:System.Windows.Documents.Bold> tatsächlich über das Überschreiben der <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> Metadaten in Ihrem statischen Konstruktor und das verfügbar machen mehrerer Instanzkonstruktoren über eine sehr geringe Implementierung. Die Tatsache, dass durch das <xref:System.Windows.Documents.Bold>-Tag eingeschlossene Elemente eine <xref:System.Windows.Documents.TextElement.FontWeight%2A> Eigenschaft von <xref:System.Windows.FontWeights.Bold%2A> erhalten, wird innerhalb des Design Stils implementiert, auf den verwiesen wird, indem der Standardwert <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> auf `typeof(Bold)`festgelegt wurde.  
  
 Wenn Sie möchten, dass das Element oder Steuerelement absichtlich keine Designstile verwendet, legen Sie die <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>-Eigenschaft auf `true`fest.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird unmittelbar nach der Initialisierung eines Elements aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementieren Sie diese Methode, um eine spezielle Verarbeitung bereitzustellen, die auftreten sollte, wenn das Element während des Ladevorgangs des Elements initialisiert wird.  
  
 Ihre Implementierung sollte die Basis Implementierung aufzurufen, da die Basis Implementierung (Standard) einige interne Flags festlegt, um die Initialisierung nachzuverfolgen.  
  
 Wenn <xref:System.Windows.FrameworkContentElement.BeginInit%2A> zuvor aufgerufen wurde, gibt die Basis Implementierung das <xref:System.Windows.FrameworkContentElement.Initialized>-Ereignis aus. Andernfalls wird das-Ereignis nicht ausgelöst, wenn <xref:System.Windows.FrameworkContentElement.BeginInit%2A> nicht aufgerufen wurde oder nicht ermittelt werden konnte, ob <xref:System.Windows.FrameworkContentElement.BeginInit%2A> aufgerufen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu suchenden Elements.</param>
        <summary>Sucht ein Element mit dem Namen des bereitgestellten Bezeichners.</summary>
        <returns>Das angeforderte Element. Kann <see langword="null" /> sein, wenn kein übereinstimmendes Element gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element über untergeordnete Elemente verfügt, werden diese untergeordneten Elemente für das angeforderte benannte Element rekursiv durchsucht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine-Eigenschaft für ein Element festgelegt, das in einer <xref:System.Windows.Documents.FlowDocument>, auf die verwiesen wird, in einem referenzierten  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner der zu findenden Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Schlüssel und löst eine Ausnahme aus, wenn die angeforderte Ressource nicht gefunden wird.</summary>
        <returns>Die gefundene Ressource oder <see langword="null" />, wenn keine übereinstimmende Ressource gefunden wurde (bei <see langword="null" /> wird ebenfalls eine Ausnahme ausgelöst).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Wenn Sie diese Methode für einen Schlüssel aufgerufen haben, der nicht gefunden werden kann, wird eine Ausnahme ausgelöst. Wenn Sie in diesem Fall keine Ausnahmen behandeln möchten, sollten Sie stattdessen <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>abrufen. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> gibt `null` zurück, wenn keine Ressource gefunden wurde, und löst keine Ausnahme aus.  
  
 Wenn die Ressource im aufrufenden Element nicht gefunden wird, wird die übergeordnete Struktur mithilfe der logischen Struktur durchsucht, und zwar auf dieselbe Weise, wie die Struktur durchsucht wird, wenn eine Ressource zur Laufzeit von einem Schlüssel angefordert wurde.  
  
 In der Regel würden Sie den Rückgabewert sofort in den Typ der Eigenschaft umwandeln, die Sie mit dem zurückgegebenen Ressourcen Wert festlegen wollten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Ressource wie in Markup definiert gefunden und auf eine bestimmte Eigenschaft eines Elements als Reaktion auf ein Routing Ereignis angewendet.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Der angeforderte Ressourcenschlüssel wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Objekts, das die Anpassung von Darstellung, Effekten oder anderen Formateigenschaften ermöglicht, die auf dieses Element angewendet werden, wenn es den Tastaturfokus erhält.</summary>
        <value>Die gewünschte Formatvorlage, die angewendet wird, wenn das Element den Fokus erhält. Der in der Abhängigkeitseigenschaft deklarierte Standardwert ist eine leere statische <see cref="T:System.Windows.Style" />. Der tatsächliche Wert zur Laufzeit ist jedoch häufig (aber nicht immer) eine Formatvorlage, die von der Designunterstützung für Steuerelemente bereitgestellt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Festlegen dieser Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]werden Stile fast immer als Ressource definiert, nicht als Inline als Element, und auf diese Ressource wird normalerweise als <xref:System.Windows.StaticResourceExtension>verwiesen.  
  
 Beachten Sie, dass sich diese Eigenschaft auf die visuelle Darstellung auswirkt, aber nicht in den Metadaten. Dies liegt daran, dass die visuelle Darstellung des Erscheinungs Bilds ereignisgesteuert ist und möglicherweise nicht immer angewendet wird und daher nicht in der Regel alle visuellen Informationen und Layoutinformationen in den Metadaten melden sollte.  
  
 Konzeptionell sollte das visuelle Verhalten von Fokus, das auf ein Steuerelement angewendet wird, von Element zu Element kohärent sein. Die sinnvollste Methode zum Erzwingen von Kohärenz besteht darin, nur den visuellen Fokus Stil zu ändern, wenn Sie ein ganzes Design erstellen. Das Festlegen dieser Eigenschaft in einzelnen Formaten und nicht als Teil eines Designs ist nicht die beabsichtigte Verwendung dieser Eigenschaft, da dies zu einer verwirrenden Benutzer Darstellung in Bezug auf den Tastaturfokus führen kann. Wenn Sie ein Element spezifisches Verhalten haben, das in einem Design absichtlich nicht kohärent ist, empfiehlt es sich, Trigger in Stilen für einzelne Eingabe Zustands Eigenschaften zu verwenden, wie z. b. <xref:System.Windows.UIElement.IsFocused%2A> oder <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, und dies auf eine Weise zu tun, die den visuellen Stil des visuellen Fokus nicht visuell beeinträchtigt. Weitere Informationen zur Entwurfs Absicht <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> und alternativer Fokus Eigenschaften finden Sie unter Formatieren [für den Fokus in Steuerelementen und liegt VisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceextension*  
 Eines der folgenden:, oder. Siehe [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleresourcekey*  
 Der Schlüssel, der den angeforderten Stil bezeichnet. Der Schlüssel verweist auf eine vorhandene Ressource in einer <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Die Syntax von Eigenschafts Elementen ist technisch möglich, wird jedoch nicht empfohlen. Weitere Informationen finden Sie unter [Inline Stile und Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Ein Bindungs Verweis mit [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) oder <xref:System.Windows.Data.Binding> ist ebenfalls möglich, aber nicht üblich.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses <see cref="T:System.Windows.FrameworkContentElement" /> das Rendern des Cursors in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] gemäß der Deklaration in dieser Instanz der <see cref="P:System.Windows.FrameworkContentElement.Cursor" />-Eigenschaft erzwingen soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn für die Darstellung des Cursors bei Positionierung über diesem Element die Cursoreinstellungen dieser Instanz (einschließlich aller untergeordneten Elemente) erzwungen werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true` festgelegt wird, werden die von untergeordneten Elementen eingerichteten Cursor Einstellungen überschrieben. Dies in allgemeinen Anwendungs [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] kann für den Benutzer verwirrend sein, insbesondere, wenn untergeordnete Elemente versuchen, Cursor anzugeben. Das Festlegen von <xref:System.Windows.FrameworkElement.ForceCursor%2A> eignet sich besser für die Steuerung von Unterklassen-oder Kompositions Szenarien.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Cursor während des-Elements erzwungen.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die Ziel-<see cref="T:System.Windows.DependencyProperty" />, aus der die Bindung abgerufen werden soll.</param>
        <summary>Ruft die <see cref="T:System.Windows.Data.BindingExpression" /> für die Bindung der angegebenen Eigenschaft ab.</summary>
        <returns>Gibt eine <see cref="T:System.Windows.Data.BindingExpression" /> zurück, wenn das Ziel datengebunden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Bindung abgerufen, indem eine-Eigenschaft abgefragt wird.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein alternatives logisches übergeordnetes Element für dieses Element zurück, wenn kein visuelles übergeordnetes Element vorhanden ist. In diesem Fall ist ein übergeordnetes <see cref="T:System.Windows.FrameworkContentElement" /> immer identisch mit dem Wert der <see cref="P:System.Windows.FrameworkContentElement.Parent" />-Eigenschaft.</summary>
        <returns>Gibt immer dann einen Wert ungleich <see langword="null" /> zurück, wenn eine auf WPF-Frameworkebene vorgenommene Implementierung dieser Methode eine nicht visuelle übergeordnete Verbindung hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt das erwartete visuelle übergeordnete Element zurück. Benutzerdefinierte Implementierungen können alternative übergeordnete Beziehungen zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn dieses <see cref="T:System.Windows.FrameworkContentElement" /> initialisiert wird. Dieses Ereignis geht mit Fällen einher, in denen sich der Wert der <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" />-Eigenschaft von <see langword="false" /> (oder nicht definiert) in <see langword="true" /> ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird immer dann ausgelöst, wenn die Methoden <xref:System.Windows.FrameworkContentElement.EndInit%2A> oder <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> aufgerufen werden. Aufrufe dieser Methoden können von einem absichtlichen Code oder vom [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Ladevorgang durchgeführt worden sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Kontexts für die von diesem <see cref="T:System.Windows.FrameworkContentElement" /> verwendete Eingabe.</summary>
        <value>Der Eingabebereich, der bestimmt, wie Eingaben von alternativen Eingabemethoden interpretiert werden. Der Standardwert ist <see langword="null" /> (führt zu einer Standardbehandlung von Befehlen).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte. Wenn untergeordnete Elemente ohne anderen Wert für <xref:System.Windows.FrameworkElement.InputScope%2A> über lokale Werte oder Stile festgelegt sind, legt das Eigenschaften System den Wert auf den <xref:System.Windows.FrameworkElement.InputScope%2A> Wert des nächsten übergeordneten Elements fest, dem dieser Wert zugewiesen ist.  
  
 Obwohl eine Syntax der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax aufgeführt ist und syntaktisch zulässig ist, ist das Festlegen dieser Eigenschaft in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nicht üblich.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.InputScope" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element durch das Laden als [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] oder durch einen expliziten Aufruf der entsprechenden <see cref="M:System.Windows.FrameworkContentElement.EndInit" />-Methode initialisiert wurde.</summary>
        <value><see langword="true" />, wenn das Element wie zuvor beschrieben durch Laden oder durch einen Methodenaufruf initialisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann auch `true` werden, wenn dieses Element innerhalb der Elementstruktur so verschoben wurde, dass es über ein neues übergeordnetes Element verfügt und daher erneut geladen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element für die Darstellung geladen wurde.</summary>
        <value><see langword="true" />, wenn das aktuelle Element an eine Elementstruktur angefügt ist und gerendert wurde, <see langword="false" />, wenn das Element noch nie an eine geladene Elementstruktur angefügt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aus einer neu erstellten Instanz startet diese Eigenschaft `false`und bleibt `true`, sobald Sie auf "`true`" festgelegt ist, auch dann, wenn Sie später durch Code entfernt wurde.  
  
   
  
## Examples  
 Im folgenden Beispielcode wird <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> als bedingte Prüfung verwendet, um sicherzustellen, dass eine Funktions `displayData` (nicht dargestellt) gültige Elemente enthält, die auf der Seite als Teil eines bedarfsgesteuerten Handlers geladen werden. Dieselbe Logik wird auch als Ereignishandler für <xref:System.Windows.FrameworkContentElement.Loaded>ausgeführt.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sprachinformationen für die Lokalisierung/Globalisierung eines einzelnen Elements ab oder legt diese Informationen fest.</summary>
        <value>Die Kulturinformationen für dieses Element. Der Standardwert ist eine <see cref="T:System.Windows.Markup.XmlLanguage" />-Instanz, deren <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />-Wert auf die Zeichenfolge „en-US“ festgelegt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichen folgen Formate folgen dem Standard RFC 3066. US-Englisch lautet z. b. "en-US". Weitere Informationen zu den Werten und dem Format finden Sie unter <xref:System.Windows.Markup.XmlLanguage>.  
  
 Diese Abhängigkeits Eigenschaft erbt Eigenschaftswerte. Wenn untergeordnete Elemente ohne anderen Wert für <xref:System.Windows.FrameworkElement.Language%2A> über lokale Werte oder Stile festgelegt sind, legt das Eigenschaften System den Wert auf den <xref:System.Windows.FrameworkElement.Language%2A> Wert des nächsten übergeordneten Elements fest, dem dieser Wert zugewiesen ist.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.Language" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Element ausgerichtet und gerendert sowie zur Interaktion vorbereitet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden. Direkt geroutete Ereignisse unterstützen das Verhalten anderer Routing Ereignisse: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente dieses Elements ab.</summary>
        <value>Ein Enumerator für die logischen untergeordneten Elemente dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Verwendung von <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> und <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>finden Sie Unterstrukturen [in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Die Richtung, in die der Fokus verschoben werden soll, als Wert der Enumeration.</param>
        <summary>Verschiebt den Tastaturfokus von diesem Element auf ein anderes Element.</summary>
        <returns>Gibt <see langword="true" /> zurück, wenn der Fokus erfolgreich verschoben wurde. <see langword="false" /> wird zurückgegeben, wenn das Zielelement in der angegebenen Richtung nicht vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des Elementnamens. Der Name stellt einen Instanzverweis bereit, sodass programmgesteuerter Code-Behind, z. B. Ereignishandlercode, während der Analyse von [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] auf ein Element verweisen kann, sobald es erstellt wurde.</summary>
        <value>Der Name des Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird am häufigsten verwendet, wenn ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Elementname im Markup angegeben wird.  
  
 Diese Eigenschaft bietet im Wesentlichen eine Eigenschaft der WPF-Frameworkebene zum Festlegen der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name-Direktive](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Das Abrufen eines <xref:System.Windows.FrameworkContentElement.Name%2A> aus dem Code ist nicht üblich, denn wenn Sie bereits über den entsprechenden Verweis im Code verfügen, können Sie einfach Methoden und Eigenschaften für den Element Verweis abrufen und benötigen die <xref:System.Windows.FrameworkContentElement.Name%2A>nicht im Allgemeinen. Eine Ausnahme ist, wenn die Zeichenfolge über eine überladene Bedeutung verfügt, beispielsweise, wenn es sinnvoll ist, den Namen in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]anzuzeigen. Das Festlegen einer <xref:System.Windows.FrameworkContentElement.Name%2A> aus Code, wenn die ursprüngliche <xref:System.Windows.FrameworkContentElement.Name%2A> aus Markup festgelegt wurde, wird ebenfalls nicht empfohlen. durch das Ändern der Eigenschaft wird der Objekt Verweis nicht geändert. Solche Objekt Verweise werden nur erstellt, wenn die zugrunde liegenden Namescopes beim Laden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] explizit erstellt werden.  
  
 Sie müssen <xref:System.Windows.FrameworkContentElement.RegisterName%2A> ausdrücklich aufzurufen, um eine effektive Änderung an der <xref:System.Windows.FrameworkContentElement.Name%2A>-Eigenschaft eines bereits geladenen Elements vorzunehmen.  
  
 Ein wichtiger Fall, bei dem das Festlegen von <xref:System.Windows.FrameworkContentElement.Name%2A> aus dem Code wichtig ist, ist das Benennen von Elementen, für die Storyboards ausgeführt werden. Bevor Sie einen Namen registrieren können, müssen Sie möglicherweise auch eine <xref:System.Windows.NameScope> Instanz instanziieren und zuweisen. Weitere Informationen finden Sie im Beispiel Abschnitt oder in der [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Wenn Sie <xref:System.Windows.FrameworkContentElement.Name%2A> aus dem Code festlegen, sind nur eingeschränkte Anwendungen möglich, das Suchen nach einem Element anhand des Namens ist jedoch eher üblich, insbesondere wenn Sie ein Navigations Modell verwenden, bei dem Seiten in die Anwendung neu geladen werden und der Lauf Zeit Code nicht notwendigerweise der Code Behind der entsprechenden Seite ist. Die <xref:System.Windows.FrameworkContentElement.FindName%2A>des-Hilfsprogramms, die von allen <xref:System.Windows.FrameworkContentElement>verfügbar ist, kann jedes beliebige Element suchen, indem es die logische Struktur dieses Elements rekursiv <xref:System.Windows.FrameworkContentElement.Name%2A>. Sie können auch die <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> statische Methode von <xref:System.Windows.LogicalTreeHelper>verwenden, die auch die <xref:System.Windows.FrameworkContentElement.Name%2A> Zeichenfolge als Argument annimmt.  
  
 Häufig verwendete Stamm Elemente (z. b.<xref:System.Windows.Window><xref:System.Windows.Controls.Page>) implementieren die-Schnittstelle <xref:System.Windows.Markup.INameScope>. Bei Implementierungen dieser Schnittstelle wird erwartet, dass die Namen innerhalb ihres Bereichs eindeutig sind.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.Name" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Sie sollten die Basis Implementierung weiterhin für den Fall aufzurufen, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat.  
  
 Der Zweck dieser Methode ähnelt [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise von einem untergeordneten-Element ausgelöst wurde, nicht notwendigerweise vom Element, das Handler aufruft. Daher muss Ihre Implementierung die Quell Eigenschaften der Ereignis Argumente berücksichtigen (und sollte in den meisten Fällen nicht versuchen, das Ereignis erneut auszuführen). Unterklassen von <xref:System.Windows.FrameworkContentElement> können festlegen, dass private Klassenhandlermethoden aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das Ereignis.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie weiterhin Base () aufzurufen.  
  
 Der Zweck dieser Methode ähnelt [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft, sodass Ihre Implementierung die Quelle der Ereignis Argumente annehmen muss. Eigenschaften in "Account" (und sollten nicht versuchen, das Ereignis in den meisten Fällen erneut auszuführen). Unterklassen von <xref:System.Windows.FrameworkContentElement> können festlegen, dass private Klassenhandlermethoden aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das Ereignis.</param>
        <summary>Der Klassenhandler für das <see cref="E:System.Windows.ContentElement.GotFocus" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Klassen Handler legt das entsprechende Fokus Verhalten für dieses Element fest, wenn das Ereignis von diesem Element stammt. Wenn die Quelle des Ereignisses ein anderes Element in der Struktur war, führt der Handler keine Aktion aus.  
  
 Überschreiben Sie diese Methode, um dieses standardmäßige Fokus Verhalten für Ihr Element zu ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das Ereignis.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> aus. Diese Methode wird immer dann aufgerufen, wenn <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> auf <see langword="true" /> festgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser virtuellen Methode löst das-Ereignis aus, wie zuvor in diesem Thema beschrieben. Über schreibungen sollten Base () aufgerufen werden, um dieses Verhalten beizubehalten.  
  
 Beachten Sie, dass die <xref:System.Windows.FrameworkContentElement.IsInitialized%2A>-Eigenschaft schreibgeschützt ist. Daher können Sie Sie nicht so festlegen, dass das Initialisierungs Verhalten auf diese Weise erzwungen wird. Die Initialisierungs Einstellung soll nur vom [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework ausgeführt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten, die die geänderte Eigenschaft beschreiben, einschließlich der alten und neuen Werte.</param>
        <summary>Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.FrameworkContentElement" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird im Argumentparameter gemeldet. Überschreibt <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht dafür vorgesehen, Eigenschafts Änderungen oder-Invalidierungen in der Regel zu erkennen. Er ist stattdessen für Änderungen des allgemeinen invalidierungsmusters vorgesehen, wenn bestimmte Informationen über breite Klassifizierungen von Eigenschaften bekannt sind.  
  
 Diese Methode wird möglicherweise mehrmals während der Lebensdauer eines Objekts aufgerufen. Daher können Sie eine bessere Leistung erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und dann <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen für einzelne Eigenschaften anfügen. Sie verwenden diese Methode jedoch, wenn eine <xref:System.Windows.FrameworkContentElement> eine beträchtliche Anzahl von Wert abhängigen Abhängigkeits Eigenschaften enthält oder wenn Sie Logik wie das Renderingverhalten enthält, das für mehrere verwandte Fälle von Eigenschafts Invalidierungen erneut ausgeführt werden muss.  
  
 Beachten Sie, dass es eine identisch benannte `OnPropertyChanged` Methode mit einer anderen Signatur gibt (der Parametertyp ist <xref:System.ComponentModel.PropertyChangedEventArgs>), der für eine Reihe von Klassen angezeigt werden kann. Diese `OnPropertyChanged` wird für Datenobjekt Benachrichtigungen verwendet und ist Teil des Vertrags für <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Nennen Sie die Basis Implementierung immer als ersten Vorgang in der Implementierung. Wenn dies nicht der Fall ist, wird das gesamte [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften System erheblich deaktiviert, was dazu führt, dass falsche Werte gemeldet werden.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Der alte Stil.</param>
        <param name="newStyle">Der neue Stil.</param>
        <summary>Wird aufgerufen, wenn sich der aktuell verwendete Stil dieses Elements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über eine Standard Implementierung, die ein internes Flag festlegt, das die Formatvorlagen Änderung angibt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ruft immer die Basis Implementierung auf, andernfalls können Stile nicht angewendet werden. Szenarios zum Überschreiben dieser Methode können einschließen, wenn die abgeleitete Klasse über einen spezialisierten stilselektor verfügt oder Stil Werte zwischenspeichert. Designänderungen können diese Methode aufrufen.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie weiterhin Base () aufzurufen.  
  
 Der Zweck dieser Methode ähnelt [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das Element, das Handler aufruft, sodass Ihre Implementierung die Quelle der Ereignis Argumente annehmen muss. Eigenschaften in "Account" (und sollten nicht versuchen, das Ereignis in den meisten Fällen erneut auszuführen). Unterklassen von <xref:System.Windows.FrameworkContentElement> können festlegen, dass private Klassenhandlermethoden aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Stellt Daten über das Ereignis bereit.</param>
        <summary>Der Aufruf erfolgt immer dann, wenn das <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" />-Routingereignis diese Klasse auf der Route erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standard Implementierung. Für den Fall, dass eine Zwischenklasse in der Vererbung diese Methode implementiert hat, sollten Sie weiterhin Base () aufzurufen.  
  
 Der Zweck dieser Methode ähnelt [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignis Muster bei *-Methoden: Sie bietet die Möglichkeit, das übereinstimmende Ereignis aus abgeleiteten Klassen mit einem Klassen Handler anstelle eines Instanzhandlers zu verarbeiten. In diesem Fall ist das Übereinstimmungs Ereignis ein Routing Ereignis. Das Implementierungs Muster der on *-Methoden unterscheidet sich für Routing Ereignisse, da das-Routing Ereignis möglicherweise durch ein untergeordnetes-Element ausgelöst wurde, nicht notwendigerweise das-Element, das Handler aufruft, sodass Ihre Implementierung die Quelle der Ereignis Argumente annehmen muss. Eigenschaften in "Account" (und sollten nicht versuchen, das Ereignis in den meisten Fällen erneut auszuführen). Unterklassen von <xref:System.Windows.FrameworkContentElement> können festlegen, dass private Klassenhandlermethoden aufgerufen werden, wenn das Ereignis entlang der Route empfangen wird. Ein mögliches Szenario besteht darin, die Argumente des Ereignisses zu übernehmen und absichtlich das Ereignis als behandelt zu markieren, um die Route zu verkürzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieses Element Stileigenschaften aus Designstilen enthält, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn dieses Element keine Designstileigenschaften verwendet, alle auf Stile zurückgehenden Eigenschaften aus den Stilen lokaler Anwendungen stammen und die Designstileigenschaften nicht angewendet werden. <see langword="false" />, wenn Anwendungsstile vor Designstilen auf Eigenschaften angewendet werden, die in Anwendungsstilen nicht explizit festgelegt wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Verwendung dieser Eigenschaft ist eine indirekte Verwendung innerhalb des Setter eines Stils, der einen Stil mit Design bereitstellt.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Element in der logischen Struktur dieses Elements ab.</summary>
        <value>Das logische übergeordnete Element dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass das logische übergeordnete Element eines Elements je nach Anwendungs Funktionalität geändert werden kann, und wenn der Wert dieser Eigenschaft beibehalten wird, wird diese Änderung nicht widerspiegelt. Sie sollten den Wert in der Regel direkt vor dem Bedarf erhalten.  
  
 Weitere Informationen zum Durchlaufen von logischen Strukturen finden Sie Unterstrukturen [in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) und in den Szenarien, in denen diese Vorgehensweise bei der Ermittlung von Elementen sinnvoll ist.  
  
 Das Eigenschaften System berechnet möglicherweise alle Eigenschaftswerte eines Elements neu, wenn es neu erstellt wird, da einige Eigenschaften Werte über die logische Struktur erben. Die <xref:System.Windows.FrameworkContentElement.DataContext%2A>, die für Bindungen gelten, können sich auch ändern, wenn Elemente neu zugeordnet werden.  
  
 Das übergeordnete Element eines Elements wird in der Regel nur durch die Bearbeitung von Auflistungen, durch die Verwendung von dedizierten Add-und Remove-Methoden oder durch Festlegen von Inhalts Eigenschaften von Elementen erreicht  
  
 Das typische Szenario für die Verwendung der <xref:System.Windows.FrameworkContentElement.Parent%2A>-Eigenschaft ist das Abrufen eines Verweises und das anschließende Abrufen verschiedener <xref:System.Windows.FrameworkContentElement> Eigenschaftswerte vom übergeordneten Element. Bei Vorlagen wird der <xref:System.Windows.FrameworkContentElement.Parent%2A> der Vorlage schließlich `null`. Wenn Sie diesen Punkt überschreiten und in die logische Struktur erweitern möchten, in der die Vorlage tatsächlich angewendet wird, verwenden Sie <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Windows.FrameworkContentElement.Parent%2A> eines <xref:System.Windows.Documents.TextPointer> einen bestimmten Typ hat.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Die Richtung, für die eine mögliche Fokusänderung bestimmt werden soll.</param>
        <summary>Bestimmt das nächste Element, das relativ zu diesem Element den Fokus in einer angegebenen Fokusverschiebungsrichtung erhalten würde, verschiebt den Fokus jedoch nicht. Diese Methode ist versiegelt und kann nicht überschrieben werden.</summary>
        <returns>Das nächste Element, auf das der Fokus verschoben würde, wenn der Fokus tatsächlich durchlaufen würde. Kann <see langword="null" /> zurückgeben, wenn der Fokus für die bereitgestellte Richtung nicht relativ zu diesem Element verschoben werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> ist die verwandte Methode, die den Fokus tatsächlich verschiebt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Gibt eine der folgenden Richtungen im <see cref="T:System.Windows.Input.TraversalRequest" /> an: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Diese Richtungen sind für <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> unzulässig (aber für <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> zulässig).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Name für die angegebene Namensobjektzuordnung.</param>
        <param name="scopedElement">Objekt für die Zuordnung.</param>
        <summary>Stellt einen Accessor bereit, der Zugriff auf die <see cref="T:System.Windows.NameScope" />-Registrierungsmethode vereinfacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode stellt eine bequeme Methode zum Aufrufen von <xref:System.Windows.NameScope.RegisterName%2A>dar. Die-Implementierung überprüft aufeinander folgende übergeordnete Elemente, bis die anwendbare <xref:System.Windows.NameScope> Implementierung gefunden wird, die gefunden wird, indem ein Element gefunden wird, das <xref:System.Windows.Markup.INameScope>implementiert. Weitere Informationen zu Namescopes finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Das Aufrufen von <xref:System.Windows.FrameworkContentElement.RegisterName%2A> ist erforderlich, um Animations Storyboards für Anwendungen ordnungsgemäß zu verbinden, wenn Sie im Code erstellt werden. Dies liegt daran, dass eine der Schlüssel Storyboard-Eigenschaften, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, anstelle eines Verweises auf ein Ziel Element eine Lauf Zeit Namen Suche verwendet. Dies gilt auch dann, wenn auf dieses Element durch einen Verweis aus dem Code zugegriffen werden kann. Weitere Informationen dazu, warum Sie Namen für Storyboard-Ziele registrieren müssen, finden Sie unter [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Animationen für Inhaltselemente sind weniger häufig als Animationen für Steuerelemente, die [Übersicht über Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) konzentriert sich auf Steuerungs Szenarios.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Das zu entfernende Element.</param>
        <summary>Entfernt das angegebene Element aus der logischen Struktur dieses Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese API ist hauptsächlich für Klassen abgeleitete Szenarien relevant, wenn Unterstützung für untergeordnete Sammlungen hinzugefügt wird.  
  
 Die meisten <xref:System.Windows.FrameworkContentElement> abgeleiteten Klassen machen dedizierte Auflistungen verfügbar, die für die Kapselung verantwortlich sind (z. b. <xref:System.Windows.Documents.Span.Inlines%2A> in der <xref:System.Windows.Documents.Span> Klasse, <xref:System.Windows.Documents.Section.Blocks%2A> der <xref:System.Windows.Documents.Section> Klasse). Das Ableiten von solchen Klassen kann in der Regel vermeiden, dass die logische Struktur direkt manipuliert werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle lokal definierte Ressourcenwörterbuch ab oder legt es fest.</summary>
        <value>Die aktuellen lokal definierten Ressourcen. Dies ist ein Wörterbuch von Ressourcen, wobei auf Ressourcen innerhalb des Wörterbuchs über Schlüssel zugegriffen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ressourcen Wörterbücher, die vollständig oder teilweise in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] definiert werden können, werden in der Regel als Eigenschafts Element erstellt und befinden sich in der Regel im Stamm Element für jede einzelne Seite oder für die Anwendung. Wenn Sie das Ressourcen Wörterbuch auf dieser Ebene platzieren, ist es leichter, von einzelnen untergeordneten Elementen auf der Seite zu suchen (oder von einer beliebigen Seite im Anwendungsfall). In den meisten Anwendungsszenarien empfiehlt es sich, Stile als Objekt Elemente innerhalb eines Ressourcen Wörterbuchs zu definieren oder als externe Ressourcen festgelegt zu werden, damit die gesamte Stil Ressource eigenständig sein kann (dieser Ansatz hilft beim Trennen des Designers. Zuständigkeiten von Entwickler Zuständigkeiten durch das Trennen der physischen Dateien, die bearbeitet werden müssen.  
  
 Beachten Sie, dass diese Eigenschaft nur das direkt in diesem Element deklarierte Ressourcen Wörterbuch zurückgibt. Dies unterscheidet sich von dem tatsächlichen Ressourcen Suchprozess, bei dem ein untergeordnetes Element auf alle Ressourcen zugreifen kann, die in den einzelnen übergeordneten Elementen definiert sind, wobei die Suche rekursiv nach oben erfolgt.  
  
 Auf Ressourcen kann auch durch Code aus der Auflistung verwiesen werden, aber beachten Sie, dass die in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] erstellten Ressourcen auf jeden Fall erst zugänglich sind, wenn <xref:System.Windows.FrameworkContentElement.Loaded> von dem Element ausgelöst wird, das das Wörterbuch deklariert. Tatsächlich werden Ressourcen asynchron analysiert, und nicht einmal das <xref:System.Windows.FrameworkContentElement.Loaded> Ereignis ist eine Zusicherung, dass Sie auf eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definierte Ressource verweisen können. Aus diesem Grund sollten Sie im Allgemeinen nur auf [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definierte Ressourcen als Teil des Lauf Zeit Codes oder über andere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Techniken, z. b. Stile oder Ressourcen Erweiterungs Verweise für Attributwerte, zugreifen. Wenn Sie über Code auf Ressourcen zugreifen, entspricht dies im Wesentlichen einem [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) -Verweis aus [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Der zugrunde liegende <xref:System.Windows.ResourceDictionary> unterstützt die Methoden, die zum Hinzufügen, entfernen oder Abfragen von Ressourcen innerhalb der Sammlung mithilfe von Code erforderlich sind. Die <xref:System.Windows.FrameworkContentElement.Resources%2A>-Eigenschaft kann festgelegt werden, um das Szenario zu unterstützen, bei dem die Ressourcen Auflistung eines Elements vollständig als neue oder andere <xref:System.Windows.ResourceDictionary>ersetzt wird.  
  
 Beachten Sie, dass die angezeigte [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Syntax kein-Element für die <xref:System.Windows.ResourceDictionary>enthält. Dies ist ein Beispiel für eine implizite Auflistungs Syntax. ein Tag, das das Auflistungs Element darstellt, kann weggelassen werden. Stattdessen werden die Elemente angegeben, die der Auflistung als Elemente hinzugefügt werden. Weitere Informationen zu impliziten Auflistungen und [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]finden Sie [in der XAML-Syntax im Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Wenn eine <xref:System.Windows.ResourceDictionary> weiterhin explizit als Element angegeben wird, wird ein zusammen geführtes Wörterbuch eingeführt. in diesem Fall sind in der Regel keine untergeordneten Elemente für diese <xref:System.Windows.ResourceDictionary>vorhanden. Weitere Informationen finden Sie unter [zusammengeführte Ressourcen Wörterbücher](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneormoreresourceelements*  
 Ein oder mehrere Objekt Elemente, von denen jede eine Ressource definiert. Jedes Ressourcen Eigenschafts Element innerhalb jeder <xref:System.Windows.ResourceDictionary> muss über einen eindeutigen Wert für die [x:Key-Direktive](~/docs/framework/xaml-services/x-key-directive.md)verfügen, der als eindeutiger Schlüssel fungiert, wenn Werte aus der <xref:System.Windows.ResourceDictionary>abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.FrameworkContentElement.Resources%2A>-Auflistung für ein <xref:System.Windows.Documents.FlowDocument> root-Element festgelegt. <xref:System.Windows.Documents.FlowDocument> ist eine typische Wahl, da es sich hierbei um eine der wenigen <xref:System.Windows.FrameworkContentElement> Klassen handelt, die als Stamm Element sinnvoll sind. Ressourcen werden im Allgemeinen im Seiten Stamm oder auf noch höheren Ebenen wie in der Anwendung gespeichert.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordnet eine Bindung zu diesem Element für die angegebene Abhängigkeitseigenschaft zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Bezeichnet die gebundene Eigenschaft.</param>
        <param name="path">Der Name der Quelleigenschaft oder der Pfad zu der für die Bindung verwendeten Eigenschaft.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Namens der Quelleigenschaft als Pfadangabe zur Datenquelle eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, die die aktuelle Instanz als <xref:System.Windows.DependencyObject>übergibt, und erstellt eine neue <xref:System.Windows.Data.Binding>, die auf dem bereitgestellten `path` Parameter basiert. Diese Signatur ist bequemer, wenn Sie eine einfache Standard Bindung einrichten. Wenn Sie Bindungseigenschaften für nicht standardmäßige Bedingungen angeben müssen oder eine <xref:System.Windows.Data.MultiBinding> oder <xref:System.Windows.Data.PriorityBinding>verwenden möchten, sollten Sie die <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> Signatur verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Bindung für ein <xref:System.Windows.Documents.Paragraph> Element festgelegt, indem ein neues benutzerdefiniertes Datenobjekt erstellt, das Objekt als <xref:System.Windows.FrameworkContentElement.DataContext%2A>festgelegt und der Bindungs Pfad auf eine Eigenschaft innerhalb der Eigenschaft festgelegt wird.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Bezeichnet die gebundene Eigenschaft.</param>
        <param name="binding">Stellt eine Datenbindung dar.</param>
        <summary>Fügt auf der Grundlage des bereitgestellten Bindungsobjekts eine Bindung an dieses Element an.</summary>
        <returns>Zeichnet die Bedingungen der Bindung auf. Dieser Rückgabewert kann bei der Fehlerüberprüfung nützlich sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine bequeme Methode zum Aufrufen von <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, die die aktuelle Instanz als <xref:System.Windows.DependencyObject>übergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Bindung für ein <xref:System.Windows.Documents.Paragraph> Element festgelegt, indem ein neuer <xref:System.Windows.Data.Binding> erstellt und die Quelle auf ein neu erstelltes `DateTime` Objekt festgelegt wird.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Die Eigenschaft, an die die Ressource gebunden ist.</param>
        <param name="name">Der Name der Ressource.</param>
        <summary>Sucht eine Ressource mit dem angegebenen Namen und richtet einen entsprechenden Ressourcenverweis für die angegebene Eigenschaft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ressourcen Verweis ähnelt der Verwendung einer [dynamikresource-Markup Erweiterung](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) im Markup. Der Ressourcen Verweis erstellt einen internen Ausdruck, der den Wert der angegebenen Eigenschaft für eine verzögerte Laufzeit bereitstellt. Der Ausdruck wird immer dann erneut ausgewertet, wenn das Ressourcen Wörterbuch einen geänderten Wert durch interne Ereignisse angibt oder wenn das aktuelle Element neu erstellt wird (eine übergeordnete Änderung würde den Pfad für die Wörterbuchsuche ändern).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob in Serialisierungsprozessen der Inhalt der <see cref="P:System.Windows.FrameworkContentElement.Resources" />-Eigenschaft für Instanzen dieser Klasse serialisiert werden soll.</summary>
        <returns><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkContentElement.Resources" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dadurch wird `true` zurückgegeben, solange mindestens eine Schlüsselressource im lokalen <xref:System.Windows.FrameworkContentElement.Resources%2A>vorhanden ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob in Serialisierungsprozessen der Inhalt der <see cref="P:System.Windows.FrameworkContentElement.Style" />-Eigenschaft für Instanzen dieser Klasse serialisiert werden soll.</summary>
        <returns><see langword="true" />, wenn der <see cref="P:System.Windows.FrameworkContentElement.Style" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dadurch wird `true` zurückgegeben, wenn die <xref:System.Windows.Style> lokal festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich eine zugeordnete Datenquelle, die an einer Bindung dieses Elements teilnimmt, ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis zeigt das <xref:System.Windows.Data.Binding.SourceUpdated> Ereignis an, das von allen <xref:System.Windows.Data.Binding> ausgelöst wird, die diesem Element zugeordnet sind.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Stil ab, der von diesem Element verwendet werden soll, oder legt ihn fest.</summary>
        <value>Der übernommene und nicht dem Standardstil entsprechende Stil für das Element, wenn ein Stil vorhanden ist. Andernfalls ist der Wert <see langword="null" />. Der Standardwert für ein mit den Standardwerten konstruiertes <see cref="T:System.Windows.FrameworkContentElement" /> ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aktuelle Stil wird häufig von einem Standardstil aus Design oder von Stilen bereitgestellt, die in der Regel durch Ressourcen auf der Seiten-oder Anwendungsebene (ein implizites Format) auf Objekte dieses Typs angewendet werden. Diese Eigenschaft legt Standard Stile (Theme) nicht fest oder gibt Sie zurück, aber Sie gibt den impliziten Stil oder einen expliziten Stil zurück. Im Fall impliziter oder expliziter Stile spielt es keine Rolle, ob auf den Stil als Ressource zugegriffen oder lokal definiert ist.  
  
 Das Festlegen der Stile hat einige Einschränkungen. Sie können die gesamte <xref:System.Windows.FrameworkContentElement.Style%2A>-Eigenschaft zu einem beliebigen Zeitpunkt auf eine neue <xref:System.Windows.Style> zurücksetzen, wodurch eine Neukomposition des Layouts erzwungen wird. Sobald dieser Stil jedoch von einem geladenen Element verwendet wird, sollte die <xref:System.Windows.Style> als versiegelt angesehen werden. Der Versuch, eine Änderung an einer einzelnen Eigenschaft eines in Gebrauch verwendeten Stils vorzunehmen (z. b. in der Auflistung von <xref:System.Windows.Style.Setters%2A>), bewirkt, dass eine Ausnahme ausgelöst wird. Ein Stil, der im Markup definiert ist, wird als in Gebrauch betrachtet, sobald er aus einem Ressourcen Wörterbuch (für Ressourcen) geladen wird, oder wenn die in enthaltene Seite geladen wird (für Inline Stile).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> ist eine Abhängigkeits Eigenschaft mit spezieller Rangfolge. Der lokal festgelegte Stil arbeitet im Allgemeinen mit der höchsten Rangfolge im Eigenschaften System. Wenn die <xref:System.Windows.FrameworkContentElement.Style%2A> zu diesem Zeitpunkt NULL ist, prüft beim Laden des Eigenschaften Systems beim Laden auf implizite Stile als definierte Ressourcen, die diesen Typ angeben. Wenn der Stil nach diesem Schritt immer noch NULL ist, wird der Stil aus dem Standardformat (Design) abgeleitet, aber der Standardstil wird nicht im <xref:System.Windows.FrameworkContentElement.Style%2A>-Eigenschafts Wert zurückgegeben. Siehe [Wert Rangfolge der Abhängigkeits Eigenschaft](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourceextension*  
 Eines der folgenden:, oder. Siehe [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleresourcekey*  
 Der Schlüssel, der den angeforderten Stil bezeichnet. Der Schlüssel verweist auf eine vorhandene Ressource in einer <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Die Syntax von Eigenschafts Elementen ist technisch möglich, wird jedoch nicht empfohlen. Weitere Informationen finden Sie unter [Inline Stile und Vorlagen](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Ein Bindungs Verweis mit [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) oder <xref:System.Windows.Data.Binding> ist ebenfalls möglich, aber nicht üblich.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.FrameworkContentElement.Resources%2A>-Auflistung für ein <xref:System.Windows.Documents.FlowDocument> root-Element erstellt und dann als eine Ressource als eine bestimmte Formatvorlage für einen <xref:System.Windows.Documents.Paragraph>darauf verwiesen.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.Style" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter der <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />-Methode.</summary>
        <returns><see langword="true" />, wenn <paramref name="propertyName" /> verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.FrameworkContentElement>-Instanz in eine <xref:System.Windows.Markup.IQueryAmbient>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen beliebigen Objektwert ab, der zum Speichern von benutzerdefinierten Informationen zu diesem Element verwendet werden kann, bzw. legt diesen fest.</summary>
        <value>Der vorgesehene Wert. Diese Eigenschaft hat keinen Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft entspricht den Tageigenschaften in anderen Microsoft-Programmier Modellen, wie z. b. Visual Basic for Applications oder Windows Forms. Es soll eine bereits vorhandene Stelle bereitstellen, um einige grundlegende benutzerdefinierte Informationen zu einem Element zu speichern, ohne dass Anwendungsentwickler zu einer Unterklasse gezwungen werden.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 Da diese Eigenschaft ein Objekt annimmt, müssen Sie die Eigenschaften Element Verwendung verwenden, um die <xref:System.Windows.FrameworkContentElement.Tag%2A>-Eigenschaft in XAML auf einen anderen Wert als ein Objekt mit einem bekannten und integrierten Typkonverter (z. b. eine Zeichenfolge) festzulegen. Objekte, die auf diese Weise verwendet werden, befinden sich in der Regel nicht innerhalb der standardmäßigen WPF-Namespaces und erfordern daher möglicherweise eine Namespace Zuordnung zum externen Namespace, um als XAML-Elemente eingeführt zu werden.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.Tag" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine zugeordnete Zieleigenschaft, die Teil einer Bindung dieses Elements ist, geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis zeigt das <xref:System.Windows.Data.Binding.TargetUpdated> Ereignis an, das von allen <xref:System.Windows.Data.Binding> ausgelöst wird, die diesem Element zugeordnet sind. Dies bedeutet in der Regel, dass es sich bei der fraglichen Bindung um eine bidirektionale Bindung handelt und dass die gebundene Abhängigkeits Eigenschaft jede Validierung oder jedes zwischen Speicherungs Schema, die von der-Eigenschaft unterstützt wird, als ungültig erklärt.  
  
 Die Ereignis Argumente dieses Ereignisses informieren Sie darüber, welche gebundene Eigenschaft geändert wurde.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die übergeordnete Vorlage dieses Elements ab. Diese Eigenschaft ist nicht relevant, wenn das Element nicht durch eine Vorlage erstellt wurde.</summary>
        <value>Das Element, dessen <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> die Erstellung dieses Elements verursacht hat. Dieser Wert ist häufig <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vorlagen sind tatsächlich freigegebene Objekte, bei denen der Inhalt der Vorlage nur einmal erstellt wird. Wenn Sie also einen Objekt Verweis auf ein Element erhalten, das aus einer Vorlage stammt, können Sie feststellen, dass die sichtbare logische Struktur nicht zum Seiten Stamm gelangt. Um einen solchen Vorlagen Verweis mit der logischen Struktur der Seite zu verbinden, sollten Sie den <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> Wert erhalten und weiterhin in der gewünschten Elementstruktur navigieren.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> werden häufig für allgemeine Objekte `null`, denn wenn Sie einen Objekt Verweis von einer Seite in der Anwendung über das übliche Mittel erhalten haben, wurde dieses Element wahrscheinlich nicht aus einer Vorlage erstellt. Fälle, in denen <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> möglicherweise nicht `null` ist, enthalten Vorgänge wie Treffer Tests, Ereignis Behandlung für bestimmte Eingabeereignisse auf niedriger Ebene oder das Arbeiten mit Enumeratoren, die möglicherweise Elemente zurückgegeben haben, die aus Vorlagen stammen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das QuickInfo-Objekt ab, das für dieses Element in der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] angezeigt wird, oder legt dieses Objekt fest.</summary>
        <value>Das QuickInfo-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert dieser Eigenschaft vom Typ <xref:System.Windows.Controls.ToolTip>ist, dann ist dies die QuickInfo, die im [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]verwendet wird.  Wenn der Wert eines anderen Typs ist, wird dieser Wert als *Inhalt* für eine vom System bereitgestellte <xref:System.Windows.Controls.ToolTip> (erstellt) verwendet. Weitere Informationen finden Sie unter <xref:System.Windows.Controls.ToolTipService>. Die Dienstklasse stellt angefügte Eigenschaften bereit, die verwendet werden können, um eine QuickInfo weiter anzupassen.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
```

- oder -

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```

<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *tooltipcontent*  
 Eine Zeichenfolge, die zum Anzeige Text für die <xref:System.Windows.FrameworkContentElement.ToolTip%2A>wird.  
  
 *tooltipobjectcontent*  
 Ein im Objekt Element Formular bereitgestelltes Objekt, das als Inhalt für das <xref:System.Windows.FrameworkContentElement> verwendet werden soll. In der Regel handelt es sich hierbei um eine <xref:System.Windows.FrameworkElement> oder ein anderes Element, das layoutcompositing für die <xref:System.Windows.FrameworkContentElement.ToolTip%2A>erstellt und schließlich Textinhalte innerhalb der Zusammensetzung enthält. In dieser Verwendung wird das <xref:System.Windows.Controls.ToolTip> Element implizit aus dem analysierten [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]erstellt, und der *tooltipobjectcontent* -Inhalt wird als <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> Eigenschaft festgelegt.  
  
 <`ToolTip`.../>  
 Siehe <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Wert der <xref:System.Windows.FrameworkElement.ToolTip%2A>-Eigenschaft direkt auf eine Zeichenfolge festgelegt.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar vor dem Schließen einer QuickInfo über dem Element ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Schließen der QuickInfo zu unterdrücken, sollten Handler des Ereignisses ihn als behandelt markieren.  
  
 Dieses Ereignis kann kein <xref:System.Windows.EventTrigger> in einem Stil sein. Dies liegt daran, dass das Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst wieder verwendet, der keine Add/Remove-Methoden für das Ereignis verfügbar macht.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Öffnen einer QuickInfo im Element auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Quick Infos manuell zu öffnen, sollten die Handler der Ereignisse das relevante Ereignis als behandelt markieren. Andernfalls wird der Wert der <xref:System.Windows.FrameworkContentElement.ToolTip%2A>-Eigenschaft verwendet, um automatisch ein Kontextmenü zu öffnen. Wenn das Ereignis behandelt wird, wird die Standardaktion effektiv abgebrochen, und es kann eine Gelegenheit sein, den Wert der <xref:System.Windows.FrameworkContentElement.ToolTip%2A>-Eigenschaft zurückzusetzen und dann die neue <xref:System.Windows.Controls.ContextMenu>zu öffnen. Beachten Sie, dass dieses Ereignis nicht ausgelöst wird, wenn <xref:System.Windows.FrameworkContentElement.ToolTip%2A> ein NULL-Verweis oder anderweitig nicht festgelegt ist.  
  
 Dieses Ereignis kann kein <xref:System.Windows.EventTrigger> in einem Stil sein. Dies liegt daran, dass das Bezeichnerfeld dieses Ereignisses eine Implementierung von einem Dienst wieder verwendet, der keine Add/Remove-Methoden für das Ereignis verfügbar macht.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Der Schlüsselbezeichner der zu findenden Ressource.</param>
        <summary>Sucht nach einer Ressource mit dem angegebenen Schlüssel und gibt diese Ressource zurück, sofern sie gefunden wurde.</summary>
        <returns>Die gefundene Ressource. Wenn keine Ressource gefunden wurde, wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ressource im aufrufenden Element nicht gefunden wird, wird die übergeordnete Struktur mithilfe der logischen Struktur durchsucht, und zwar auf dieselbe Weise, in der die Struktur durchsucht wird, wenn zur Laufzeit ein dynamischer Ressourcen Verweis von einem Schlüssel angefordert wird.  
  
 In der Regel würden Sie den Rückgabewert sofort in den Typ der Eigenschaft umwandeln, die Sie mit dem zurückgegebenen Ressourcen Wert festlegen wollten.  
  
 Die <xref:System.Windows.FrameworkContentElement.FindResource%2A>-Methode hat ein ähnliches Verhalten, mit dem Unterschied, dass eine Ausnahme ausgelöst wird, wenn keine Ressource mit dem angegebenen Schlüssel gefunden wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Ressource wie in Markup definiert gefunden und auf eine bestimmte Eigenschaft eines Elements als Reaktion auf ein Routing Ereignis angewendet.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Element aus einer Elementstruktur geladener Elemente entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Direkte Routing Ereignisse folgen keiner Route, Sie werden nur innerhalb desselben Elements behandelt, für das Sie ausgelöst werden. Direkt geroutete Ereignisse unterstützen das Verhalten anderer Routing Ereignisse: Sie unterstützen eine barrierefreie Handlerauflistung und können als <xref:System.Windows.EventTrigger> in einem Stil verwendet werden.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereignisbezeichnerobjekte werden erstellt, wenn Routing Ereignisse registriert werden (siehe <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) und können dann zum Hinzufügen von Klassen Handlern verwendet werden (siehe <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Bezeichnerobjekte enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Name/Objekt-Paars, der aus dem aktuellen Bereich entfernt werden soll.</param>
        <summary>Vereinfacht den Zugriff auf die <see cref="T:System.Windows.NameScope" />-Methode zum Aufheben der Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein anderes Element mit demselben Namen erneut registrieren möchten, müssen Sie die Registrierung von Namen aufheben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet erneut den Standardstil auf den aktuellen <see cref="T:System.Windows.FrameworkContentElement" /> an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
