<Type Name="Condition" FullName="System.Windows.Condition">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="15a1a1f4f454aae33befbbd418eacb49ed7a1589" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37493457" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Condition : System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Condition extends System.Object implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Condition" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Condition&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Condition sealed : System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Condition = class&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.XamlSetMarkupExtension("ReceiveMarkupExtension")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XamlSetTypeConverter("ReceiveTypeConverter")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Bedingung für <see cref="T:System.Windows.MultiTrigger" /> und <see cref="T:System.Windows.MultiDataTrigger" /> dar, die Änderungen an Eigenschaftswerten anhand einer Reihe von Bedingungen anwenden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s und <xref:System.Windows.MultiDataTrigger>s können Sie Eigenschaftswerte, die basierend auf einem Satz von Bedingungen festzulegen. Eine Bedingung erfüllt wird, wenn der Wert der Eigenschaft für das Element oder ein Datenelement in den angegebenen workflowverfolgungsereignissen übereinstimmt <xref:System.Windows.Condition.Value%2A> (Überprüfung auf Gleichheit verweisen). Wenn alle angegebene Bedingungen erfüllt sind, wird der Trigger angewendet.  
  
 Im folgenden finden eine Liste der Fälle, die eine Ausnahme ausgelöst wird:  
  
-   Für jede <xref:System.Windows.Condition>, Sie können entweder nur Festlegen der <xref:System.Windows.Condition.Property%2A> Eigenschaft oder das <xref:System.Windows.Condition.Binding%2A> Eigenschaft. Wenn beide Eigenschaften festgelegt sind, wird eine Ausnahme ausgelöst.  
  
-   Wenn die <xref:System.Windows.Condition> ist für eine <xref:System.Windows.MultiTrigger>, <xref:System.Windows.Condition.Property%2A> Eigenschaft darf nicht null sein.  
  
-   Wenn die <xref:System.Windows.Condition> ist für eine <xref:System.Windows.MultiDataTrigger>, <xref:System.Windows.Condition.Binding%2A> Eigenschaft darf nicht null sein.  
  
-   Eine Ausnahme wird ausgelöst, wenn das angegebene <xref:System.Windows.Condition.Value%2A> gilt nicht für den Typ des angegebenen <xref:System.Windows.Condition.Property%2A>.  
  
 Beachten Sie, dass bei der <xref:System.Windows.Condition> ist für eine <xref:System.Windows.MultiTrigger>, <xref:System.Windows.Condition.Property%2A> und <xref:System.Windows.Condition.Value%2A> Eigenschaften müssen festgelegt werden. Ist dies für eine <xref:System.Windows.MultiDataTrigger>, <xref:System.Windows.Condition.Binding%2A> und <xref:System.Windows.Condition.Value%2A> Eigenschaften müssen festgelegt werden.  
  
   
  
## Examples  
 Das folgende Beispiel enthält zwei <xref:System.Windows.MultiTrigger>s. Die ersten Sätze der **MinWidth** Eigenschaft Wert fest, wenn die **"HasItems"** Eigenschaft ist "false" und die **Breite** Eigenschaft **automatisch**. Das zweite Argument ist ähnlich, jedoch ist für die **MinHeight** Eigenschaft.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 Finden Sie unter den <xref:System.Windows.Condition.Binding%2A> -Eigenschaft für die Beispiele für Bedingungen dar, die einem <xref:System.Windows.MultiDataTrigger>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Condition" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Condition" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.Data.BindingBase binding, object conditionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Data.BindingBase binding, object conditionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.Data.BindingBase,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (binding As BindingBase, conditionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::Data::BindingBase ^ binding, System::Object ^ conditionValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.Data.BindingBase * obj -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (binding, conditionValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
        <Parameter Name="conditionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binding">Die Bindung, die die Eigenschaft der Bedingung angibt.</param>
        <param name="conditionValue">Der Wert der Bedingung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Condition" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.DependencyProperty conditionProperty, object conditionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty conditionProperty, object conditionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (conditionProperty As DependencyProperty, conditionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::DependencyProperty ^ conditionProperty, System::Object ^ conditionValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.DependencyProperty * obj -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (conditionProperty, conditionValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="conditionProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="conditionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="conditionProperty">Die Eigenschaft der Bedingung.</param>
        <param name="conditionValue">Der Wert der Bedingung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Condition" />-Klasse mit der angegebenen Eigenschaft und dem angegebenen Wert. Dieser Konstruktor führt die Parametervalidierung aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.DependencyProperty conditionProperty, object conditionValue, string sourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty conditionProperty, object conditionValue, string sourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.DependencyProperty,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (conditionProperty As DependencyProperty, conditionValue As Object, sourceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::DependencyProperty ^ conditionProperty, System::Object ^ conditionValue, System::String ^ sourceName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.DependencyProperty * obj * string -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (conditionProperty, conditionValue, sourceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="conditionProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="conditionValue" Type="System.Object" />
        <Parameter Name="sourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="conditionProperty">Die Eigenschaft der Bedingung.</param>
        <param name="conditionValue">Der Wert der Bedingung.</param>
        <param name="sourceName">
          <c>x:name</c> des Objekts mit der <c>ConditionProperty</c>.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Condition" /> -Klasse mit der angegebenen Eigenschaft, dem angegebenen Wert und dem Namen des Quellobjekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Binding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingBase Binding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingBase Binding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Binding" />
      <MemberSignature Language="VB.NET" Value="Public Property Binding As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingBase ^ Binding { System::Windows::Data::BindingBase ^ get(); void set(System::Windows::Data::BindingBase ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Binding : System.Windows.Data.BindingBase with get, set" Usage="System.Windows.Condition.Binding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bindung ab, die die Eigenschaft der Bedingung angibt, oder legt sie fest. Dies gilt nur für <see cref="T:System.Windows.MultiDataTrigger" />-Objekte.</summary>
        <value>Der Standardwert ist NULL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiDataTrigger>s können Sie zum Festlegen von Eigenschaftswerten, die basierend auf den Werten der Daten, die zurückgegeben werden. Wenn Sie eine Liste von Aufgabenelementen anzeigen, sollten Sie z. B. eine Aufgabe mit einem roten Hintergrund angezeigt, wenn sie von hoher Priorität und nicht auf mehr als zwei Wochen gesucht wurde wurde.  
  
 Sie erstellen eine Bindung und die <xref:System.Windows.Data.Binding.Path%2A> Eigenschaft zum Binden an eine Eigenschaft eines bestimmten Objekts (das Bindungsquellobjekt). Angenommen, Sie können eine Bindung die *Priorität* Eigenschaft eine *Aufgabe*. Weitere Informationen finden Sie unter [Übersicht über Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Beachten Sie, dass, wenn sie eine Bedingung für eine <xref:System.Windows.MultiDataTrigger>, <xref:System.Windows.Condition.Binding%2A> und <xref:System.Windows.Condition.Value%2A> Eigenschaften müssen festgelegt werden. Festlegen der <xref:System.Windows.Condition.Property%2A> Wert würden in diesem Fall eine Ausnahme ausgelöst.  
  
<a name="xamlAttributeUsage_PriorityBinding"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="{Binding  declaration}"/>  
```  
  
<a name="xamlPropertyElementUsage_Binding"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Binding>  
    <Binding …/>  
  </object.Binding>  
</object>  
```  
  
<a name="xamlValues_PriorityBinding"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *declaration*  
 Die Deklaration einer Bindung. Finden Sie unter [Deklarationen Übersicht über Datenbindung](~/docs/framework/wpf/data/binding-declarations-overview.md) für Weitere Informationen.  
  
   
  
## Examples  
 Im folgenden Beispiel die <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> von der <xref:System.Windows.Controls.ListBox> gebunden ist *stellen*, <xref:System.Collections.ObjectModel.ObservableCollection%601> von *Ort* Objekte. *Direkte* Objekte verfügen über Eigenschaften *Namen* und *Zustand*.  
  
 Jede <xref:System.Windows.Controls.ListBoxItem> von der <xref:System.Windows.Controls.ListBox> zeigt eine *Ort* Objekt. Die <xref:System.Windows.Style> im Beispiel wird angewendet auf die einzelnen <xref:System.Windows.Controls.ListBoxItem>. Die <xref:System.Windows.Condition>s der <xref:System.Windows.MultiDataTrigger> angegeben sind so, dass wenn der *Namen* und *Zustand* von der *Ort* Datenelement ist "Berlin" und "Oder" bzw. die Hintergrund des entsprechenden <xref:System.Windows.Controls.ListBoxItem> auf Cyan festgelegt wird.  
  
 [!code-xaml[DataTrigger#1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTrigger/CSharp/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Condition.Property" />
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty Property { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty Property" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Property" />
      <MemberSignature Language="VB.NET" Value="Public Property Property As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ Property { System::Windows::DependencyProperty ^ get(); void set(System::Windows::DependencyProperty ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Property : System.Windows.DependencyProperty with get, set" Usage="System.Windows.Condition.Property" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaft der Bedingung ab oder legt diese fest. Dies gilt nur für <see cref="T:System.Windows.MultiTrigger" />-Objekte.</summary>
        <value>Eine <see cref="T:System.Windows.DependencyProperty" />, die die Eigenschaft der Bedingung angibt. Der Standardwert ist NULL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s können Sie Eigenschaftswerte, die basierend auf einem Satz von Bedingungen festzulegen. Eine Bedingung ist erfüllt, wenn der Wert der Eigenschaft (gemäß der <xref:System.Windows.Condition.Property%2A> Eigenschaft) des Elements entspricht dem angegebenen <xref:System.Windows.Condition.Value%2A> (Überprüfung auf Gleichheit verweisen). Wenn alle angegebene Bedingungen erfüllt sind, wird der Trigger angewendet.  
  
 Wenn `TargetType` nicht auf das Format der Vorlage mit den Triggern festgelegt ist. Anschließend Sie die Eigenschaft mit qualifizieren müssen der `ClassName.PropertyName` Syntax.  
  
 Beachten Sie, dass, wenn sie eine Bedingung für eine <xref:System.Windows.MultiTrigger>, <xref:System.Windows.Condition.Property%2A> und <xref:System.Windows.Condition.Value%2A> Eigenschaften müssen festgelegt werden. Festlegen der <xref:System.Windows.Condition.Binding%2A> Wert würden in diesem Fall eine Ausnahme ausgelöst.  
  
 Für <xref:System.Windows.Condition>s in <xref:System.Windows.MultiDataTrigger>s, die <xref:System.Windows.Condition.Binding%2A> Eigenschaft sollte anstelle dieser Eigenschaft verwendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel enthält zwei <xref:System.Windows.MultiTrigger>s. Die ersten Sätze der **MinWidth** Eigenschaft Wert fest, wenn die **"HasItems"** Eigenschaft ist "false" und die **Breite** Eigenschaft **automatisch**. Das zweite Argument ist ähnlich, jedoch ist für die **MinHeight** Eigenschaft.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Condition.Binding" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMarkupExtension">
      <MemberSignature Language="C#" Value="public static void ReceiveMarkupExtension (object targetObject, System.Windows.Markup.XamlSetMarkupExtensionEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReceiveMarkupExtension(object targetObject, class System.Windows.Markup.XamlSetMarkupExtensionEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.ReceiveMarkupExtension(System.Object,System.Windows.Markup.XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReceiveMarkupExtension (targetObject As Object, eventArgs As XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReceiveMarkupExtension(System::Object ^ targetObject, System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="static member ReceiveMarkupExtension : obj * System.Windows.Markup.XamlSetMarkupExtensionEventArgs -&gt; unit" Usage="System.Windows.Condition.ReceiveMarkupExtension (targetObject, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetObject" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
      </Parameters>
      <Docs>
        <param name="targetObject">Das Objekt, in dem die Markuperweiterung den Wert festlegt.</param>
        <param name="eventArgs">Daten, die relevant für die Markuperweiterungsverarbeitung sind.</param>
        <summary>Behandelt Fälle, in denen eine Markuperweiterung einen Wert für die Eigenschaft eines <see cref="T:System.Windows.Condition" />-Objekts bereitstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Methode, die auf die verwiesen wird von einem übernommenen <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> -Attributs auf Klassenebene, was bedeutet, dass diese Methode alle Versuche zum Festlegen von verarbeitet <xref:System.Windows.Condition> mit einer Markuperweiterung. In der Regel wird diese Methode nicht direkt aufrufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionAttribute" />
        <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTypeConverter">
      <MemberSignature Language="C#" Value="public static void ReceiveTypeConverter (object targetObject, System.Windows.Markup.XamlSetTypeConverterEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReceiveTypeConverter(object targetObject, class System.Windows.Markup.XamlSetTypeConverterEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.ReceiveTypeConverter(System.Object,System.Windows.Markup.XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReceiveTypeConverter (targetObject As Object, eventArgs As XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReceiveTypeConverter(System::Object ^ targetObject, System::Windows::Markup::XamlSetTypeConverterEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="static member ReceiveTypeConverter : obj * System.Windows.Markup.XamlSetTypeConverterEventArgs -&gt; unit" Usage="System.Windows.Condition.ReceiveTypeConverter (targetObject, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetObject" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.Windows.Markup.XamlSetTypeConverterEventArgs" />
      </Parameters>
      <Docs>
        <param name="targetObject">Das Objekt, in dem der Typkonverter den Wert festlegt.</param>
        <param name="eventArgs">Daten, die relevant für die Typkonverterverarbeitung sind.</param>
        <summary>Behandelt Fälle, in denen ein Typkonverter einen Wert für die Eigenschaft eines <see cref="T:System.Windows.Condition" />-Objekts bereitstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Methode, die auf die verwiesen wird von einem übernommenen <xref:System.Windows.Markup.XamlSetTypeConverterAttribute> -Attributs auf Klassenebene, was bedeutet, dass diese Methode alle Versuche zum Festlegen von verarbeitet <xref:System.Windows.Condition> mit einem Typkonverter. In der Regel wird diese Methode nicht direkt aufrufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.XamlSetTypeConverterAttribute" />
        <altmember cref="T:System.Windows.Markup.XamlSetTypeConverterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SourceName">
      <MemberSignature Language="C#" Value="public string SourceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.SourceName" />
      <MemberSignature Language="VB.NET" Value="Public Property SourceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SourceName : string with get, set" Usage="System.Windows.Condition.SourceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Objekts mit der Eigenschaft ab, durch die die zugeordneten Setter angewendet werden, oder legt diesen fest. Dies gilt nur für <see cref="T:System.Windows.MultiTrigger" />-Objekte.</summary>
        <value>Die Standardeigenschaft ist <see langword="null" />. Wenn die Eigenschaft <see langword="null" /> ist, sorgt die Eigenschaft des formatierten Objekts dafür, dass die zugeordneten Setter angewendet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft festlegen, auf den Namen eines Elements innerhalb des Bereichs, in dem die triggerauflistung (die Auflistung, die der Trigger, der diese Bedingung enthält gehört) angewendet wird. Dies ist normalerweise ein benanntes Element, das in der Vorlage, die den Trigger enthält.  
  
 Sie können den Namen eines Objekts mit der [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) Syntax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Condition" />, die verwendet werden, können nicht mehr geändert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert dem Objekt den Start der Initialisierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Condition>-Instanz in eine <xref:System.ComponentModel.ISupportInitialize>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert dem Objekt den Abschluss der Initialisierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Condition>-Instanz in eine <xref:System.ComponentModel.ISupportInitialize>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj with get, set" Usage="System.Windows.Condition.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Markup.SetterTriggerConditionValueConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der Bedingung ab oder legt diesen fest.</summary>
        <value>Die <see cref="P:System.Windows.Condition.Value" />-Eigenschaft für eine angegebene <see cref="T:System.Windows.Condition" /> kann nicht NULL sein.  Weitere Informationen finden Sie im Abschnitt für Ausnahmen. Der Standardwert ist NULL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s und <xref:System.Windows.MultiDataTrigger>s können Sie Eigenschaftswerte, die basierend auf einem Satz von Bedingungen festzulegen. Eine Bedingung erfüllt wird, wenn der Wert der Eigenschaft für das Element oder ein Datenelement in den angegebenen workflowverfolgungsereignissen übereinstimmt <xref:System.Windows.Condition.Value%2A>. Wenn alle angegebene Bedingungen erfüllt sind, wird der Trigger angewendet. Wenn alle angegebene Bedingungen erfüllt sind, wird der Trigger angewendet.  
  
   
  
## Examples  
 Das folgende Beispiel enthält zwei <xref:System.Windows.MultiTrigger>s. Die ersten Sätze der **MinWidth** Eigenschaft Wert fest, wenn die **"HasItems"** Eigenschaft ist "false" und die **Breite** Eigenschaft **automatisch**. Das zweite Argument ist ähnlich, jedoch ist für die **MinHeight** Eigenschaft.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 Finden Sie unter den <xref:System.Windows.Condition.Binding%2A> -Eigenschaft für die Beispiele für Bedingungen dar, die einem <xref:System.Windows.MultiDataTrigger>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ausdrücke werden nicht unterstützt.</exception>
      </Docs>
    </Member>
  </Members>
</Type>