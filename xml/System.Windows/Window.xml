<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30e9c154175370c143890004c37ed150b5ecabbb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36456200" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides the ability to create, configure, show, and manage the lifetime of windows and dialog boxes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ort der Interaktion zwischen einem Benutzer und eine eigenständige Anwendung ist ein Fenster. Ein [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Fenster besteht aus zwei unterschiedlichen Bereichen:  
  
-   Ein nicht-Clientbereich, hostet die Windows-Zusatzelemente, z. B. ein Symbol, Titel, Systemmenü, Minimieren-Schaltfläche, Schaltfläche, Schaltfläche "Wiederherstellen", Schaltfläche "Schließen" und einen Rahmen zu maximieren.  
  
-   Ein Client-Bereich, der anwendungsspezifischen Inhalt hostet.  
  
 Standardfensters ist in der folgenden Abbildung gezeigt:  
  
 ![Fensterelemente](~/add/media/windowoverviewfigure1.PNG "Fensterelemente")  
  
 <xref:System.Windows.Window> Kapselt die Möglichkeit zu erstellen, konfigurieren, anzeigen und Verwalten der Lebensdauer von Fenstern und Dialogfeldern, und stellt die folgenden wichtige Dienste bereit:  
  
 **Verwaltung der Objektlebensdauer**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Fensterverwaltung**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Aussehen und Verhalten**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Dialogfelder**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Darüber hinaus <xref:System.Windows.Application> spezielle Unterstützung für die Verwaltung aller Fenster in einer Anwendung macht:  
  
-   Dienstanwendung verwaltet eine Liste aller Fenster angezeigt, die zurzeit in der Anwendung instanziiert werden. Diese Liste wird verfügbar gemacht, indem die <xref:System.Windows.Application.Windows%2A> Eigenschaft.  
  
-   Standardmäßig <xref:System.Windows.Application.MainWindow%2A> wird automatisch mit einem Verweis auf das erste festgelegt <xref:System.Windows.Window> , die in einer Anwendung instanziiert wird. Diese und dem Fenster das Hauptanwendungsfenster macht.  
  
 Ein <xref:System.Windows.Window> mit Markup, Markup und CodeBehind oder Code implementiert werden können.  
  
 <xref:System.Windows.Window> wird hauptsächlich verwendet, um Fenster und Dialogfelder für eigenständige Anwendungen anzuzeigen. Für Anwendungen, die Navigation auf der Fenster-Ebene, z. B. Assistenten, erfordern Sie können jedoch <xref:System.Windows.Navigation.NavigationWindow> stattdessen; <xref:System.Windows.Navigation.NavigationWindow> leitet sich von <xref:System.Windows.Window> und erweitert sie mit Unterstützung für die Navigation im Webbrowserstil.  
  
> [!NOTE]
>  Inseln navigierbar Inhalte können integriert werden, in andere Inhalte und Container, die mit <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> muss `UnmanagedCode` Sicherheitsberechtigung instanziiert werden. Dies hat folgenden Konsequenzen:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-bereitgestellten eigenständige Anwendungen fordert berechtigungserweiterung beim Start von Zonen "Internet" oder "Lokales Intranet.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] die fordern etwas kleiner als die uneingeschränkte Berechtigungen nicht Windows oder Dialogfelder instanziieren können.  
  
 Informationen zur Bereitstellung einer eigenständigen Anwendung und Überlegungen zur Sicherheit finden Sie unter [WPF-Sicherheitsstrategie – Plattformsicherheit](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Ein <xref:System.Windows.Window> ist eine <xref:System.Windows.Controls.ContentControl>, was bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. B. eine Zeichenfolge, ein Bild oder ein Bereich) enthalten kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.ContentControl>-Klasse. Darüber hinaus <xref:System.Windows.Window> ein Stammelement und aus diesem Grund darf nicht Teil einer anderen Elementinhalt.  
  
> [!NOTE]
>  Die <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, und <xref:System.Windows.Window.Left%2A> Eigenschaften für eine <xref:System.Windows.Window> über einen Stil nicht ausgeglichen werden zur Laufzeit.  
  
## <a name="customizing-the-window-control"></a>Anpassen des Window-Steuerelements  
 Zum Anwenden der gleichen eigenschafteneinstellungen mit mehreren <xref:System.Windows.Window> -Steuerelemente verwenden die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Sie können den Standardwert ändern <xref:System.Windows.Controls.ControlTemplate> auf dem Steuerelement ein einzigartiges aussehen zu verleihen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate>, finden Sie unter [Anpassen der Darstellung von einem vorhandenen Steuerelement durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Um anzuzeigen, die Teile und Zustände, die spezifisch für die <xref:System.Windows.Window>, finden Sie unter [Fensterstile und Vorlagen](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat für das Steuerelement festgelegt werden.  Wenn eine Eigenschaft von einem Standardformat festgelegt ist, kann die Eigenschaft von seinem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt, welche desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Standard-WPF-Designs](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Festlegen einer visuellen Eigenschaft haben nur Auswirkungen, wenn diese Eigenschaft sowohl in vorhanden ist <xref:System.Windows.Window> Steuerelement die Standardvorlage und festgelegt ist, mit ein. Sie finden eine Liste der Eigenschaften visueller Elemente im Abschnitt "Ändern der visuellen Struktur eines Steuerelements" [Anpassen der Darstellung von einem vorhandenen Steuerelement durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein standard-Fenster wird nur mit Markup definiert:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 Das folgende Beispiel zeigt, wie ein Standardfenster mit definiert wurde nur code:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Das folgende Beispiel zeigt, wie ein standard-Fenster wird mit einer Kombination von Markup und CodeBehind definiert.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Window" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor initialisiert die <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, und <xref:System.Windows.Window.Left%2A> Eigenschaften mit ihren Standardwerten <xref:System.Windows.Window> Werte.  
  
 Erstellt ein Fenster innerhalb eine <xref:System.AppDomain> mit dem ein <xref:System.Windows.Application> -Objekt, fügt der Konstruktor der <xref:System.Windows.Window> Objekt, das den Satz von <xref:System.Windows.Application>-verwaltete Windows über die <xref:System.Windows.Application.Windows%2A> Eigenschaft von der <xref:System.Windows.Application> Objekt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung für dieses Objekt unsichere systemeigene Methoden aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to bring the window to the foreground and activates it.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Windows.Window" /> was successfully activated; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln, die bestimmen, ob das Fenster aktiviert ist, sind identisch mit denen von verwendet die [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` Funktion ("User32.dll").  
  
 Wenn das Fenster in einer Windows Presentation Foundation-Anwendung aktiviert ist, die nicht die benutzeranwendung Vordergrund ist <xref:System.Windows.Application.Activated> Ereignis wird ausgelöst.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für ein Fenster zu aktivieren. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a window becomes the foreground window.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster aktiviert ist (wird das Fenster im Vordergrund) Wenn:  
  
-   Das Fenster wird zuerst geöffnet werden.  
  
-   Ein Benutzer wechselt zu einem Fenster, indem Sie sie auswählen, mit der Maus, und drücken ALT + TAB, oder im Task Manager.  
  
-   Ein Benutzer klickt auf die Schaltfläche auf der Taskleiste des Fensters.  
  
 Windows, die erkennen, wenn es sich bei Aktivierung müssen können behandeln die <xref:System.Windows.Window.Activated> Ereignis.  
  
 Nachdem ein Fenster erstmals aktiviert ist, kann es deaktiviert und erneut mehrere Male während seiner Lebensdauer aktiviert. Wenn das Verhalten einer Anwendungsverzeichnis oder der Zustand von Aktivierungszustand abhängig ist, können Sie überprüfen <xref:System.Windows.Window.IsActive%2A> um zu bestimmen, welche Aktivierungsstatus befindet sich im.  
  
 Eine Anwendung kann auch <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window's client area supports transparency.</summary>
        <value>
          <see langword="true" /> Wenn das Fenster Transparenz unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Controls.Control.Background%2A> Eigenschaft eines Fensters festgelegt ist, um eine transparente Farbe, mit <xref:System.Windows.Media.Brushes.Transparent%2A> beispielsweise bleibt das Fenster nicht transparent. Dies bedeutet, dass alle ausgeführten Anwendungen "das Fenster beneath" und auf dem Desktop nicht angezeigt werden. So aktivieren Sie diese Art von Transparenz, <xref:System.Windows.Window.AllowsTransparency%2A> muss festgelegt werden, um `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> ist vorhanden, um die Erstellung von nicht rechteckigen Fenstern zu erleichtern und folglich beim <xref:System.Windows.Window.AllowsTransparency%2A> festgelegt ist, um `true`, ein Fenster <xref:System.Windows.Window.WindowStyle%2A> Eigenschaft muss festgelegt werden, um <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A window that has a <see cref="P:System.Windows.Window.WindowStyle" /> value of anything other than <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.AllowsTransparency" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">A <see cref="T:System.Windows.Size" /> that reflects the final size that the window should use to arrange itself and its children.</param>
        <summary>Override this method to arrange and size a window and its child elements.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> that reflects the actual size that was used.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft hat den Wert des <xref:System.Windows.Visibility.Collapsed>. Wenn der Wert der <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> aufgerufen wird.  
  
> [!NOTE]
>  Wenn entweder <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft eine <xref:System.Windows.Window> auf festgelegt ist <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Manually closes a <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Window> kann geschlossen werden, verwenden eine von mehreren, bekannte, vom System bereitgestellte Mechanismen in der Titelleiste befindet:  
  
-   ALT + F4.  
  
-   Systemmenü &#124; **schließen**.  
  
-   **Schließen** Schaltfläche.  
  
 Ein <xref:System.Windows.Window> kann geschlossen werden mit einer von mehreren bekannten Mechanismen im Clientbereich, die von Entwicklern, einschließlich bereitgestellt werden:  
  
-   **Datei** &#124; **beenden** auf ein Hauptfenster.  
  
-   **Datei** &#124; **schließen** oder ein **schließen** auf ein untergeordnetes Fenster auf die Schaltfläche.  
  
> [!NOTE]
>  **OK** und **"Abbrechen"** Schaltflächen in einem Dialogfeld werden auch von Entwicklern bereitgestellt, obwohl wird wahrscheinlich Satz <xref:System.Windows.Window.DialogResult%2A>, die automatisch geschlossen wird, ein Fenster, das durch den Aufruf geöffnet wurde <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Diese Mechanismen erfordern Sie explizit aufrufen <xref:System.Windows.Window.Close%2A> um ein Fenster zu schließen.  
  
> [!NOTE]
>  Wenn ein Fenster geöffnet wird, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>, und mit einer <xref:System.Windows.Controls.Button> mit seiner <xref:System.Windows.Controls.Button.IsCancel%2A> -Eigenschaft auf "true" festgelegt wird automatisch geschlossen, wenn die Schaltfläche geklickt oder die ESC-Taste gedrückt wird. Wenn das Fenster geöffnet wurde mit <xref:System.Windows.Window.Show%2A>, allerdings <xref:System.Windows.Window.Close%2A> muss explizit aufgerufen werden, z. B. <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignishandler für das <xref:System.Windows.Controls.Button>.  
  
 Schließen eines Fensters bewirkt, dass die <xref:System.Windows.Window.Closing> Ereignis ausgelöst wurde. Wenn die <xref:System.Windows.Window.Closing> Ereignis wird nicht abgebrochen, geschieht Folgendes:  
  
-   Die <xref:System.Windows.Window> wird daraus <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (wenn ein <xref:System.Windows.Application> Objekt vorhanden ist).  
  
-   Die <xref:System.Windows.Window> wird vom Besitzer entfernt <xref:System.Windows.Window> , wenn die Besitzer contosoit Beziehung hergestellt wurde vor der Besitzer <xref:System.Windows.Window> angezeigt wurde und nach der Besitzer <xref:System.Windows.Window> geöffnet wurde.  
  
-   Das <xref:System.Windows.Window.Closed>-Ereignis wird ausgelöst.  
  
-   Nicht verwaltete Ressourcen erstellt, indem die <xref:System.Windows.Window> verworfen werden.  
  
-   Wenn <xref:System.Windows.Window.ShowDialog%2A> wurde aufgerufen, um das Anzeigen der <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> zurückgibt.  
  
 Schließen einer <xref:System.Windows.Window> bewirkt, dass alle Fenster, die er besitzt, um die geschlossen werden. Darüber hinaus schließen eine <xref:System.Windows.Window> kann dazu führen, dass eine Anwendung beendet wird, je nachdem, wie der <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> festgelegt wird.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine **Datei** &#124; **beenden** Menü wird behandelt, um explizit aufrufen <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window is about to close.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem dieses Ereignis ausgelöst wird, kann nicht schließen ein Fensters verhindert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Hide" /> is called while a window is closing.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs directly after <see cref="M:System.Windows.Window.Close" /> is called, and can be handled to cancel window closure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> kann behandelt werden, um zu erkennen, wenn ein Fenster geschlossen wird (z. B. wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird). Darüber hinaus <xref:System.Windows.Window.Closing> können verwendet werden, um zu verhindern, dass ein Fenster schließen. Zum Schließen ein Fensters zu verhindern, legen Sie die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> Argument für `true`.  
  
 Die <xref:System.Windows.Window.Closing> Ereignis wird ausgelöst, wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird, wenn ein Fenster Schaltfläche "Schließen" geklickt wird oder wenn der Benutzer drückt, ALT + F4.  
  
 Wenn ein Besitzer Fenster geöffnet wurde, dessen Besitzer Fenster mit <xref:System.Windows.Window.Show%2A>, und der Besitzer Fenster geschlossen ist, wird des zugehörige Fensters <xref:System.Windows.Window.Closing> Ereignis wird nicht ausgelöst. Wenn der Besitzer eines Fensters geschlossen wird (finden Sie unter <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> nicht für das zugehörige Fenster ausgelöst wird.  
  
 Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, die <xref:System.Windows.Window.Closing> Ereignis für jedes Fenster wird ausgelöst. Jedoch wenn <xref:System.Windows.Window.Closing> wird abgebrochen, Abbruch wird ignoriert.  
  
 Wenn eine Sitzung beendet, da ein Benutzer abmeldet oder Herunterfahren <xref:System.Windows.Window.Closing> wird nicht ausgelöst; behandeln <xref:System.Windows.Application.SessionEnding> um Code zu implementieren, das Schließen der Anwendung abbricht.  
  
 Wenn Sie anzeigen oder Ausblenden eines Fensters während der Lebensdauer einer Anwendung mehrmals möchten und nicht das Fenster jedes Mal neu instanziieren möchten Sie diese anzeigen, können Sie behandeln die <xref:System.Windows.Window.Closing> Ereignis, brechen Sie ihn ab, und rufen die <xref:System.Windows.Window.Hide%2A> Methode. Rufen Sie Sie dann <xref:System.Windows.Window.Show%2A> in der gleichen Instanz aus, um es erneut zu öffnen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Windows.Window> , der bestimmt, ob zum Schließen ein Benutzereingriff erforderlich.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Close" /> is called while a window is closing.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a window's content has been rendered.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Fenster um keinen Inhalt hat, wird dieses Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a window becomes a background window.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster ist deaktiviert (wird zu einem Hintergrundfenster) Wenn:  
  
-   Ein Benutzer wechselt zu einem anderen Fenster in der aktuellen Anwendung.  
  
-   Ein Benutzer wechselt zum Fenster in einer anderen Anwendung mithilfe der Tastenkombination ALT + TAB oder mithilfe von Task-Manager.  
  
-   Ein Benutzer klickt auf die Taskleistenschaltfläche für ein Fenster in einer anderen Anwendung.  
  
 Windows, die erkennen, wenn die Deaktivierung durch behandeln müssen die <xref:System.Windows.Window.Deactivated> Ereignis.  
  
 Nachdem ein Fenster zunächst deaktiviert ist, kann Sie erneut aktiviert und oft während seiner Lebensdauer deaktiviert werden. Wenn das Verhalten einer Anwendungsverzeichnis oder der Zustand von Aktivierungszustand abhängig ist, können Sie überprüfen <xref:System.Windows.Window.IsActive%2A> um zu bestimmen, welche Aktivierungsstatus befindet sich im.  
  
 Eine Anwendung kann auch <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the dialog result value, which is the value that is returned from the <see cref="M:System.Windows.Window.ShowDialog" /> method.</summary>
        <value>Ein <see cref="T:System.Nullable`1" /> Wert vom Typ <see cref="T:System.Boolean" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> kann verwendet werden, aus dem Code, der ein Dialogfeld, um zu bestimmen, ob ein Benutzer akzeptiert ergab (`true`) oder abgebrochen wurde (`false`) des Dialogfelds "". Wenn ein Dialogfeld akzeptiert wurde, bedeutet dies, um den Code, der zum Abrufen von Daten, die vom Benutzer gesammelt wurden und verarbeiten sie das Dialogfeld geöffnet. Wenn ein Dialogfeld abgebrochen wurde, allerdings bedeutet dies, dass das Aufrufen von Code beendet werden soll, weitere Verarbeitung.  
  
 Wird standardmäßig ein Dialogfeld abgebrochen wird, wenn ein Benutzer eine der folgenden ist:  
  
-   PressesALT + F4.  
  
-   Klickt der **schließen** Schaltfläche.  
  
-   Wählt **schließen** aus dem Systemmenü.  
  
 In all diesen Fällen <xref:System.Windows.Window.DialogResult%2A> ist `false` standardmäßig.  
  
 Ein Dialogfeld, in der Regel stellt eine spezielle Schaltfläche, um ein Dialogfeld "Abbrechen", die die Schaltfläche "", deren <xref:System.Windows.Controls.Button.IsCancel%2A> -Eigenschaftensatz auf `true`. Eine Schaltfläche, die auf diese Weise konfiguriert wird ein Fenster automatisch geschlossen, wenn entweder es gedrückt wird oder wenn die ESC-Taste gedrückt wird. In diesen Fällen <xref:System.Windows.Window.DialogResult%2A> bleibt `false`.  
  
 Ein Dialogfeld in der Regel auch eine Bestätigungsschaltfläche, die die Schaltfläche "" enthält, deren <xref:System.Windows.Controls.Button.IsDefault%2A> -Eigenschaftensatz auf `true`. Eine Schaltfläche, die diese Art konfigurierten löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis aus, wenn sie oder die EINGABETASTE gedrückt wird. Jedoch wird nicht automatisch das Dialogfeld schließen, noch wird festgelegt <xref:System.Windows.Window.DialogResult%2A> auf `true`. Müssen Sie manuell dieser Schreiben von Code in der Regel aus der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignishandler für die Standardschaltfläche.  
  
 <xref:System.Windows.Window.DialogResult%2A> ist `null` das Dialogfeld wird angezeigt, wenn jedoch weder akzeptiert noch abgebrochen.  
  
 Nachdem ein Dialogfeld wird, und geschlossen Sie erhalten das Dialogergebnis über den Rückgabewert von <xref:System.Windows.Window.ShowDialog%2A> -Methode, oder durch Überprüfen der <xref:System.Windows.Window.DialogResult%2A> Eigenschaft.  
  
 <xref:System.Windows.Window.DialogResult%2A> kann nur festgelegt werden, wenn eine <xref:System.Windows.Window> geöffnet wird, durch Aufrufen seiner <xref:System.Windows.Window.ShowDialog%2A> Methode.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine Schaltfläche "OK" und eine Schaltfläche "Abbrechen", um die entsprechende zurückzugeben konfigurieren <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> is set before a window is opened by calling <see cref="M:System.Windows.Window.ShowDialog" />.  -or-  <see cref="P:System.Windows.Window.DialogResult" /> is set on a window that is opened by calling <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the DPI of the screen on which the Window is displayed changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.Windows.RoutedEvent" /> for when the DPI of the screen the Window is on changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows a window to be dragged by a mouse with its left button down over an exposed area of the window's client area.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die linke Maustaste gedrückt werden muss, heruntergefahren, wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird. Eine Möglichkeit zum erkennen, wenn die linke Maustaste gedrückt wird, zu behandeln ist die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis.  
  
 Wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird, wird die linke Maustaste über einen verfügbar gemachten Bereich des Clientbereichs des Fensters gedrückt werden muss.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> Aufrufen <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The left mouse button is not down.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für ein Fenster ziehen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">The dependency object.</param>
        <summary>Returns a reference to the <see cref="T:System.Windows.Window" /> object that hosts the content tree within which the dependency object is located.</summary>
        <returns>A <see cref="T:System.Windows.Window" /> reference to the host window.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes a window invisible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster wird nicht geschlossen, wenn es ausgeblendet ist, und weder die <xref:System.Windows.Window.Closing> noch <xref:System.Windows.Window.Closed> Ereignis wird ausgelöst. Stattdessen des Fensters <xref:System.Windows.UIElement.Visibility%2A> -Eigenschaftensatz auf <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Wenn ein Fenster der Anwendungsverzeichnis wird <xref:System.Windows.Application.MainWindow%2A> und die Anwendung <xref:System.Windows.Application.ShutdownMode%2A> ist <xref:System.Windows.ShutdownMode.OnMainWindowClose>, die Anwendung wird nicht heruntergefahren. Andererseits die Anwendung wird nicht heruntergefahren, wenn ein Fenster das einzige Fenster ist und Modus Herunterfahren der Anwendung <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Wenn Sie anzeigen oder Ausblenden eines Fensters während der Lebensdauer einer Anwendung mehrmals, und nicht das Fenster jedes Mal erneut instanziieren möchten Sie diese anzeigen, können Sie behandeln die <xref:System.Windows.Window.Closing> Ereignis, brechen Sie ihn ab, und rufen die <xref:System.Windows.Window.Hide%2A> Methode. Rufen Sie Sie dann <xref:System.Windows.Window.Show%2A> in der gleichen Instanz aus, um es erneut zu öffnen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's icon.</summary>
        <value>Ein <see cref="T:System.Windows.Media.ImageSource" /> Objekt, das das Symbol darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) eigenständige Anwendungen sind zwei Symbole:  
  
-   Eine Assembly-Symbol, das mithilfe des Parameters der `<ApplicationIcon>` Datei Eigenschaft im Projekt der Anwendung zu erstellen. Dieses Symbol wird als das Desktopsymbol für eine Assembly verwendet.  
  
    > [!NOTE]
    >  Beim Debuggen in Visual Studio möglicherweise das Symbol nicht aufgrund der Hostprozess angezeigt. Wenn Sie die ausführbare Datei ausführen, wird das Symbol angezeigt. Weitere Informationen finden Sie unter [Hostprozess („vshost.exe“)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Ein Symbol pro Fenster, das durch Festlegen von angegebenen <xref:System.Windows.Window.Icon%2A>. Für jedes Fenster wird dieses Symbol in der Titelleiste der Taskleistenschaltfläche und in die Tastenkombination ALT + TAB Auswahl-Liste Anwendungseintrag verwendet.  
  
 Ein WPF-Fenster wird immer ein Symbol angezeigt. Wenn nicht bereitgestellt durch Festlegen von <xref:System.Windows.Window.Icon%2A>, WPF wählt ein Symbol anzuzeigende anhand der folgenden Regeln:  
  
1.  Verwenden Sie das Symbol "Assembly", falls angegeben.  
  
2.  Wenn das Symbol "Assembly" nicht angegeben ist, verwenden Sie das Standardsymbol für Microsoft Windows.  
  
 Bei Verwendung von <xref:System.Windows.Window.Icon%2A> um ein benutzerdefiniertes Fenstersymbol angeben, können Sie das Standardsymbol für die Anwendung wiederherstellen, indem festlegen <xref:System.Windows.Window.Icon%2A> auf `null`.  
  
 Ein einzelnes Symbol kann auf verschiedene Weise in Windows, einschließlich der in der Titelleiste eines Fensters, auf der Taskleiste für ein Fenster, die Dateiliste Auswahl ALT + TAB angezeigt wird, verwendet werden. Jedes davon wird gezeigt, das Symbol mit einer anderen Größe: ein 16 x 16 Pixel-Symbol wird in der Titelleiste eines Fensters und in der Taskleiste angezeigt, während ein 32 x 32 Pixel großes Symbol in der Dateiliste Auswahl ALT + TAB angezeigt wird. Einige Anwendungen wie [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], geben Sie einen **Ansicht** Menü, mit dem Sie die Größe des Symbols zu wählen, Sie anzeigen möchten.  
  
 Um die verschiedenen Anzeigegrößen erfüllen, eine Symboldatei mindestens eine tatsächliche Symbole besteht, in denen jeweils eine Version des Symbols darstellt, die eine bestimmte Größe und Farbe Tiefe ausgerichtet ist. Beispielsweise kann ein Symbol nur besitzen ein einzelnes 16 x 16 Pixelsymbol mit 16 Farben während eine andere 16 x 16 Pixel und 32 x 32 Pixel großes Symbole mit 16 Farben und 256 Farben enthalten kann.  
  
 Wenn in einer Symboldatei Symbole für alle möglichen Größen und Farbtiefen vorhanden <xref:System.Windows.Window> wird das entsprechende Symbol verwenden. Wenn eine Symboldatei nur eine Teilmenge aller möglichen Symbole enthält <xref:System.Windows.Window> das nächste Symbol "am besten geeignete" sinkender Größen und Farbtiefe verwendet.  
  
 Das Ergebnis ist, dass ein Symbol wird immer durch verwendet, <xref:System.Windows.Window>, obwohl das Symbol verwendet nicht die erforderliche Größe und die Farbtiefe Ziel verwenden kann. Beispielsweise kann ein Pixelsymbol 16 x 16 mit 16 Farben für die Anzeige als ein 32 x 32 Pixel großes Symbol mit 256 Farben verwendet werden. Dies kann dazu führen, dass unerwünschte visuelle Effekte wie geglättet, jedoch möglicherweise vermieden werden, indem Sie die Symbole für alle entsprechenden Größe und Farbe Tiefen erstellen.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.IconProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie ein Symbol "Fenster" festgelegt wird.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Festlegen des Symbols. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Icon" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the window is active.</summary>
        <value>
          <see langword="true" /> Wenn das Fenster aktiv ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein aktiven Fensters wird der aktuelle Vordergrundfenster des Benutzers und den Fokus hat, was durch die aktive Darstellung der Titelleiste angezeigt wird. Ein aktives Fenster werden auch die oberste alle Fenster auf oberster Ebene, die nicht explizit festlegen der <xref:System.Windows.Window.Topmost%2A> Eigenschaft.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.IsActiveProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.IsActive" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window's left edge, in relation to the desktop.</summary>
        <value>Die Position des linken Fensterrands in logischen Einheiten (1/96 Zoll).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> maximiert wird oder minimiert, dieser Wert darstellt, die der linke Rand der Wiederherstellung von Wiederherstellungspunkten für die <xref:System.Windows.Window>.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie einen Wert nicht angeben <xref:System.Windows.Window.Left%2A> auf den Standardwert des Systems festgelegt ist. Sie können auch die Systemstandardwert angeben, durch Festlegen von <xref:System.Windows.Window.Left%2A> auf <xref:System.Double.NaN>. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.LeftProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Left" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window's location changes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position des Fensters wird geändert, wenn:  
  
-   Ein Benutzer verschiebt ein Fenster durch ziehen es mit der Titelleiste des Fensters.  
  
-   Ein Fenster verschoben wird, nachdem <xref:System.Windows.Window.DragMove%2A> aufgerufen wird.  
  
-   Entweder die <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> Eigenschaft programmgesteuert festgelegt ist.  
  
-   Die **verschieben** Menüelement Systemmenü des Fensters ausgewählt ist.  
  
-   Die <xref:System.Windows.Window.WindowState%2A> -Eigenschaft geändert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator for a window's logical child elements.</summary>
        <value>Ein <see cref="T:System.Collections.IEnumerator" /> die logischen untergeordneten Elemente eines Fensters.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">A <see cref="T:System.Windows.Size" /> that reflects the available size that this window can give to the child. Infinity can be given as a value to indicate that the window will size to whatever content is available.</param>
        <summary>Override this method to measure the size of a window.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> that reflects the size that this window determines it needs during layout, based on its calculations of children's sizes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft hat den Wert des <xref:System.Windows.Visibility.Collapsed>. Wenn der Wert der <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> aufgerufen wird.  
  
> [!NOTE]
>  Wenn entweder <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft eine <xref:System.Windows.Window> auf festgelegt ist <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Activated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnActivated%2A> wird das <xref:System.Windows.Window.Activated>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnActivated%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnActivated%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Activated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Closed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosed%2A> wird das <xref:System.Windows.Window.Closed>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnClosed%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnClosed%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Closed> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Closing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosing%2A> wird das <xref:System.Windows.Window.Closing>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnClosing%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnClosing%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Closing> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">A reference to the root of the old content tree.</param>
        <param name="newContent">A reference to the root of the new content tree.</param>
        <summary>Called when the <see cref="P:System.Windows.Controls.ContentControl.Content" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.ContentRendered" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnContentRendered%2A> wird das <xref:System.Windows.Window.ContentRendered>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnContentRendered%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnContentRendered%2A> in der Basisklasse Wenn <xref:System.Windows.Window.ContentRendered> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates and returns a <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</summary>
        <returns>A <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Deactivated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnDeactivated%2A> wird das <xref:System.Windows.Window.Deactivated>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnDeactivated%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnDeactivated%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Deactivated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">The previous DPI scale setting.</param>
        <param name="newDpi">The new DPI scale setting.</param>
        <summary>Called when the DPI at which this window is rendered changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.LocationChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnLocationChanged%2A> wird das <xref:System.Windows.Window.LocationChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnLocationChanged%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnLocationChanged%2A> in der Basisklasse Wenn <xref:System.Windows.Window.LocationChanged> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The data for the event.</param>
        <summary>Called when the <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> event occurs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses, die das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.SourceInitialized" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnSourceInitialized%2A> wird das <xref:System.Windows.Window.SourceInitialized>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnSourceInitialized%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnSourceInitialized%2A> in der Basisklasse Wenn <xref:System.Windows.Window.SourceInitialized> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.StateChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnStateChanged%2A> wird das <xref:System.Windows.Window.StateChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der von ableitet <xref:System.Windows.Window> Überschreiben dieses möglicherweise <xref:System.Windows.Window.OnStateChanged%2A>. Die überschriebene Methode aufrufen, muss <xref:System.Windows.Window.OnStateChanged%2A> in der Basisklasse Wenn <xref:System.Windows.Window.StateChanged> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">The previous parent. Set to null if the <see cref="T:System.Windows.DependencyObject" /> did not have a previous parent.</param>
        <summary>Called when the parent of the window is changed.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of windows for which this window is the owner.</summary>
        <value>Ein <see cref="T:System.Windows.WindowCollection" /> enthält Verweise auf die der Besitzer dieses Fenster ist Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein im Besitz befindlichen Fenster ist eine, deren <xref:System.Windows.Window.Owner%2A> Eigenschaftensatz mit einem Verweis auf ein anderes Fenster, das als das besitzende Fenster bezeichnet wird. Um alle Fenster suchen, die einem Besitzerfenster gehören, können Sie auflisten <xref:System.Windows.WindowCollection> der zurückgegeben wird, indem die <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie auflisten <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Window" /> that owns this <see cref="T:System.Windows.Window" />.</summary>
        <value>Ein <see cref="T:System.Windows.Window" /> -Objekt, das den Besitzer dieses darstellt <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein untergeordnetes Fenster durch Aufrufen von einem übergeordneten Fenster geöffnet wird <xref:System.Windows.Window.ShowDialog%2A>, eine implizite Beziehung zwischen übergeordneten und untergeordneten Fenster eingerichtet. Diese Beziehung erzwingt bestimmte Verhaltensweisen, z. B. in Bezug auf Maximieren, minimieren und wiederherstellen.  
  
 Wenn ein untergeordnetes Fenster durch Aufruf von einem übergeordneten Fenster erstellt wurde <xref:System.Windows.Window.Show%2A>, das untergeordnete Fenster verfügt jedoch nicht über eine Beziehung mit dem übergeordneten Fenster. Dies bedeutet Folgendes:  
  
-   Einen Verweis auf das übergeordnete Fenster keine untergeordneten Fenster.  
  
-   Das Verhalten des untergeordneten Fensters ist nicht das Verhalten des übergeordneten Fensters abhängig; entweder Fenster deckt die andere oder minimiert, maximiert und unabhängig voneinander wiederhergestellt.  
  
 Ermöglicht das Erstellen eine Beziehung zwischen einem untergeordneten Fenster und ein übergeordnetes Fenster, <xref:System.Windows.Window> unterstützt das Konzept des Besitzes. Besitz wird eingerichtet, wenn die <xref:System.Windows.Window.Owner%2A> Eigenschaft eines Fensters (das im Besitz befindlichen Fenster) mit einem Verweis auf ein anderes Fenster (das Besitzerfenster) festgelegt ist.  
  
 Sobald diese Beziehung hergestellt wurde, werden die folgenden Verhalten gezeigt:  
  
-   Wenn ein Besitzerfenster minimiert wird, werden auch alle seine zugehörige Fenster minimiert.  
  
-   Wenn ein Fenster im Besitz befindlichen minimiert wird, ist der Besitzer nicht minimiert.  
  
-   Wenn ein Besitzerfenster maximiert ist, werden das besitzende Fenster und die zugehörige Windows wiederhergestellt.  
  
-   Ein Besitzerfenster kann nie eine zugehörige Fenster abdecken.  
  
-   Im Besitz von Fenstern, die nicht mit geöffnet wurden <xref:System.Windows.Window.ShowDialog%2A> sind nicht modal. Die Benutzer kann weiterhin das besitzende Fenster interagieren.  
  
-   Wenn Sie ein Besitzerfenster schließen, werden die im Besitz befindlichen Windows ebenfalls geschlossen.  
  
-   Wenn ein Besitzer Fenster geöffnet wurde, dessen Besitzer Fenster mit <xref:System.Windows.Window.Show%2A>, und der Besitzer Fenster geschlossen ist, wird des zugehörige Fensters <xref:System.Windows.Window.Closing> Ereignis wird nicht ausgelöst.  
  
 Wenn Sie ein untergeordnetes Fenster öffnen, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>, Sie sollten auch festlegen, die <xref:System.Windows.Window.Owner%2A> Eigenschaft des untergeordneten Fensters. Wenn Sie dies nicht tun, wird nicht Ihre Benutzer untergeordnetes Fenster und übergeordneten Fenster durch Drücken der Taskleistenschaltfläche wiederherstellen können. Drücken die Taskleistenschaltfläche, wird eine Liste von Windows, einschließlich der untergeordneten und übergeordneten Fenster, um Wählen Sie stattdessen ergeben; nur das ausgewählte Fenster wird wiederhergestellt.  
  
> [!IMPORTANT]
>  Sie sollten auch festlegen, die <xref:System.Windows.Window.Owner%2A> -Eigenschaft für ein Fenster, die durch den Aufruf geöffnet ist <xref:System.Windows.Window.ShowDialog%2A> , das richtige Verhalten mit sicherzustellen.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie die Besitzer contosoit Beziehung hergestellt wird.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A window tries to own itself  -or-  Two windows try to own each other.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Windows.Window.Owner" /> property is set on a visible window shown using <see cref="M:System.Windows.Window.ShowDialog" />  -or-  The <see cref="P:System.Windows.Window.Owner" /> property is set with a window that has not been previously shown.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the resize mode.</summary>
        <value>Ein <see cref="T:System.Windows.ResizeMode" /> Wert, der den Größenänderungsmodus angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt vier Optionen aus:  
  
-   **False**. Der Benutzer kann nicht die Fenstergröße ändern. Die Maximieren und minimieren Felder werden nicht angezeigt.  
  
-   **CanMinimize**. Der Benutzer kann nur das Fenster minimieren und Wiederherstellen über die Taskleiste aus. Die Felder minimieren und Maximieren werden angezeigt, aber nur das Kästchen zum Minimieren aktiviert ist.  
  
-   **CanResize**. Der Benutzer kann die vollständige Größe des Fensters Felder minimieren und Maximieren und Größenänderungsoptionen verwenden, um das Fenster. Die Felder minimieren und Maximieren sind angezeigt und aktiviert. (Standard).  
  
-   **CanResizeWithGrip**. Diese Option hat die gleiche Funktionalität wie <xref:System.Windows.ResizeMode.CanResize>, aber der unteren rechten Ecke des Fensters "Resize Ziehpunkts" hinzugefügt.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ResizeModeProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ResizeMode" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size and location of a window before being either minimized or maximized.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" /> , die gibt die Größe und Position eines Fensters vor dem Minimieren oder maximieren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Rechteck für die Wiederherstellung ist die Region, die vom Fenster belegt wird, bevor es minimiert oder maximiert wurde. Sie können <xref:System.Windows.Window.RestoreBounds%2A> die letzte Größe und Position eines Fensters zu speichern, bevor eine Anwendung geschlossen wird, und diese Werte das nächste Mal eine Anwendung gestartet wird, um ein Fenster der Art und Weise wiederherzustellen, ein Benutzer sie abrufen.  
  
 Wenn Sie Abfragen <xref:System.Windows.Window.RestoreBounds%2A> bevor das Fenster angezeigt wird oder nachdem er geschlossen wurde, <xref:System.Windows.Rect.Empty%2A> wird zurückgegeben.  
  
> [!NOTE]
>  Diese Eigenschaft kann nicht abgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Window.RestoreBounds%2A> und isolierten Speicher, um sicherzustellen, dass die Größe und Position eines Fensters sind die gleiche wie beim vorherigen Mal Fenster gezeigt wurde.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Berechtigung zum Abfragen der Größe und Position eines Fensters für das umgebende Rechteck. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opens a window and returns without waiting for the newly opened window to close.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> Klasse instanziiert wird, ist jedoch nicht standardmäßig angezeigt. <xref:System.Windows.Window.Show%2A> Zeigt ein Fenster, und gibt sofort zurück, ohne zu warten, für das Fenster geschlossen werden. Daher wird das geöffnete Fenster nicht Benutzer verhindert Interaktion mit anderen Fenstern in der Anwendung. Diese Art von Fenster bezeichnet ist ein *nicht modalen* Fenster. Allgemeine Beispiele für nicht modale Fenster sind Eigenschaftenfenster, Toolboxen und Paletten. Um ein Benutzer auf die Interaktion mit einem bestimmten Fenster beschränken möchten, muss das Fenster geöffnet werden durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ein Fenster, das durch Aufrufen von <xref:System.Windows.Window.Show%2A> wird nicht automatisch eine Beziehung mit dem Fenster, das sie geöffnet haben, insbesondere das geöffnete Fenster weiß nicht, welches Fenster öffnen. Diese Beziehung mit hergestellt werden kann die <xref:System.Windows.Window.Owner%2A> Eigenschaft und verwalteten mithilfe der <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft.  
  
 Aufrufen <xref:System.Windows.Window.Show%2A> erzielt wird das gleiche Endergebnis als Einstellung <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft von der <xref:System.Windows.Window> -Objekt <xref:System.Windows.Visibility.Visible>. Allerdings besteht ein Unterschied zwischen den beiden hinsichtlich der zeitlichen Steuerung.  
  
 Aufrufen von <xref:System.Windows.Window.Show%2A> ist ein synchroner Vorgang, der erst nach zurückgibt der <xref:System.Windows.FrameworkElement.Loaded> auf das untergeordnete Fenster-Ereignis ausgelöst wurde:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Festlegen von <xref:System.Windows.UIElement.Visibility%2A>, jedoch ist ein asynchroner Vorgang, der sofort zurückgibt:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Beim Festlegen von <xref:System.Windows.UIElement.Visibility%2A>, alle Fensterereignisse, die Sie registrieren, bevor Sie festlegen, <xref:System.Windows.UIElement.Visibility%2A> kann nicht ausgelöst werden, erst nach der Methode, in dem Sie festlegen <xref:System.Windows.UIElement.Visibility%2A> Ausführung abgeschlossen hat.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie ein nicht modales Fenster zu öffnen.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window is activated when first shown.</summary>
        <value>
          <see langword="true" /> Wenn ein Fenster aktiviert wird, wenn Sie zuerst angezeigt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Fenster mit seiner <xref:System.Windows.Window.ShowActivated%2A> -Eigenschaftensatz auf `false` ist geöffnet, wird das Fenster nicht aktiviert und die zugehörige <xref:System.Windows.Window.Activated> Ereignis wird nicht ausgelöst, bis ein Benutzer das Fenster manuell durch Auswahl aktiviert. Nachdem das Fenster ausgewählt ist, aktiviert und normalerweise deaktiviert.  
  
 Um zu verhindern, dass ein Fenster wird aktiviert, wenn er geöffnet wird, die <xref:System.Windows.Window.ShowActivated%2A> Eigenschaft muss festgelegt werden, um `false` , bevor das Fenster angezeigt wird (durch Aufrufen von <xref:System.Windows.Window.Show%2A>); Einstellung <xref:System.Windows.Window.ShowActivated%2A> auf `false` ein Fenster angezeigt wird, hat keine Auswirkungen, die nach.  
  
 Festlegen von <xref:System.Windows.Window.ShowActivated%2A> auf `false` für ein Fenster, das durch den Aufruf modal, geöffnet wird <xref:System.Windows.Window.ShowDialog%2A>, keine tatsächlichen Auswirkungen hat. Obwohl das modale Fenster nicht aktiviert wird, wird mit modale Fenster verhindert, dass den Benutzer andere Anwendungsfenster aktivieren.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Markup verwendet wird, so konfigurieren Sie ein Fenster geöffnet werden, ohne aktiviert wird.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Das folgende Beispiel zeigt, wie Code verwenden, so konfigurieren Sie ein Fenster geöffnet werden, ohne dass es aktiviert wird.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ShowActivated" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opens a window and returns only when the newly opened window is closed.</summary>
        <returns>A <see cref="T:System.Nullable`1" /> value of type <see cref="T:System.Boolean" /> that specifies whether the activity was accepted (<see langword="true" />) or canceled (<see langword="false" />). The return value is the value of the <see cref="P:System.Windows.Window.DialogResult" /> property before a window closes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Window> Klasse instanziiert wird, ist jedoch nicht standardmäßig angezeigt. <xref:System.Windows.Window.ShowDialog%2A> Zeigt das Fenster deaktiviert alle anderen Fenster in der Anwendung und gibt nur, wenn das Fenster geschlossen wird. Diese Art von Fenster wird als bezeichnet eine *modale* Fenster.  
  
 Modale Fenster werden in erster Linie als Dialogfelder verwendet. Ein Dialogfeld ist eine besondere Art von Fenster, die Anwendungen für die Interaktion mit Benutzern die Ausführung von Aufgaben wie das Öffnen von Dateien oder Drucken von Dokumenten verwenden. Dialogfelder Benutzern häufig zu akzeptieren, oder brechen Sie den Task für den sie vor dem Schließen des Dialogfelds angezeigt wurden. <xref:System.Windows.Window.ShowDialog%2A> Gibt eine <xref:System.Nullable%601> <xref:System.Boolean> Wert, der angibt, ob die Aktivität bestätigt oder abgebrochen wurde. Der Rückgabewert ist der Wert, der die <xref:System.Windows.Window.DialogResult%2A> Eigenschaft vor dem Schließen eines Fensters. Weitere Informationen finden Sie unter <xref:System.Windows.Window.DialogResult%2A>.  
  
 Ein Fenster, das durch Aufrufen von der <xref:System.Windows.Window.ShowDialog%2A> Methode muss nicht automatisch eine Beziehung mit dem Fenster, die es geöffnet; insbesondere das geöffnete Fenster weiß nicht, welches Fenster öffnen. Diese Beziehung mit hergestellt werden kann die <xref:System.Windows.Window.Owner%2A> Eigenschaft und verwalteten mithilfe der <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft. Zur Unterstützung [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Automation (finden Sie unter [Übersicht über die Benutzeroberflächenautomatisierung](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> muss festgelegt werden, für ein Fenster geöffnet, die durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster (ein Fenster geöffnet wird, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>) geschlossen wird, die zuvor aktivierten Fenster erneut aktiviert. Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster verfügt über kein Besitzerfenster (finden Sie unter <xref:System.Windows.Window.Owner%2A>), das besitzende Fenster wird nicht erneut aktiviert, wenn der modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster wird geschlossen, es sei denn, sie Fenster zuvor aktiviert war.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie ein modales Fenster geöffnet.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">nach der Installationsberechtigung für ein Fenster zu aktivieren. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the window has a task bar button.</summary>
        <value>
          <see langword="true" /> Wenn das Fenster mit einer Taskleistenschaltfläche verfügt über; andernfalls <see langword="false" />. Gilt nicht für das Fenster in einem Browser gehostet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.ShowInTaskbar%2A> festgelegt ist, um `true`, das Fenster wird auch in der Auswahlliste der Tastenkombination ALT + TAB-Anwendung angezeigt.  
  
 Das Symbol, das für die Taskleistenschaltfläche und die Tastenkombination ALT + TAB Anwendungsauswahlliste verwendet wird, ist der Wert von der <xref:System.Windows.Window.Icon%2A> Eigenschaft.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ShowInTaskbar" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window will automatically size itself to fit the size of its content.</summary>
        <value>Ein <see cref="T:System.Windows.SizeToContent" />-Wert. Die Standardeinstellung ist <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> festgelegt ist, um <xref:System.Windows.SizeToContent.WidthAndHeight>, Einstellung <xref:System.Windows.FrameworkElement.Height%2A> oder <xref:System.Windows.FrameworkElement.Width%2A> hat keine Auswirkungen; beide Eigenschaften können festgelegt werden, aber die Werte, die sie festgelegt werden nicht an das Fenster angewendet.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> festgelegt ist, um <xref:System.Windows.SizeToContent.Height>, wobei <xref:System.Windows.FrameworkElement.Height%2A> ändert sich nicht auf die Höhe des Fensters.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> festgelegt ist, um <xref:System.Windows.SizeToContent.Width>, wobei <xref:System.Windows.FrameworkElement.Width%2A> ändert sich nicht auf die Breite des Fensters.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> verfügt über einen Wert außer <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> wird automatisch festgelegt, um <xref:System.Windows.SizeToContent.Manual> , wenn ein Benutzer durch den Ziehpunkt auf der Größe oder Ziehen des Rahmens Größe des Fensters ändern.  
  
-   Wenn die Größe des Inhalts auf eine Weise ändert, die das Fenster selbst, ändern Sie die Größe wird <xref:System.Windows.FrameworkElement.SizeChanged> ausgelöst wird.  
  
 Wenn ein Fenster sicherheitstransparent ist (finden Sie unter <xref:System.Windows.Window.AllowsTransparency%2A>), sollten Sie die Einstellung <xref:System.Windows.Window.SizeToContent%2A> auf <xref:System.Windows.SizeToContent.WidthAndHeight> sicherzustellen, dass das Fenster nicht größer als die sichtbaren Inhalt.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.SizeToContentProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Festlegen der <xref:System.Windows.Window.SizeToContent%2A> -Eigenschaft im Code angeben, wie die Fenstergröße an ihren Inhalt.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.SizeToContent" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised to support interoperation with [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. See <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window's <see cref="P:System.Windows.Window.WindowState" /> property changes.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the [!INCLUDE[win7](~/includes/win7-md.md)] taskbar thumbnail for the <see cref="T:System.Windows.Window" />.</summary>
        <value>Der [! Include[Win7](~/Includes/win7-MD.MD)] Taskleistenminiaturansicht für die <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Verwendung der [!INCLUDE[win7](~/includes/win7-md.md)] Taskleiste Miniaturansichten, finden Sie unter der <xref:System.Windows.Shell.TaskbarItemInfo> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.TaskbarItemInfo" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's title.</summary>
        <value>Ein <see cref="T:System.String" /> , enthält das Window-Titel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Titel des eine <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, oder [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], kann auch festgelegt werden, mithilfe von <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TitleProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Title" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window's top edge, in relation to the desktop.</summary>
        <value>Die Position des oberen Bereich des Fensters in logischen Einheiten (1/96").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> maximiert wird oder minimiert, dieser Wert stellt den obere Rand der Wiederherstellung von Wiederherstellungspunkten für die <xref:System.Windows.Window>.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie einen Wert nicht angeben <xref:System.Windows.Window.Top%2A> auf den Standardwert des Systems festgelegt ist. Sie können auch die Systemstandardwert angeben, durch Festlegen von <xref:System.Windows.Window.Top%2A> auf <xref:System.Double.NaN>. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TopProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window appears in the topmost z-order.</summary>
        <value>
          <see langword="true" /> Wenn das Fenster auf oberster Ebene handelt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster, dessen <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `true` über alle Fenster angezeigt, deren <xref:System.Windows.Window.Topmost%2A> Eigenschaften werden festgelegt, um `false`.  
  
 In der Gruppe, von denen Windows <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `true`, das Fenster, das derzeit aktiviert ist das oberste Fenster ist. Ebenso für die Gruppe von Fenstern, die über <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `false`.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TopmostProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Topmost" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Top" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window when first shown.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStartupLocation" /> Wert, der die obere linke Position eines Fensters beim ersten Anzeigen angibt. Die Standardeinstellung ist <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen von <xref:System.Windows.WindowStartupLocation> auf <xref:System.Windows.WindowStartupLocation.Manual> bewirkt, dass ein Fenster entsprechend dem positioniert werden seine <xref:System.Windows.Window.Left%2A> und <xref:System.Windows.Window.Top%2A> Eigenschaftswerte. Wenn entweder die <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> Eigenschaften nicht angegeben wird, deren Werte werden durch Windows bestimmt.  
  
 Festlegen von <xref:System.Windows.WindowStartupLocation.CenterScreen> bewirkt, dass ein Fenster in der Mitte des Bildschirms positioniert werden, die den Cursor enthält.  
  
 Festlegen von <xref:System.Windows.WindowStartupLocation> auf <xref:System.Windows.WindowStartupLocation.CenterOwner> bewirkt, dass ein Fenster in der Mitte des Besitzerfensters positioniert sein (finden Sie unter <xref:System.Windows.Window.Owner%2A>) angegeben. Das besitzende Fenster kann es sich um einen anderen WPF-Fenster oder in einem nicht-WPF-Fenster sein.  
  
> [!NOTE]
>  Weitere Informationen zu WPF-Fenstern mit nicht-WPF-Fenstern finden Sie unter [WPF und Win32 Interoperation](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) und <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Wenn ein Besitzerfenster nicht angegeben ist, richtet sich die Position des Fensters auf die gleiche Weise wie wenn <xref:System.Windows.WindowStartupLocation> auf festgelegt ist <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder rufen Sie den Wert dieser Eigenschaft ein, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window is restored, minimized, or maximized.</summary>
        <value>Ein <see cref="T:System.Windows.WindowState" /> , der bestimmt, ob ein Fenster wiederhergestellt, minimiert oder maximiert wird. Die Standardeinstellung ist <see cref="F:System.Windows.WindowState.Normal" /> (wiederhergestellt).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor ein Fenster minimiert oder maximiert ist, seiner Größe und Position befinden sich <xref:System.Windows.Window.RestoreBounds%2A>. Wenn ein Fenster später wiederhergestellt wird, werden seine Größe und Position Werte mit den Werten aus wiederhergestellt <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Wenn die <xref:System.Windows.Window.WindowState%2A> Eigenschaft geändert wird, <xref:System.Windows.Window.StateChanged> ausgelöst wird.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.WindowStateProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.WindowState" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's border style.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStyle" /> , die Rahmenart eines Fensters angibt. Die Standardeinstellung ist <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> kann eine von der <xref:System.Windows.WindowStyle> -Enumerationswerte fest, einschließlich <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (Standard), und <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 Die folgende Abbildung zeigt die Fensterstile auf [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero Design, mit aktiviertem transparentem Glaseffekt):  
  
 ![Fensterstile](~/add/media/windowoverviewfigure6.PNG "Fensterstile")  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft abzurufen, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.WindowStyleProperty>|  
|Metadaten-Eigenschaften festgelegt auf. `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.WindowStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>