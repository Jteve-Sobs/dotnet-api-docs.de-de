<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f4c98f780cf2b33620fc8b6b257afeb2bea3448" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52594195" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Bietet die Möglichkeit, die Lebensdauer von Fenstern und Dialogfeldern zu erstellen, zu konfigurieren, anzuzeigen und zu verwalten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Punkt der Interaktion zwischen Benutzer und eine eigenständige Anwendung ist ein Fenster. Ein [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Fenster besteht aus zwei unterschiedlichen Bereichen:  
  
-   Eine nicht-Clientbereich, hostet die Windows-Zusatzelemente, z. B. ein Symbol, Titel, Systemmenü, Schaltfläche zum Minimieren, maximieren, Schaltfläche, Schaltfläche "Wiederherstellen", Schaltfläche "Schließen" und einen Rahmen.  
  
-   Ein Client-Bereich, anwendungsspezifischen Inhalt hostet.  
  
 Ein Standardfenster ist in der folgenden Abbildung dargestellt:  
  
 ![Fensterelemente](~/add/media/windowoverviewfigure1.PNG "Fensterelemente")  
  
 <xref:System.Windows.Window> Kapselt die Möglichkeit zu erstellen, konfigurieren, anzeigen und Verwalten der Lebensdauer von Fenstern und Dialogfeldern, und bietet die folgenden wichtigsten Dienste:  
  
 **Verwaltung der Lebensdauer**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Fensterverwaltung**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Aussehen und Verhalten**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Dialogfelder**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Darüber hinaus <xref:System.Windows.Application> stellt spezielle Unterstützung für die Verwaltung aller Fenster in einer Anwendung:  
  
-   Dienstanwendung verwaltet eine Liste aller Fenster, die derzeit in der Anwendung instanziiert werden. Diese Liste wird verfügbar gemacht, indem die <xref:System.Windows.Application.Windows%2A> Eigenschaft.  
  
-   In der Standardeinstellung <xref:System.Windows.Application.MainWindow%2A> wird automatisch festgelegt, mit einem Verweis auf das erste <xref:System.Windows.Window> , die in einer Anwendung instanziiert wird. Diese und macht dem Fenster das Hauptanwendungsfenster.  
  
 Ein <xref:System.Windows.Window> Markup, Markup und Code-Behind oder in Code implementiert werden können.  
  
 <xref:System.Windows.Window> wird hauptsächlich verwendet, um Fenster und Dialogfelder für eigenständige Anwendungen anzuzeigen. Für Anwendungen, die Navigation auf der Ebene des Fenster z. B. Assistenten, benötigen Sie können jedoch <xref:System.Windows.Navigation.NavigationWindow> stattdessen <xref:System.Windows.Navigation.NavigationWindow> leitet sich von <xref:System.Windows.Window> und erweitert diese Unterstützung der Navigation im Browserstil.  
  
> [!NOTE]
>  Inseln navigierbarem Inhalt können integriert werden, in anderen Inhalten und Containern, die unter Verwendung von <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> muss `UnmanagedCode` Sicherheitsberechtigung instanziiert werden. Dies hat folgenden Konsequenzen:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-bereitgestellten eigenständigen Anwendungen fordert berechtigungserweiterung, wenn die durch die Zonen "Internet" oder "Lokales Intranet gestartet.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] jede beliebige Anforderung, die, kleiner als vollständige Berechtigungen nicht Fenster oder Dialogfelder instanziieren können.  
  
 Informationen zu eigenständigen Anwendung bereitstellungs- und sicherheitsüberlegungen finden Sie unter [WPF-Sicherheitsstrategie – Plattformsicherheit](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Ein <xref:System.Windows.Window> ist eine <xref:System.Windows.Controls.ContentControl>, was bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. B. eine Zeichenfolge, ein Bild oder einen Bereich) enthalten kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.ContentControl>-Klasse. Darüber hinaus <xref:System.Windows.Window> ein Stammelement ist und daher nicht Teil des Inhalts von einem anderen Element vorhanden sein.  
  
> [!NOTE]
>  Die <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, und <xref:System.Windows.Window.Left%2A> Eigenschaften für eine <xref:System.Windows.Window> über einen Stil wird nicht angewendet werden zur Laufzeit.  
  
## <a name="customizing-the-window-control"></a>Das Window-Steuerelement anpassen  
 Zum Anwenden der gleichen eigenschafteneinstellungen mit mehreren <xref:System.Windows.Window> -Steuerelemente verwenden die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Sie können den Standardwert ändern <xref:System.Windows.Controls.ControlTemplate> auf dem Steuerelement eine unverwechselbare Darstellung verleihen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate>, finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuerelements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Um anzuzeigen, die Teile und Zustände, die spezifisch für die <xref:System.Windows.Window>, finden Sie unter [Window-Stile und-Vorlagen](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat des Steuerelements festgelegt werden.  Wenn eine Eigenschaft von einem standardmäßigen Format festgelegt ist, kann die Eigenschaft den Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt durch die Desktopdesign verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Festlegen einer visuellen Eigenschaft haben nur Auswirkungen, wenn diese Eigenschaft sowohl in vorhanden ist <xref:System.Windows.Window> Steuerelement der Standardvorlage und wird festgelegt, indem Sie mit ein. Eine Liste der Eigenschaften visueller Elemente finden Sie im Abschnitt "Ändern der visuellen Struktur eines Steuerelements" [Anpassen der Darstellung eines vorhandenen Steuerelements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein Standardfenster ist nur mit Markup definiert:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 Das folgende Beispiel zeigt, wie ein Standardfenster mit definiert wird nur code:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Das folgende Beispiel zeigt, wie ein standard-Fenster mit einer Kombination aus Markup und CodeBehind definiert.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Window" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor initialisiert die <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, und <xref:System.Windows.Window.Left%2A> Eigenschaften mit ihren Standardwerten <xref:System.Windows.Window> Werte.  
  
 Bei Erstellung ein Fensters innerhalb einer <xref:System.AppDomain> , bei dem ein <xref:System.Windows.Application> Objekt, fügt der Konstruktor der <xref:System.Windows.Window> Objekt, das den Satz von <xref:System.Windows.Application>-verwaltet Windows über die <xref:System.Windows.Application.Windows%2A> Eigenschaft der <xref:System.Windows.Application> Objekt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung für dieses Objekt um unsicheren native Methoden aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, das Fenster in den Vordergrund zu bringen, und aktiviert dieses.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Windows.Window" /> erfolgreich aktiviert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln, die bestimmen, ob das Fenster aktiviert ist sind identisch mit denen ein, die die [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` Funktion ("User32.dll").  
  
 Wenn das Fenster in einer Windows Presentation Foundation-Anwendung aktiviert ist, die nicht der Benutzer die Anwendung im Vordergrund, <xref:System.Windows.Application.Activated> Ereignis wird ausgelöst.  
  
> [!NOTE]
>  Diese Methode werden nicht aufgerufen, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, um ein Fenster zu aktivieren. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fenster in den Vordergrund gesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster aktiviert ist (wird das Fenster im Vordergrund) beim:  
  
-   Öffnen des Fensters ist.  
  
-   Ein Benutzer wechselt zu einem Fenster, indem Sie sie auswählen, mit der Maus, und drücken ALT + TAB, oder dem Task-Manager.  
  
-   Ein Benutzer auf die Taskleistenschaltfläche des Fensters klickt.  
  
 Windows, die erkennen, wenn es sich bei Aktivierung müssen können behandeln die <xref:System.Windows.Window.Activated> Ereignis.  
  
 Nachdem ein Fenster erstmals aktiviert ist, kann er deaktiviert und oft während seiner Lebensdauer erneut aktiviert werden. Wenn vom Aktivierungszustand Verhalten oder der Zustand der Anwendung abhängig ist, prüft er <xref:System.Windows.Window.IsActive%2A> um zu bestimmen, welche Aktivierungszustand ist.  
  
 Eine Anwendung kann auch sein, <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Clientbereich eines Fensters Transparenz unterstützt.</summary>
        <value>
          <see langword="true" />, wenn das Fenster Transparenz unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Controls.Control.Background%2A> eines Fensters-Eigenschaftensatz auf eine transparente Farbe, mit <xref:System.Windows.Media.Brushes.Transparent%2A> z. B. das Fenster bleibt nicht transparent. Dies bedeutet, dass der Desktop und alle ausgeführten Anwendungen "beneath" im Fenster nicht sichtbar ist. So aktivieren Sie diese Art von Transparenz <xref:System.Windows.Window.AllowsTransparency%2A> muss festgelegt werden, um `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> vorhanden ist, um die Erstellung von nicht rechteckigen Fenstern, zu vereinfachen und folglich beim <xref:System.Windows.Window.AllowsTransparency%2A> nastaven NA hodnotu `true`, eines Fensters <xref:System.Windows.Window.WindowStyle%2A> Eigenschaft muss festgelegt werden, um <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ein Fenster, das über einen beliebigen anderen <see cref="P:System.Windows.Window.WindowStyle" />-Wert als <see cref="F:System.Windows.WindowStyle.None" /> verfügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.AllowsTransparency" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Eine <see cref="T:System.Windows.Size" />, die die endgültige Größe wiedergibt, anhand derer das Fenster sich selbst und seine untergeordneten Elemente anordnen soll.</param>
        <summary>Überschreiben Sie diese Methode, um ein Fenster und dessen untergeordnete Elemente anzuordnen und in der Größe zu ändern.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />, die die verwendete tatsächliche Größe wiedergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft hat den Wert <xref:System.Windows.Visibility.Collapsed>. Wenn der Wert des der <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> aufgerufen wird.  
  
> [!NOTE]
>  Wenn entweder <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft eine <xref:System.Windows.Window> nastaven NA hodnotu <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt ein <see cref="T:System.Windows.Window" /> manuell.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Window> kann geschlossen werden, mit einer von mehreren, bekannte, vom System bereitgestellten Mechanismen befindet sich in der Titelleiste, einschließlich:  
  
-   ALT + F4.  
  
-   Systemmenü &#124; **schließen**.  
  
-   **Schließen** Schaltfläche.  
  
 Ein <xref:System.Windows.Window> kann geschlossen werden mit mehreren bekannten Mechanismen im Clientbereich, die von Entwicklern, einschließlich bereitgestellt werden:  
  
-   **Datei** &#124; **beenden** in einem Hauptfenster.  
  
-   **Datei** &#124; **schließen** oder **schließen** Schaltfläche in einem untergeordneten Fenster.  
  
> [!NOTE]
>  **OK** und **Abbrechen** Schaltflächen in einem Dialogfeld werden auch an Entwickler bereitgestellt, jedoch werden Sie wahrscheinlich Satz <xref:System.Windows.Window.DialogResult%2A>, die automatisch geschlossen wird, ein Fenster, das durch den Aufruf geöffnet wurde <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Diese Mechanismen müssen Sie explizit aufrufen, <xref:System.Windows.Window.Close%2A> um ein Fenster zu schließen.  
  
> [!NOTE]
>  Wenn ein Fenster geöffnet wird, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>, und mit einer <xref:System.Windows.Controls.Button> mit seiner <xref:System.Windows.Controls.Button.IsCancel%2A> Eigenschaft auf "true" festgelegt ist, wird automatisch geschlossen, wenn entweder die Schaltfläche geklickt wird, oder die ESC-Taste gedrückt wird. Wenn das Fenster geöffnet wurde, mithilfe von <xref:System.Windows.Window.Show%2A>jedoch <xref:System.Windows.Window.Close%2A> muss explizit aufgerufen werden, z. B. <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignishandler für die <xref:System.Windows.Controls.Button>.  
  
 Schließen eines Fensters bewirkt, dass die <xref:System.Windows.Window.Closing> Ereignis ausgelöst wurde. Wenn die <xref:System.Windows.Window.Closing> Ereignis wird nicht abgebrochen, geschieht Folgendes:  
  
-   Die <xref:System.Windows.Window> aus entfernt <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (wenn ein <xref:System.Windows.Application> Objekt vorhanden ist).  
  
-   Die <xref:System.Windows.Window> wird vom Besitzer entfernt <xref:System.Windows.Window> , wenn die Besitzer/owned-Beziehung hergestellt wurde vor der im Besitz des Benutzers <xref:System.Windows.Window> wurde angezeigt und nach dem Besitzer <xref:System.Windows.Window> geöffnet wurde.  
  
-   Das <xref:System.Windows.Window.Closed>-Ereignis wird ausgelöst.  
  
-   Nicht verwaltete Ressourcen, die erstellt werden, indem die <xref:System.Windows.Window> verworfen werden.  
  
-   Wenn <xref:System.Windows.Window.ShowDialog%2A> war aufgerufen, um das Anzeigen der <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> zurückgibt.  
  
 Schließen einer <xref:System.Windows.Window> bewirkt, dass alle Fenster, die es besitzt, um die geschlossen werden. Darüber hinaus schließen eine <xref:System.Windows.Window> kann dazu führen, dass eine Anwendung nicht mehr ausgeführt wird, je nachdem, wie der <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> festgelegt wird.  
  
> [!NOTE]
>  Diese Methode werden nicht aufgerufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine **Datei** &#124; **beenden** Menü wird behandelt, um explizit aufrufen <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, die alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt kurz vor dem Schließen des Fensters auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Ereignis ausgelöst wird, kann nicht schließen ein Fensters verhindert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Während ein Fenster schließt, wird <see cref="P:System.Windows.UIElement.Visibility" /> festgelegt, oder <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> oder <see cref="M:System.Windows.Window.Hide" /> wird aufgerufen.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Window.Close" /> auf und kann behandelt werden, um das Schließen des Fensters abzubrechen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> können behandelt werden, um zu ermitteln, wenn ein Fenster geschlossen wird (z. B. wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird). Darüber hinaus <xref:System.Windows.Window.Closing> können verwendet werden, um zu verhindern, dass ein Fenster schließen. Zum Schließen ein Fensters zu verhindern, Sie können festlegen, die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft der <xref:System.ComponentModel.CancelEventArgs> Argument `true`.  
  
 Die <xref:System.Windows.Window.Closing> Ereignis wird ausgelöst, wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird, wenn ein Fenster auf die Schaltfläche "Schließen" geklickt wird oder wenn der Benutzer ALT + F4 drücken.  
  
 Wenn ein zum Besitzer gehörige Fenster, mithilfe von dessen Besitzer Fenster geöffnet wurde <xref:System.Windows.Window.Show%2A>, und der Besitzer geschlossen wird, die im Besitz des Fensters <xref:System.Windows.Window.Closing> Ereignis wird nicht ausgelöst. Wenn der Besitzer eines Fensters geschlossen wird (finden Sie unter <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> nicht für das Fenster im Besitz des Benutzers ausgelöst wird.  
  
 Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, die <xref:System.Windows.Window.Closing> Ereignis für jedes Fenster wird ausgelöst. Aber wenn <xref:System.Windows.Window.Closing> wird abgebrochen, Abbruch wird ignoriert.  
  
 Wenn eine Sitzung beendet, weil ein Benutzer abmeldet oder wird heruntergefahren, <xref:System.Windows.Window.Closing> wird nicht ausgelöst; behandeln <xref:System.Windows.Application.SessionEnding> zur Implementierung von Code, in dem Schließen der Anwendung abgebrochen.  
  
 Wenn auf Sie ein- und Ausblenden von einem Fenster mehrere Male während der Lebensdauer einer Anwendung werden sollen, und nicht das Fenster jedes Mal neu instanziieren möchten Sie diese anzeigen, können Sie behandeln die <xref:System.Windows.Window.Closing> -Ereignis, brechen Sie den Befehl, und rufen Sie die <xref:System.Windows.Window.Hide%2A> Methode. Anschließend rufen Sie <xref:System.Windows.Window.Show%2A> auf der gleichen Instanz aus, um es erneut zu öffnen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Windows.Window> , der bestimmt, ob schließen ein Benutzereingriff erforderlich.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Während ein Fenster schließt, wird <see cref="P:System.Windows.UIElement.Visibility" /> festgelegt, oder <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> oder <see cref="M:System.Windows.Window.Close" /> wird aufgerufen.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt nach dem Rendern des Inhalts eines Fensters auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Fenster um keinen Inhalt hat, wird dieses Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fenster zum Hintergrundfenster wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster deaktiviert ist (wird zu einem Hintergrundfenster) beim:  
  
-   Ein Benutzer wechselt zu einem anderen Fenster in der aktuellen Anwendung.  
  
-   Ein Benutzer wechselt zum Fenster in einer anderen Anwendung mit ALT + TAB oder mithilfe des Task-Manager.  
  
-   Ein Benutzer klickt auf die Taskleistenschaltfläche für ein Fenster in einer anderen Anwendung.  
  
 Windows, die erkennen, wenn die Deaktivierung durch Behandeln der <xref:System.Windows.Window.Deactivated> Ereignis.  
  
 Nachdem ein Fenster zunächst deaktiviert wurde, kann er erneut aktiviert und deaktiviert oft während seiner Lebensdauer. Wenn vom Aktivierungszustand Verhalten oder der Zustand der Anwendung abhängig ist, prüft er <xref:System.Windows.Window.IsActive%2A> um zu bestimmen, welche Aktivierungszustand ist.  
  
 Eine Anwendung kann auch sein, <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ergebniswert des Dialogfelds ab, d. h. den von der <see cref="M:System.Windows.Window.ShowDialog" />-Methode zurückgegebenen Wert, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Nullable`1" />-Wert vom Typ <see cref="T:System.Boolean" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> kann verwendet werden, aus dem Code, die ein Dialogfeld, um zu bestimmen, ob ein Benutzer akzeptiert angezeigt wurde (`true`) oder abgebrochen (`false`) das Dialogfeld. Wenn ein Dialogfeld akzeptiert wurde, bedeutet dies, um den Code, der zum Abrufen von Daten, die vom Benutzer erfasst wurden und verarbeiten sie das Dialogfeld öffnen. Wenn ein Dialogfeld abgebrochen wurde, allerdings bedeutet dies, dass das Aufrufen von Code beendet werden soll, weitere Verarbeitung.  
  
 Standardmäßig wird ein Dialogfeld, das abgebrochen, wenn ein Benutzer eine der folgenden ausführt:  
  
-   PressesALT + F4.  
  
-   Klickt der **schließen** Schaltfläche.  
  
-   Wählt **schließen** im Systemmenü.  
  
 In allen diesen Fällen <xref:System.Windows.Window.DialogResult%2A> ist `false` standardmäßig.  
  
 Ein Dialogfeld, das in der Regel stellt einer speziellen Schaltfläche zum abzubrechen. Dies ist die Schaltfläche wird ein Dialogfeld, deren <xref:System.Windows.Controls.Button.IsCancel%2A> -Eigenschaftensatz auf `true`. Eine Schaltfläche auf diese Weise konfiguriert wird ein Fenster automatisch geschlossen, wenn entweder es gedrückt wird oder wenn die ESC-Taste gedrückt wird. In beiden Fällen <xref:System.Windows.Window.DialogResult%2A> bleibt `false`.  
  
 Ein Dialogfeld, das auch in der Regel enthält einer Schaltfläche annehmen, wird die Schaltfläche, deren <xref:System.Windows.Controls.Button.IsDefault%2A> -Eigenschaftensatz auf `true`. Eine Schaltfläche, die diese Art konfigurierten löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis aus, wenn sie oder die EINGABETASTE gedrückt wird. Allerdings es wird nicht automatisch das Dialogfeld zu schließen, noch wird festgelegt <xref:System.Windows.Window.DialogResult%2A> zu `true`. Sie müssen manuell dieser Schreiben von Code in der Regel aus der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignishandler für die Schaltfläche "Standard".  
  
 <xref:System.Windows.Window.DialogResult%2A> ist `null` das Dialogfeld wird angezeigt, wenn jedoch weder akzeptiert noch abgebrochen.  
  
 Nachdem ein Dialogfeld wird, und geschlossen Sie erhalten das Dialogfeldergebnis aus den Rückgabewert von <xref:System.Windows.Window.ShowDialog%2A> -Methode, oder durch Überprüfen der <xref:System.Windows.Window.DialogResult%2A> Eigenschaft.  
  
 <xref:System.Windows.Window.DialogResult%2A> kann nur festgelegt werden, wenn eine <xref:System.Windows.Window> geöffnet wird, durch den Aufruf der <xref:System.Windows.Window.ShowDialog%2A> Methode.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie so konfigurieren Sie die Schaltfläche "OK" und eine Schaltfläche "Abbrechen", um die entsprechende zurückzugeben <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> wird festgelegt, bevor ein Fenster durch Aufrufen von <see cref="M:System.Windows.Window.ShowDialog" /> geöffnet wird.  
  
- oder -  
 <see cref="P:System.Windows.Window.DialogResult" /> wird in einem Fenster festgelegt, das durch Aufrufen von <see cref="M:System.Windows.Window.Show" /> geöffnet wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem sich die DPI-Auflösung des Bildschirms geändert hat, auf dem das Fenster angezeigt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein <see cref="T:System.Windows.RoutedEvent" /> für den Fall, dass der DPI-Wert des Bildschirms, der das Fenster anzeigt, geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es, ein Fenster mit der Maus auf einen verfügbar gemachten Bereich im Clientbereich des Fensters zu ziehen, indem die linke Maustaste gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die linke Maustaste gedrückt werden muss, heruntergefahren, wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird. Eine Möglichkeit zum erkennen, wenn die linke Maustaste gedrückt wird, behandeln wird die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis.  
  
 Wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird, wird die linke Maustaste über einen verfügbar gemachten Teil des Clientbereichs des Fensters gedrückt werden muss.  
  
> [!NOTE]
>  Diese Methode werden nicht aufgerufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> aufzurufende <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die linke Maustaste wird nicht gedrückt gehalten.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, ein Fenster ziehen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Das Abhängigkeitsobjekt.</param>
        <summary>Gibt einen Verweis auf das <see cref="T:System.Windows.Window" />-Objekt zurück, das die Inhaltsstruktur mit dem Abhängigkeitsobjekt hostet.</summary>
        <returns>Ein <see cref="T:System.Windows.Window" />-Verweis auf das Hostfenster.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Macht ein Fenster unsichtbar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster wird nicht geschlossen, wenn es ausgeblendet ist, und weder der <xref:System.Windows.Window.Closing> noch <xref:System.Windows.Window.Closed> Ereignis wird ausgelöst. Stattdessen des Fensters <xref:System.Windows.UIElement.Visibility%2A> -Eigenschaftensatz auf <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Wenn ein Fenster der Anwendung ist <xref:System.Windows.Application.MainWindow%2A> und der Anwendung <xref:System.Windows.Application.ShutdownMode%2A> ist <xref:System.Windows.ShutdownMode.OnMainWindowClose>, die Anwendung wird nicht heruntergefahren. Andererseits die Anwendung wird nicht heruntergefahren, wenn ein Fenster das einzige Fenster ist und Modus für das Herunterfahren der Anwendung <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Wenn auf Sie ein- und Ausblenden von einem Fenster mehrere Male während der Lebensdauer einer Anwendung werden sollen, und nicht das Fenster jedes Mal erneut instanziieren möchten Sie diese anzeigen, können Sie behandeln die <xref:System.Windows.Window.Closing> -Ereignis, brechen Sie den Befehl, und rufen Sie die <xref:System.Windows.Window.Hide%2A> Methode. Anschließend rufen Sie <xref:System.Windows.Window.Show%2A> auf der gleichen Instanz aus, um es erneut zu öffnen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> wird für ein Fenster aufgerufen, das geschlossen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Symbol eines Fensters ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Media.ImageSource" />-Objekt, das das Symbol darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) von eigenständigen Anwendungen haben zwei Arten von Symbolen:  
  
-   Eine Assembly-Symbol, das mit der `<ApplicationIcon>` erstellen Datei-Eigenschaft im Projekt der Anwendung. Dieses Symbol wird als das Desktopsymbol für eine Assembly verwendet.  
  
    > [!NOTE]
    >  Beim Debuggen in Visual Studio möglicherweise Ihr Symbol nicht aufgrund der Hostprozess angezeigt. Wenn Sie die ausführbare Datei ausführen, wird das Symbol angezeigt. Weitere Informationen finden Sie unter [Hostprozess („vshost.exe“)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Ein Symbol pro Fenster, das durch das Festlegen von angegeben wird <xref:System.Windows.Window.Icon%2A>. Für jedes Fenster wird dieses Symbol in der Titelleiste angezeigt wird, seine Taskleistenschaltfläche, und der ALT-TAB Anwendung Auswahl Listeneintrag verwendet.  
  
 Ein WPF-Fenster wird immer ein Symbol angezeigt. Wenn nicht bereitgestellt durch Festlegen von <xref:System.Windows.Window.Icon%2A>, WPF auswählt, ein Symbol angezeigt wird basierend auf den folgenden Regeln:  
  
1.  Verwenden Sie das Symbol "Assembly", falls angegeben.  
  
2.  Wenn das Symbol "Assembly" nicht angegeben ist, verwenden Sie das Standardsymbol für das Microsoft Windows.  
  
 Bei Verwendung von <xref:System.Windows.Window.Icon%2A> um ein benutzerdefiniertes Symbol anzugeben, können Sie das Standardanwendungssymbol wiederherstellen, indem festlegen <xref:System.Windows.Window.Icon%2A> zu `null`.  
  
 Ein einzelnes Symbol kann in einer Vielzahl von Methoden in Windows, einschließlich der in der Titelleiste eines Fensters, auf der Taskleiste für ein Fenster, die Dateiliste Auswahl ALT + TAB angezeigt wird, verwendet werden. Jedes davon wird das Symbol in unterschiedlichen Größen angezeigt. eine 16 x 16 Pixelsymbol wird in der Titelleiste eines Fensters, und klicken Sie in der Taskleiste angezeigt, während ein 32 x 32 Pixel großes Symbol in der Auswahlliste der ALT + TAB-Datei angezeigt wird. Einige Anwendungen, z. B. [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], geben Sie einen **Ansicht** Menü, das können Sie auf die Größe des Symbols, Sie anzeigen möchten.  
  
 Um die verschiedenen Anzeigegrößen zu erfüllen, eine Symboldatei einen oder mehrere tatsächliche Symbole besteht, wobei jeweils eine Version des Symbols darstellt, die einer bestimmten Größe und Farbtiefe ausgerichtet ist. Z. B. möglicherweise ein Symbol nur das ein einzelnes Pixelsymbol von 16 x 16 und 16 Farben, während eine andere 16 x 16 Pixel und 32 x 32 Pixel großes Symbole mit 16 Farben und 256 Farben enthalten kann.  
  
 Wenn Symbole für alle möglichen Größen und Farbtiefen innerhalb einer Symboldatei vorhanden <xref:System.Windows.Window> verwendet das entsprechende Symbol. Wenn eine Symboldatei nur eine Teilmenge aller möglichen Symbole enthält <xref:System.Windows.Window> das nächste am besten geeignete Symbol in der Reihenfolge abnehmender Größe und Farbtiefe verwendet.  
  
 Das Ergebnis ist, dass ein Symbol wird immer durch verwendet, <xref:System.Windows.Window>, obwohl das Symbol, das möglicherweise nicht die erforderliche Größe und Farbtiefe entspricht. Beispielsweise kann ein Pixelsymbol 16 x 16 mit 16 Farben für die Anzeige als 32 x 32 Pixel großes Symbol mit 256 Farben verwendet werden. Dies kann dazu führen, dass unerwünschte visuelle Effekte wie geglättet, jedoch kann durch Erstellen von Symbolen für die aller als Ziel festgelegten Größe und Farbe Tiefen vermieden werden.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.IconProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein Fenstersymbol festgelegt wird.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Festlegen des Symbols. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Icon" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Fenster aktiv ist.</summary>
        <value>
          <see langword="true" />, wenn das Fenster aktiv ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein aktiven Fensters wird das aktuelle Vordergrundfenster in des Benutzers und den Fokus hat, was durch die aktive Darstellung der Titelleiste angezeigt wird. Ein aktiven Fensters zuoberst angeordnetes alle Fenster auf oberster Ebene, die nicht explizit festlegen. Außerdem wird die <xref:System.Windows.Window.Topmost%2A> Eigenschaft.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.IsActiveProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.IsActive" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des linken Fensterrands im Verhältnis zum Desktop ab oder legt diese fest.</summary>
        <value>Die Position des linken Fensterrands in logischen Einheiten (1/96 Zoll).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> maximiert oder minimiert, dieser Wert darstellt, die der linke Rand der Wiederherstellung für zeigen die <xref:System.Windows.Window>.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie einen Wert nicht angeben <xref:System.Windows.Window.Left%2A> auf den Standardwert des Systems festgelegt ist. Sie können auch den standardmäßigen Systemwert angeben, durch Festlegen von <xref:System.Windows.Window.Left%2A> zu <xref:System.Double.NaN>. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.LeftProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Left" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Position des Fensters geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position des Fensters wird geändert, wenn:  
  
-   Ein Benutzer verschiebt ein Fenster, um mit der Titelleiste des Fensters ziehen.  
  
-   Ein Fenster verschoben wird, nach dem <xref:System.Windows.Window.DragMove%2A> aufgerufen wird.  
  
-   Entweder die <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> -Eigenschaft programmgesteuert festgelegt wird.  
  
-   Die **verschieben** Menüelement eines Fensters Systemmenü ausgewählt ist.  
  
-   Die <xref:System.Windows.Window.WindowState%2A> -Eigenschaft geändert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente eines Fensters ab.</summary>
        <value>Ein <see cref="T:System.Collections.IEnumerator" /> für die logischen untergeordneten Elemente eines Fensters.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Eine <see cref="T:System.Windows.Size" />, die die verfügbare Größe wiedergibt, die dieses Fenster für das untergeordnete Element bereitstellen kann. Sie können den Wert als unendlich angeben, um anzuzeigen, dass das Fenster an die Größe jedes beliebigen Inhalts angepasst wird.</param>
        <summary>Überschreiben Sie diese Methode, um die Größe eines Fensters zu messen.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />, die die Größe wiedergibt, die dieses Fenster auf der Grundlage der Berechnung der Größe der untergeordneten Elemente bestimmt und während des Layouts benötigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft hat den Wert <xref:System.Windows.Visibility.Collapsed>. Wenn der Wert des der <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> aufgerufen wird.  
  
> [!NOTE]
>  Wenn entweder <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, die <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft eine <xref:System.Windows.Window> nastaven NA hodnotu <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Activated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnActivated%2A> wird das <xref:System.Windows.Window.Activated>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnActivated%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnActivated%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Activated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Closed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosed%2A> wird das <xref:System.Windows.Window.Closed>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnClosed%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnClosed%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Closed> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Closing" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosing%2A> wird das <xref:System.Windows.Window.Closing>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnClosing%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnClosing%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Closing> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Ein Verweis auf den Stamm der alten Inhaltsstruktur.</param>
        <param name="newContent">Ein Verweis auf den Stamm der neuen Inhaltsstruktur.</param>
        <summary>Wird aufgerufen, wenn sich die <see cref="P:System.Windows.Controls.ContentControl.Content" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.ContentRendered" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnContentRendered%2A> wird das <xref:System.Windows.Window.ContentRendered>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnContentRendered%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnContentRendered%2A> in der Basisklasse Wenn <xref:System.Windows.Window.ContentRendered> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />-Objekt für dieses <see cref="T:System.Windows.Window" /> und gibt es zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />-Objekt für diesen <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.Deactivated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnDeactivated%2A> wird das <xref:System.Windows.Window.Deactivated>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnDeactivated%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnDeactivated%2A> in der Basisklasse Wenn <xref:System.Windows.Window.Deactivated> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Die vorherige DPI-Größeneinstellung.</param>
        <param name="newDpi">Die neue DPI-Größeneinstellung.</param>
        <summary>Wird aufgerufen, wenn sich der DPI-Wert ändert, mit dem dieses Fenster gerendert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.LocationChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnLocationChanged%2A> wird das <xref:System.Windows.Window.LocationChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnLocationChanged%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnLocationChanged%2A> in der Basisklasse Wenn <xref:System.Windows.Window.LocationChanged> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn das <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />-Ereignis eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses, das das Laufzeitverhalten der endgültige Klasse ändern kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.SourceInitialized" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnSourceInitialized%2A> wird das <xref:System.Windows.Window.SourceInitialized>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnSourceInitialized%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnSourceInitialized%2A> in der Basisklasse Wenn <xref:System.Windows.Window.SourceInitialized> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Window.StateChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnStateChanged%2A> wird das <xref:System.Windows.Window.StateChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der abgeleitet <xref:System.Windows.Window> kann überschreiben <xref:System.Windows.Window.OnStateChanged%2A>. Die überschriebene Methode aufrufen muss <xref:System.Windows.Window.OnStateChanged%2A> in der Basisklasse Wenn <xref:System.Windows.Window.StateChanged> ausgelöst werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded">Das der Auflistung hinzugefügte <see cref="T:System.Windows.Media.Visual" />-Objekt.</param>
        <param name="visualRemoved">Das aus der Auflistung entfernte <see cref="T:System.Windows.Media.Visual" />-Objekt.</param>
        <summary>Wird aufgerufen, wenn <see cref="T:System.Windows.Media.VisualCollection" /> für dieses <see cref="T:System.Windows.Window" />-Objekt geändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das bisherige übergeordnete Element. Wird auf NULL festgelegt, wenn das <see cref="T:System.Windows.DependencyObject" /> kein vorheriges übergeordnetes Element aufweist.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element des Fensters geändert wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Fenstern ab, deren Besitzer dieses Fenster ist.</summary>
        <value>Eine <see cref="T:System.Windows.WindowCollection" /> mit Verweisen auf die Fenster, deren Besitzer dieses Fenster ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein zum Besitzer gehörige Fenster ist eine, deren <xref:System.Windows.Window.Owner%2A> Eigenschaft wird festgelegt, mit einem Verweis auf ein anderes Fenster, das als das besitzende Fenster bezeichnet wird. Um alle Fenster suchen, die einem Besitzerfenster gehören, können Sie auflisten <xref:System.Windows.WindowCollection> das zurückgegeben wird, indem die <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie auflisten <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Window" /> ab, das dieses <see cref="T:System.Windows.Window" /> besitzt.</summary>
        <value>Ein <see cref="T:System.Windows.Window" />-Objekt, das den Besitzer dieses <see cref="T:System.Windows.Window" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein untergeordnetes Fenster durch Aufrufen von einem übergeordneten Fenster geöffnet wird <xref:System.Windows.Window.ShowDialog%2A>, eine Beziehung zwischen über- und untergeordneten Fenster eingerichtet ist. Diese Beziehung erzwingt bestimmte Verhalten, wie in Bezug auf Minimieren, Maximieren und wiederherstellen.  
  
 Wenn ein untergeordnetes Fenster durch Aufrufen von einem übergeordneten Fenster erstellt wird <xref:System.Windows.Window.Show%2A>, das untergeordnete Fenster verfügt jedoch nicht über eine Beziehung mit dem übergeordneten Fenster. Dies bedeutet Folgendes:  
  
-   Das untergeordnete Fenster muss sich nicht auf einen Verweis auf das übergeordnete Fenster aus.  
  
-   Das Verhalten des untergeordneten Fensters ist nicht das Verhalten des übergeordneten Fensters abhängig. Beide Fenster kann abdecken, die andere oder minimiert, maximiert und wiederhergestellt, unabhängig voneinander.  
  
 Erstellen Sie eine Beziehung zwischen einem untergeordneten Fenster und ein übergeordnetes Fenster, ermöglichen <xref:System.Windows.Window> unterstützt das Konzept der Gesamtbetriebskosten. Besitz wird hergestellt, wenn die <xref:System.Windows.Window.Owner%2A> Eigenschaft eines Window (das im Besitz des Benutzers Fenster) mit einem Verweis auf ein anderes Fenster (das Besitzerfenster) festgelegt ist.  
  
 Sobald diese Beziehung eingerichtet ist, werden die folgenden Verhalten gezeigt:  
  
-   Wenn ein Besitzerfenster minimiert wird, werden auch alle seine eigenen Fenster minimiert.  
  
-   Wenn ein zum Besitzer gehörige Fenster minimiert wird, wird der Besitzer nicht minimiert.  
  
-   Wenn eine besitzende Fenster maximiert ist, werden sowohl das besitzende Fenster als auch die im Besitz des Benutzers Windows wiederhergestellt.  
  
-   Ein Besitzerfenster kann nie einen Besitzer gehörige Fenster abdecken.  
  
-   Im Besitz von Fenstern, die nicht mit geöffnet wurden <xref:System.Windows.Window.ShowDialog%2A> sind nicht modal. Der Benutzer kann das besitzende Fenster weiterhin interagieren.  
  
-   Wenn Sie über eine besitzende Fenster schließen, werden die im Besitz des Benutzers Windows ebenfalls geschlossen.  
  
-   Wenn ein zum Besitzer gehörige Fenster, mithilfe von dessen Besitzer Fenster geöffnet wurde <xref:System.Windows.Window.Show%2A>, und der Besitzer geschlossen wird, die im Besitz des Fensters <xref:System.Windows.Window.Closing> Ereignis wird nicht ausgelöst.  
  
 Wenn Sie ein untergeordnetes Fenster öffnen, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>, sollten Sie auch Festlegen der <xref:System.Windows.Window.Owner%2A> Eigenschaft des untergeordneten Fensters. Falls nicht, klicken Sie dann Ihre Benutzer untergeordnete und übergeordnete Fenster wiederhergestellt, drücken Sie die Taskleistenschaltfläche nicht. Drücken die Taskleistenschaltfläche wird stattdessen eine Liste von Windows, einschließlich untergeordnete und das übergeordnete Fenster für diese Auswahl ergeben; Es wird nur das ausgewählte Fenster wiederhergestellt.  
  
> [!IMPORTANT]
>  Sie sollten auch festlegen, die <xref:System.Windows.Window.Owner%2A> Eigenschaft in einem Fenster, die durch den Aufruf geöffnet ist <xref:System.Windows.Window.ShowDialog%2A> um sicherzustellen, dass korrektes Verhalten bei.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die Besitzer/owned Beziehung herzustellen.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Fenster versucht, sich selbst zu besitzen 
- oder -  
Zwei Fenster versuchen, einander zu besitzen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Window.Owner" />-Eigenschaft wird für ein sichtbares Fenster festgelegt, das mit <see cref="M:System.Windows.Window.ShowDialog" /> angezeigt wird  
  
- oder -  
Die <see cref="P:System.Windows.Window.Owner" />-Eigenschaft wird für ein Fenster festgelegt, das bisher nicht angezeigt wurde.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, die alle Fenster und Benutzereingabeereignisse uneingeschränkt verwenden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Größenänderungsmodus ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.ResizeMode" />-Wert, der den Größenänderungsmodus angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt vier Optionen aus:  
  
-   **False**. Der Benutzer nicht über das Fenster anpassen. Die Maximieren und minimieren-Felder werden nicht angezeigt.  
  
-   **CanMinimize**. Der Benutzer kann nur das Fenster minimieren und Wiederherstellen über die Taskleiste. Die Felder minimieren und Maximieren werden angezeigt, jedoch nur das Minimieren-Feld aktiviert.  
  
-   **CanResize**. Der Benutzer hat die uneingeschränkte Möglichkeit zum Ändern der Größe der Fenster mithilfe der Felder minimieren und Maximieren und Größenänderungsoptionen um das Fenster. Die Felder minimieren und Maximieren sind angezeigt und aktiviert. (Standard).  
  
-   **CanResizeWithGrip**. Diese Option hat die gleiche Funktionalität wie <xref:System.Windows.ResizeMode.CanResize>, aber der unteren rechten Ecke des Fensters "Ziehpunkt zur Größenänderung" hinzugefügt.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.ResizeModeProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.ResizeMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe und Position eines Fensters vor dem Minimieren oder Maximieren ab.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" />, das die Größe und Position eines Fensters vor dem Minimieren oder Maximieren angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Rechteck für die Wiederherstellung ist die Region, die vom Fenster belegt wird, bevor sie minimiert oder maximiert wurde. Sie können <xref:System.Windows.Window.RestoreBounds%2A> rufen diese Werte beim nächsten Start eine Anwendung ein Fenster mit der Art und Weise wiederherstellen ein Benutzers zu belassen, und speichern Sie die letzte Größe und Position eines Fensters, bevor eine Anwendung geschlossen wird.  
  
 Wenn Sie Abfragen <xref:System.Windows.Window.RestoreBounds%2A> vor das Fenster angezeigt wurde, oder nachdem es geschlossen wurde, <xref:System.Windows.Rect.Empty%2A> zurückgegeben wird.  
  
> [!NOTE]
>  Diese Eigenschaft kann nicht abgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Window.RestoreBounds%2A> und isolierter Speicher, um sicherzustellen, dass die Größe und Position eines Fensters der gleiche wie beim vorherigen Mal das Fenster angezeigt wurde.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Abfragen der Größe und Position eines Fensters des umschließenden Rechtecks. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet ein Fenster und wird beendet, ohne auf das Schließen des neu geöffneten Fensters zu warten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> Klasse instanziiert wird, es ist nicht standardmäßig angezeigt. <xref:System.Windows.Window.Show%2A> Zeigt ein Fenster, und gibt sofort zurück, ohne zu warten, für das Fenster geschlossen wird. Daher ist das geöffnete Fenster nicht, dass Benutzer von der Interaktion mit anderen Fenstern in der Anwendung. Diese Art von Fenster wird aufgerufen, eine *nicht modale* Fenster. Häufige Beispiele nicht modale Fenster sind Eigenschaftenfenster, Toolboxen und Paletten. Um einen Benutzer interagieren mit einem bestimmten Fenster zu beschränken, muss das Fenster geöffnet werden durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ein Fenster, das durch Aufrufen von <xref:System.Windows.Window.Show%2A> wird nicht automatisch über eine Beziehung mit dem Fenster, die es geöffnet; insbesondere das geöffnete Fenster weiß nicht, welches Fenster, die sie geöffnet. Diese Beziehung kann hergestellt werden, mithilfe der <xref:System.Windows.Window.Owner%2A> -Eigenschaft und Verwenden von verwalteten der <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft.  
  
 Aufrufen von <xref:System.Windows.Window.Show%2A> erzielt dasselbe Endergebnis wie das Festlegen <xref:System.Windows.UIElement.Visibility%2A> Eigenschaft der <xref:System.Windows.Window> -Objekt <xref:System.Windows.Visibility.Visible>. Allerdings besteht ein Unterschied zwischen den beiden hinsichtlich der zeitlichen Steuerung.  
  
 Aufrufen von <xref:System.Windows.Window.Show%2A> ist ein synchroner Vorgang, der erst nach zurückgibt. die <xref:System.Windows.FrameworkElement.Loaded> -Ereignis für das untergeordnete Element ausgelöst wurde:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Festlegen von <xref:System.Windows.UIElement.Visibility%2A>, jedoch ist ein asynchroner Vorgang, der sofort beendet:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Beim Festlegen <xref:System.Windows.UIElement.Visibility%2A>, alle Fensterereignisse, die Sie registrieren, bevor Sie festlegen, <xref:System.Windows.UIElement.Visibility%2A> möglicherweise nicht ausgelöst werden, erst nach der Methode, in dem Sie festlegen <xref:System.Windows.UIElement.Visibility%2A> die Ausführung abgeschlossen hat.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, wie ein nicht modales Fenster zu öffnen.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> wird für ein Fenster aufgerufen, das geschlossen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Fenster beim ersten Anzeigen aktiviert wird.</summary>
        <value>
          <see langword="true" />, wenn ein Fenster beim ersten Anzeigen aktiviert wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Fenster mit der <xref:System.Windows.Window.ShowActivated%2A> -Eigenschaft auf festgelegt `false` wird geöffnet, wird das Fenster nicht aktiviert und die zugehörige <xref:System.Windows.Window.Activated> Ereignis wird nicht ausgelöst, bis ein Benutzer das Fenster manuell aktiviert, indem Sie ihn auswählen. Nachdem das Fenster aktiviert ist, aktiviert und deaktiviert die Regel.  
  
 Um zu verhindern, dass ein Fenster aktiviert wird, wenn es geöffnet wird, die <xref:System.Windows.Window.ShowActivated%2A> Eigenschaft muss festgelegt werden, um `false` , bevor das Fenster angezeigt wird (durch Aufrufen von <xref:System.Windows.Window.Show%2A>); Einstellung <xref:System.Windows.Window.ShowActivated%2A> zu `false` nachdem ein Fenster angezeigt wird, wirkt sich nicht.  
  
 Festlegen von <xref:System.Windows.Window.ShowActivated%2A> zu `false` in einem Fenster, die durch den Aufruf modal, geöffnet wird <xref:System.Windows.Window.ShowDialog%2A>, verfügt über keine tatsächlichen Auswirkungen. Obwohl das modale Fenster nicht aktiviert wird, wird das modale Fenster verhindert, dass den Benutzer andere Anwendungsfenster aktivieren.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie das Markup zu verwenden, um ein Fenster geöffnet werden, ohne Aktivierung zu konfigurieren.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Das folgende Beispiel zeigt, wie Sie Code verwenden, so konfigurieren Sie ein Fenster ohne aktivierte geöffnet werden.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.ShowActivated" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet ein Fenster und wird erst beendet, wenn das neu geöffnete Fenster geschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" />-Wert vom Typ <see cref="T:System.Boolean" /> gibt an, ob die Aktivität bestätigt (<see langword="true" />) oder abgebrochen (<see langword="false" />) wurde. Der Rückgabewert ist der Wert der <see cref="P:System.Windows.Window.DialogResult" />-Eigenschaft, bevor ein Fenster geschlossen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Window> Klasse instanziiert wird, es ist nicht standardmäßig angezeigt. <xref:System.Windows.Window.ShowDialog%2A> Zeigt das Fenster deaktiviert alle anderen Fenster in der Anwendung und gibt nur, wenn das Fenster geschlossen wird. Diese Art von Fenster wird als bezeichnet ein *modale* Fenster.  
  
 Modale Fenster werden in erster Linie als Dialogfelder verwendet werden. Ein Dialogfeld, das ist eine besondere Art von Fenster, die Anwendungen, die für die Interaktion mit Benutzern die Ausführung von Aufgaben wie das Öffnen von Dateien oder Drucken von Dokumenten verwenden. Dialogfelder ermöglichen im Allgemeinen Benutzer zum annehmen oder Abbrechen der Aufgabe, die für die sie angezeigt wurden, bevor Sie das Dialogfeld geschlossen wird. <xref:System.Windows.Window.ShowDialog%2A> Gibt eine <xref:System.Nullable%601> <xref:System.Boolean> Wert, der angibt, ob die Aktivität bestätigt oder abgebrochen wurde. Der Rückgabewert ist der Wert der <xref:System.Windows.Window.DialogResult%2A>-Eigenschaft, bevor ein Fenster geschlossen wird. Weitere Informationen finden Sie unter <xref:System.Windows.Window.DialogResult%2A>.  
  
 Ein Fenster, das durch den Aufruf geöffnet wird die <xref:System.Windows.Window.ShowDialog%2A> Methode muss nicht automatisch eine Beziehung mit dem Fenster, die es geöffnet; insbesondere das geöffnete Fenster weiß nicht, welches Fenster, die sie geöffnet. Diese Beziehung kann hergestellt werden, mithilfe der <xref:System.Windows.Window.Owner%2A> -Eigenschaft und Verwenden von verwalteten der <xref:System.Windows.Window.OwnedWindows%2A> Eigenschaft. Zur Unterstützung [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Automation (finden Sie unter [UI Automation Overview](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> muss festgelegt werden, für ein Fenster durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Wenn eine modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster (ein Fenster geöffnet wird, durch den Aufruf <xref:System.Windows.Window.ShowDialog%2A>) geschlossen ist, das zuvor aktivierte Fenster erneut aktiviert. Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster verfügt über eine besitzende Fenster (finden Sie unter <xref:System.Windows.Window.Owner%2A>), das besitzende Fenster ist nicht erneut aktiviert, wenn der modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster wird geschlossen, es sei denn, das zuvor aktivierte Fenster war.  
  
> [!NOTE]
>  Diese Methode werden nicht aufgerufen, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie ein modales Fenster geöffnet wird.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> wird für ein Fenster aufgerufen, das geschlossen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung, um ein Fenster zu aktivieren. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Fenster über eine Taskleistenschaltfläche verfügt, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Fenster über eine Taskleistenschaltfläche verfügt, andernfalls <see langword="false" />. Wird nicht angewendet, wenn das Fenster in einem Browser gehostet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.ShowInTaskbar%2A> nastaven NA hodnotu `true`, das Fenster wird auch angezeigt, in der Auswahlliste der ALT + TAB-Anwendung.  
  
 Das Symbol, das für die Taskleisten-Schaltfläche und der Auswahlliste der ALT + TAB-Anwendung verwendet wird, ist der Wert des der <xref:System.Windows.Window.Icon%2A> Eigenschaft.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.ShowInTaskbar" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab (bzw. legt diesen fest), der angibt, ob ein Fenster seine Größe automatisch an die Größe seines Inhalts anpasst.</summary>
        <value>Ein <see cref="T:System.Windows.SizeToContent" />-Wert. Der Standardwert ist <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> nastaven NA hodnotu <xref:System.Windows.SizeToContent.WidthAndHeight>, Einstellung <xref:System.Windows.FrameworkElement.Height%2A> oder <xref:System.Windows.FrameworkElement.Width%2A> hat keine Auswirkungen; beide Eigenschaften können festgelegt werden, aber die Werte werden festgelegt, mit nicht auf das Fenster angewendet.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> nastaven NA hodnotu <xref:System.Windows.SizeToContent.Height>, wobei <xref:System.Windows.FrameworkElement.Height%2A> ändert sich nicht auf die Höhe des Fensters.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> nastaven NA hodnotu <xref:System.Windows.SizeToContent.Width>, wobei <xref:System.Windows.FrameworkElement.Width%2A> ändert sich nicht auf die Breite des Fensters.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> verfügt über einen Wert als <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> wird automatisch festgelegt, um <xref:System.Windows.SizeToContent.Manual> , wenn ein Benutzer die Fenstergröße wird durch den Ziehpunkt zur Größenänderung oder Ziehen des Rahmens.  
  
-   Wenn die Größe des Inhalts auf eine Weise ändert, die bewirkt, dass das Fenster selbst, Ändern der Größe <xref:System.Windows.FrameworkElement.SizeChanged> ausgelöst wird.  
  
 Wenn ein Fenster transparent ist (finden Sie unter <xref:System.Windows.Window.AllowsTransparency%2A>), sollten Sie die Einstellung <xref:System.Windows.Window.SizeToContent%2A> zu <xref:System.Windows.SizeToContent.WidthAndHeight> um sicherzustellen, dass das Fenster ist nicht größer als die sichtbaren Inhalts.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.SizeToContentProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen Sie die <xref:System.Windows.Window.SizeToContent%2A> Eigenschaft im Code, um anzugeben, wie die Fenstergröße um seinen Inhalt anzupassen.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.SizeToContent" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Ereignis wird ausgelöst, um die Interoperation mit [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] zu unterstützen. Siehe <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Window.WindowState" />-Eigenschaft des Fensters geändert wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die [!INCLUDE[win7](~/includes/win7-md.md)]-Taskleistenminiaturansicht für <see cref="T:System.Windows.Window" /> ab oder legt diese fest.</summary>
        <value>Die [!INCLUDE[win7](~/includes/win7-md.md)]-Taskleistenminiaturansicht für <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Verwendung der [!INCLUDE[win7](~/includes/win7-md.md)] Taskleiste Miniaturansichten, finden Sie unter den <xref:System.Windows.Shell.TaskbarItemInfo> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.TaskbarItemInfo" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Titel eines Fensters ab bzw. legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />, der den Titel des Fensters enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Titel des eine <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, oder [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], kann auch festgelegt werden, mithilfe von <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.TitleProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Title" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des oberen Fensterrands im Verhältnis zum Desktop ab oder legt diese fest.</summary>
        <value>Die Position des oberen Fensterrands in logischen Einheiten (1/96 ").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window> maximiert oder minimiert, dieser Wert darstellt, zeigen Sie der obere Rand der Wiederherstellung für, die <xref:System.Windows.Window>.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie einen Wert nicht angeben <xref:System.Windows.Window.Top%2A> auf den Standardwert des Systems festgelegt ist. Sie können auch den standardmäßigen Systemwert angeben, durch Festlegen von <xref:System.Windows.Window.Top%2A> zu <xref:System.Double.NaN>. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.TopProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Fenster in der z-Reihenfolge zuoberst angezeigt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn es sich um das oberste Fenster handelt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster, dessen <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `true` wird über alle Fenster, dessen <xref:System.Windows.Window.Topmost%2A> Eigenschaften festgelegt werden, um `false`.  
  
 In der Gruppe von Windows, die <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `true`, das Fenster, das derzeit aktiviert ist, ist das oberste Fenster. Dasselbe gilt für die Gruppe von Windows, die <xref:System.Windows.Window.Topmost%2A> -Eigenschaftensatz auf `false`.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.TopmostProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Topmost" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.Top" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Fensters beim ersten Anzeigen ab bzw. legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStartupLocation" />-Wert, der die Position links oben für ein Fenster beim ersten Anzeigen angibt. Der Standardwert ist <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der `WindowStartupLocation` Eigenschaft <xref:System.Windows.WindowStartupLocation.Manual> bewirkt, dass ein Fenster entsprechend positioniert werden die <xref:System.Windows.Window.Left%2A> und <xref:System.Windows.Window.Top%2A> Eigenschaftswerte. Wenn entweder die <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> Eigenschaften nicht angegeben werden, deren Werte werden durch Windows bestimmt.  
  
 Festlegen der `WindowStartupLocation` Eigenschaft <xref:System.Windows.WindowStartupLocation.CenterScreen> wird ein Fenster in der Mitte des Bildschirms positioniert werden, die den Cursor enthält.  
  
 Festlegen der `WindowStartupLocation` Eigenschaft <xref:System.Windows.WindowStartupLocation.CenterOwner> bewirkt, dass ein Fenster in der Mitte des Besitzerfensters positioniert werden soll (finden Sie unter <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>) angegeben. Das besitzende Fenster kann entweder eine andere WPF-Fenster oder ein nicht-WPF-Fenster sein.

> [!NOTE]   
>  Weitere Informationen zu WPF-Fenster mit nicht-WPF-Fenstern, finden Sie unter [WPF und Win32-Interoperation](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) und <xref:System.Windows.Interop.WindowInteropHelper>. 

 Wenn ein Fenster "Besitzer" nicht angegeben ist, richtet sich die Position des Fensters auf die gleiche Weise wie die `WindowStartupLocation` -Eigenschaftensatz auf <xref:System.Windows.WindowStartupLocation.Manual>.

> [!NOTE]
>  Sie können nicht festgelegt, oder rufen Sie den Wert dieser Eigenschaft ein, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Fenster wiederhergestellt, minimiert oder maximiert ist, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.WindowState" />, der bestimmt, ob ein Fenster wiederhergestellt, minimiert oder maximiert ist. Der Standardwert ist <see cref="F:System.Windows.WindowState.Normal" /> (wiederhergestellt).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor ein Fenster minimiert oder maximiert wird, die die Größe und Position werden in gespeichert <xref:System.Windows.Window.RestoreBounds%2A>. Wenn ein Fenster später wiederhergestellt wird, werden die Werte für Größe und Position mit den Werten aus wiederhergestellt <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Wenn die <xref:System.Windows.Window.WindowState%2A> -Eigenschaft geändert wird, <xref:System.Windows.Window.StateChanged> ausgelöst wird.  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.WindowStateProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.WindowState" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Rahmenart eines Fensters ab bzw. legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStyle" />, der die Rahmenart eines Fensters angibt. Der Standardwert ist <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> kann die <xref:System.Windows.WindowStyle> -Enumerationswerte fest, einschließlich <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (Standard), und <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 Die folgende Abbildung zeigt das Window-Stile auf [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero-Design, mit aktiviertem transparenten Glaseffekt):  
  
 ![Window-Stile](~/add/media/windowoverviewfigure6.PNG "Window-Stile")  
  
> [!NOTE]
>  Sie können nicht festgelegt oder diese Eigenschaft zu erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Window.WindowStyleProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Window.WindowStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>