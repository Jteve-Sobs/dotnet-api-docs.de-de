<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9cb2033afd5cdb9a823ef84f125beb76fdaa2a3d" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75051071" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Bietet die Möglichkeit, die Lebensdauer von Fenstern und Dialogfeldern zu erstellen, zu konfigurieren, anzuzeigen und zu verwalten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Punkt der Interaktion zwischen einem Benutzer und einer eigenständigen Anwendung ist ein Fenster. Ein [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Fenster besteht aus zwei unterschiedlichen Bereichen:  
  
-   Ein nicht-Client Bereich, der die Windows-Zusatzelemente hostet, einschließlich Symbol, Titel, System Menü, minimieren, Schaltfläche maximieren, Schaltfläche "Wiederherstellen", Schaltfläche "Schließen" und Rahmen.  
  
-   Ein Client Bereich, der anwendungsspezifischen Inhalt hostet.  
  
 Ein Standardfenster ist in der folgenden Abbildung dargestellt:  
  
 ![Fensterelemente](~/add/media/windowoverviewfigure1.PNG "Fensterelemente")  
  
 <xref:System.Windows.Window> kapselt die Möglichkeit, die Lebensdauer von Fenstern und Dialogfeldern zu erstellen, zu konfigurieren, anzuzeigen und zu verwalten, und stellt die folgenden Schlüsseldienste bereit:  
  
 **Lebensdauer Verwaltung**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Fensterverwaltung**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A><xref:System.Windows.Window.Owner%2A>.  
  
 Darstellung **und Verhalten**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Dialog Felder**: <xref:System.Windows.Window.DialogResult%2A><xref:System.Windows.Window.ShowDialog%2A>.  
  
 Außerdem bietet <xref:System.Windows.Application> besondere Unterstützung für die Verwaltung aller Fenster in einer Anwendung:  
  
-   Die Anwendung verwaltet eine Liste aller Fenster, die zurzeit in der Anwendung instanziiert werden. Diese Liste wird durch die <xref:System.Windows.Application.Windows%2A>-Eigenschaft verfügbar gemacht.  
  
-   Standardmäßig wird <xref:System.Windows.Application.MainWindow%2A> automatisch mit einem Verweis auf den ersten <xref:System.Windows.Window> festgelegt, der in einer Anwendung instanziiert wird. Dadurch wird das Fenster zum Hauptanwendungsfenster.  
  
 Eine <xref:System.Windows.Window> kann mithilfe von Markup, Markup und Code Behind oder Code implementiert werden.  
  
 <xref:System.Windows.Window> wird hauptsächlich zum Anzeigen von Fenstern und Dialogfeldern für eigenständige Anwendungen verwendet. Allerdings können Sie für Anwendungen, die eine Navigation auf der Fenster Ebene erfordern (z. b. Assistenten), stattdessen <xref:System.Windows.Navigation.NavigationWindow> verwenden. <xref:System.Windows.Navigation.NavigationWindow> von <xref:System.Windows.Window> abgeleitet und durch die Navigation im Browser Stil erweitert.  
  
> [!NOTE]
>  Inseln mit Navigier barem Inhalt können mithilfe von <xref:System.Windows.Controls.Frame>in andere Inhalts-und Inhalts Container eingebunden werden.  
  
 <xref:System.Windows.Window> muss `UnmanagedCode` Sicherheits Berechtigung instanziiert werden. Das hat folgende Konsequenzen:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]bereitgestellte eigenständige Anwendungen fordern eine Berechtigungs Erweiterung an, wenn Sie entweder über die Zone Internet oder lokales Intranet gestartet werden.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], die eine beliebige Version als vollständige Berechtigungen anfordern, können Windows oder Dialogfelder nicht instanziiert werden.  
  
 Informationen zu eigenständigen Bereitstellungs-und Sicherheitsüberlegungen für Anwendungen finden Sie unter [WPF-Sicherheitsstrategie-Plattformsicherheit](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Ein <xref:System.Windows.Window> ist ein <xref:System.Windows.Controls.ContentControl>. Dies bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. b. eine Zeichenfolge, ein Bild oder ein Panel) enthalten kann. Weitere Informationen finden Sie im Thema zur Klasse <xref:System.Windows.Controls.ContentControl>. Außerdem ist <xref:System.Windows.Window> ein root-Element und kann daher nicht Teil des Inhalts eines anderen Elements sein.  
  
> [!NOTE]
>  Die Eigenschaften "<xref:System.Windows.FrameworkElement.Height%2A>", "<xref:System.Windows.FrameworkElement.Width%2A>", "<xref:System.Windows.Window.Top%2A>" und "<xref:System.Windows.Window.Left%2A>", die auf einem <xref:System.Windows.Window> durch einen Stil festgelegt wurden, werden nicht zur Laufzeit angewendet  
  
## <a name="customizing-the-window-control"></a>Anpassen des Window-Steuer Elements  
 Um dieselben Eigenschaften Einstellungen auf mehrere <xref:System.Windows.Window> Steuerelemente anzuwenden, verwenden Sie die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft. Sie können die Standard <xref:System.Windows.Controls.ControlTemplate> ändern, um dem Steuerelement eine eindeutige Darstellung zu verschaffen. Weitere Informationen zum Erstellen eines <xref:System.Windows.Controls.ControlTemplate>finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Informationen zu den für die <xref:System.Windows.Window>spezifischen Teilen und Zuständen finden Sie unter [Fenster Stile und-Vorlagen](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Standardfenster nur mit Markup definiert wird:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 Im folgenden Beispiel wird gezeigt, wie ein Standardfenster nur mit Code definiert wird:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Im folgenden Beispiel wird gezeigt, wie ein Standardfenster mithilfe einer Kombination aus Markup und Code Behind definiert wird.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Window" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Konstruktor initialisiert die Eigenschaften <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>und <xref:System.Windows.Window.Left%2A> mit ihren standardmäßigen <xref:System.Windows.Window> Werten.  
  
 Wenn ein Fenster in einem <xref:System.AppDomain> erstellt wird, das ein <xref:System.Windows.Application>-Objekt aufweist, fügt der Konstruktor dem Satz der <xref:System.Windows.Application>verwalteten Fenster über die <xref:System.Windows.Application.Windows%2A>-Eigenschaft des <xref:System.Windows.Application> Objekts das <xref:System.Windows.Window>-Objekt hinzu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung für dieses Objekt, unsichere Native Methoden aufzurufen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, das Fenster in den Vordergrund zu bringen, und aktiviert dieses.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Windows.Window" /> erfolgreich aktiviert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln, die bestimmen, ob das Fenster aktiviert ist, sind identisch mit denen, die von der [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow`-Funktion (user32. dll) verwendet werden.  
  
 Wenn das Fenster in einer Windows Presentation Foundation Anwendung aktiviert ist, die nicht die Vordergrund Anwendung des Benutzers ist, wird <xref:System.Windows.Application.Activated> Ereignis ausgelöst.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Aktivieren eines Fensters. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fenster in den Vordergrund gesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster wird aktiviert (wird zum Vordergrund Fenster), wenn Folgendes gilt:  
  
-   Das Fenster wird zuerst geöffnet.  
  
-   Ein Benutzer wechselt zu einem Fenster, indem er mit der Maus ausgewählt und Alt + Tab oder vom Task-Manager drückt.  
  
-   Ein Benutzer klickt auf die Schaltfläche der Taskleiste des Fensters.  
  
 Windows, die erkennen müssen, wann Sie aktiviert werden, können das <xref:System.Windows.Window.Activated> Ereignis verarbeiten.  
  
 Nachdem ein Fenster zum ersten Mal aktiviert wurde, kann es während seiner Lebensdauer mehrmals deaktiviert und erneut aktiviert werden. Wenn das Verhalten oder der Zustand einer Anwendung vom Aktivierungszustand abhängig ist, kann Sie <xref:System.Windows.Window.IsActive%2A> überprüfen, um zu bestimmen, in welchem Aktivierungszustand Sie sich befindet.  
  
 Eine Anwendung kann auch <xref:System.Windows.Application.Activated>werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Clientbereich eines Fensters Transparenz unterstützt.</summary>
        <value><see langword="true" />, wenn das Fenster Transparenz unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Controls.Control.Background%2A>-Eigenschaft eines Fensters auf eine transparente Farbe festgelegt wird, bleibt das Fenster mithilfe <xref:System.Windows.Media.Brushes.Transparent%2A> beispielsweise nicht transparent. Dies bedeutet, dass der Desktop und alle laufenden Anwendungen "unterhalb" des Fensters nicht sichtbar sind. Um diese Art von Transparenz zu aktivieren, müssen <xref:System.Windows.Window.AllowsTransparency%2A> auf `true`festgelegt werden.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> vorhanden ist, um die Erstellung von nicht rechteckigen Fenstern zu vereinfachen. Folglich muss die <xref:System.Windows.Window.WindowStyle%2A> Eigenschaft eines Fensters auf <xref:System.Windows.WindowStyle.None>festgelegt werden, wenn <xref:System.Windows.Window.AllowsTransparency%2A> auf `true`festgelegt ist.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ein Fenster, das über einen beliebigen anderen <see cref="P:System.Windows.Window.WindowStyle" />-Wert als <see cref="F:System.Windows.WindowStyle.None" /> verfügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.AllowsTransparency" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Eine <see cref="T:System.Windows.Size" />, die die endgültige Größe wiedergibt, anhand derer das Fenster sich selbst und seine untergeordneten Elemente anordnen soll.</param>
        <summary>Überschreiben Sie diese Methode, um ein Fenster und dessen untergeordnete Elemente anzuordnen und in der Größe zu ändern.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />, die die verwendete tatsächliche Größe wiedergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft den Wert <xref:System.Windows.Visibility.Collapsed>aufweist. Wenn der Wert der <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft entweder <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>ist, wird <xref:System.Windows.Window.ArrangeOverride%2A> aufgerufen.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, wird die Eigenschaft <xref:System.Windows.UIElement.Visibility%2A> einer <xref:System.Windows.Window> auf <xref:System.Windows.Visibility.Visible>festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt ein <see cref="T:System.Windows.Window" /> manuell.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Window> kann mit einem von mehreren bekannten und vom System bereitgestellten Mechanismen geschlossen werden, die sich in der Titelleiste befinden, einschließlich:  
  
-   Alt + F4.  
  
-   Das System &#124; Menü ist **geschlossen**.  
  
-   Schaltfläche **Schließen** .  
  
 Eine <xref:System.Windows.Window> kann auch mit einem von mehreren bekannten Mechanismen im Client Bereich geschlossen werden, die von Entwicklern bereitgestellt werden, einschließlich:  
  
-   **** &#124; **Beenden** von Dateien in einem Hauptfenster.  
  
-   **** &#124; **Schließen** Sie die Datei oder eine Schaltfläche **Schließen** in einem untergeordneten Fenster.  
  
> [!NOTE]
>  Die Schaltflächen **OK** und **Abbrechen** in einem Dialogfeld werden ebenfalls vom Entwickler bereitgestellt, obwohl wahrscheinlich <xref:System.Windows.Window.DialogResult%2A>festlegen, wodurch automatisch ein Fenster geschlossen wird, das durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>geöffnet wurde.  
  
 Diese Mechanismen erfordern, dass Sie <xref:System.Windows.Window.Close%2A> explizit aufzurufen, um ein Fenster zu schließen.  
  
> [!NOTE]
>  Wenn ein Fenster, das durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>geöffnet wird, und mit einem <xref:System.Windows.Controls.Button>, dessen <xref:System.Windows.Controls.Button.IsCancel%2A>-Eigenschaft auf true festgelegt ist, automatisch geschlossen wird, wenn auf die Schaltfläche geklickt wird oder ESC gedrückt wird. Wenn das Fenster jedoch mit <xref:System.Windows.Window.Show%2A>geöffnet wurde, müssen <xref:System.Windows.Window.Close%2A> explizit aufgerufen werden, z. b. von <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignishandler für die <xref:System.Windows.Controls.Button>.  
  
 Das Schließen eines Fensters bewirkt, dass das <xref:System.Windows.Window.Closing> Ereignis ausgelöst wird. Wenn das <xref:System.Windows.Window.Closing> Ereignis nicht abgebrochen wird, geschieht Folgendes:  
  
-   Die <xref:System.Windows.Window> wird aus <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> entfernt (wenn ein <xref:System.Windows.Application> Objekt vorhanden ist).  
  
-   Die <xref:System.Windows.Window> wird aus der Besitzer <xref:System.Windows.Window> entfernt, wenn die Besitzer/besitzende Beziehung hergestellt wurde, bevor die <xref:System.Windows.Window> angezeigt wurde, und nachdem der Besitzer <xref:System.Windows.Window> geöffnet wurde.  
  
-   Das <xref:System.Windows.Window.Closed>-Ereignis wird ausgelöst.  
  
-   Nicht verwaltete Ressourcen, die von der <xref:System.Windows.Window> erstellt wurden, werden verworfen.  
  
-   Wenn <xref:System.Windows.Window.ShowDialog%2A> aufgerufen wurde, um die <xref:System.Windows.Window>anzuzeigen, gibt <xref:System.Windows.Window.ShowDialog%2A> zurück.  
  
 Das Schließen einer <xref:System.Windows.Window> bewirkt, dass alle Fenster, die Sie besitzt, geschlossen werden. Außerdem kann das Schließen einer <xref:System.Windows.Window> dazu führen, dass eine Anwendung nicht mehr ausgeführt wird, je nachdem, wie die <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType>-Eigenschaft festgelegt wird.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein **Datei** &#124; -Beendigungs **Menü behandelt** wird, um <xref:System.Windows.Window.Close%2A>explizit aufzurufen.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zur Verwendung aller Windows-und Benutzereingabe Ereignisse ohne Einschränkung. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt kurz vor dem Schließen des Fensters auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Ereignis ausgelöst wird, kann das Schließen eines Fensters nicht verhindert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Während ein Fenster schließt, wird <see cref="P:System.Windows.UIElement.Visibility" /> festgelegt, oder <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> oder <see cref="M:System.Windows.Window.Hide" /> wird aufgerufen.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Window.Close" /> auf und kann behandelt werden, um das Schließen des Fensters abzubrechen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> können behandelt werden, um zu erkennen, wann ein Fenster geschlossen wird (z. b. wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird). Darüber hinaus können <xref:System.Windows.Window.Closing> verwendet werden, um zu verhindern, dass ein Fenster geschlossen wird. Um zu verhindern, dass ein Fenster geschlossen wird, können Sie die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Eigenschaft des <xref:System.ComponentModel.CancelEventArgs>-Arguments auf `true`festlegen.  
  
 Das <xref:System.Windows.Window.Closing> Ereignis wird ausgelöst, wenn <xref:System.Windows.Window.Close%2A> aufgerufen wird, wenn auf die Schaltfläche Schließen eines Fensters geklickt wird oder wenn der Benutzer ALT + F4 drückt.  
  
 Wenn ein im Besitz befindlichen Fenster mithilfe <xref:System.Windows.Window.Show%2A>von seinem Besitzer Fenster geöffnet wurde und das Besitzer Fenster geschlossen wird, wird das <xref:System.Windows.Window.Closing> Ereignis des eigenen Fensters nicht ausgelöst. Wenn der Besitzer eines Fensters geschlossen wird (siehe <xref:System.Windows.Window.Owner%2A>), wird <xref:System.Windows.Window.Closing> nicht im eigenen Fenster ausgelöst.  
  
 Wenn <xref:System.Windows.Application.Shutdown%2A> aufgerufen wird, wird das <xref:System.Windows.Window.Closing>-Ereignis für jedes Fenster ausgelöst. Wenn <xref:System.Windows.Window.Closing> jedoch abgebrochen wird, wird der Abbruch ignoriert.  
  
 Wenn eine Sitzung beendet wird, weil ein Benutzer sich abmeldet oder herunterfährt, wird <xref:System.Windows.Window.Closing> nicht ausgelöst. Handle <xref:System.Windows.Application.SessionEnding>, um Code zu implementieren, der die Anwendungs Schließung abbricht.  
  
 Wenn Sie ein Fenster während der Lebensdauer einer Anwendung mehrmals anzeigen und ausblenden möchten, und Sie das Fenster nicht jedes Mal neu installieren möchten, wenn Sie es anzeigen, können Sie das <xref:System.Windows.Window.Closing>-Ereignis behandeln, Abbrechen und die <xref:System.Windows.Window.Hide%2A>-Methode aufzurufen. Anschließend können Sie <xref:System.Windows.Window.Show%2A> für die gleiche Instanz abrufen, um Sie erneut zu öffnen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Window> veranschaulicht, die bestimmt, ob ein Benutzereingriff geschlossen werden muss.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Während ein Fenster schließt, wird <see cref="P:System.Windows.UIElement.Visibility" /> festgelegt, oder <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> oder <see cref="M:System.Windows.Window.Close" /> wird aufgerufen.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContentRendered;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt nach dem Rendern des Inhalts eines Fensters auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Fenster keinen Inhalt aufweist, wird dieses Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fenster zum Hintergrundfenster wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster wird deaktiviert (wird zu einem Hintergrund Fenster), wenn Folgendes gilt:  
  
-   Ein Benutzer wechselt zu einem anderen Fenster in der aktuellen Anwendung.  
  
-   Ein Benutzer wechselt zum Fenster in einer anderen Anwendung, indem er Alt + Tab oder den Task-Manager verwendet.  
  
-   Ein Benutzer klickt auf die Task leisten Schaltfläche für ein Fenster in einer anderen Anwendung.  
  
 Fenster, die erkennen müssen, wenn Sie durch die Behandlung des <xref:System.Windows.Window.Deactivated> Ereignisses deaktiviert werden.  
  
 Nachdem ein Fenster zum ersten Mal deaktiviert wurde, kann es während seiner Lebensdauer mehrmals reaktiviert und deaktiviert werden. Wenn das Verhalten oder der Zustand einer Anwendung vom Aktivierungszustand abhängig ist, kann Sie <xref:System.Windows.Window.IsActive%2A> überprüfen, um zu bestimmen, in welchem Aktivierungszustand Sie sich befindet.  
  
 Eine Anwendung kann auch <xref:System.Windows.Application.Deactivated>werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ergebniswert des Dialogfelds ab, d. h. den von der <see cref="M:System.Windows.Window.ShowDialog" />-Methode zurückgegebenen Wert, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Nullable`1" />-Wert vom Typ <see cref="T:System.Boolean" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> können aus dem Code verwendet werden, der ein Dialogfeld anzeigt, um zu bestimmen, ob ein Benutzer das Dialogfeld akzeptiert (`true`) oder abgebrochen hat (`false`). Wenn ein Dialogfeld akzeptiert wurde, bedeutet dies für den Code, der das Dialogfeld geöffnet hat, um die vom Benutzer gesammelten Daten abzurufen und zu verarbeiten. Wenn ein Dialogfeld abgebrochen wurde, bedeutet dies jedoch, dass der aufrufende Code alle weiteren Verarbeitungsvorgänge abbrechen soll.  
  
 Standardmäßig wird ein Dialogfeld abgebrochen, wenn ein Benutzer eine der folgenden Aktionen durchführt:  
  
-   Pressesalt + F4.  
  
-   Klickt auf die Schaltfläche **Schließen** .  
  
-   Wählt **Schließen** im Menü System aus.  
  
 In allen diesen Fällen wird <xref:System.Windows.Window.DialogResult%2A> standardmäßig `false`.  
  
 Ein Dialogfeld stellt in der Regel eine spezielle Schaltfläche zum Abbrechen eines Dialogs bereit. Dies ist die Schaltfläche, deren <xref:System.Windows.Controls.Button.IsCancel%2A>-Eigenschaft auf `true`festgelegt ist. Eine auf diese Weise konfigurierte Schaltfläche schließt ein Fenster automatisch, wenn es gedrückt wird oder wenn die ESC-Taste gedrückt wird. In beiden Fällen bleibt <xref:System.Windows.Window.DialogResult%2A> `false`.  
  
 Ein Dialogfeld stellt in der Regel auch eine Accept-Schaltfläche bereit, bei der es sich um die Schaltfläche handelt, deren <xref:System.Windows.Controls.Button.IsDefault%2A>-Eigenschaft `true` Eine auf diese Weise konfigurierte Schaltfläche erhöht das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis, wenn entweder oder die EINGABETASTE gedrückt wird. Das Dialogfeld wird jedoch nicht automatisch geschlossen, und es wird <xref:System.Windows.Window.DialogResult%2A> nicht auf `true`festgelegt. Sie müssen diesen Code manuell schreiben, üblicherweise aus dem <xref:System.Windows.Controls.Primitives.ButtonBase.Click>-Ereignishandler für die Standard Schaltfläche.  
  
 <xref:System.Windows.Window.DialogResult%2A> wird `null`, wenn das Dialogfeld angezeigt wird, aber weder akzeptiert noch abgebrochen wurde.  
  
 Nachdem ein Dialogfeld geschlossen wurde, können Sie das Dialogfeld Ergebnis aus dem von <xref:System.Windows.Window.ShowDialog%2A>-Methode zurückgegebenen Wert oder durch Überprüfen der <xref:System.Windows.Window.DialogResult%2A>-Eigenschaft erhalten.  
  
 <xref:System.Windows.Window.DialogResult%2A> können nur festgelegt werden, wenn eine <xref:System.Windows.Window> geöffnet wird, indem die zugehörige <xref:System.Windows.Window.ShowDialog%2A>-Methode aufgerufen wird.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Schaltfläche OK und eine Schaltfläche Abbrechen zum Zurückgeben der entsprechenden <xref:System.Windows.Window.DialogResult%2A>konfigurieren.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.DialogResult" /> wird festgelegt, bevor ein Fenster durch Aufrufen von <see cref="M:System.Windows.Window.ShowDialog" /> geöffnet wird.  
  
- oder - 
 <see cref="P:System.Windows.Window.DialogResult" /> wird in einem Fenster festgelegt, das durch Aufrufen von <see cref="M:System.Windows.Window.Show" /> geöffnet wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem sich die DPI-Auflösung des Bildschirms geändert hat, auf dem das Fenster angezeigt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein <see cref="T:System.Windows.RoutedEvent" /> für den Fall, dass der DPI-Wert des Bildschirms, der das Fenster anzeigt, geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es, ein Fenster mit der Maus auf einen verfügbar gemachten Bereich im Clientbereich des Fensters zu ziehen, indem die linke Maustaste gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die linke Maustaste muss nicht angezeigt werden, wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird. Eine Möglichkeit, zu erkennen, wenn die linke Maustaste gedrückt wird, besteht darin, das <xref:System.Windows.UIElement.MouseLeftButtonDown>-Ereignis zu behandeln.  
  
 Wenn <xref:System.Windows.Window.DragMove%2A> aufgerufen wird, muss die linke Maustaste über einem verfügbar gemachten Bereich des Client Bereichs des Fensters gedrückt werden.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> überschrieben wird, um <xref:System.Windows.Window.DragMove%2A>aufzurufen.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die linke Maustaste wird nicht gedrückt gehalten.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">, wenn die Berechtigung zum Ziehen eines Fensters angezeigt werden soll. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Das Abhängigkeitsobjekt.</param>
        <summary>Gibt einen Verweis auf das <see cref="T:System.Windows.Window" />-Objekt zurück, das die Inhaltsstruktur mit dem Abhängigkeitsobjekt hostet.</summary>
        <returns>Ein <see cref="T:System.Windows.Window" />-Verweis auf das Hostfenster.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Macht ein Fenster unsichtbar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster wird nicht geschlossen, wenn es ausgeblendet ist, und weder das <xref:System.Windows.Window.Closing> noch das <xref:System.Windows.Window.Closed> Ereignis wird ausgelöst. Stattdessen wird die <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft des Fensters auf <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>festgelegt.  
  
 Wenn ein Fenster die <xref:System.Windows.Application.MainWindow%2A> der Anwendung ist und die <xref:System.Windows.Application.ShutdownMode%2A> der Anwendung <xref:System.Windows.ShutdownMode.OnMainWindowClose>ist, wird die Anwendung nicht heruntergefahren. Ebenso wird die Anwendung nicht heruntergefahren, wenn ein Fenster das einzige Fenster ist und der herunter Fahr Modus der Anwendung <xref:System.Windows.ShutdownMode.OnLastWindowClose>ist.  
  
 Wenn Sie ein Fenster während der Lebensdauer einer Anwendung mehrmals ein-und ausblenden möchten, und Sie das Fenster nicht jedes Mal neu instanziieren möchten, können Sie das <xref:System.Windows.Window.Closing>-Ereignis behandeln, Abbrechen und die <xref:System.Windows.Window.Hide%2A>-Methode aufzurufen. Anschließend können Sie <xref:System.Windows.Window.Show%2A> auf derselben Instanz aufzurufen, um Sie erneut zu öffnen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.Hide" /> wird für ein Fenster aufgerufen, das geschlossen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Symbol eines Fensters ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Media.ImageSource" />-Objekt, das das Symbol darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenständige WPF-Anwendungen (Windows Presentation Foundation) haben zwei Arten von Symbolen:  
  
-   Ein Assemblysymbol, das mit der `<ApplicationIcon>`-Eigenschaft in der Projektbuilddatei der Anwendung angegeben wird. Dieses Symbol wird als Desktop Symbol für eine Assembly verwendet.  
  
    > [!NOTE]
    >  Wenn Sie in Visual Studio debuggen, wird das Symbol möglicherweise aufgrund des Hostingprozesses nicht angezeigt. Wenn Sie die ausführbare Datei ausführen, wird das Symbol angezeigt. Weitere Informationen finden Sie unter [Hostprozess („vshost.exe“)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Ein Symbol pro Fenster, das durch Festlegen von <xref:System.Windows.Window.Icon%2A>angegeben wird. Für jedes Fenster wird dieses Symbol in der Titelleiste, der Task leisten Schaltfläche und in der Liste der Anwendungs Auswahl Einträge der alt-Registerkarte verwendet.  
  
 Ein WPF-Fenster zeigt immer ein Symbol an. Wenn eine nicht durch Festlegen von <xref:System.Windows.Window.Icon%2A>bereitgestellt wird, wählt WPF ein Symbol aus, das auf der Grundlage der folgenden Regeln angezeigt wird:  
  
1.  Verwenden Sie das Assembly-Symbol, falls angegeben.  
  
2.  Wenn das Assemblysymbol nicht angegeben ist, verwenden Sie das Microsoft Windows-Standard Symbol.  
  
 Wenn Sie <xref:System.Windows.Window.Icon%2A> verwenden, um ein benutzerdefiniertes Fenster Symbol anzugeben, können Sie das Standard Anwendungssymbol wiederherstellen, indem Sie <xref:System.Windows.Window.Icon%2A> auf `null`festlegen.  
  
 Ein einzelnes Symbol kann auf verschiedene Weise in Windows verwendet werden, einschließlich der Anzeige in der Titelleiste eines Fensters, der Taskleiste für ein Fenster, der Dateiauswahl Liste Alt + Tab. Jedes dieser Zeichen zeigt das Symbol mit einer anderen Größe an. ein 16x16-Pixel-Symbol wird in der Titelleiste eines Fensters und in der Taskleiste angezeigt, während in der Dateiauswahl Liste Alt + Tab ein Symbol für 32 x 32 Pixel angezeigt wird. Einige Anwendungen, wie z. b. [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], bieten ein Menü **Ansicht** , in dem Sie die Größe des Symbols auswählen können, das Sie anzeigen möchten.  
  
 Um die verschiedenen Anzeige Größen zu berücksichtigen, besteht eine Symbol Datei aus einem oder mehreren echten Symbolen, wobei jede eine Version des Symbols darstellt, das eine bestimmte Größe und Farbtiefe als Ziel hat. Ein Symbol kann z. b. nur ein einzelnes 16x16-Pixel-Symbol mit 16 Farben enthalten, während ein weiteres 16x16-Pixel-und 32 x 32 Pixel-Symbole mit 16 Farben und 256 Farben enthalten kann.  
  
 Wenn in einer Symbol Dateisymbole für alle möglichen Größen und Farb Tiefe vorhanden sind, wird <xref:System.Windows.Window> das entsprechende Symbol verwenden. Wenn eine Symbol Datei nur eine Teilmenge aller möglichen Symbole enthält, verwendet <xref:System.Windows.Window> das am besten geeignete Symbol in der Reihenfolge der abnehmenden Größen und der Farbtiefe.  
  
 Das Ergebnis ist, dass ein Symbol immer von <xref:System.Windows.Window>verwendet wird, obwohl das verwendete Symbol möglicherweise nicht die erforderliche Größe und Farbtiefe als Ziel verwendet. Beispielsweise kann ein 16x16-Pixel Symbol mit 16 Farben als 32 x 32 Pixel Symbol mit 256 Farben verwendet werden. Dies kann zu unerwünschten visuellen Effekten, wie z. b. der Entwicklung, führen, kann jedoch vermieden werden, indem Symbole für alle Zielgrößen und Farbtiefe erstellt werden.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.IconProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Fenster Symbol festgelegt wird.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Festlegen des Symbols. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.Icon" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Fenster aktiv ist.</summary>
        <value><see langword="true" />, wenn das Fenster aktiv ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein aktives Fenster ist das aktuelle Vordergrund Fenster des Benutzers und hat den Fokus, der durch die aktive Darstellung der Titelleiste gekennzeichnet wird. Ein aktives Fenster ist auch der oberste Rand aller Fenster der obersten Ebene, die die <xref:System.Windows.Window.Topmost%2A>-Eigenschaft nicht explizit festlegen.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.IsActiveProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.IsActive" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des linken Fensterrands im Verhältnis zum Desktop ab oder legt diese fest.</summary>
        <value>Die Position des linken Fensterrands in logischen Einheiten (1/96 Zoll).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Window> maximiert oder minimiert ist, stellt dieser Wert den linken Rand des Wiederherstellungs Punkts für die <xref:System.Windows.Window>dar.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie keinen Wert angeben, wird <xref:System.Windows.Window.Left%2A> auf den Standardwert des Systems festgelegt. Sie können den Standardwert des Systems auch angeben, indem Sie <xref:System.Windows.Window.Left%2A> auf <xref:System.Double.NaN>festlegen. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.LeftProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.Left" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Position des Fensters geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Speicherort eines Fensters ändert sich im folgenden:  
  
-   Ein Benutzer verschiebt ein Fenster durchziehen mit der Titelleiste des Fensters.  
  
-   Ein Fenster wird verschoben, nachdem <xref:System.Windows.Window.DragMove%2A> aufgerufen wurde.  
  
-   Entweder wird die <xref:System.Windows.Window.Left%2A>-Eigenschaft oder die <xref:System.Windows.Window.Top%2A>-Eigenschaft Programm gesteuert festgelegt.  
  
-   Das Menü Element **verschieben** des System Menüs eines Fensters wird ausgewählt.  
  
-   Die <xref:System.Windows.Window.WindowState%2A>-Eigenschaft wird geändert.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator für die logischen untergeordneten Elemente eines Fensters ab.</summary>
        <value>Ein <see cref="T:System.Collections.IEnumerator" /> für die logischen untergeordneten Elemente eines Fensters.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Eine <see cref="T:System.Windows.Size" />, die die verfügbare Größe wiedergibt, die dieses Fenster für das untergeordnete Element bereitstellen kann. Sie können den Wert als unendlich angeben, um anzuzeigen, dass das Fenster an die Größe jedes beliebigen Inhalts angepasst wird.</param>
        <summary>Überschreiben Sie diese Methode, um die Größe eines Fensters zu messen.</summary>
        <returns>Eine <see cref="T:System.Windows.Size" />, die die Größe wiedergibt, die dieses Fenster auf der Grundlage der Berechnung der Größe der untergeordneten Elemente bestimmt und während des Layouts benötigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> wird nicht aufgerufen, wenn die <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft den Wert <xref:System.Windows.Visibility.Collapsed>aufweist. Wenn der Wert der <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft entweder <xref:System.Windows.Visibility.Hidden> oder <xref:System.Windows.Visibility.Visible>ist, wird <xref:System.Windows.Window.MeasureOverride%2A> aufgerufen.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Window.Show%2A> oder <xref:System.Windows.Window.ShowDialog%2A> aufgerufen werden, wird die Eigenschaft <xref:System.Windows.UIElement.Visibility%2A> einer <xref:System.Windows.Window> auf <xref:System.Windows.Visibility.Visible>festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.Activated" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnActivated%2A> wird das <xref:System.Windows.Window.Activated>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnActivated%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnActivated%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.Activated> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.Closed" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosed%2A> wird das <xref:System.Windows.Window.Closed>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnClosed%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnClosed%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.Closed> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.Closing" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnClosing%2A> wird das <xref:System.Windows.Window.Closing>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnClosing%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnClosing%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.Closing> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Ein Verweis auf den Stamm der alten Inhaltsstruktur.</param>
        <param name="newContent">Ein Verweis auf den Stamm der neuen Inhaltsstruktur.</param>
        <summary>Wird aufgerufen, wenn sich die <see cref="P:System.Windows.Controls.ContentControl.Content" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.ContentRendered" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnContentRendered%2A> wird das <xref:System.Windows.Window.ContentRendered>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnContentRendered%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnContentRendered%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.ContentRendered> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />-Objekt für dieses <see cref="T:System.Windows.Window" /> und gibt es zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />-Objekt für diesen <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.Deactivated" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnDeactivated%2A> wird das <xref:System.Windows.Window.Deactivated>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnDeactivated%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnDeactivated%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.Deactivated> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Die vorherige DPI-Größeneinstellung.</param>
        <param name="newDpi">Die neue DPI-Größeneinstellung.</param>
        <summary>Wird aufgerufen, wenn sich der DPI-Wert ändert, mit dem dieses Fenster gerendert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.LocationChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnLocationChanged%2A> wird das <xref:System.Windows.Window.LocationChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnLocationChanged%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnLocationChanged%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.LocationChanged> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn das <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />-Ereignis eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht den behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A>-Eigenschaft) der <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />überschreiben, müssen Sie immer die Basis Implementierung in ihrer <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />-Implementierung aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das-Ereignis behandeln, wodurch möglicherweise das Laufzeitverhalten der endgültigen Klasse geändert wird. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.SourceInitialized" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnSourceInitialized%2A> wird das <xref:System.Windows.Window.SourceInitialized>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnSourceInitialized%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnSourceInitialized%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.SourceInitialized> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Window.StateChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Windows.Window.OnStateChanged%2A> wird das <xref:System.Windows.Window.StateChanged>-Ereignis ausgelöst.  
  
 Ein Typ, der von <xref:System.Windows.Window> abgeleitet ist, kann <xref:System.Windows.Window.OnStateChanged%2A>außer Kraft setzen. Die überschriebene Methode muss <xref:System.Windows.Window.OnStateChanged%2A> für die Basisklasse aufzurufen, wenn <xref:System.Windows.Window.StateChanged> ausgelöst werden muss.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.8" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="visualAdded">Das der Auflistung hinzugefügte <see cref="T:System.Windows.Media.Visual" />-Objekt.</param>
        <param name="visualRemoved">Das aus der Auflistung entfernte <see cref="T:System.Windows.Media.Visual" />-Objekt.</param>
        <summary>Wird aufgerufen, wenn <see cref="T:System.Windows.Media.VisualCollection" /> für dieses <see cref="T:System.Windows.Window" />-Objekt geändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das bisherige übergeordnete Element. Wird auf NULL festgelegt, wenn das <see cref="T:System.Windows.DependencyObject" /> kein vorheriges übergeordnetes Element aufweist.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element des Fensters geändert wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Fenstern ab, deren Besitzer dieses Fenster ist.</summary>
        <value>Eine <see cref="T:System.Windows.WindowCollection" /> mit Verweisen auf die Fenster, deren Besitzer dieses Fenster ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein eigenes Fenster ist ein Fenster, dessen <xref:System.Windows.Window.Owner%2A>-Eigenschaft mit einem Verweis auf ein anderes Fenster festgelegt wird, das als Besitzer Fenster bezeichnet wird. Wenn Sie alle Fenster suchen möchten, die ein Besitzer Fenster besitzt, können Sie <xref:System.Windows.WindowCollection> auflisten, die von der <xref:System.Windows.Window.OwnedWindows%2A>-Eigenschaft zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie <xref:System.Windows.Window.OwnedWindows%2A>aufzählen können.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Window" /> ab, das dieses <see cref="T:System.Windows.Window" /> besitzt.</summary>
        <value>Ein <see cref="T:System.Windows.Window" />-Objekt, das den Besitzer dieses <see cref="T:System.Windows.Window" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein untergeordnetes Fenster durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>durch ein übergeordnetes Fenster geöffnet wird, wird zwischen dem übergeordneten und dem untergeordneten Fenster eine implizite Beziehung hergestellt. Diese Beziehung erzwingt bestimmte Verhalten, einschließlich der Minimierung, Maximierung und Wiederherstellung.  
  
 Wenn ein untergeordnetes Fenster durch Aufrufen von <xref:System.Windows.Window.Show%2A>von einem übergeordneten Fenster erstellt wird, verfügt das untergeordnete Fenster nicht über eine Beziehung mit dem übergeordneten Fenster. Dies bedeutet Folgendes:  
  
-   Das untergeordnete Fenster enthält keinen Verweis auf das übergeordnete Fenster.  
  
-   Das Verhalten des untergeordneten Fensters ist nicht vom Verhalten des übergeordneten Fensters abhängig. Beide Fenster können den anderen abdecken oder minimiert, maximiert und unabhängig voneinander wieder hergestellt werden.  
  
 Damit Sie eine Beziehung zwischen einem untergeordneten Fenster und einem übergeordneten Fenster erstellen können, <xref:System.Windows.Window> unterstützt das Konzept des Besitzes. Der Besitz wird hergestellt, wenn die <xref:System.Windows.Window.Owner%2A>-Eigenschaft eines Fensters (das im Besitz befindliche Fenster) mit einem Verweis auf ein anderes Fenster (das Besitzer Fenster) festgelegt wird.  
  
 Nachdem diese Beziehung hergestellt wurde, werden die folgenden Verhaltensweisen angezeigt:  
  
-   Wenn ein Besitzer Fenster minimiert wird, werden auch alle eigenen Fenster minimiert.  
  
-   Wenn ein eigenes Fenster minimiert wird, wird dessen Besitzer nicht minimiert.  
  
-   Wenn ein Besitzer Fenster maximiert ist, werden sowohl das Besitzer Fenster als auch seine eigenen Fenster wieder hergestellt.  
  
-   Ein Besitzer Fenster kann nie ein eigenes Fenster abdecken.  
  
-   Im Besitz befindliche Fenster, die nicht mit <xref:System.Windows.Window.ShowDialog%2A> geöffnet wurden, sind nicht modal. Der Benutzer kann weiterhin mit dem Besitzer Fenster interagieren.  
  
-   Wenn Sie ein Besitzer Fenster schließen, werden seine eigenen Fenster ebenfalls geschlossen.  
  
-   Wenn ein im Besitz befindlichen Fenster mithilfe <xref:System.Windows.Window.Show%2A>von seinem Besitzer Fenster geöffnet wurde und das Besitzer Fenster geschlossen wird, wird das <xref:System.Windows.Window.Closing> Ereignis des eigenen Fensters nicht ausgelöst.  
  
 Wenn Sie ein untergeordnetes Fenster öffnen, indem Sie <xref:System.Windows.Window.ShowDialog%2A>aufrufen, sollten Sie auch die <xref:System.Windows.Window.Owner%2A>-Eigenschaft des untergeordneten Fensters festlegen. Wenn Sie dies nicht tun, können Ihre Benutzer nicht sowohl das untergeordnete Fenster als auch das übergeordnete Fenster durch Drücken der Task leisten Schaltfläche wiederherstellen. Stattdessen wird durch Drücken der Task leisten Schaltfläche eine Liste der Fenster, einschließlich des untergeordneten Fensters und des übergeordneten Fensters, angezeigt, damit Sie ausgewählt werden können. nur das ausgewählte Fenster wird wieder hergestellt.  
  
> [!IMPORTANT]
>  Sie sollten auch die <xref:System.Windows.Window.Owner%2A>-Eigenschaft in einem geöffneten Fenster festlegen, indem Sie <xref:System.Windows.Window.ShowDialog%2A> aufrufen, um das korrekte Verhalten mit sicherzustellen.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Besitzer/eigene Beziehung hergestellt wird.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Fenster versucht, sich selbst zu besitzen  
  
 - oder -  
  
 Zwei Fenster versuchen, einander zu besitzen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Window.Owner" />-Eigenschaft wird für ein sichtbares Fenster festgelegt, das mit <see cref="M:System.Windows.Window.ShowDialog" /> angezeigt wird  
  
- oder - 
Die <see cref="P:System.Windows.Window.Owner" />-Eigenschaft wird für ein Fenster festgelegt, das bisher nicht angezeigt wurde.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zur Verwendung aller Windows-und Benutzereingabe Ereignisse ohne Einschränkung. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Größenänderungsmodus ab oder legt ihn fest.</summary>
        <value>Ein <see cref="T:System.Windows.ResizeMode" />-Wert, der den Größenänderungsmodus angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vier Optionen stehen zur Verfügung:  
  
-   **NORESIZE**. Der Benutzer kann die Größe des Fensters nicht ändern. Die Felder maximieren und minimieren werden nicht angezeigt.  
  
-   **Canmini mieren**. Der Benutzer kann das Fenster nur minimieren und über die Taskleiste wiederherstellen. Die Felder minimieren und maximieren werden angezeigt, es ist jedoch nur das Feld minimieren aktiviert.  
  
-   **CanResize**. Der Benutzer ist in der Lage, die Größe des Fensters zu ändern, indem er die Felder minimieren und maximieren und einen dragbaren Umriss um das Fenster enthält. Die Felder minimieren und maximieren werden angezeigt und aktiviert. (Standard).  
  
-   **Canresizewithziehpunkt**. Diese Option verfügt über die gleiche Funktionalität wie <xref:System.Windows.ResizeMode.CanResize>, aber fügt der unteren rechten Ecke des Fensters einen "Ziehpunkt für die Größenänderung" hinzu.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ResizeModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.ResizeMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe und Position eines Fensters vor dem Minimieren oder Maximieren ab.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" />, das die Größe und Position eines Fensters vor dem Minimieren oder Maximieren angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Wiederherstellungs Rechteck ist die Region, die vom Fenster belegt wird, bevor es minimiert oder maximiert wurde. Sie können <xref:System.Windows.Window.RestoreBounds%2A> verwenden, um die letzte Größe und Position eines Fensters vor dem Schließen einer Anwendung zu speichern und diese Werte abzurufen, wenn eine Anwendung das nächste Mal startet, um ein Fenster auf die Art und Weise wiederherzustellen, in der ein Benutzer das Fenster verlassen hat.  
  
 Wenn Sie <xref:System.Windows.Window.RestoreBounds%2A> Abfragen, bevor das Fenster angezeigt wird oder nachdem es geschlossen wurde, wird <xref:System.Windows.Rect.Empty%2A> zurückgegeben.  
  
> [!NOTE]
>  Diese Eigenschaft kann nicht angezeigt werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Window.RestoreBounds%2A> und isolierter Speicher verwendet, um sicherzustellen, dass die Größe und die Position eines Fensters identisch mit dem Zeitpunkt sind, an dem das Fenster angezeigt wurde.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">, wenn die Berechtigung zum Abfragen der Größe und Position des umgebenden Rechtecks eines Fensters angezeigt werden soll. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet ein Fenster und wird beendet, ohne auf das Schließen des neu geöffneten Fensters zu warten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Window>-Klasse instanziiert wird, ist Sie standardmäßig nicht sichtbar. <xref:System.Windows.Window.Show%2A> zeigt ein Fenster an und wird sofort zurückgegeben, ohne darauf zu warten, dass das Fenster geschlossen wird. Folglich verhindert das geöffnete Fenster nicht, dass Benutzer mit anderen Fenstern in der Anwendung interagieren. Dieser Fenstertyp wird als nicht *modalem Fenster bezeichnet* . Gängige Beispiele für nicht modante Fenster sind Eigenschaften Fenster, Symbol Felder und Paletten. Um einen Benutzer auf die Interaktion mit einem bestimmten Fenster zu beschränken, muss das Fenster durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>geöffnet werden.  
  
 Ein Fenster, das durch Aufrufen <xref:System.Windows.Window.Show%2A> geöffnet wird, verfügt nicht automatisch über eine Beziehung mit dem Fenster, das es geöffnet hat. insbesondere das geöffnete Fenster weiß nicht, welches Fenster es geöffnet hat. Diese Beziehung kann mit der <xref:System.Windows.Window.Owner%2A>-Eigenschaft hergestellt und mithilfe der <xref:System.Windows.Window.OwnedWindows%2A>-Eigenschaft verwaltet werden.  
  
 Durch das Aufrufen von <xref:System.Windows.Window.Show%2A> wird das gleiche Endergebnis erzielt wie das Festlegen <xref:System.Windows.UIElement.Visibility%2A>-Eigenschaft des <xref:System.Windows.Window>-Objekts auf <xref:System.Windows.Visibility.Visible>. Es gibt jedoch einen Unterschied zwischen den beiden aus der zeitlichen Steuerung.  
  
 Das Aufrufen von <xref:System.Windows.Window.Show%2A> ist ein synchroner Vorgang, der nur zurückgibt, nachdem das <xref:System.Windows.FrameworkElement.Loaded>-Ereignis im untergeordneten Fenster ausgelöst wurde:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Das Festlegen von <xref:System.Windows.UIElement.Visibility%2A>ist jedoch ein asynchroner Vorgang, der sofort zurückgegeben wird:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Wenn Sie <xref:System.Windows.UIElement.Visibility%2A>festlegen, werden alle Fenster Ereignisse, die Sie vor dem Festlegen von <xref:System.Windows.UIElement.Visibility%2A> registrieren, möglicherweise erst ausgelöst, nachdem die Methode, in der Sie festgelegt haben <xref:System.Windows.UIElement.Visibility%2A> die Ausführung abgeschlossen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein nicht modalem Fenster geöffnet wird.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.Show" /> wird für ein Fenster aufgerufen, das geschlossen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Fenster beim ersten Anzeigen aktiviert wird.</summary>
        <value><see langword="true" />, wenn ein Fenster beim ersten Anzeigen aktiviert wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Fenster geöffnet wird, dessen <xref:System.Windows.Window.ShowActivated%2A>-Eigenschaft auf `false` geöffnet ist, wird das Fenster nicht aktiviert, und das <xref:System.Windows.Window.Activated> Ereignis wird erst ausgelöst, wenn ein Benutzer das Fenster manuell aktiviert, indem es ausgewählt wird. Nachdem das Fenster ausgewählt wurde, wird es normal aktiviert und deaktiviert.  
  
 Um zu verhindern, dass ein Fenster beim Öffnen aktiviert wird, muss die <xref:System.Windows.Window.ShowActivated%2A>-Eigenschaft auf `false` festgelegt werden, bevor das Fenster angezeigt wird (durch Aufrufen von <xref:System.Windows.Window.Show%2A>). das Festlegen <xref:System.Windows.Window.ShowActivated%2A> auf `false`, nachdem ein Fenster angezeigt wird, hat keine Auswirkungen.  
  
 Das Festlegen von <xref:System.Windows.Window.ShowActivated%2A> auf `false` in einem Fenster, das durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>modale geöffnet wird, hat keine wirklichen Auswirkungen. Obwohl das modale Fenster nicht aktiviert wird, verhindert das modale Fenster, dass der Benutzer alle anderen geöffneten Anwendungsfenster aktiviert.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie mit Markup ein Fenster so konfigurieren, dass es geöffnet wird, ohne aktiviert zu werden.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Im folgenden Beispiel wird gezeigt, wie Sie mit Code ein Fenster so konfigurieren, dass es geöffnet wird, ohne dass es aktiviert wird.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.ShowActivated" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet ein Fenster und wird erst beendet, wenn das neu geöffnete Fenster geschlossen wird.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" />-Wert vom Typ <see cref="T:System.Boolean" /> gibt an, ob die Aktivität bestätigt (<see langword="true" />) oder abgebrochen (<see langword="false" />) wurde. Der Rückgabewert ist der Wert der <see cref="P:System.Windows.Window.DialogResult" />-Eigenschaft, bevor ein Fenster geschlossen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Window> Klasse instanziiert wird, ist Sie standardmäßig nicht sichtbar. <xref:System.Windows.Window.ShowDialog%2A> das Fenster anzeigt, deaktiviert alle anderen Fenster in der Anwendung und gibt nur dann zurück, wenn das Fenster geschlossen wird. Dieser Fenstertyp wird als *modales* Fenster bezeichnet.  
  
 Modale Fenster werden hauptsächlich als Dialogfelder verwendet. Ein Dialogfeld ist ein spezieller Fenstertyp, der von Anwendungen zum interagieren mit Benutzern verwendet wird, um Aufgaben auszuführen, z. b. das Öffnen von Dateien oder das Drucken von Dokumenten. In Dialog Feldern können Benutzer die Aufgabe, für die Sie angezeigt wurden, annehmen oder Abbrechen, bevor das Dialogfeld geschlossen wird. <xref:System.Windows.Window.ShowDialog%2A> gibt einen <xref:System.Nullable%601><xref:System.Boolean>-Wert zurück, der angibt, ob die Aktivität akzeptiert oder abgebrochen wurde. Der Rückgabewert ist der Wert der <xref:System.Windows.Window.DialogResult%2A>-Eigenschaft, bevor ein Fenster geschlossen wird. Weitere Informationen finden Sie unter <xref:System.Windows.Window.DialogResult%2A>.  
  
 Ein Fenster, das durch Aufrufen der <xref:System.Windows.Window.ShowDialog%2A>-Methode geöffnet wird, verfügt nicht automatisch über eine Beziehung mit dem Fenster, das es geöffnet hat. insbesondere das geöffnete Fenster weiß nicht, welches Fenster es geöffnet hat. Diese Beziehung kann mit der <xref:System.Windows.Window.Owner%2A>-Eigenschaft hergestellt und mithilfe der <xref:System.Windows.Window.OwnedWindows%2A>-Eigenschaft verwaltet werden. Zur Unterstützung [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Automation (siehe [Übersicht über die Benutzeroberflächen Automatisierung](~/docs/framework/ui-automation/ui-automation-overview.md)) müssen <xref:System.Windows.Window.Owner%2A> für ein Fenster festgelegt werden, das durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>geöffnet wird.  
  
 Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster (ein Fenster, das durch Aufrufen von <xref:System.Windows.Window.ShowDialog%2A>geöffnet wird) geschlossen wird, wird das zuvor aktivierte Fenster erneut aktiviert. Wenn ein modales [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster ein Besitzer Fenster hat (siehe <xref:System.Windows.Window.Owner%2A>), wird das Besitzer Fenster nicht erneut aktiviert, wenn das modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Fenster geschlossen wird, es sei denn, es handelt sich um das zuvor aktivierte Fenster.  
  
> [!NOTE]
>  Diese Methode kann nicht aufgerufen werden, wenn ein Fenster in einem Browser gehostet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein modales Fenster geöffnet wird.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.ShowDialog" /> wird für ein Fenster aufgerufen, das geschlossen wird (<see cref="E:System.Windows.Window.Closing" />) oder geschlossen wurde (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für die Berechtigung zum Aktivieren eines Fensters. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Fenster über eine Taskleistenschaltfläche verfügt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Fenster über eine Taskleistenschaltfläche verfügt, andernfalls <see langword="false" />. Wird nicht angewendet, wenn das Fenster in einem Browser gehostet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.ShowInTaskbar%2A> auf `true`festgelegt ist, wird das Fenster auch in der Anwendungs Auswahlliste Alt + Tab angezeigt.  
  
 Das Symbol, das sowohl für die Task leisten Schaltfläche als auch für die Anwendungs Auswahlliste Alt + Tab verwendet wird, ist der Wert der <xref:System.Windows.Window.Icon%2A>-Eigenschaft.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.ShowInTaskbar" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab (bzw. legt diesen fest), der angibt, ob ein Fenster seine Größe automatisch an die Größe seines Inhalts anpasst.</summary>
        <value>Ein <see cref="T:System.Windows.SizeToContent" />-Wert. Der Standardwert ist <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> auf <xref:System.Windows.SizeToContent.WidthAndHeight>festgelegt ist, hat das Festlegen von <xref:System.Windows.FrameworkElement.Height%2A> oder <xref:System.Windows.FrameworkElement.Width%2A> keine Auswirkung; beide Eigenschaften können festgelegt werden, aber die Werte, mit denen Sie festgelegt werden, werden nicht auf das Fenster angewendet.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> auf <xref:System.Windows.SizeToContent.Height>festgelegt ist, wird durch das Festlegen von <xref:System.Windows.FrameworkElement.Height%2A> die Höhe des Fensters nicht geändert.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> auf <xref:System.Windows.SizeToContent.Width>festgelegt ist, wird durch das Festlegen von <xref:System.Windows.FrameworkElement.Width%2A> nicht die Breite des Fensters geändert.  
  
 Wenn <xref:System.Windows.Window.SizeToContent%2A> einen anderen Wert als <xref:System.Windows.SizeToContent.Manual>hat:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> wird automatisch auf <xref:System.Windows.SizeToContent.Manual> festgelegt, wenn ein Benutzer die Größe des Fensters ändert, indem er den Zieh Punkt für die Größenänderung verwendet oder den Rahmen zieht.  
  
-   Wenn sich die Größe des Inhalts auf eine Weise ändert, die bewirkt, dass die Größe des Fensters geändert wird, wird <xref:System.Windows.FrameworkElement.SizeChanged> ausgelöst.  
  
 Wenn ein Fenster transparent ist (siehe <xref:System.Windows.Window.AllowsTransparency%2A>), sollten Sie die Festlegung von <xref:System.Windows.Window.SizeToContent%2A> auf <xref:System.Windows.SizeToContent.WidthAndHeight> in Erwägung gezogen, um sicherzustellen, dass das Fenster nicht größer als der sichtbare Inhalt ist.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.SizeToContentProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Window.SizeToContent%2A>-Eigenschaft im Code festgelegt wird, um anzugeben, wie die Größe eines Fensters an seinen Inhalt angepasst wird.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.SizeToContent" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Ereignis wird ausgelöst, um die Interoperation mit [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] zu unterstützen. Siehe <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Window.WindowState" />-Eigenschaft des Fensters geändert wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die [!INCLUDE[win7](~/includes/win7-md.md)]-Taskleistenminiaturansicht für <see cref="T:System.Windows.Window" /> ab oder legt diese fest.</summary>
        <value>Die [!INCLUDE[win7](~/includes/win7-md.md)]-Taskleistenminiaturansicht für <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Verwendung der [!INCLUDE[win7](~/includes/win7-md.md)]-Task leisten Miniaturansicht finden Sie in der <xref:System.Windows.Shell.TaskbarItemInfo>-Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.TaskbarItemInfo" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Titel eines Fensters ab bzw. legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />, der den Titel des Fensters enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Titel einer <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>oder [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]kann auch mit <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>festgelegt werden.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TitleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.Title" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des oberen Fensterrands im Verhältnis zum Desktop ab oder legt diese fest.</summary>
        <value>Die Position des oberen Fensterrands in logischen Einheiten (1/96 ").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Window> maximiert oder minimiert ist, stellt dieser Wert den oberen Rand des Wiederherstellungs Punkts für die <xref:System.Windows.Window>dar.  
  
 Diese Eigenschaft kann nicht über einen Stil festgelegt werden.  
  
 Wenn Sie keinen Wert angeben, wird <xref:System.Windows.Window.Top%2A> auf den Standardwert des Systems festgelegt. Sie können den Standardwert des Systems auch angeben, indem Sie <xref:System.Windows.Window.Top%2A> auf <xref:System.Double.NaN>festlegen. Weder <xref:System.Double.NegativeInfinity> noch <xref:System.Double.PositiveInfinity> ist ein gültiger Wert für <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TopProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Fenster in der z-Reihenfolge zuoberst angezeigt wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn es sich um das oberste Fenster handelt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fenster, dessen <xref:System.Windows.Window.Topmost%2A>-Eigenschaft auf `true` festgelegt ist, wird über allen Fenstern angezeigt, deren <xref:System.Windows.Window.Topmost%2A>-Eigenschaften auf `false`festgelegt sind.  
  
 In der Windows-Gruppe, für die <xref:System.Windows.Window.Topmost%2A>-Eigenschaft auf `true`festgelegt ist, ist das aktuell aktivierte Fenster das oberste Fenster. Gleiches gilt für die Windows-Gruppe, für die <xref:System.Windows.Window.Topmost%2A>-Eigenschaft auf `false`festgelegt ist.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.TopmostProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.Topmost" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.Top" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Fensters beim ersten Anzeigen ab bzw. legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStartupLocation" />-Wert, der die Position links oben für ein Fenster beim ersten Anzeigen angibt. Der Standardwert ist <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die `WindowStartupLocation`-Eigenschaft auf <xref:System.Windows.WindowStartupLocation.Manual> festlegen, wird ein Fenster entsprechend seiner <xref:System.Windows.Window.Left%2A> und <xref:System.Windows.Window.Top%2A> Eigenschaftswerte positioniert. Wenn die Eigenschaften <xref:System.Windows.Window.Left%2A> oder <xref:System.Windows.Window.Top%2A> nicht angegeben sind, werden ihre Werte von Windows bestimmt.  
  
 Wenn Sie die `WindowStartupLocation`-Eigenschaft auf <xref:System.Windows.WindowStartupLocation.CenterScreen> festlegen, wird ein Fenster in der Mitte des Bildschirms positioniert, der den Maus Cursor enthält.  
  
 Wenn Sie die `WindowStartupLocation`-Eigenschaft auf <xref:System.Windows.WindowStartupLocation.CenterOwner> festlegen, wird ein Fenster in der Mitte des Besitzer Fensters positioniert (siehe <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>), falls angegeben. Das Besitzer Fenster kann entweder ein anderes WPF-Fenster oder ein nicht-WPF-Fenster sein.

> [!NOTE]   
>  Weitere Informationen zu WPF-Fenstern mit nicht-WPF-Fenstern finden Sie unter Interoperation und <xref:System.Windows.Interop.WindowInteropHelper>von [WPF und Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) . 

 Wenn kein Besitzer Fenster angegeben ist, wird die Position des Fensters auf die gleiche Weise bestimmt, als ob die `WindowStartupLocation`-Eigenschaft auf <xref:System.Windows.WindowStartupLocation.Manual>festgelegt ist.

> [!NOTE]
>  Der Wert dieser Eigenschaft kann nicht festgelegt oder nicht festgelegt werden, wenn ein Fenster in einem Browser gehostet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Fenster wiederhergestellt, minimiert oder maximiert ist, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.WindowState" />, der bestimmt, ob ein Fenster wiederhergestellt, minimiert oder maximiert ist. Der Standardwert ist <see cref="F:System.Windows.WindowState.Normal" /> (wiederhergestellt).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem minimieren oder maximieren eines Fensters werden seine Größe und Position in <xref:System.Windows.Window.RestoreBounds%2A>gespeichert. Wenn ein Fenster anschließend wieder hergestellt wird, werden die Werte für Größe und Speicherort mit den Werten aus <xref:System.Windows.Window.RestoreBounds%2A>wieder hergestellt.  
  
 Wenn die <xref:System.Windows.Window.WindowState%2A>-Eigenschaft geändert wird, wird <xref:System.Windows.Window.StateChanged> ausgelöst.  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.WindowStateProperty>|  
|Metadateneigenschaften auf `true` festgelegt|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.WindowState" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Rahmenart eines Fensters ab bzw. legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.WindowStyle" />, der die Rahmenart eines Fensters angibt. Der Standardwert ist <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> kann einer der <xref:System.Windows.WindowStyle> Enumerationswerte sein, einschließlich <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (Standard) und <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 Die folgende Abbildung zeigt die Fenster Stile auf [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero-Design mit aktiviertem transparentem Glas):  
  
 ![Fenster Stile](~/add/media/windowoverviewfigure6.PNG "Fensterstile")  
  
> [!NOTE]
>  Sie können diese Eigenschaft nicht festlegen oder erhalten, wenn ein Fenster in einem Browser gehostet wird.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Window.WindowStyleProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Window.WindowStyle" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
