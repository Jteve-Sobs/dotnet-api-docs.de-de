<Type Name="ComponentResourceKey" FullName="System.Windows.ComponentResourceKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="171026b625ffffdcdcbaf1c1d4f61e45fe231c82" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83968535" /></Metadata><TypeSignature Language="C#" Value="public class ComponentResourceKey : System.Windows.ResourceKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ComponentResourceKey extends System.Windows.ResourceKey" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ComponentResourceKey" />
  <TypeSignature Language="VB.NET" Value="Public Class ComponentResourceKey&#xA;Inherits ResourceKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class ComponentResourceKey : System::Windows::ResourceKey" />
  <TypeSignature Language="F#" Value="type ComponentResourceKey = class&#xA;    inherit ResourceKey" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ResourceKey</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Markup.ComponentResourceKeyConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert oder verweist auf Ressourcenschlüssel basierend auf Klassennamen in externen Assemblys und einem zusätzlichen Bezeichner.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Informationen finden Sie unter [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension).  
  
 Diese Klasse implementiert einen Objekttyp, der zum Erstellen von Schlüsseln nützlich ist, die auf Typen in Assemblys und einem Bezeichner basieren. Da Sie den Typ definieren oder referenzieren, müssen Sie keine bestimmte <xref:System.Windows.ResourceDictionary>anfordern, und in der Assembly können mehrere Ressourcen Sätze vorhanden sein, die jeweils durch den Typ ihrer <xref:System.Windows.ComponentResourceKey>unterschieden werden.  
  
 Es gibt zwei Möglichkeiten, eine <xref:System.Windows.ComponentResourceKey>zu definieren.  
  
 Wenn Sie einen leicht zugänglichen Schlüssel benötigen, können Sie eine statische Eigenschaft im Code der Steuerelement Klasse definieren, die eine <xref:System.Windows.ComponentResourceKey>zurückgibt, die mit einer <xref:System.Windows.ComponentResourceKey.TypeInTargetAssembly%2A> erstellt wurde, die in der externen Ressourcenassembly vorhanden ist, und eine <xref:System.Windows.ComponentResourceKey.ResourceId%2A>. Der Schlüssel kann zum Definieren alternativer Standard Stile für Steuerelemente in einer Assembly verwendet werden, indem die ursprüngliche externe Ressourcenassembly für eine benutzerdefinierte Assembly ausgetauscht wird. Sie können auch einen benannten Ressourcen Teil innerhalb eines größeren Steuerelement Stils oder einer Vorlage definieren, um einen Einstiegspunkt für die Anpassung verfügbar zu machen. Dies ist besonders nützlich, wenn Sie ein Design Ressourcen Wörterbuch für das Steuerelement definieren.  
  
 Sie können auch die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension) in ausführliche-Syntax direkt verwenden, um eine lose Instanz des Schlüssels zu erstellen. Dies ist hilfreich, wenn Sie private Ressourcen aus anderen Assemblys deklarieren möchten, die für eine Anpassung weniger auffindbar sind.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Windows.ComponentResourceKey" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ComponentResourceKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ComponentResourceKey.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ComponentResourceKey();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Windows.ComponentResourceKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Parameter lose Konstruktor wird in der Regel nicht verwendet, weil ein <xref:System.Windows.ComponentResourceKey.TypeInTargetAssembly%2A> Wert und <xref:System.Windows.ComponentResourceKey.ResourceId%2A> Wert für die ordnungsgemäße Initialisierung erforderlich sind. Der Parameter lose Konstruktor ist hauptsächlich zur Unterstützung der XAML-Verwendung der [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension) in einem benannten Parameter Formular vorhanden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ComponentResourceKey (Type typeInTargetAssembly, object resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type typeInTargetAssembly, object resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ComponentResourceKey.#ctor(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (typeInTargetAssembly As Type, resourceId As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ComponentResourceKey(Type ^ typeInTargetAssembly, System::Object ^ resourceId);" />
      <MemberSignature Language="F#" Value="new System.Windows.ComponentResourceKey : Type * obj -&gt; System.Windows.ComponentResourceKey" Usage="new System.Windows.ComponentResourceKey (typeInTargetAssembly, resourceId)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeInTargetAssembly" Type="System.Type" />
        <Parameter Name="resourceId" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="typeInTargetAssembly">Der Typ, der den Ressourcenschlüssel definiert.</param>
        <param name="resourceId">Ein eindeutiger Bezeichner, mit dem dieser <see cref="T:System.Windows.ComponentResourceKey" /> von anderen dem <paramref name="typeInTargetAssembly" />-Typ zugeordneten Schlüsseln unterschieden wird.</param>
        <summary>Initialisiert eine neue Instanz eines <see cref="T:System.Windows.ComponentResourceKey" /> und gibt den <see cref="T:System.Type" /> an, durch den der Schlüssel definiert wird, sowie ein Objekt, das als zusätzlicher Ressourcenbezeichner verwendet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist für zwei Szenarien vorhanden, wobei das erste Szenario das wichtigste ist:  
  
-   Unterstützt das Erstellen einer <xref:System.Windows.ComponentResourceKey>, die dann als öffentliches statisches Feld in einer benutzerdefinierten Steuerelement Klasse verfügbar gemacht wird. Dies vereinfacht den Zugriff eines Steuer Elements auf seine eigenen definierten Ressourcen in der Vorlage, indem `{x:Static}` Verwendungen für Vorlagen Eigenschaftswerte genutzt werden.  
  
-   Unterstützt die XAML-Verwendung der [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension) in einem Positions Parameter Formular, bei dem es sich um eine Technik handelt, die für Dritte verfügbar ist, die auf eine Komponenten Ressource  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.ComponentResourceKey> erstellt, die dann als statischer Schlüssel einer Steuerelement Klasse verfügbar gemacht wird, um einen Einstiegspunkt für die Stil Anpassung bereitzustellen.  
  
 [!code-csharp[CorePseudocode#CRKCode](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#crkcode)]
 [!code-vb[CorePseudocode#CRKCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#crkcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ComponentResourceKey.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Windows.ComponentResourceKey.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Assemblyobjekt ab, das angibt, im Wörterbuch welcher Assembly nach dem Wert gesucht werden soll, der diesem Schlüssel zugeordnet ist.</summary>
        <value>Die abgerufene Assembly als Reflektionsklasse.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ComponentResourceKey.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="componentResourceKey.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das mit dem aktuellen <see cref="T:System.Windows.ComponentResourceKey" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt dem aktuellen <see cref="T:System.Windows.ComponentResourceKey" /> entspricht.</summary>
        <returns><see langword="true" />, wenn die Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Schlüssel sind gleich, wenn beide dieselben Werte für alle ihre unmittelbaren festleg baren Eigenschaften haben (<xref:System.Windows.ComponentResourceKey.ResourceId%2A><xref:System.Windows.ComponentResourceKey.TypeInTargetAssembly%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ComponentResourceKey.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="componentResourceKey.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für diese <see cref="T:System.Windows.ComponentResourceKey" /> zurück.</summary>
        <returns>Ein 32-Bit-Ganzzahlwert mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceId">
      <MemberSignature Language="C#" Value="public object ResourceId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ResourceId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ComponentResourceKey.ResourceId" />
      <MemberSignature Language="VB.NET" Value="Public Property ResourceId As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ResourceId { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceId : obj with get, set" Usage="System.Windows.ComponentResourceKey.ResourceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner ab, um diesen Schlüssel von anderen diesem Typ zugeordneten Schlüsseln zu unterscheiden, oder legt diesen fest.</summary>
        <value>Einen eindeutigen Bezeichner. Dies ist i. d. R. eine Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Informationen finden Sie unter [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension).  
  
 In der Regel entspricht die Zeichenfolge, die für einen <xref:System.Windows.ComponentResourceKey.ResourceId%2A> Wert verwendet wird, der [XamlName-Grammatik](/dotnet/framework/xaml-services/xamlname-grammar).  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.ComponentResourceKey.ResourceId%2A> verwendet wird, um diesen Schlüssel von anderen zu unterscheiden, die diesem Typ zugeordnet sind.  
  
 [!code-xaml[ColorPicker_snip#SliderStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_snip/CSharp/ColorPickerLib/Themes/generic.xaml#sliderstyle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ComponentResourceKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="componentResourceKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Zeichenfolgendarstellung eines <see cref="T:System.Windows.ComponentResourceKey" /> ab.</summary>
        <returns>Die Zeichenfolgendarstellung.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeInTargetAssembly">
      <MemberSignature Language="C#" Value="public Type TypeInTargetAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TypeInTargetAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ComponentResourceKey.TypeInTargetAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeInTargetAssembly As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ TypeInTargetAssembly { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TypeInTargetAssembly : Type with get, set" Usage="System.Windows.ComponentResourceKey.TypeInTargetAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Type" /> ab, der den Ressourcenschlüssel definiert, oder legt diesen fest.</summary>
        <value>Der Typ, der den Ressourcenschlüssel definiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Informationen finden Sie unter [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension).  
  
 Das <xref:System.Windows.ComponentResourceKey>-Element wird von benutzerdefinierten Komponenten verwendet, um Schlüssel für Ressourcen zu definieren, auf die von externen Assemblys aus zugegriffen wird. Dies basiert auf einer Assembly, die den Typ enthält. Benutzerdefinierte Komponenten definieren häufig neue Typen, die sich in der Assembly befinden müssen, in der sich die Ressource befindet. Im Allgemeinen haben diese Typen keine andere Implementierung, die Typen sind nur vorhanden, um die Suchanforderungen einer <xref:System.Windows.ComponentResourceKey>zu erfüllen.  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Windows.ComponentResourceKey> mit <xref:System.Windows.ComponentResourceKey.TypeInTargetAssembly%2A> und <xref:System.Windows.ComponentResourceKey.ResourceId%2A> mithilfe der [ComponentResourceKey-Markup Erweiterung](/dotnet/framework/wpf/advanced/componentresourcekey-markup-extension)definiert wird. Diese Ressource kann dann in eine externe Assembly eingefügt werden, und der Zugriff darauf erfolgt über eine Schlüssel Verwendung, die die Ressource mithilfe eines Analog <xref:System.Windows.ComponentResourceKey> in der Anforderung anfordert.  
  
 [!code-xaml[ColorPicker_snip#SliderStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_snip/CSharp/ColorPickerLib/Themes/generic.xaml#sliderstyle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
