<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c54b9a8339beb8390ea1f85cf455b976681eff53" /><Meta Name="ms.sourcegitcommit" Value="83d757eaee63e682417f41094d711281691d9aba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/10/2020" /><Meta Name="ms.locfileid" Value="78956458" /></Metadata><TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <TypeSignature Language="F#" Value="type RouteCollection = class&#xA;    inherit Collection&lt;RouteBase&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Routing</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Web.Routing" FromVersion="4.0.0.0" To="System.Web" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Auflistung von Routen für das ASP.NET-Routing bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Web.Routing.RouteCollection>-Klasse stellt Methoden bereit, die es Ihnen ermöglichen, eine Auflistung von Objekten zu verwalten, die von der <xref:System.Web.Routing.RouteBase>-Klasse abgeleitet werden.

 In der Regel verwenden Sie die `static`<xref:System.Web.Routing.RouteTable.Routes%2A>-Eigenschaft der <xref:System.Web.Routing.RouteTable>-Klasse, um ein <xref:System.Web.Routing.RouteCollection> Objekt abzurufen. Die <xref:System.Web.Routing.RouteTable.Routes%2A>-Eigenschaft speichert alle Routen für eine ASP.NET-Anwendung. ASP.NET Routing durchläuft die Routen in der <xref:System.Web.Routing.RouteTable.Routes%2A>-Eigenschaft, um die Route zu suchen, die mit einer URL übereinstimmt.

 Zum Erstellen einer URL wird die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A>-Methode aufgerufen und eine Auflistung von Werten übergeben. Die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A>-Methode sucht die erste Route mit Parametern, die mit den übergebenen Werten übereinstimmen, und gibt ein <xref:System.Web.Routing.VirtualPathData> Objekt zurück, das Informationen über die übereinstimmende Route enthält. Sie rufen die URL über die <xref:System.Web.Routing.VirtualPathData.VirtualPath%2A>-Eigenschaft des <xref:System.Web.Routing.VirtualPathData>-Objekts ab.

 Sie können eine Route entweder mit einem Namen oder ohne Namen hinzufügen. Durch Einschließen eines Namens können Sie beim Konstruieren von URLs zwischen ähnlichen Routen unterscheiden. Wenn Sie keinen Namen angeben, wird die erste übereinstimmende Route in der Auflistung von ASP.NET Routing verwendet, um eine URL zu erstellen.

 Wenn Sie dem <xref:System.Web.Routing.RouteCollection> Objekt eine unbenannte Route hinzufügen, können Sie keine Route hinzufügen, die bereits in der Auflistung vorhanden ist. Wenn Sie eine benannte Route hinzufügen, können Sie keinen Namen verwenden, der bereits eine Route in der Auflistung identifiziert.

 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.

 Weitere Informationen zum Hinzufügen einer Route zu einer Routen Sammlung finden Sie unter [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)).

 ]]></format>
    </remarks>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.Routing.RouteCollection" />-Klasse.</summary>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.Routing.RouteCollection" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (virtualPathProvider As VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberSignature Language="F#" Value="new System.Web.Routing.RouteCollection : System.Web.Hosting.VirtualPathProvider -&gt; System.Web.Routing.RouteCollection" Usage="new System.Web.Routing.RouteCollection virtualPathProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">Ein Anbieter zum Abrufen von Ressourcen aus einem virtuellen Dateisystem.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.Routing.RouteCollection" />-Klasse mit dem angegebenen Anbieter des virtuellen Pfads.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.Add : string * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.Add (name, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">Der Wert, der die Route identifiziert. Der Wert kann <see langword="null" /> oder eine leere Zeichenfolge sein.</param>
        <param name="item">Die Route, die am Ende der Auflistung hinzugefügt werden soll.</param>
        <summary>Fügt am Ende des <see cref="T:System.Web.Routing.RouteCollection" />-Objekts eine Route hinzu und weist dieser den angegebenen Namen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Mit der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode können Sie einen Namen für eine Route definieren, wenn Sie Sie der Routen Auflistung hinzufügen. Wenn Sie einen Namen für die Route definieren, können Sie eine bestimmte Route angeben, die verwendet werden soll, wenn Sie Routing verwenden, um eine URL zu erstellen. Die Angabe einer bestimmten Route ist wichtig, wenn mehr als eine Route mit den Werten übereinstimmt, die Sie an die <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> Methode übergeben. Wenn Sie keine benannte Route angeben, verwendet ASP.NET Routing die erste Route in der Auflistung, die mit den Werten übereinstimmt. Weitere Informationen finden Sie unter Gewusst [wie: Erstellen von URLs aus Routen](https://docs.microsoft.com/previous-versions/aspnet/cc668176(v=vs.100)).

 Ein Name kann nur einmal im <xref:System.Web.Routing.RouteCollection> Objekt verwendet werden.

 Wenn Sie keinen Namen für die Route angeben müssen, können Sie die Route hinzufügen, indem Sie die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-Methode aufrufen.

 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der-Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Route zu einem <xref:System.Web.Routing.RouteCollection> Objekt hinzugefügt und der Route ein Name zugewiesen wird.

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> wird bereits in der Auflistung verwendet.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AppendTrailingSlash : bool with get, set" Usage="System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob nachgestellte Schrägstriche hinzugefügt werden, wenn virtuelle Pfade normalisiert wurden.</summary>
        <value><see langword="true" />, wenn nachfolgende Schrägstriche hinzugefügt werden; andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="routeCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus dem <see cref="T:System.Web.Routing.RouteCollection" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der-Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberSignature Language="F#" Value="member this.GetReadLock : unit -&gt; IDisposable" Usage="routeCollection.GetReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt ein Objekt zur Verwaltung der Threadsicherheit bereit, wenn Sie ein Objekt aus der Auflistung abrufen.</summary>
        <returns>Ein Objekt, das die Threadsicherheit verwaltet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Web.Routing.RouteCollection>-Objekt ist für mehrere Prozesse in der Anwendung verfügbar. Wenn Sie also eine Route abrufen müssen, während die Anwendung ausgeführt wird, verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode, um die Thread Sicherheit zu gewährleisten. Wenn Sie eine Lesesperre für die Routen Sammlung erhalten, stellen Sie sicher, dass die Sammlung nicht geändert wird, während Sie versuchen, Sie abzurufen.

 Durch die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode wird verhindert, dass der Thread fortgesetzt wird, bis die Sperre abgerufen werden kann. Wenn eine Schreibsperre vorhanden ist, wartet der Thread, bis das Update abgeschlossen und die Schreibsperre aufgehoben wurde. Die Lesesperre für die Routen Auflistung wird freigegeben, wenn das <xref:System.IDisposable> Objekt, das von dieser Methode zurückgegeben wird, verworfen wird.

 Wenn Sie <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>nicht verwenden, erhalten Sie möglicherweise eine Fehlermeldung, wenn Sie die <xref:System.Web.Routing.RouteCollection> Auflistung lesen. Nehmen Sie beispielsweise an, Sie durchlaufen die Objekte in der <xref:System.Web.Routing.RouteCollection>-Auflistung, um Sie zu lesen, ohne <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>aufzurufenden. Während Sie dies tun, kann ein anderer Thread aus einer anderen Anforderung <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> aufzurufen und der Auflistung eine Route hinzufügen. Der erste Thread schlägt dann mit einem Fehler fehl.

 Es gibt zwei Szenarien, in denen Sie <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>nicht anrufen müssen:

-   Öffentliche Methoden der <xref:System.Web.Routing.RouteCollection>-Klasse, z. b. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> und <xref:System.Web.Routing.RouteCollection.GetRouteData%2A> den internen Rückruf <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>. Daher müssen Sie <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> nicht explizit aufrufen, wenn Sie eine öffentliche Methode der <xref:System.Web.Routing.RouteCollection>-Klasse aufrufen, um Daten aus der Auflistung abzurufen.

-   Wenn die Anwendung gestartet wird und noch keine Anforderungen verarbeitet, wie z. b. im `Application_Start` Ereignishandler, wird nur ein Thread ausgeführt. Da keine anderen Threads vorhanden sind, die die Sammlung während des Lesens aktualisieren, müssen Sie <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>nicht aufzurufen.



## Examples
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode verwenden, wenn Sie eine Route abrufen, während die Anwendung ausgeführt wird. Durch die `Using`-Anweisung wird sichergestellt, dass die Sperre am Ende des `Using` Codeblocks sicher freigegeben wird, unabhängig davon, was zur Laufzeit geschieht, wenn Sie aus der Auflistung lesen (ob der Code normal abgeschlossen oder eine Ausnahme ausgelöst wird).



 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberSignature Language="F#" Value="member this.GetRouteData : System.Web.HttpContextBase -&gt; System.Web.Routing.RouteData" Usage="routeCollection.GetRouteData httpContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">Ein Objekt, das Informationen zur HTTP-Anforderung kapselt.</param>
        <summary>Gibt Informationen über die Route in der Auflistung zurück, die den angegebenen Werten entspricht.</summary>
        <returns>Ein Objekt, das die Werte aus der Routendefinition enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="context" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Web.HttpContextBase.Request" />-Eigenschaft des Objekts im <paramref name="context" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt Informationen zum URL-Pfad zurück, der der Route zugeordnet ist.</summary>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetVirtualPath (requestContext As RequestContext, values As RouteValueDictionary) As VirtualPathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Ein Objekt, das Informationen zu der angeforderten Route kapselt.</param>
        <param name="values">Ein Objekt, das die Parameter für eine Route enthält.</param>
        <summary>Gibt Informationen zum URL-Pfad, der der Route zugeordnet ist, anhand des angegebenen Kontexts und der Parameterwerte zurück.</summary>
        <returns>Ein Objekt, das Informationen zum URL-Pfad enthält, der der Route zugeordnet ist.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetVirtualPath (requestContext As RequestContext, name As String, values As RouteValueDictionary) As VirtualPathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * string * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, name, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Ein Objekt, das Informationen zu der angeforderten Route kapselt.</param>
        <param name="name">Der Name der Route, die zum Abrufen von Informationen zum URL-Pfad verwendet wird.</param>
        <param name="values">Ein Objekt, das die Parameter für eine Route enthält.</param>
        <summary>Gibt Informationen zum URL-Pfad zurück, der der benannten Route zugeordnet ist, anhand des angegebenen Kontexts, der Routennamens und der Parameterwerte.</summary>
        <returns>Ein Objekt, das Informationen zum URL-Pfad enthält, der der Route zugeordnet ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Es wurde keine Route mit dem Namen gefunden, der im <paramref name="name" />-Parameter angegeben ist.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberSignature Language="F#" Value="member this.GetWriteLock : unit -&gt; IDisposable" Usage="routeCollection.GetWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt ein Objekt zur Verwaltung der Threadsicherheit bereit, wenn Sie Elemente zur Auflistung hinzufügen oder aus dieser entfernen.</summary>
        <returns>Ein Objekt, das die Threadsicherheit verwaltet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die empfohlene Vorgehensweise zum Definieren von Routen in einer ASP.NET-Anwendung besteht darin, die Routen der <xref:System.Web.Routing.RouteTable.Routes%2A>-Eigenschaft in einem Ereignishandler für das `Application_Start`-Ereignis in der Datei "Global. asax" hinzuzufügen. Weitere Informationen finden Sie unter <xref:System.Web.Routing.RouteCollection>.

 Wenn Sie eine Route hinzufügen müssen, während die Anwendung ausgeführt wird, verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um die Thread Sicherheit zu gewährleisten. Die Schreibsperre für die Routen Sammlung wird aufgehoben, wenn das <xref:System.IDisposable> Objekt, das von dieser Methode zurückgegeben wird, verworfen wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode verwenden, wenn Sie eine Route hinzufügen, während die Anwendung ausgeführt wird.



 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert ein URL-Muster, das nicht mit Routen für Übereinstimmungen verglichen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode erstellt eine Route, die dem <xref:System.Web.Routing.StopRoutingHandler>-Routen Handler zugeordnet ist. Nachdem Sie diese Methode aufgerufen haben, werden Anforderungen, die dem angegebenen URL-Muster entsprechen, nicht als Routen Anforderungen verarbeitet.

 ASP.NET Routing ignoriert automatisch Anforderungen, wenn die URL mit einer physischen Datei übereinstimmt, z. b. mit einer Bilddatei. In einigen Fällen möchten Sie möglicherweise auch Routing zum Ignorieren von Anforderungen, wenn keine physische Datei vorhanden ist. Beispielsweise sollten die Anforderungen, die ASP.NET automatisch für AXD-Dateien erstellt, nicht als Routen Anforderungen behandelt werden, auch wenn keine physische Datei vorhanden ist, die der Dateinamenerweiterung ". axd" entspricht.

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string -&gt; unit" Usage="routeCollection.Ignore url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Das zu ignorierende URL-Muster.</param>
        <summary>Definiert ein URL-Muster, das nicht mit Routen für Übereinstimmungen verglichen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode erstellt eine Route, die dem <xref:System.Web.Routing.StopRoutingHandler>-Routen Handler zugeordnet ist. Nachdem Sie diese Methode aufgerufen haben, werden Anforderungen, die dem angegebenen URL-Muster entsprechen, nicht als Routen Anforderungen verarbeitet.

 ASP.NET Routing ignoriert automatisch Anforderungen, wenn die URL mit einer physischen Datei übereinstimmt, z. b. mit einer Bilddatei. In einigen Fällen möchten Sie möglicherweise auch Routing zum Ignorieren von Anforderungen, wenn keine physische Datei vorhanden ist. Beispielsweise sollten die Anforderungen, die ASP.NET automatisch für AXD-Dateien erstellt, nicht als Routen Anforderungen behandelt werden, auch wenn keine physische Datei vorhanden ist, die der Dateinamenerweiterung ". axd" entspricht.



## Examples
 Die Standardvorlage für MVC-Projekte verwendet diese Methode, um axd-Dateien aus dem Routing auszuschließen, wie im folgenden Beispiel gezeigt:

 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string * obj -&gt; unit" Usage="routeCollection.Ignore (url, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="constraints" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Das zu ignorierende URL-Muster.</param>
        <param name="constraints">Zusätzliche Kriterien, die bestimmen, ob eine Anforderung, die mit dem URL-Muster übereinstimmt, ignoriert wird.</param>
        <summary>Definiert ein URL-Muster, das nicht auf Übereinstimmungen für Routen überprüft werden soll, falls eine Anforderungs-URL den angegebenen Einschränkungen entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode erstellt eine Route, die dem <xref:System.Web.Routing.StopRoutingHandler>-Routen Handler zugeordnet ist. Nachdem Sie diese Methode aufgerufen haben, werden Anforderungen, die dem angegebenen URL-Muster entsprechen, nicht als Routen Anforderungen verarbeitet.

 ASP.NET Routing ignoriert automatisch Anforderungen, wenn die URL mit einer physischen Datei übereinstimmt, z. b. mit einer Bilddatei. In einigen Fällen möchten Sie möglicherweise auch Routing zum Ignorieren von Anforderungen, wenn keine physische Datei vorhanden ist. Beispielsweise sollten die Anforderungen, die ASP.NET automatisch für AXD-Dateien erstellt, nicht als Routen Anforderungen behandelt werden, auch wenn keine physische Datei vorhanden ist, die der Dateinamenerweiterung ". axd" entspricht.



## Examples
 Im folgenden Beispiel wird gezeigt, wie diese Methode verwendet wird, um alle URLs zu ignorieren, die über die Erweiterung ". aspx" verfügen. Dies ist möglicherweise sinnvoll, wenn Sie einen benutzerdefinierten HTTP-Handler registrieren, um alle URLs für Dateien mit der Erweiterung ". aspx" zu verarbeiten. Ein einzelnes URL-Muster, das alle ASPX-Anforderungen abgleichen würde, erfordert zwei Parameter des typersters (z. b. `{*path}.aspx/{*pathinfo}`). (Dieses Muster entspricht jeder URL, die auf ". aspx" endet, einschließlich derjenigen, die Abfrage Zeichenfolgen-Parameter aufweisen.) Das Routing lässt jedoch nur einen ""-Parameter am Ende zu. Als Alternative können Sie ein URL-Muster angeben, das über einen einzelnen Parameter vom Typ "" "" "". aspx "verfügt, der mit allen URLs übereinstimmt, und dann Einschränkungen angeben, die nicht die Erweiterung". aspx "aufweisen, wie im folgenden Beispiel gezeigt:

```vb
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})
```

```csharp
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});
```

 Die vorherige Codezeile wird in der Regel zu einer Methode hinzugefügt, die von der `Application_Start`-Methode in der Datei "Global. asax" aufgerufen wird, wie im Beispiel für die <xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29> Überladung gezeigt.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="url" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt wird.</param>
        <param name="item">Die einzufügende Route.</param>
        <summary>Fügt die angegebene Route am angegebenen Index in das <see cref="T:System.Web.Routing.RouteCollection" />-Objekt ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie dem <xref:System.Web.Routing.RouteCollection> Objekt eine unbenannte Route hinzufügen, können Sie keine Route hinzufügen, die bereits in der Auflistung vorhanden ist.

 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der-Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> ist bereits in der Auflistung vorhanden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Web.Routing.RouteBase" Usage="System.Web.Routing.RouteCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Wert, der die abzurufende Route identifiziert.</param>
        <summary>Ruft die Route in der Auflistung mit dem angegebenen Namen ab.</summary>
        <value>Ein Objekt mit dem angegebenen Namen oder <see langword="null" />, wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist oder keiner Route in der Auflistung entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der-Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LowercaseUrls : bool with get, set" Usage="System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob URLs in Kleinbuchstaben konvertiert werden, wenn virtuelle Pfade normalisiert sind.</summary>
        <value><see langword="true" />, um URLs zu Kleinbuchstaben zu konvertieren; andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn eine Abfrage Zeichenfolge in der URL enthalten ist, wird dieser Teil der URL nicht in Kleinbuchstaben konvertiert.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bietet eine Möglichkeit, Routen für Web Forms-Anwendungen zu definieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode und der Übergabe eines <xref:System.Web.Routing.Route>-Objekts, das mit der <xref:System.Web.Routing.PageRouteHandler>-Klasse erstellt wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie Routen für eine Web Forms Anwendung mithilfe dieser Methode definiert werden. Das Beispiel zeigt eine Methode mit dem Namen `RegisterRoutes`, die von `Application_Start` in der Datei Global. asax aufgerufen wird. Die-Methode verwendet jede Überladung von <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>, um der Anwendung eine Route hinzuzufügen. Weitere Informationen zum Definieren von Routen für Web Forms Anwendungen finden Sie unter Gewusst [wie: Definieren von Routen für Web Forms Anwendungen](https://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678).

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeUrl" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="physicalFile" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeUrl">Das URL-Muster für die Route.</param>
        <param name="physicalFile">Die physische URL für die Route.</param>
        <summary>Bietet eine Möglichkeit, Routen für Web Forms-Anwendungen zu definieren.</summary>
        <returns>Die Route, die der Routenauflistung hinzugefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode und der Übergabe eines <xref:System.Web.Routing.Route>-Objekts, das mit der <xref:System.Web.Routing.PageRouteHandler>-Klasse erstellt wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Route mithilfe dieser Methode definiert wird. Die erste Anweisung definiert eine Route, die keinen Namen hat. Die zweite Anweisung definiert eine benannte Route. Dieses Beispiel ist Teil eines größeren Beispiels, das in der Übersicht über <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>-Methode verfügbar ist.

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeUrl" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="physicalFile" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeUrl">Das URL-Muster für die Route.</param>
        <param name="physicalFile">Die physische URL für die Route.</param>
        <param name="checkPhysicalUrlAccess">Ein Wert, der angibt, ob von ASP.NET überprüft werden sollte, ob der Benutzer über die Berechtigung verfügt, auf die physische URL (die Routen-URL wird immer überprüft) zuzugreifen. Dieser Parameter legt die <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />-Eigenschaft fest.</param>
        <summary>Bietet eine Möglichkeit, Routen für Web Forms-Anwendungen zu definieren.</summary>
        <returns>Die Route, die der Routenauflistung hinzugefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode und der Übergabe eines <xref:System.Web.Routing.Route>-Objekts, das mit der <xref:System.Web.Routing.PageRouteHandler>-Klasse erstellt wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Route mithilfe dieser Methode definiert wird. Dieses Beispiel ist Teil eines größeren Beispiels, das in der Übersicht über <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>-Methode verfügbar ist.

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeUrl" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="physicalFile" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeUrl">Das URL-Muster für die Route.</param>
        <param name="physicalFile">Die physische URL für die Route.</param>
        <param name="checkPhysicalUrlAccess">Ein Wert, der angibt, ob von ASP.NET überprüft werden sollte, ob der Benutzer über die Berechtigung verfügt, auf die physische URL (die Routen-URL wird immer überprüft) zuzugreifen. Dieser Parameter legt die <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />-Eigenschaft fest.</param>
        <param name="defaults">Standardwerte für die Routenparameter.</param>
        <summary>Bietet eine Möglichkeit, Routen für Web Forms-Anwendungen zu definieren.</summary>
        <returns>Die Route, die der Routenauflistung hinzugefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode und der Übergabe eines <xref:System.Web.Routing.Route>-Objekts, das mit der <xref:System.Web.Routing.PageRouteHandler>-Klasse erstellt wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Route mithilfe dieser Methode definiert wird. Dieses Beispiel ist Teil eines größeren Beispiels, das in der Übersicht über <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>-Methode verfügbar ist.

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeUrl" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="physicalFile" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeUrl">Das URL-Muster für die Route.</param>
        <param name="physicalFile">Die physische URL für die Route.</param>
        <param name="checkPhysicalUrlAccess">Ein Wert, der angibt, ob von ASP.NET überprüft werden sollte, ob der Benutzer über die Berechtigung verfügt, auf die physische URL (die Routen-URL wird immer überprüft) zuzugreifen. Dieser Parameter legt die <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />-Eigenschaft fest.</param>
        <param name="defaults">Standardwerte für die Route.</param>
        <param name="constraints">Einschränkungen, die eine URL-Anforderung erfüllen muss, um als diese Route verarbeitet zu werden.</param>
        <summary>Bietet eine Möglichkeit, Routen für Web Forms-Anwendungen zu definieren.</summary>
        <returns>Die Route, die der Routenauflistung hinzugefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode und der Übergabe eines <xref:System.Web.Routing.Route>-Objekts, das mit der <xref:System.Web.Routing.PageRouteHandler>-Klasse erstellt wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Route mithilfe dieser Methode definiert wird. Dieses Beispiel ist Teil eines größeren Beispiels, das in der Übersicht über <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>-Methode verfügbar ist.

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints, dataTokens)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeUrl" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="physicalFile" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Der Name der Route.</param>
        <param name="routeUrl">Das URL-Muster für die Route.</param>
        <param name="physicalFile">Die physische URL für die Route.</param>
        <param name="checkPhysicalUrlAccess">Ein Wert, der angibt, ob von ASP.NET überprüft werden sollte, ob der Benutzer über die Berechtigung verfügt, auf die physische URL (die Routen-URL wird immer überprüft) zuzugreifen. Dieser Parameter legt die <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />-Eigenschaft fest.</param>
        <param name="defaults">Standardwerte für die Routenparameter.</param>
        <param name="constraints">Einschränkungen, die eine URL-Anforderung erfüllen muss, um als diese Route verarbeitet zu werden.</param>
        <param name="dataTokens">Werte, die der Route zugeordnet werden und anhand denen nicht bestimmt wird, ob eine Route einem URL-Muster entspricht.</param>
        <summary>Bietet eine Möglichkeit, Routen für Web Forms-Anwendungen zu definieren.</summary>
        <returns>Die Route, die der Routenauflistung hinzugefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode wird zur besseren Codierung bereitgestellt. Dies entspricht dem Aufrufen der <xref:System.Web.Routing.RouteCollection.Add%2A>-Methode und der Übergabe eines <xref:System.Web.Routing.Route>-Objekts, das mit der <xref:System.Web.Routing.PageRouteHandler>-Klasse erstellt wird.



## Examples
 Im folgenden Beispiel wird gezeigt, wie eine Route mithilfe dieser Methode definiert wird. Dieses Beispiel ist Teil eines größeren Beispiels, das in der Übersicht über <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>-Methode verfügbar ist.

 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="routeUrl" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="routeCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index der zu entfernenden Route.</param>
        <summary>Entfernt die Route aus dem <see cref="T:System.Web.Routing.RouteCollection" />-Objekt am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der-Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteExistingFiles : bool with get, set" Usage="System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der anzeigt, ob URLs, die mit einer vorhandenen Datei übereinstimmen, vom ASP.NET-Routing behandelt werden sollen.</summary>
        <value><see langword="true" />, wenn alle Anforderungen vom ASP.NET-Routing behandelt werden, auch solche, die einer vorhandenen Datei entsprechen, andernfalls <see langword="false" />. Standardwert: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Obwohl dieser Wert dynamisch geändert werden kann, werden alle Änderungen, die nach der Aktivierung eines Dienstes vorgenommen werden, bei Verwendung der ASP.NET-Routing Integration ignoriert. Weitere Informationen finden Sie unter [ASP.NET Routing Integration](https://go.microsoft.com/fwlink/?LinkId=195235).

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index der zu ersetzenden Route.</param>
        <param name="item">Die Route, die am angegebenen Index hinzugefügt werden soll.</param>
        <summary>Ersetzt die Route am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie dem <xref:System.Web.Routing.RouteCollection> Objekt eine unbenannte Route hinzufügen, können Sie keine Route hinzufügen, die bereits in der Auflistung vorhanden ist.

 Verwenden Sie die <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>-Methode und die <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>-Methode, um sicherzustellen, dass Sie mit der-Auflistung interagieren, ohne dass Konflikte mit anderen Prozessen auftreten.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> ist bereits in der Auflistung vorhanden.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET-Routing</related>
      </Docs>
    </Member>
  </Members>
</Type>
