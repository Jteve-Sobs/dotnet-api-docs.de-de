<Type Name="ButtonBase" FullName="System.Windows.Controls.Primitives.ButtonBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad03599cb19d3d68ad844a475df8124576797fee" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70418886" /></Metadata><TypeSignature Language="C#" Value="public abstract class ButtonBase : System.Windows.Controls.ContentControl, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ButtonBase extends System.Windows.Controls.ContentControl implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ButtonBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ButtonBase&#xA;Inherits ContentControl&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class ButtonBase abstract : System::Windows::Controls::ContentControl, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type ButtonBase = class&#xA;    inherit ContentControl&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Button)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die Basisklasse für alle <see cref="T:System.Windows.Controls.Button" />-Steuerelemente dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Behandeln Sie <xref:System.Windows.Controls.Primitives.ButtonBase.Click> das Ereignis, um zu reagieren, wenn <xref:System.Windows.Controls.Primitives.ButtonBase>der Benutzer auf einen klickt. Der Benutzer kann das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis <xref:System.Windows.Controls.AccessText> mithilfe von oder durch Drücken der EINGABETASTE oder der Leertaste, wenn das Steuerelement den Fokus besitzt, erhöhen.  Wenn der Benutzer die LEERTASTE drückt, legt <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> das Steuerelement auf `true` fest und erfasst die Maus.  Folglich gibt das <xref:System.Windows.UIElement.MouseEnter> -Steuerelement Mausereignisse aus, z. b <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. und. Beachten Sie, dass <xref:System.Windows.Controls.AccessText> durch die Verwendung der- <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder-Eingabetaste die Maus nicht geändert oder erfasst <xref:System.Windows.Controls.Primitives.ButtonBase.Click> wird, sondern das-Ereignis erhöht wird.  
  
 Der <xref:System.Windows.Controls.Primitives.ButtonBase> legt die <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> angefügte- `true`Eigenschaft auf fest.  
  
 Der <xref:System.Windows.Controls.Primitives.ButtonBase> legt die <xref:System.Windows.UIElement.IsInputMethodEnabled%2A>-Eigenschaft auf `false` fest.  
  
 Ein <xref:System.Windows.Controls.Primitives.ButtonBase> ist ein <xref:System.Windows.Controls.ContentControl>. Dies bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. b. eine Zeichenfolge, ein Bild oder ein Panel) enthalten kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.ContentControl>-Klasse.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ButtonBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ButtonBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ButtonBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.RoutedEventHandler " Usage="member this.Click : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn auf ein <see cref="T:System.Windows.Controls.Button" /> geklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer kann das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis <xref:System.Windows.Controls.AccessText> mithilfe von oder durch Drücken der EINGABETASTE oder der Leertaste, wenn das Steuerelement den Fokus besitzt, erhöhen.  Wenn der Benutzer die LEERTASTE drückt, legt <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> das Steuerelement auf `true` fest und erfasst die Maus.  Folglich gibt das <xref:System.Windows.UIElement.MouseEnter> -Steuerelement Mausereignisse aus, z. b <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. und. Beachten Sie, dass <xref:System.Windows.Controls.AccessText> durch die Verwendung der- <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder-Eingabetaste die Maus nicht geändert oder erfasst <xref:System.Windows.Controls.Primitives.ButtonBase.Click> wird, sondern das-Ereignis erhöht wird.  
  
 Der <xref:System.Windows.Controls.Primitives.ButtonBase> markiert das <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis in der <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> -Methode als behandelt und löst <xref:System.Windows.Controls.Primitives.ButtonBase.Click> das-Ereignis aus. Daher tritt das <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> -Ereignis nie bei einem Steuerelement auf, das von <xref:System.Windows.Controls.Primitives.ButtonBase>erbt. Fügen Sie stattdessen einen Ereignishandler an das <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> -Ereignis an, <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> oder `handledEventsToo` verwenden Sie `true`, wobei auf festgelegt ist.  
  
<a name="routedEventInfo_Click"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickEvent>|  
|Routing Strategie|Blasen|  
|delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt drei Schaltflächen, die auf drei verschiedene Arten auf Klicks Antworten.  
  
-   Hover: die erste Schaltfläche ändert die Farben, wenn der Benutzer mit dem Mauszeiger auf die Schaltfläche bewegt wird.  
  
-   Drücken Sie-die zweite Schaltfläche erfordert, dass die Maus gedrückt wird, während sich der Mauszeiger in der Schaltfläche befindet.  
  
-   Release-das dritte setzt die Hintergrundfarbe der Schaltflächen erst zurück, wenn die Maus gedrückt und in der Schaltfläche losgelassen wurde.  
  
 [!code-xaml[ClickModes_snip#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml#1)]  
  
 [!code-csharp[ClickModes_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ClickModes_snip#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClickModes_snip/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ClickEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis entspricht einem Mausklick mit der linken Maustaste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ClickMode ClickMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ClickMode ClickMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ClickMode As ClickMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ClickMode ClickMode { System::Windows::Controls::ClickMode get(); void set(System::Windows::Controls::ClickMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClickMode : System.Windows.Controls.ClickMode with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ClickMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, wann das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Ereignis auftritt.</summary>
        <value>Auftreten des <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Ereignisses. Der Standardwert ist <see cref="F:System.Windows.Controls.ClickMode.Release" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ClickMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClickModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClickModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClickModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Befehl ab, der beim Drücken dieser Schaltfläche aufgerufen wird, bzw. legt diesen fest.</summary>
        <value>Ein Befehl, der beim Klicken auf diese Schaltfläche aufgerufen wird. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird zum Zuordnen eines Befehls zu einer bestimmten Schaltflächen Instanz verwendet.  
  
 In [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]ist diese Eigenschaft am häufigsten als statischer Befehls Wert aus einer der vorhandenen Befehls Bibliotheken, <xref:System.Windows.Input.ApplicationCommands> z. b. oder <xref:System.Windows.Input.NavigationCommands>, festgelegt. Weitere Informationen finden Sie unter [Befehls Übersicht](~/docs/framework/wpf/advanced/commanding-overview.md) oder <xref:System.Windows.Input.ICommand>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Command="commandName"/>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *CommandName*  
 Der Befehl, der aufgerufen werden soll, wenn diese Schaltfläche gedrückt wird.  
  
<a name="dependencyPropertyInfo_Command"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Parameter ab, der an die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />-Eigenschaft übergeben wird, oder legt diesen fest.</summary>
        <value>Der Parameter, der an die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />-Eigenschaft übergeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten vorhandenen Befehle in den Befehls Bibliotheken verwenden keinen Befehlsparameter. Der Befehle, die einen Befehlsparameter verwenden, verwenden die meisten dieser Parameter einen Parameter mit einem primitiven Typwert, z. b. eine ganze Zahl oder eine Zeichenfolge. Es ist jedoch möglich, einen benutzerdefinierten Befehl zu erstellen, bei dem dieser Befehl einen nicht primitiven Typ als Befehlsparameter erwartet. Bei einem solchen benutzerdefinierten Befehls Fall kann das <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> Festlegen von im Code eine neue oder vorhandene Objektinstanz erfordern. Das <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> festlegen in Markup erfordert möglicherweise eine Eigenschafts Element Syntax, wobei das Objekt Element, das die Eigenschafts Element Syntax füllt, ein neues Element des Typs ist, der von diesem Befehl erwartet wird. Alternativ dazu kann die Einstellung in Markup einen Verweis durch eine Markup Erweiterung auf ein vorhandenes Objekt erfordern (in der Regel werden diese Verweise mit der [Bindungs Markup Erweiterung](~/docs/framework/wpf/advanced/binding-markup-extension.md) oder [statikresource-Markup Erweiterung](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)erstellt).  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object CommandParameter="commandParameter" />  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *commandParameter*  
 Ein Wert desselben Typs wie der in der <xref:System.Windows.Controls.Primitives.ButtonBase.Command%2A> -Eigenschaft angegebene Befehl erwartet. Wenn Sie einen vorhandenen Befehls Bibliotheks Befehl verwenden, finden Sie in der Dokumentation der Befehls [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Bibliothek Informationen zu den Verwendungs Informationen, <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> einschließlich des Typs, den der Befehl erwartet. Wenn Sie einen benutzerdefinierten Befehl verwenden, finden Sie weitere Informationen unter Hinweise.  
  
<a name="dependencyPropertyInfo_CommandParameter"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die weitergeleitete <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Element ab, für das der angegebene Befehl aufgerufen werden soll, bzw. legt dieses fest.</summary>
        <value>Element, für das ein Befehl ausgelöst wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> -Eigenschaft kann nicht verwendet werden, <xref:System.Windows.UIElement>um eine zu definieren. Die <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> -Eigenschaft stellt einen Verweis auf ein Element bereit, das bereits irgendwo in der Anwendung definiert ist.  
  
<a name="xamlAttributeUsage_Target"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<ButtonBase CommandTarget="{Binding ElementName= elementName }"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *elementName*  
 Der Name von <xref:System.Windows.IInputElement> , der den Befehl empfängt.  
  
<a name="dependencyPropertyInfo_CommandTarget"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der <see cref="P:System.Windows.ContentElement.IsEnabled" />-Eigenschaft ab.</summary>
        <value><see langword="true" />, wenn das Steuerelement aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Implementierung außer Kraft setzen möchten, stellen Sie sicher, dass Sie die Basis Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressed">
      <MemberSignature Language="C#" Value="public bool IsPressed { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPressed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPressed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsPressed {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPressed : bool with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> aktuell aktiviert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> aktiviert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A>der Zustand einer Schaltfläche, die angibt, dass die linke Maustaste oder die LEERTASTE über der Schaltfläche gedrückt wird. Wenn  <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> den Wert hat, erfasst das Steuerelement die Maus. `true`  Folglich gibt das <xref:System.Windows.UIElement.MouseEnter> -Steuerelement Mausereignisse aus, z. b <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. und. Beachten Sie, dass <xref:System.Windows.Controls.AccessText> durch die Verwendung der- <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder-Eingabetaste die Maus nicht geändert oder erfasst <xref:System.Windows.Controls.Primitives.ButtonBase.Click> wird, sondern das-Ereignis aufhebt.  
  
 Beginnend mit der .NET Framework Version 3,0 Service Pack 1, <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> verfügt über einen geschützten Setter. Um diese Funktionalität nutzen zu können, sollte Ihre Anwendung die .NET Framework Version 3,5 als Ziel verwenden.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
<a name="dependencyPropertyInfo_IsPressed"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 In diesem Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> die-Eigenschaft in einem auslöserstil verwendet wird.  
  
 [!code-xaml[BtnColor#9](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnColor/CSharp/Pane1.xaml#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsPressedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsPressedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsPressedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsPressedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsPressedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected override void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="buttonBase.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.AccessKeyManager.AccessKeyPressed" />-Ereignis.</param>
        <summary>Reagiert, wenn der <see cref="P:System.Windows.Controls.AccessText.AccessKey" /> für dieses Steuerelement aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Input.AccessKeyEventArgs.IsMultiple%2A> ist `true` , ruft diese Methode die Basis Implementierung auf, die diesem Steuerelement den Fokus übergibt.  Andernfalls löst diese Methode das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignis aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick();" />
      <MemberSignature Language="F#" Value="abstract member OnClick : unit -&gt; unit&#xA;override this.OnClick : unit -&gt; unit" Usage="buttonBase.OnClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Routingereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das-Steuerelement <xref:System.Windows.Controls.Primitives.ButtonBase.Click> löst das Ereignis <xref:System.Windows.UIElement.RaiseEvent%2A>durch Aufrufen von aus. Weitere Informationen finden Sie unter [Übersicht über Routing Ereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> in einer abgeleiteten Klasse sicher, dass die-Methode der Basisklasse aufgerufen wird, damit registrierte Delegaten das Ereignis empfangen. <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsPressedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsPressedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsPressedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnIsPressedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsPressedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsPressedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="buttonBase.OnIsPressedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</param>
        <summary>Wird aufgerufen, wenn sich die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyDown" />-Routingereignis bereit, das auftritt, wenn der Benutzer eine Taste drückt, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung markiert das <xref:System.Windows.UIElement.KeyDown> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft der Ereignisdaten auf `true` fest <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> gelegt wird, wenn <xref:System.Windows.Controls.ClickMode.Hover> nicht auf festgelegt ist und einer der folgenden Fälle zutrifft:  
  
-   Der Benutzer drückt die Leertaste.  
  
-   Der Benutzer drückt die Eingabe <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> Taste `true` und ist für dieses Steuerelement.  
  
 In allen anderen Fällen ändert diese Implementierung nicht den behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft) <xref:System.Windows.UIElement.KeyDown> der Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.UIElement.KeyUp" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyUp" />-Routingereignis bereit, das auftritt, wenn der Benutzer eine Taste loslässt, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung markiert das <xref:System.Windows.UIElement.KeyUp> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft der Ereignisdaten auf `true` festgelegt wird, wenn der Benutzer die LEERTASTE loslässt. Andernfalls ändert diese Implementierung nicht den behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft) <xref:System.Windows.UIElement.KeyUp> der Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="buttonBase.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.IInputElement.LostKeyboardFocus" />-Ereignis.</param>
        <summary>Wird aufgerufen, wenn ein Element den Tastaturfokus verliert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.LostMouseCapture" />-Routingereignis bereit, das auftritt, wenn dieses Steuerelement keine Mausereignismeldungen mehr erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht den behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft) <xref:System.Windows.UIElement.LostMouseCapture> der Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.Mouse.MouseEnter" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />-Ereignis bereit, das auftritt, wenn der Mauszeiger in den Bereich des Steuerelements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> auf <xref:System.Windows.RoutedEventArgs.Handled%2A> <xref:System.Windows.UIElement.MouseEnter> `true` <xref:System.Windows.Controls.Primitives.ButtonBase.Click> festgelegt ist, markiert diese Implementierung das Ereignis als behandelt, indem die-Eigenschaft der Ereignisdaten auf festgelegt wird und das-Ereignis ausgelöst wird. <xref:System.Windows.Controls.ClickMode.Hover>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.Mouse.MouseLeave" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeave" />-Routingereignis bereit, das auftritt, wenn der Mauszeiger ein Element verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung markiert das <xref:System.Windows.UIElement.MouseLeave> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft der Ereignisdaten auf `true` fest <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> gelegt wird, <xref:System.Windows.Controls.ClickMode.Hover>wenn auf festgelegt ist.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" />-Routingereignis bereit, das auftritt, wenn die linke Maustaste gedrückt wird, während sich der Mauszeiger über diesem Steuerelement befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung markiert das <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft der Ereignisdaten auf `true` fest <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> gelegt wird, wenn <xref:System.Windows.Controls.ClickMode.Hover>nicht auf festgelegt ist. Fügen Sie zum reagieren <xref:System.Windows.UIElement.MouseLeftButtonDown> auf das-Ereignis einen Ereignishandler an <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> das-Ereignis an <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> , `handledEventsToo` oder wenden `true`Sie an, wobei auf festgelegt ist.  
  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> <xref:System.Windows.Controls.Primitives.ButtonBase.Click> auf <xref:System.Windows.Controls.ClickMode.Press>festgelegt ist, löst diese Methode das-Ereignis aus.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" />-Routingereignis bereit, das auftritt, wenn die linke Maustaste losgelassen wird, während der Mauszeiger sich über diesem Steuerelement befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung markiert das <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft der Ereignisdaten auf `true` fest <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> gelegt wird, wenn <xref:System.Windows.Controls.ClickMode.Hover>nicht auf festgelegt ist. Fügen Sie zum reagieren <xref:System.Windows.UIElement.MouseLeftButtonUp> auf das-Ereignis einen Ereignishandler an <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> das-Ereignis an <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> , `handledEventsToo` oder wenden `true`Sie an, wobei auf festgelegt ist.  
  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> <xref:System.Windows.Controls.ClickMode.Release> <xref:System.Windows.Controls.Primitives.ButtonBase.Click> auf festgelegt ist, löst diese Methode das-Ereignis aus. <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A>  `true`  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseMove" />-Routingereignis bereit, das auftritt, wenn der Mauszeiger bewegt wird, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung markiert das <xref:System.Windows.UIElement.MouseMove> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> -Eigenschaft der Ereignisdaten auf `true` fest <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> gelegt wird, wenn nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> auf `true`festgelegt ist und auf <xref:System.Windows.Controls.ClickMode.Hover> festgelegt ist. Fügen Sie zum reagieren <xref:System.Windows.UIElement.MouseMove> auf das-Ereignis einen Ereignishandler an <xref:System.Windows.ContentElement.PreviewMouseMove> das-Ereignis an <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> , `handledEventsToo` oder wenden `true`Sie an, wobei auf festgelegt ist.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie über <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />schreiben, müssen Sie immer die Basis Implementierung <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" /> in der Implementierung von aufzurufen. Wenn Sie die Basis Implementierung nicht aufzurufen, wird verhindert, dass Basisklassen das Ereignis mit einem Klassen Handler behandeln, der das Laufzeitverhalten der endgültigen Klasse möglicherweise ändert. Abhängig von Ihren Anforderungen können Sie die Basis Implementierung entweder vor oder nach ihrer speziellen Behandlung abrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="buttonBase.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Gibt die Größenänderungen an.</param>
        <summary>Wird aufgerufen, wenn sich die Darstellungsgröße eines Steuerelements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreibt die <xref:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged%2A> -Methode <xref:System.Windows.UIElement>von.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
