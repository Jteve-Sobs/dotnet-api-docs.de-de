<Type Name="ButtonBase" FullName="System.Windows.Controls.Primitives.ButtonBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1060e5f1f18508efa92dfd0f5069359ba78fc33" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55352937" /></Metadata><TypeSignature Language="C#" Value="public abstract class ButtonBase : System.Windows.Controls.ContentControl, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ButtonBase extends System.Windows.Controls.ContentControl implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ButtonBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ButtonBase&#xA;Inherits ContentControl&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class ButtonBase abstract : System::Windows::Controls::ContentControl, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type ButtonBase = class&#xA;    inherit ContentControl&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Button)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die Basisklasse für alle <see cref="T:System.Windows.Controls.Button" />-Steuerelemente dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Behandeln der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis reagieren, wenn der Benutzer klickt auf eine <xref:System.Windows.Controls.Primitives.ButtonBase>. Der Benutzer kann Auslösen der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis, indem ein <xref:System.Windows.Controls.AccessText> oder durch Drücken von EINGABETASTE oder LEERTASTE, wenn das Steuerelement den Fokus besitzt.  Wenn der Benutzer drückt die LEERTASTE, die Zugriffskonfigurationen <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> zu `true` und die Maus erfasst.  Daher das Steuerelement ausgelöst Mausereignisse wie z. B. <xref:System.Windows.UIElement.MouseEnter> und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Beachten Sie, dass die Verwendung der <xref:System.Windows.Controls.AccessText> oder EINGABETASTE ändert sich nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder die Maus erfassen, aber es löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase> legt die <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> angefügte Eigenschaft zu `true`.  
  
 Der <xref:System.Windows.Controls.Primitives.ButtonBase> legt die <xref:System.Windows.UIElement.IsInputMethodEnabled%2A>-Eigenschaft auf `false` fest.  
  
 Ein <xref:System.Windows.Controls.Primitives.ButtonBase> ist eine <xref:System.Windows.Controls.ContentControl>, was bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. B. eine Zeichenfolge, ein Bild oder einen Bereich) enthalten kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.ContentControl>-Klasse.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ButtonBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ButtonBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ButtonBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.RoutedEventHandler " Usage="member this.Click : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn auf ein <see cref="T:System.Windows.Controls.Button" /> geklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer kann Auslösen der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis, indem ein <xref:System.Windows.Controls.AccessText> oder durch Drücken von EINGABETASTE oder LEERTASTE, wenn das Steuerelement den Fokus besitzt.  Wenn der Benutzer drückt die LEERTASTE, die Zugriffskonfigurationen <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> zu `true` und die Maus erfasst.  Daher das Steuerelement ausgelöst Mausereignisse wie z. B. <xref:System.Windows.UIElement.MouseEnter> und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Beachten Sie, dass die Verwendung der <xref:System.Windows.Controls.AccessText> oder EINGABETASTE ändert sich nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder die Maus erfassen, aber es löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase> markiert die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis als behandelt, in der <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> -Methode und löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis. Daher die <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> Ereignis treten nie für ein Steuerelement, das von erbt <xref:System.Windows.Controls.Primitives.ButtonBase>. Fügen Sie stattdessen einen Ereignishandler an das <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> -Ereignis, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
<a name="routedEventInfo_Click"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt drei Schaltflächen, die auf Mausklicks auf drei verschiedene Arten zu reagieren.  
  
-   Hover - ändert die erste Schaltfläche Farben, wenn der Benutzer über die Schaltfläche mit der Maus gezeigt wird  
  
-   Drücken Sie die - erfordert die zweite Schaltfläche, mit der Maus geklickt werden, während der Mauszeiger in der Schaltfläche befindet.  
  
-   Release - ist die dritte erst zurückgesetzt, die Hintergrundfarbe Schaltflächen die Maustaste gedrückt und losgelassen wird, auf die Schaltfläche.  
  
 [!code-xaml[ClickModes_snip#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml#1)]  
  
 [!code-csharp[ClickModes_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ClickModes_snip#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClickModes_snip/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ClickEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis entspricht linke Schaltfläche geklickt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ClickMode ClickMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ClickMode ClickMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ClickMode As ClickMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ClickMode ClickMode { System::Windows::Controls::ClickMode get(); void set(System::Windows::Controls::ClickMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClickMode : System.Windows.Controls.ClickMode with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ClickMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, wann das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Ereignis auftritt.</summary>
        <value>Auftreten des <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Ereignisses. Der Standardwert ist <see cref="F:System.Windows.Controls.ClickMode.Release" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ClickMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClickModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClickModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClickModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Befehl ab, der beim Drücken dieser Schaltfläche aufgerufen wird, bzw. legt diesen fest.</summary>
        <value>Ein Befehl, der beim Klicken auf diese Schaltfläche aufgerufen wird. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird verwendet, um einen Befehl mit einer bestimmten Schaltfläche-Instanz zuzuordnen.  
  
 In [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], diese Eigenschaft wird meist auf eine statische Befehlswert aus einer von den vorhandenen Bibliotheken, wie z. B. festgelegt <xref:System.Windows.Input.ApplicationCommands> oder <xref:System.Windows.Input.NavigationCommands>. Weitere Informationen finden Sie unter [Befehlsübersicht](~/docs/framework/wpf/advanced/commanding-overview.md) oder <xref:System.Windows.Input.ICommand>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Command="commandName"/>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *commandName*  
 Der Befehl, der aufgerufen wird, wenn diese Taste gedrückt wird.  
  
<a name="dependencyPropertyInfo_Command"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Parameter ab, der an die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />-Eigenschaft übergeben wird, oder legt diesen fest.</summary>
        <value>Der Parameter, der an die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />-Eigenschaft übergeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten vorhandenen Befehle aus den Bibliotheken verwenden einen Befehlsparameter nicht. Befehle, die einen Parameter verwenden, nutzen die meisten dieser Parameter mit einem primitiven Typ-Wert, z. B. eine ganze Zahl oder eine Zeichenfolge. Allerdings ist es möglich, einen benutzerdefinierten Befehl zu erstellen, bei denen dieses Befehls einen nicht primitiven Typ als Befehlsparameter erwartet. Für einen benutzerdefinierten Befehl Fall wie folgt, Festlegen von <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> im Code möglicherweise eine neue oder vorhandene Objektinstanz. Festlegen von <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> im Markup Eigenschaftenelement-Syntax, in dem das Object-Element, das Ausfüllen der Eigenschaftenelementsyntax ein neues Element des Typs erwartet wird durch diesen Befehl ist erforderlich. Alternativ kann die Einstellung im Markup erfordern einen Verweis durch eine Markuperweiterung auf ein vorhandenes Objekt (in der Regel werden diese Verweise mit [Binding als Markuperweiterung](~/docs/framework/wpf/advanced/binding-markup-extension.md) oder [StaticResource-Markuperweiterung ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)).  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object CommandParameter="commandParameter" />  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *commandParameter*  
 Ein Wert, der den gleichen Typ wie der angegebene im Befehl den <xref:System.Windows.Controls.Primitives.ButtonBase.Command%2A> Eigenschaft erwartet. Wenn Sie einen vorhandene Bibliothek-Befehl verwenden, finden Sie Dokumentation, Befehlsbibliothek [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Nutzungsinformationen, einschließlich der <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> erwartet, dass der Befehl. Wenn Sie einen benutzerdefinierten Befehl verwenden, finden Sie unter "Hinweise".  
  
<a name="dependencyPropertyInfo_CommandParameter"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die weitergeleitete <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Element ab, für das der angegebene Befehl aufgerufen werden soll, bzw. legt dieses fest.</summary>
        <value>Element, für das ein Befehl ausgelöst wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> Eigenschaft kann nicht verwendet werden, zum Definieren einer <xref:System.Windows.UIElement>. Die <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> Eigenschaft stellt einen Verweis auf ein Element, das bereits in Ihrer Anwendung definiert ist.  
  
<a name="xamlAttributeUsage_Target"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<ButtonBase CommandTarget="{Binding ElementName= elementName }"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *elementName*  
 Der Name des <xref:System.Windows.IInputElement> , der den Befehl empfängt.  
  
<a name="dependencyPropertyInfo_CommandTarget"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der <see cref="P:System.Windows.ContentElement.IsEnabled" />-Eigenschaft ab.</summary>
        <value><see langword="true" />, wenn das Steuerelement aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Implementierung überschreiben möchten, stellen Sie sicher, dass Sie die Basismethode aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressed">
      <MemberSignature Language="C#" Value="public bool IsPressed { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPressed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPressed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsPressed {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPressed : bool with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> aktuell aktiviert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> aktiviert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist der Zustand einer Schaltfläche, der die linke Maustaste gedrückt angibt oder die LEERTASTE über die Schaltfläche gedrückt wird. Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist `true`, zeichnet die Maus das Steuerelement.  Daher das Steuerelement ausgelöst Mausereignisse wie z. B. <xref:System.Windows.UIElement.MouseEnter> und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Beachten Sie, dass die Verwendung der <xref:System.Windows.Controls.AccessText> oder EINGABETASTE ändert sich nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder Erfassen der Maus, jedoch wird wird ausgelöst der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Ab .NET Framework Version 3.0 Servicepack 1, <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> verfügt über einen geschützten Setter. Um diese Funktion verwenden zu können, sollte die Anwendung .NET Framework, Version 3.5 ausgelegt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
<a name="dependencyPropertyInfo_IsPressed"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
   
  
## Examples  
 Dieses Beispiel zeigt, wie Sie mit der <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> Eigenschaft als Auslöser.  
  
 [!code-xaml[BtnColor#9](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnColor/CSharp/Pane1.xaml#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsPressedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsPressedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsPressedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsPressedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsPressedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected override void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="buttonBase.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.AccessKeyManager.AccessKeyPressed" />-Ereignis.</param>
        <summary>Reagiert, wenn der <see cref="P:System.Windows.Controls.AccessText.AccessKey" /> für dieses Steuerelement aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Input.AccessKeyEventArgs.IsMultiple%2A> ist `true`, ruft diese Methode die basisimplementierung, wodurch dieses den Steuerelementfokus erhält.  Andernfalls löst diese Methode die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick();" />
      <MemberSignature Language="F#" Value="abstract member OnClick : unit -&gt; unit&#xA;override this.OnClick : unit -&gt; unit" Usage="buttonBase.OnClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Routingereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das Steuerelement die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignis durch einen Aufruf <xref:System.Windows.UIElement.RaiseEvent%2A>. Weitere Informationen finden Sie unter [Übersicht über Routingereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> in einer abgeleiteten Klasse, werden Sie sicher, dass die Basisklasse aufrufen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsPressedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsPressedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsPressedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnIsPressedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsPressedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsPressedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="buttonBase.OnIsPressedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</param>
        <summary>Wird aufgerufen, wenn sich die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyDown" />-Routingereignis bereit, das auftritt, wenn der Benutzer eine Taste drückt, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.KeyDown> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nicht auf festgelegt ist <xref:System.Windows.Controls.ClickMode.Hover> und eine der folgenden Fälle zutrifft:  
  
-   Der Benutzer drückt die LEERTASTE.  
  
-   Der Benutzer drückt die EINGABETASTE und <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> ist `true` für dieses Steuerelement.  
  
 In allen anderen Fällen diese Implementierung ändert nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.KeyDown> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.UIElement.KeyUp" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyUp" />-Routingereignis bereit, das auftritt, wenn der Benutzer eine Taste loslässt, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.KeyUp> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` Wenn der Benutzer die LEERTASTE freigibt. Diese Implementierung ändert, andernfalls nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.KeyUp> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="buttonBase.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.IInputElement.LostKeyboardFocus" />-Ereignis.</param>
        <summary>Wird aufgerufen, wenn ein Element den Tastaturfokus verliert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.LostMouseCapture" />-Routingereignis bereit, das auftritt, wenn dieses Steuerelement keine Mausereignismeldungen mehr erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.LostMouseCapture> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.Mouse.MouseEnter" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />-Ereignis bereit, das auftritt, wenn der Mauszeiger in den Bereich des Steuerelements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nastaven NA hodnotu <xref:System.Windows.Controls.ClickMode.Hover>, diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseEnter> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` und löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für das <see cref="E:System.Windows.Input.Mouse.MouseLeave" />-Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeave" />-Routingereignis bereit, das auftritt, wenn der Mauszeiger ein Element verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseLeave> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nastaven NA hodnotu <xref:System.Windows.Controls.ClickMode.Hover>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" />-Routingereignis bereit, das auftritt, wenn die linke Maustaste gedrückt wird, während sich der Mauszeiger über diesem Steuerelement befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> ist nicht auf festgelegt <xref:System.Windows.Controls.ClickMode.Hover>. Auf reagieren die <xref:System.Windows.UIElement.MouseLeftButtonDown> -Ereignis, fügen Sie einen Ereignishandler an die <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> -Ereignis, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nastaven NA hodnotu <xref:System.Windows.Controls.ClickMode.Press>, löst diese Methode die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" />-Routingereignis bereit, das auftritt, wenn die linke Maustaste losgelassen wird, während der Mauszeiger sich über diesem Steuerelement befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> ist nicht auf festgelegt <xref:System.Windows.Controls.ClickMode.Hover>. Auf reagieren die <xref:System.Windows.UIElement.MouseLeftButtonUp> -Ereignis, fügen Sie einen Ereignishandler an die <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> -Ereignis, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nastaven NA hodnotu <xref:System.Windows.Controls.ClickMode.Release> ist <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist `true`, löst diese Methode die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseMove" />-Routingereignis bereit, das auftritt, wenn der Mauszeiger bewegt wird, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseMove> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> ist nicht auf festgelegt <xref:System.Windows.Controls.ClickMode.Hover> und <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist `true`. Auf reagieren die <xref:System.Windows.UIElement.MouseMove> -Ereignis, fügen Sie einen Ereignishandler an die <xref:System.Windows.ContentElement.PreviewMouseMove> -Ereignis, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />, rufen Sie die basisimplementierung immer Ihre <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" /> Implementierung. Fehler beim Aufrufen der basisimplementierung wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültige Klasse unterschiedlich sein kann. Sie können die basisimplementierung vor oder nach der speziellen Behandlung je nach Anforderung aufrufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="buttonBase.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Gibt die Größenänderungen an.</param>
        <summary>Wird aufgerufen, wenn sich die Darstellungsgröße eines Steuerelements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreibt die <xref:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged%2A> Methode der <xref:System.Windows.UIElement>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>