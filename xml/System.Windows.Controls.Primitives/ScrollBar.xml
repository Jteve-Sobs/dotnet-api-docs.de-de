<Type Name="ScrollBar" FullName="System.Windows.Controls.Primitives.ScrollBar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee4c11eaab7bc6272bae1a2ef8a8d4566d9f7c38" /><Meta Name="ms.sourcegitcommit" Value="22744e2f9d07a51900a968efffd9e390117d64a1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/03/2019" /><Meta Name="ms.locfileid" Value="55674020" /></Metadata><TypeSignature Language="C#" Value="public class ScrollBar : System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollBar extends System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ScrollBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollBar&#xA;Inherits RangeBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollBar : System::Windows::Controls::Primitives::RangeBase" />
  <TypeSignature Language="F#" Value="type ScrollBar = class&#xA;    inherit RangeBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.RangeBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Steuerelement dar, das eine Schiebeleiste mit einem verschiebbaren <see cref="T:System.Windows.Controls.Primitives.Thumb" /> bereitstellt, dessen Position einem Wert entspricht.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Abbildung zeigt eine <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement.  
  
 ![Abbildung der Schiebeleiste](~/add/media/scrollbar-illustration.JPG "Scrollbar-Abbildung")  
  
 Die <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement enthält eine <xref:System.Windows.Controls.Primitives.Track> Steuerelement. Die <xref:System.Windows.Controls.Primitives.Track> -Steuerelement besteht aus einem <xref:System.Windows.Controls.Primitives.Thumb> -Steuerelements und zweier <xref:System.Windows.Controls.Primitives.RepeatButton> Steuerelemente. Können Sie erhöhen und verringern die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> Eigenschaft der <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement durch Drücken der <xref:System.Windows.Controls.Primitives.RepeatButton> steuert, oder Verschieben von der <xref:System.Windows.Controls.Primitives.Thumb>. Der Standardbereich von Werten für die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> Eigenschaft ist 0 bis 1. Die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> stellt die Luftlinie von der <xref:System.Windows.Controls.Primitives.Thumb> zwischen den Endpunkten der <xref:System.Windows.Controls.Primitives.ScrollBar>. Sie können den Standardbereich der Werte ändern, durch Festlegen der <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> und <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> Eigenschaften. Die <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> Eigenschaft bestimmt, ob die <xref:System.Windows.Controls.Primitives.ScrollBar> horizontal oder vertikal angezeigt wird und Sie müssen diese Eigenschaft für definieren die <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement angezeigt werden.  
  
 Die <xref:System.Windows.Controls.Primitives.Track> in einem <xref:System.Windows.Controls.Primitives.ScrollBar> ausgerichtet ist, sodass Werte von oben nach unten bei einem vertikalen erhöhen <xref:System.Windows.Controls.Primitives.ScrollBar> oder von links nach rechts bei einer horizontalen <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Die <xref:System.Windows.Controls.Primitives.Track> Eigenschaften in der folgenden Tabelle sind die Bindungsziele für die für den entsprechenden <xref:System.Windows.Controls.Primitives.ScrollBar> Eigenschaften bei der <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> Eigenschaft nicht explizit definiert. Wenn Sie explizit definieren die <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> -Eigenschaft, die Bindung erfolgt nicht.  
  
|<xref:System.Windows.Controls.Primitives.Track> -Eigenschaft|<xref:System.Windows.Controls.Primitives.ScrollBar> -Eigenschaft|  
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.Primitives.Track.Maximum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Minimum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Value%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A?displayProperty=nameWithType>|  
  
 Sie können den Zugriff auf die <xref:System.Windows.Controls.Primitives.Track> Kontrolle über eine <xref:System.Windows.Controls.Primitives.ScrollBar> -Steuerelement unter Verwendung der <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> Eigenschaft.  
  
 Anzuzeigende <xref:System.Windows.UIElement> -Inhalt in einem Feld, das Scrollleisten hat, verwenden Sie die <xref:System.Windows.Controls.ScrollViewer> Steuerelement.  
  
## <a name="customizing-the-scrollbar-control"></a>Anpassen der ScrollBar-Steuerelement  
 Zum Anwenden der gleichen eigenschafteneinstellungen mit mehreren <xref:System.Windows.Controls.Primitives.ScrollBar> -Steuerelemente verwenden die <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft. Sie können den Standardwert ändern <xref:System.Windows.Controls.ControlTemplate> auf dem Steuerelement eine unverwechselbare Darstellung verleihen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate>, finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuerelements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Um anzuzeigen, die Teile und Zustände, die spezifisch für die <xref:System.Windows.Controls.Primitives.ScrollBar>, finden Sie unter [ScrollBar-Stile und-Vorlagen](~/docs/framework/wpf/controls/scrollbar-styles-and-templates.md).  
  
 Abhängigkeitseigenschaften für dieses Steuerelement können vom Standardformat des Steuerelements festgelegt werden.  Wenn eine Eigenschaft von einem standardmäßigen Format festgelegt ist, kann die Eigenschaft den Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Das Standardformat wird bestimmt durch die Desktopdesign verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Das folgende Beispiel zeigt, wie ein horizontaler <xref:System.Windows.Controls.Primitives.ScrollBar> , die einen Bereich von Werten zwischen 0 und 100 ist.  
  
 [!code-xaml[ScrollBarSnips#ScrollBar](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scrollbar)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.RangeBase" />
    <altmember cref="T:System.Windows.Controls.Primitives.Track" />
    <altmember cref="T:System.Windows.Controls.Primitives.Thumb" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieser Befehl benachrichtigt den <see cref="T:System.Windows.Controls.ScrollViewer" />, dass der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> der horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> auf den Wert zieht, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer zieht das Thumb-Steuerelement von einem <xref:System.Windows.Controls.Primitives.ScrollBar>, <xref:System.Windows.Controls.Primitives.ScrollBar> Aufrufe <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> für die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand>. Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> gibt `true`, <xref:System.Windows.Controls.Primitives.ScrollBar> führt diese aus.  Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> gibt `false`, <xref:System.Windows.Controls.Primitives.ScrollBar> führt die <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand>.  
  
 Die <xref:System.Windows.Controls.ScrollViewer> mit diesem Befehl wird verwendet, um verzögertes Scrollen zu aktivieren. Beim <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> ist `true` und ein Benutzer zieht die <xref:System.Windows.Controls.Primitives.Thumb> von der <xref:System.Windows.Controls.Primitives.ScrollBar>, die Inhalt der <xref:System.Windows.Controls.ScrollViewer> wird nicht geändert werden, bis der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb>. Wenn verzögerte Bildlauf aktiviert ist, die <xref:System.Windows.Controls.Primitives.ScrollBar> führt die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> bei einem horizontalen <xref:System.Windows.Controls.Primitives.ScrollBar> Wenn der Benutzer zieht die <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieser Befehl benachrichtigt den <see cref="T:System.Windows.Controls.ScrollViewer" />, dass der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> der vertikalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> auf den Wert zieht, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer zieht das Thumb-Steuerelement von einem <xref:System.Windows.Controls.Primitives.ScrollBar>, <xref:System.Windows.Controls.Primitives.ScrollBar> Aufrufe <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> für die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand>. Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> gibt `true`, <xref:System.Windows.Controls.Primitives.ScrollBar> führt diese aus.  Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> gibt `false`, <xref:System.Windows.Controls.Primitives.ScrollBar> führt die <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand>.  
  
 Die <xref:System.Windows.Controls.ScrollViewer> mit diesem Befehl wird verwendet, um verzögertes Scrollen zu aktivieren. Beim <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> ist `true` und ein Benutzer zieht die <xref:System.Windows.Controls.Primitives.Thumb> von der <xref:System.Windows.Controls.Primitives.ScrollBar>, die Inhalt der <xref:System.Windows.Controls.ScrollViewer> wird nicht geändert werden, bis der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb>. Wenn verzögerte Bildlauf aktiviert ist, die <xref:System.Windows.Controls.Primitives.ScrollBar> führt die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> bei einem vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar> Wenn der Benutzer zieht die <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> aktiviert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> aktiviert ist und die Größe des Inhalts den Anzeigebereich überschreitet, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung legt <xref:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore%2A> zu `true` nur, wenn die <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> Wert der <xref:System.Windows.Controls.Primitives.ScrollBar> ist größer als die <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> Wert und die <xref:System.Windows.Controls.Primitives.ScrollBar> aktiviert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl erhöht die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer die nach-unten-Taste drückt.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_LineDownCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.LineDownCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#LineDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl verringert die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert des der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer auf der linken Seite drückt <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_LineLeftCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.LineLeftCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#LineLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl erhöht die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer das Recht drückt <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_LineRightCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.LineRightCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#LineRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird reduziert die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in die <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert von der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer die nach-oben-Taste drückt.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_LineUpCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.LineUpCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#LineUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="scrollBar.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die visuelle Struktur für das <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung legt außerdem die <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> Eigenschaft, um die <xref:System.Windows.Controls.Primitives.Track> , definiert ist, der <xref:System.Windows.Controls.Primitives.ScrollBar> Vorlage.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Ereignis bereit, das auftritt, wenn das <see cref="T:System.Windows.Controls.ContextMenu" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ContextMenu> von einer <xref:System.Windows.Controls.Primitives.ScrollBar> bietet Optionen zum Ändern der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von der <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Ereignis bereit, das auftritt, wenn das <see cref="T:System.Windows.Controls.ContextMenu" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ContextMenu> von einer <xref:System.Windows.Controls.Primitives.ScrollBar> bietet Optionen zum Ändern der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von der <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="scrollBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> für dieses <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.ScrollBarAutomationPeer" /> für das <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />-Ereignis bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von der <xref:System.Windows.Controls.Primitives.ScrollBar> auf den Speicherort der der <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignis tritt auf, während der Benutzer die UMSCHALT-Taste drückt. Das Ereignis behandelt, indem <xref:System.Windows.RoutedEventArgs.Handled%2A> in den Ereignisdaten `e` zu `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />-Ereignis bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung speichert die Position des Mausklicks, damit die <xref:System.Windows.Controls.Primitives.ScrollBar> können einen Bildlauf durchführen, um diese Position als Reaktion auf eine <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand>.  
  
   
  
## Examples  
 Ein <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> tritt auf, wenn der Benutzer wählt **Bildlauf hier** aus dem Menü aus, die dargestellt, wenn wird der Benutzer drückt die rechte Maustaste über der <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); void set(System::Windows::Controls::Orientation value); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob die <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertikal oder horizontal angezeigt wird.</summary>
        <value>Ein <see cref="T:System.Windows.Controls.Orientation" />-Enumerationswert, der definiert, ob <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal oder vertikal angezeigt wird. Die Standardeinstellung ist <see cref="F:System.Windows.Controls.Orientation.Vertical" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen Sie die <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> -Eigenschaft für eine <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement.  
  
 [!code-csharp[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#orientation)]
 [!code-vb[ScrollBarSnips#Orientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#orientation)]
 [!code-xaml[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#orientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl erhöht die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer die Bild-ab-Taste drückt.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_PageDownCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.PageDownCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#PageDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl verringert die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert des der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer die Seite-Schaltfläche drückt, die auf der linken Seite von der <xref:System.Windows.Controls.Primitives.Thumb>. Die folgende Abbildung zeigt die Seitenschaltflächen in einem <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Die verschiedenen Teile einer Bildlaufleiste](~/add/media/scrollbarpagebutton.png "die verschiedenen Teile einer Bildlaufleiste")  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_PageLeftCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.PageLeftCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#PageLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl erhöht die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer die Seite-Schaltfläche drückt, die rechts neben der <xref:System.Windows.Controls.Primitives.Thumb>. Die folgende Abbildung zeigt die Seitenschaltflächen in einem <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Die verschiedenen Teile einer Bildlaufleiste](~/add/media/scrollbarpagebutton.png "die verschiedenen Teile einer Bildlaufleiste")  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_PageRightCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.PageRightCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#PageRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird reduziert die <xref:System.Windows.Controls.Primitives.Track.Value%2A> von der <xref:System.Windows.Controls.Primitives.Track> in die <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert von der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft.  
  
 Mit diesem Befehl tritt auf, wenn der Benutzer die Bild-auf-Taste drückt.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_PageUpCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.PageUpCommand**`"/>`  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand> in einem benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage.  
  
 [!code-xaml[ScrollBarTemplateExample#PageUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.Primitives.ScrollEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.Primitives.ScrollEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As ScrollEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::Primitives::ScrollEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " Usage="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.ScrollEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt einmal oder mehrmals auf, wenn der Inhalt einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschoben wird, während der Benutzer den <see cref="P:System.Windows.Controls.Primitives.Track.Thumb" /> mit dem Mauszeiger bewegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt normalerweise auf mehrere Male Wenn der Benutzer ändert die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von der <xref:System.Windows.Controls.Primitives.ScrollBar> durch Ziehen der <xref:System.Windows.Controls.Primitives.Track.Thumb%2A>. Es gibt keine Beschränkung der Anzahl der Male, die dieses Ereignis, als ausgelöst wird die <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> Position gezogen wird.  
  
 Dieses Ereignis ist nicht ausgelöst wird, wenn die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von der <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement im Code geändert wird.  
  
<a name="routedEventInfo_Scroll"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.Windows.Controls.Primitives.ScrollEventHandler>|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie weisen einen Ereignishandler für die <xref:System.Windows.Controls.Primitives.ScrollBar.Scroll> Ereignis, um eine <xref:System.Windows.Controls.Primitives.ScrollBar> -Steuerelement, und wie den Ereignishandler im Code definiert.  
  
 [!code-xaml[ScrollBarSnips#Scroll](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scroll)]  
  
 [!code-csharp[ScrollBarSnips#ScrollHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#scrollhandler)]
 [!code-vb[ScrollBarSnips#ScrollHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#scrollhandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollHereCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollHereCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollHereCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollHereCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollHereCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollHereCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> an den Punkt verschiebt, an dem durch einen Mausklick das <see cref="T:System.Windows.Controls.ContextMenu" /> in der <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> aufgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl tritt auf, wenn der Benutzer auswählt **Bildlauf hier** aus der <xref:System.Windows.Controls.ContextMenu> Optionen. Die <xref:System.Windows.Controls.ContextMenu> von der <xref:System.Windows.Controls.Primitives.ScrollBar> angezeigt wird, wenn der Benutzer den Mauszeiger über hält die <xref:System.Windows.Controls.Primitives.ScrollBar> und drückt die rechte Maustaste gedrückt. Dieses Menü bietet Optionen für den Bildlauf der <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Dieser Befehl ist für eine <xref:System.Windows.Controls.Primitives.ScrollBar> Teil einer <xref:System.Windows.Controls.ScrollViewer> steuern und wird ausgeführt, indem die <xref:System.Windows.Controls.ScrollViewer>.  
  
<a name="xamlTextUsage_ScrollHereCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="` **ScrollBar.ScrollHereCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottomCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToBottomCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToBottomCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToBottomCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToBottomCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToBottomCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einem vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar>, tritt diese Bewegung auf, wenn Benutzer die Tasten STRG + ENDE drücken.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToBottomCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.ScrollToBottomCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der den Inhalt zur unteren rechten Ecke eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Steuerelements verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird nur verwendet, mit einem <xref:System.Windows.Controls.ScrollViewer> Steuerelement.  
  
<a name="xamlTextUsage_ScrollToEndCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.ScrollToEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHomeCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHomeCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHomeCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHomeCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHomeCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHomeCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der den Inhalt zur oberen linken Ecke eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Steuerelements verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird nur verwendet, mit einem <xref:System.Windows.Controls.ScrollViewer> Steuerelement.  
  
<a name="xamlTextUsage_ScrollToHomeCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.ScrollToHomeCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine horizontale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> zu dem Wert verschiebt, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird nur verwendet, mit einem <xref:System.Windows.Controls.ScrollViewer> Steuerelement.  
  
<a name="xamlTextUsage_ScrollToHorizontalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.ScrollToHorizontalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToLeftEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToLeftEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToLeftEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToLeftEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToLeftEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Minimum" />-Wert einer horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl tritt auf, wenn der Benutzer die Tasten STRG + POS1 bei einem horizontalen drückt <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToLeftEndCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="` **ScrollBar.ScrollToLeftEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToRightEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToRightEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToRightEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToRightEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToRightEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert einer horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl tritt auf, wenn der Benutzer die Tasten STRG + Ende bei einer horizontalen drückt <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToRightEndCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="` **ScrollBar.ScrollToRightEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTopCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToTopCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToTopCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToTopCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToTopCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToTopCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert einer vertikalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einem vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar>, tritt diese Bewegung auf, wenn der Benutzer die Tasten STRG + POS1 drückt.  
  
 Bei der Implementierung einer <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil einer <xref:System.Windows.Controls.ScrollViewer> -Steuerelement, die <xref:System.Windows.Controls.ScrollViewer> führt diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToTopCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.ScrollToTopCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine vertikale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> zu dem Wert verschiebt, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird nur verwendet, mit einem <xref:System.Windows.Controls.ScrollViewer> Steuerelement.  
  
<a name="xamlTextUsage_ScrollToVerticalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 `<` *object* *property*`="`**ScrollBar.ScrollToVerticalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Track">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.Track Track { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.Track Track" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Track As Track" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::Track ^ Track { System::Windows::Controls::Primitives::Track ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Track : System.Windows.Controls.Primitives.Track" Usage="System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.Track</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Controls.Primitives.Track" /> für ein <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement ab.</summary>
        <value>Der <see cref="T:System.Windows.Controls.Primitives.Track" />, der mit einem <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine typische Style-Vorlage für eine <xref:System.Windows.Controls.Primitives.ScrollBar> -Steuerelement enthält eine <xref:System.Windows.Controls.Primitives.Track> -Steuerelement, das auf beiden Seiten, durch zwei eingeschlossen ist <xref:System.Windows.Controls.Button> Steuerelemente.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie den Zugriff auf die <xref:System.Windows.Controls.Primitives.Track> -Steuerelement, das verwendet wird, mit einem <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement.  
  
 [!code-csharp[ScrollBarSnips#Track](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#track)]
 [!code-vb[ScrollBarSnips#Track](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#track)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSize">
      <MemberSignature Language="C#" Value="public double ViewportSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewportSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ViewportSize : double with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des aktuell sichtbaren verschiebbaren Inhalts ab bzw. legt diesen fest.</summary>
        <value>Die Größe des aktuell sichtbaren Teils des bildlauffähigen Inhalts. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheiten für die verwendeten <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> sind die gleichen Einheiten, die zum Beschreiben der Länge des Inhalts verwendet werden. Beispiele hierfür sind Textzeilen oder Seiten des Texts.  
  
 Der Wert des der <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> Eigenschaft wird verwendet, um die Berechnung der Größe der <xref:System.Windows.Controls.Primitives.Thumb> -Steuerelement, das als gleitenden Wert Indikators in angezeigt wird eine <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement. Die <xref:System.Windows.Controls.Primitives.Thumb> Größe des Steuerelements darstellt, die Menge an eine <xref:System.Windows.Controls.ScrollViewer> den Inhalt des Steuerelements, das sichtbar ist.  Wenn 25 Prozent der ein <xref:System.Windows.Controls.ScrollViewer> den Inhalt des Steuerelements sichtbar ist, wird die <xref:System.Windows.Controls.Primitives.Thumb> beansprucht 25 Prozent der Spur in die <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Sie können entscheiden, welche Einheiten <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> verwendet.  Wenn Sie diese Eigenschaft festlegen, stellen sicher, dass die <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A>, und <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> Eigenschaften verwenden die gleichen Einheiten.  
  
 Die folgende Abbildung zeigt die <xref:System.Windows.Controls.Primitives.Thumb> Größe gibt die Menge an Inhalt, der angezeigt wird.  
  
 ![Die Länge und Ziehpunktgröße einer ScrollBar](~/add/media/scrollbarthumbsize.png "die Länge und Ziehpunktgröße einer ScrollBar")  
  
<a name="dependencyPropertyInfo_ViewportSize"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|None|  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen Sie die <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> auf eine <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement.  
  
 [!code-csharp[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#viewport)]
 [!code-vb[ScrollBarSnips#Viewport](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#viewport)]
 [!code-xaml[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#viewport)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>