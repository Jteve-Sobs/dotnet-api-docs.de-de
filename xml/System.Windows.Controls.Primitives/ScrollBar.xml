<Type Name="ScrollBar" FullName="System.Windows.Controls.Primitives.ScrollBar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="62a7e0cc52d58c4ceb2e351784e4d8d9f81b55f4" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82499035" /></Metadata><TypeSignature Language="C#" Value="public class ScrollBar : System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ScrollBar extends System.Windows.Controls.Primitives.RangeBase" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ScrollBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollBar&#xA;Inherits RangeBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollBar : System::Windows::Controls::Primitives::RangeBase" />
  <TypeSignature Language="F#" Value="type ScrollBar = class&#xA;    inherit RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollBar extends System.Windows.Controls.Primitives.RangeBase" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.RangeBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Steuerelement dar, das eine Schiebeleiste mit einem verschiebbaren <see cref="T:System.Windows.Controls.Primitives.Thumb" /> bereitstellt, dessen Position einem Wert entspricht.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Abbildung zeigt ein <xref:System.Windows.Controls.Primitives.ScrollBar>-Steuerelement.  
  
 ![Darstellung der Scrollleiste](~/add/media/scrollbar-illustration.JPG "Abbildung der Schiebeleiste")  
  
 Das <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement enthält ein <xref:System.Windows.Controls.Primitives.Track>-Steuerelement. Das <xref:System.Windows.Controls.Primitives.Track> Steuerelement besteht aus einem <xref:System.Windows.Controls.Primitives.Thumb>-Steuerelement und zwei <xref:System.Windows.Controls.Primitives.RepeatButton>-Steuerelementen. Sie können die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A>-Eigenschaft des <xref:System.Windows.Controls.Primitives.ScrollBar> Steuer Elements vergrößern und verkleinern, indem Sie die <xref:System.Windows.Controls.Primitives.RepeatButton>-Steuerelemente drücken oder die <xref:System.Windows.Controls.Primitives.Thumb>verschieben. Der Standardwerte Bereich für die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A>-Eigenschaft liegt zwischen 0 und 1. Der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> der den linearen Abstand des <xref:System.Windows.Controls.Primitives.Thumb> zwischen den Endpunkten der <xref:System.Windows.Controls.Primitives.ScrollBar>darstellt. Sie können den Standardbereich der Werte ändern, indem Sie die Eigenschaften <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> und <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> festlegen. Die <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A>-Eigenschaft bestimmt, ob die <xref:System.Windows.Controls.Primitives.ScrollBar> horizontal oder vertikal angezeigt wird, und Sie müssen diese Eigenschaft definieren, damit das <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement angezeigt wird.  
  
 Der <xref:System.Windows.Controls.Primitives.Track> in einer <xref:System.Windows.Controls.Primitives.ScrollBar> ist so ausgerichtet, dass die Werte für eine vertikale <xref:System.Windows.Controls.Primitives.ScrollBar> von oben nach unten oder von links nach rechts für ein horizontales <xref:System.Windows.Controls.Primitives.ScrollBar>erhöht werden.  
  
 Die <xref:System.Windows.Controls.Primitives.Track> Eigenschaften in der folgenden Tabelle sind die Bindungs Ziele für die entsprechenden <xref:System.Windows.Controls.Primitives.ScrollBar> Eigenschaften, wenn die <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A>-Eigenschaft nicht explizit definiert ist. Wenn Sie die <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A>-Eigenschaft explizit definieren, erfolgt keine Bindung.  
  
|<xref:System.Windows.Controls.Primitives.Track>-Eigenschaft|<xref:System.Windows.Controls.Primitives.ScrollBar>-Eigenschaft|  
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.Primitives.Track.Maximum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Minimum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Value%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A?displayProperty=nameWithType>|  
  
 Mithilfe der <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A>-Eigenschaft können Sie auf das <xref:System.Windows.Controls.Primitives.Track> Steuerelement eines <xref:System.Windows.Controls.Primitives.ScrollBar> Steuer Elements zugreifen.  
  
 Verwenden Sie das <xref:System.Windows.Controls.ScrollViewer>-Steuerelement, um <xref:System.Windows.UIElement> Inhalt in einem Feld mit Bild Lauf leisten anzuzeigen.  
  
## <a name="customizing-the-scrollbar-control"></a>Anpassen des ScrollBar-Steuer Elements  
 Um dieselben Eigenschaften Einstellungen auf mehrere <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelemente anzuwenden, verwenden Sie die <xref:System.Windows.FrameworkElement.Style%2A>-Eigenschaft. Sie können die Standard <xref:System.Windows.Controls.ControlTemplate> ändern, um dem Steuerelement eine eindeutige Darstellung zu verschaffen. Weitere Informationen zum Erstellen eines <xref:System.Windows.Controls.ControlTemplate>finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Informationen zu den für die <xref:System.Windows.Controls.Primitives.ScrollBar>spezifischen Teilen und Zuständen finden Sie unter [ScrollBar-Stile und-Vorlagen](~/docs/framework/wpf/controls/scrollbar-styles-and-templates.md).  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein horizontales <xref:System.Windows.Controls.Primitives.ScrollBar> erstellt wird, das einen Wertebereich zwischen 0 und 100 aufweist.  
  
 [!code-xaml[ScrollBarSnips#ScrollBar](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scrollbar)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.RangeBase" />
    <altmember cref="T:System.Windows.Controls.Primitives.Track" />
    <altmember cref="T:System.Windows.Controls.Primitives.Thumb" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieser Befehl benachrichtigt den <see cref="T:System.Windows.Controls.ScrollViewer" />, dass der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> der horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> auf den Wert zieht, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer den Ziehpunkt eines <xref:System.Windows.Controls.Primitives.ScrollBar>zieht, ruft der <xref:System.Windows.Controls.Primitives.ScrollBar> <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> für die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand>auf. Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> `true`zurückgibt, führt der <xref:System.Windows.Controls.Primitives.ScrollBar> den Befehl aus.  Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> `false`zurückgibt, führt der <xref:System.Windows.Controls.Primitives.ScrollBar> den <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand>aus.  
  
 Der <xref:System.Windows.Controls.ScrollViewer> verwendet diesen Befehl, um den verzögerten Bildlauf zu aktivieren. Wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> `true` und ein Benutzer die <xref:System.Windows.Controls.Primitives.Thumb> der <xref:System.Windows.Controls.Primitives.ScrollBar>zieht, ändert sich der Inhalt des <xref:System.Windows.Controls.ScrollViewer> erst, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>freigibt. Wenn der verzögerte Bildlauf aktiviert ist, führt der <xref:System.Windows.Controls.Primitives.ScrollBar> die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> für einen horizontalen <xref:System.Windows.Controls.Primitives.ScrollBar> aus, wenn der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb>zieht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieser Befehl benachrichtigt den <see cref="T:System.Windows.Controls.ScrollViewer" />, dass der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> der vertikalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> auf den Wert zieht, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer den Ziehpunkt eines <xref:System.Windows.Controls.Primitives.ScrollBar>zieht, ruft der <xref:System.Windows.Controls.Primitives.ScrollBar> <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> für die <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand>auf. Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> `true`zurückgibt, führt der <xref:System.Windows.Controls.Primitives.ScrollBar> den Befehl aus.  Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> `false`zurückgibt, führt der <xref:System.Windows.Controls.Primitives.ScrollBar> den <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand>aus.  
  
 Der <xref:System.Windows.Controls.ScrollViewer> verwendet diesen Befehl, um den verzögerten Bildlauf zu aktivieren. Wenn <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> `true` und ein Benutzer die <xref:System.Windows.Controls.Primitives.Thumb> der <xref:System.Windows.Controls.Primitives.ScrollBar>zieht, ändert sich der Inhalt des <xref:System.Windows.Controls.ScrollViewer> erst, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.Thumb>freigibt. Wenn der verzögerte Bildlauf aktiviert ist, führt der <xref:System.Windows.Controls.Primitives.ScrollBar> den <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> für eine vertikale <xref:System.Windows.Controls.Primitives.ScrollBar> aus, wenn der Benutzer die <xref:System.Windows.Controls.Primitives.Thumb>zieht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> aktiviert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> aktiviert ist und die Größe des Inhalts den Anzeigebereich überschreitet, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung legt <xref:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore%2A> nur `true` fest, wenn der <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> Wert des <xref:System.Windows.Controls.Primitives.ScrollBar> größer als der <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> Wert und die <xref:System.Windows.Controls.Primitives.ScrollBar> aktiviert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> im <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A>-Eigenschaft erhöht.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die nach-unten-Taste drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_LineDownCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. LineDownCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A>-Eigenschaft verringert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die linke <xref:System.Windows.Controls.Primitives.RepeatButton>drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_LineLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. LineLeftCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> im <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A>-Eigenschaft erhöht.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Rechte <xref:System.Windows.Controls.Primitives.RepeatButton>drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_LineRightCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. LineRightCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> im <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A>-Eigenschaft reduziert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die nach-oben-Taste drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_LineUpCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. LineUpCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="scrollBar.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die visuelle Struktur für das <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung legt auch die <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A>-Eigenschaft auf den <xref:System.Windows.Controls.Primitives.Track> fest, der in der <xref:System.Windows.Controls.Primitives.ScrollBar>-Vorlage definiert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Ereignis bereit, das auftritt, wenn das <see cref="T:System.Windows.Controls.ContextMenu" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.ContextMenu> eines <xref:System.Windows.Controls.Primitives.ScrollBar> bietet Optionen zum Ändern der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> des <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Ereignis bereit, das auftritt, wenn das <see cref="T:System.Windows.Controls.ContextMenu" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.ContextMenu> eines <xref:System.Windows.Controls.Primitives.ScrollBar> bietet Optionen zum Ändern der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> des <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="scrollBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> für dieses <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.ScrollBarAutomationPeer" /> für das <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />-Ereignis bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> der <xref:System.Windows.Controls.Primitives.ScrollBar> in den Speicherort des <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignisses, das auftritt, während der Benutzer die UMSCHALTTASTE drückt. Das Ereignis wird behandelt, indem <xref:System.Windows.RoutedEventArgs.Handled%2A> in den Ereignisdaten `e` auf `true`festgelegt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />-Ereignis bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung speichert die Position des Mausklicks, sodass der <xref:System.Windows.Controls.Primitives.ScrollBar> als Reaktion auf einen <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand>einen Bildlauf zu dieser Position durchführen kann.  
  
   
  
## Examples  
 Eine <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> tritt auf, wenn der Benutzer im Menü, das angezeigt wird, wenn der Benutzer mit der rechten Maustaste auf die <xref:System.Windows.Controls.Primitives.ScrollBar>drückt, einen Bildlauf **hier** auswählt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); void set(System::Windows::Controls::Orientation value); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob die <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertikal oder horizontal angezeigt wird.</summary>
        <value>Ein <see cref="T:System.Windows.Controls.Orientation" />-Enumerationswert, der definiert, ob <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal oder vertikal angezeigt wird. Der Standardwert lautet <see cref="F:System.Windows.Controls.Orientation.Vertical" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A>-Eigenschaft für ein <xref:System.Windows.Controls.Primitives.ScrollBar>-Steuerelement festgelegt wird.  
  
 [!code-csharp[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#orientation)]
 [!code-vb[ScrollBarSnips#Orientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#orientation)]
 [!code-xaml[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#orientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> im <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A>-Eigenschaft erhöht.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Bild-ab-Taste drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_PageDownCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. PageDownCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A>-Eigenschaft verringert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Seiten Schaltfläche auf der linken Seite des <xref:System.Windows.Controls.Primitives.Thumb>drückt. Die folgende Abbildung zeigt die Seiten Schaltflächen in einem <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Die verschiedenen Teile einer Scrollleiste](~/add/media/scrollbarpagebutton.png "Die unterschiedlichen Teil einer ScrollBar")  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_PageLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. PageLeftCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> im <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A>-Eigenschaft erhöht.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Seiten Schaltfläche auf der rechten Seite des <xref:System.Windows.Controls.Primitives.Thumb>drückt. Die folgende Abbildung zeigt die Seiten Schaltflächen in einem <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Die verschiedenen Teile einer Scrollleiste](~/add/media/scrollbarpagebutton.png "Die unterschiedlichen Teil einer ScrollBar")  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_PageRightCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. PageRightCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die <xref:System.Windows.Controls.Primitives.Track.Value%2A> der <xref:System.Windows.Controls.Primitives.Track> im <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A>-Eigenschaft reduziert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Bild-auf-Taste drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_PageUpCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. PageUpCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand> in einer benutzerdefinierten Vorlage für <xref:System.Windows.Controls.Primitives.ScrollBar> Stile angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.Primitives.ScrollEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.Primitives.ScrollEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As ScrollEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::Primitives::ScrollEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " Usage="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.ScrollEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt einmal oder mehrmals auf, wenn der Inhalt einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschoben wird, während der Benutzer den <see cref="P:System.Windows.Controls.Primitives.Track.Thumb" /> mit dem Mauszeiger bewegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt in der Regel mehrmals auf, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> des <xref:System.Windows.Controls.Primitives.ScrollBar> durchziehen des <xref:System.Windows.Controls.Primitives.Track.Thumb%2A>ändert. Es gibt keine Beschränkung für die Häufigkeit, mit der dieses Ereignis ausgelöst wird, wenn die <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> Position gezogen wird.  
  
 Dieses Ereignis wird nicht ausgelöst, wenn die <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> des <xref:System.Windows.Controls.Primitives.ScrollBar> Steuer Elements im Code geändert wird.  
  
<a name="routedEventInfo_Scroll"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.Primitives.ScrollEventHandler>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Ereignishandler für das <xref:System.Windows.Controls.Primitives.ScrollBar.Scroll>-Ereignis einem <xref:System.Windows.Controls.Primitives.ScrollBar>-Steuerelement zugewiesen wird und wie der Ereignishandler im Code definiert wird.  
  
 [!code-xaml[ScrollBarSnips#Scroll](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scroll)]  
  
 [!code-csharp[ScrollBarSnips#ScrollHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#scrollhandler)]
 [!code-vb[ScrollBarSnips#ScrollHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#scrollhandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollHereCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollHereCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollHereCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollHereCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollHereCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollHereCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> an den Punkt verschiebt, an dem durch einen Mausklick das <see cref="T:System.Windows.Controls.ContextMenu" /> in der <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> aufgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl tritt auf, wenn der Benutzer einen Bildlauf **hier** aus den <xref:System.Windows.Controls.ContextMenu> Optionen auswählt. Der <xref:System.Windows.Controls.ContextMenu> der <xref:System.Windows.Controls.Primitives.ScrollBar> wird angezeigt, wenn der Benutzer den Mauszeiger über die <xref:System.Windows.Controls.Primitives.ScrollBar> hält und mit der rechten Maustaste drückt. Dieses Menü enthält Optionen zum Scrollen der <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Dieser Befehl ist für eine <xref:System.Windows.Controls.Primitives.ScrollBar>, die Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements ist und vom <xref:System.Windows.Controls.ScrollViewer>ausgeführt wird.  
  
<a name="xamlTextUsage_ScrollHereCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="` **ScrollBar. ScrollHereCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottomCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToBottomCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToBottomCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToBottomCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToBottomCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToBottomCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einem vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar>tritt diese Bewegung auf, wenn der Benutzer die STRG + Ende-Taste drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToBottomCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. ScrollTo bottomcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der den Inhalt zur unteren rechten Ecke eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Steuerelements verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem <xref:System.Windows.Controls.ScrollViewer>-Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToEndCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. ScrollTo endcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHomeCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHomeCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHomeCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHomeCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHomeCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHomeCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der den Inhalt zur oberen linken Ecke eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Steuerelements verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem <xref:System.Windows.Controls.ScrollViewer>-Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToHomeCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. scrolldohomecommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine horizontale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> zu dem Wert verschiebt, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem <xref:System.Windows.Controls.ScrollViewer>-Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToHorizontalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. Scroll**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToLeftEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToLeftEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToLeftEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToLeftEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToLeftEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Minimum" />-Wert einer horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl tritt auf, wenn der Benutzer die Tastenkombination Strg + Home für ein horizontales <xref:System.Windows.Controls.Primitives.ScrollBar>drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToLeftEndCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="` **ScrollBar. scrolltoleftendcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToRightEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToRightEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToRightEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToRightEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToRightEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert einer horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl tritt auf, wenn der Benutzer die Tasten STRG + Ende für ein horizontales <xref:System.Windows.Controls.Primitives.ScrollBar>drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToRightEndCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="` **ScrollBar. scrolltorightendcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTopCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToTopCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToTopCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToTopCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToTopCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToTopCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert einer vertikalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einem vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar>tritt diese Bewegung auf, wenn der Benutzer die Strg + Home-Taste drückt.  
  
 Wenn Sie eine <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements implementieren, führt der <xref:System.Windows.Controls.ScrollViewer> diesen Befehl aus.  
  
<a name="xamlTextUsage_ScrollToTopCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. ScrollTo topcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine vertikale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> zu dem Wert verschiebt, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem <xref:System.Windows.Controls.ScrollViewer>-Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToVerticalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<` *Objekt* *Eigenschaft*`="`**ScrollBar. scrolltverticaloffsetcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Track">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.Track Track { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.Track Track" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Track As Track" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::Track ^ Track { System::Windows::Controls::Primitives::Track ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Track : System.Windows.Controls.Primitives.Track" Usage="System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.Track</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Controls.Primitives.Track" /> für ein <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement ab.</summary>
        <value>Der <see cref="T:System.Windows.Controls.Primitives.Track" />, der mit einem <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine typische Stilvorlage für ein <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement enthält ein <xref:System.Windows.Controls.Primitives.Track> Steuerelement, das Nebeneinander von zwei <xref:System.Windows.Controls.Button> Steuerelementen umgeben ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie auf das <xref:System.Windows.Controls.Primitives.Track> Steuerelement zugegriffen wird, das mit einem <xref:System.Windows.Controls.Primitives.ScrollBar>-Steuerelement verwendet wird.  
  
 [!code-csharp[ScrollBarSnips#Track](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#track)]
 [!code-vb[ScrollBarSnips#Track](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#track)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSize">
      <MemberSignature Language="C#" Value="public double ViewportSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewportSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ViewportSize : double with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des aktuell sichtbaren verschiebbaren Inhalts ab bzw. legt diesen fest.</summary>
        <value>Die Größe des aktuell sichtbaren Teils des bildlauffähigen Inhalts. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheiten, die für <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> verwendet werden, sind die gleichen Einheiten, die zum Beschreiben der Länge des Inhalts verwendet werden. Einige Beispiele sind Textzeilen oder Textseiten.  
  
 Der Wert der <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A>-Eigenschaft wird verwendet, um die Größe des <xref:System.Windows.Controls.Primitives.Thumb> Steuer Elements zu berechnen, das als Indikator für gleitenden Wert in einem <xref:System.Windows.Controls.Primitives.ScrollBar>-Steuerelement angezeigt wird. Die Größe des <xref:System.Windows.Controls.Primitives.Thumb> Steuer Elements stellt die Größe des sichtbaren Inhalts eines <xref:System.Windows.Controls.ScrollViewer> Steuer Elements dar.  Wenn 25 Prozent der Inhalte eines <xref:System.Windows.Controls.ScrollViewer>-Steuer Elements sichtbar sind, belegt der <xref:System.Windows.Controls.Primitives.Thumb> 25 Prozent der Spur im <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Sie können entscheiden, welche Einheiten <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> verwendet.  Wenn Sie diese Eigenschaft festlegen, stellen Sie sicher, dass die Eigenschaften <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A>und <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> dieselben Einheiten verwenden.  
  
 In der folgenden Abbildung wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.Thumb> Größe die Menge an sichtbarem Inhalt widerspiegelt.  
  
 ![Die Tracklänge und die Finger Größe einer Scrollleiste.](~/add/media/scrollbarthumbsize.png "Die Länge und Ziehpunktgröße einer ScrollBar")  
  
<a name="dependencyPropertyInfo_ViewportSize"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> für ein <xref:System.Windows.Controls.Primitives.ScrollBar>-Steuerelement festgelegt wird.  
  
 [!code-csharp[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#viewport)]
 [!code-vb[ScrollBarSnips#Viewport](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#viewport)]
 [!code-xaml[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#viewport)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
