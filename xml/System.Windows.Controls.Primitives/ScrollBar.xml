<Type Name="ScrollBar" FullName="System.Windows.Controls.Primitives.ScrollBar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b98c63d3d0f5b21e027def425f3a07619f00ae9e" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86712558" /></Metadata><TypeSignature Language="C#" Value="public class ScrollBar : System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ScrollBar extends System.Windows.Controls.Primitives.RangeBase" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ScrollBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollBar&#xA;Inherits RangeBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollBar : System::Windows::Controls::Primitives::RangeBase" />
  <TypeSignature Language="F#" Value="type ScrollBar = class&#xA;    inherit RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollBar extends System.Windows.Controls.Primitives.RangeBase" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.RangeBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Steuerelement dar, das eine Schiebeleiste mit einem verschiebbaren <see cref="T:System.Windows.Controls.Primitives.Thumb" /> bereitstellt, dessen Position einem Wert entspricht.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Abbildung zeigt ein- <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement.  
  
 ![Abbildung der Schiebeleiste](~/add/media/scrollbar-illustration.JPG "Abbildung der Schiebeleiste")  
  
 Das- <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement enthält ein- <xref:System.Windows.Controls.Primitives.Track> Steuerelement. Das <xref:System.Windows.Controls.Primitives.Track> Steuerelement besteht aus einem <xref:System.Windows.Controls.Primitives.Thumb> -Steuerelement und zwei-Steuer <xref:System.Windows.Controls.Primitives.RepeatButton> Elementen. Sie können die-Eigenschaft des-Steuer Elements vergrößern und verkleinern, <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> <xref:System.Windows.Controls.Primitives.ScrollBar> indem Sie die Steuer <xref:System.Windows.Controls.Primitives.RepeatButton> Elemente drücken oder die verschieben <xref:System.Windows.Controls.Primitives.Thumb> . Der Standardwerte Bereich für die- <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> Eigenschaft liegt zwischen 0 und 1. Der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> stellt die lineare Entfernung des <xref:System.Windows.Controls.Primitives.Thumb> zwischen den Endpunkten von dar <xref:System.Windows.Controls.Primitives.ScrollBar> . Sie können den Standardbereich der Werte ändern, indem Sie <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> die <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> Eigenschaften und festlegen. Die <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> -Eigenschaft bestimmt, ob der <xref:System.Windows.Controls.Primitives.ScrollBar> horizontal oder vertikal angezeigt wird, und Sie müssen diese Eigenschaft definieren, damit das Steuerelement angezeigt wird <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 Der <xref:System.Windows.Controls.Primitives.Track> in einer <xref:System.Windows.Controls.Primitives.ScrollBar> ist so ausgerichtet, dass die Werte für einen horizontalen von oben nach unten <xref:System.Windows.Controls.Primitives.ScrollBar> oder von links nach rechts vergrößert werden <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 Die <xref:System.Windows.Controls.Primitives.Track> Eigenschaften in der folgenden Tabelle sind die Bindungs Ziele für die entsprechenden <xref:System.Windows.Controls.Primitives.ScrollBar> Eigenschaften, wenn die <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> Eigenschaft nicht explizit definiert ist. Wenn Sie die Eigenschaft explizit definieren <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> , erfolgt keine Bindung.  
  
|<xref:System.Windows.Controls.Primitives.Track>-Eigenschaft|<xref:System.Windows.Controls.Primitives.ScrollBar>-Eigenschaft|  
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.Primitives.Track.Maximum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Minimum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Value%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A?displayProperty=nameWithType>|  
  
 Mithilfe der-Eigenschaft können Sie auf das Steuerelement eines-Steuer Elements zugreifen <xref:System.Windows.Controls.Primitives.Track> <xref:System.Windows.Controls.Primitives.ScrollBar> <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> .  
  
 Verwenden Sie das-Steuerelement, um <xref:System.Windows.UIElement> Inhalt in einem Feld mit Bild Lauf leisten anzuzeigen <xref:System.Windows.Controls.ScrollViewer> .  
  
## <a name="customizing-the-scrollbar-control"></a>Anpassen des ScrollBar-Steuer Elements  
 Verwenden Sie die-Eigenschaft, um die gleichen Eigenschaften Einstellungen auf mehrere Steuer <xref:System.Windows.Controls.Primitives.ScrollBar> Elemente anzuwenden <xref:System.Windows.FrameworkElement.Style%2A> . Sie können die Standardeinstellung ändern <xref:System.Windows.Controls.ControlTemplate> , um dem Steuerelement eine eindeutige Darstellung zu verschaffen. Weitere Informationen zum Erstellen einer <xref:System.Windows.Controls.ControlTemplate> finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control).  Informationen zu den Teilen und Zuständen, die für spezifisch sind <xref:System.Windows.Controls.Primitives.ScrollBar> , finden Sie unter [ScrollBar-Stile und-Vorlagen](/dotnet/framework/wpf/controls/scrollbar-styles-and-templates).  
  
 Abhängigkeits Eigenschaften für dieses Steuerelement können durch den Standardstil des Steuer Elements festgelegt werden.  Wenn eine Eigenschaft durch einen Standardstil festgelegt wird, kann sich die Eigenschaft von ihrem Standardwert ändern, wenn das Steuerelement in der Anwendung angezeigt wird. Der Standardstil wird bestimmt, welches Desktop Design verwendet wird, wenn die Anwendung ausgeführt wird.  Weitere Informationen finden Sie unter [standardmäßige WPF](https://go.microsoft.com/fwlink/?LinkID=158252)-Designs.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein horizontales erstellt wird <xref:System.Windows.Controls.Primitives.ScrollBar> , das einen Wertebereich zwischen 0 und 100 aufweist.  
  
 [!code-xaml[ScrollBarSnips#ScrollBar](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scrollbar)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.RangeBase" />
    <altmember cref="T:System.Windows.Controls.Primitives.Track" />
    <altmember cref="T:System.Windows.Controls.Primitives.Thumb" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieser Befehl benachrichtigt den <see cref="T:System.Windows.Controls.ScrollViewer" />, dass der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> der horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> auf den Wert zieht, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer den Ziehpunkt eines zieht <xref:System.Windows.Controls.Primitives.ScrollBar> , Ruft den <xref:System.Windows.Controls.Primitives.ScrollBar> <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> auf <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> . Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> zurückgibt `true` , <xref:System.Windows.Controls.Primitives.ScrollBar> führt den Befehl aus.  Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> zurückgibt `false` , <xref:System.Windows.Controls.Primitives.ScrollBar> führt den aus <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand> .  
  
 Der <xref:System.Windows.Controls.ScrollViewer> verwendet diesen Befehl, um verzögertes scrollen zu aktivieren. Wenn den Wert <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> `true` hat und ein Benutzer den <xref:System.Windows.Controls.Primitives.Thumb> von zieht <xref:System.Windows.Controls.Primitives.ScrollBar> , ändert sich der Inhalt des <xref:System.Windows.Controls.ScrollViewer> nicht, bis der Benutzer die loslässt <xref:System.Windows.Controls.Primitives.Thumb> . Wenn der verzögerte Bildlauf aktiviert ist, <xref:System.Windows.Controls.Primitives.ScrollBar> führt den <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> für einen horizontalen aus, <xref:System.Windows.Controls.Primitives.ScrollBar> Wenn der Benutzer das zieht <xref:System.Windows.Controls.Primitives.Thumb> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieser Befehl benachrichtigt den <see cref="T:System.Windows.Controls.ScrollViewer" />, dass der Benutzer den <see cref="T:System.Windows.Controls.Primitives.Thumb" /> der vertikalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> auf den Wert zieht, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer den Ziehpunkt eines zieht <xref:System.Windows.Controls.Primitives.ScrollBar> , Ruft den <xref:System.Windows.Controls.Primitives.ScrollBar> <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> auf <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> . Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> zurückgibt `true` , <xref:System.Windows.Controls.Primitives.ScrollBar> führt den Befehl aus.  Wenn <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> zurückgibt `false` , <xref:System.Windows.Controls.Primitives.ScrollBar> führt den aus <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand> .  
  
 Der <xref:System.Windows.Controls.ScrollViewer> verwendet diesen Befehl, um verzögertes scrollen zu aktivieren. Wenn den Wert <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> `true` hat und ein Benutzer den <xref:System.Windows.Controls.Primitives.Thumb> von zieht <xref:System.Windows.Controls.Primitives.ScrollBar> , ändert sich der Inhalt des <xref:System.Windows.Controls.ScrollViewer> nicht, bis der Benutzer die loslässt <xref:System.Windows.Controls.Primitives.Thumb> . Wenn der verzögerte Bildlauf aktiviert ist, <xref:System.Windows.Controls.Primitives.ScrollBar> führt den <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> für eine vertikale aus, <xref:System.Windows.Controls.Primitives.ScrollBar> Wenn der Benutzer das zieht <xref:System.Windows.Controls.Primitives.Thumb> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> aktiviert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> aktiviert ist und die Größe des Inhalts den Anzeigebereich überschreitet, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung legt <xref:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore%2A> auf fest, `true` Wenn der <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> Wert von <xref:System.Windows.Controls.Primitives.ScrollBar> größer als der <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> -Wert und <xref:System.Windows.Controls.Primitives.ScrollBar> aktiviert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft vergrößert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die nach-unten-Taste drückt.  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_LineDownCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. LineDownCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft verringert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die linke Taste drückt <xref:System.Windows.Controls.Primitives.RepeatButton> .  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_LineLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. LineLeftCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft vergrößert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Rechte drückt <xref:System.Windows.Controls.Primitives.RepeatButton> .  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_LineRightCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. LineRightCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen kleinen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> Eigenschaft reduziert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die nach-oben-Taste drückt.  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_LineUpCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. LineUpCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#LineUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="scrollBar.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die visuelle Struktur für das <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung legt auch die- <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> Eigenschaft auf die <xref:System.Windows.Controls.Primitives.Track> fest, die in der Vorlage definiert ist <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />-Ereignis bereit, das auftritt, wenn das <see cref="T:System.Windows.Controls.ContextMenu" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.ContextMenu> einer <xref:System.Windows.Controls.Primitives.ScrollBar> stellt Optionen zum Ändern des <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von bereit <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />-Ereignis bereit, das auftritt, wenn das <see cref="T:System.Windows.Controls.ContextMenu" /> einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> geöffnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Controls.ContextMenu> einer <xref:System.Windows.Controls.Primitives.ScrollBar> stellt Optionen zum Ändern des <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von bereit <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="scrollBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> für dieses <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement.</summary>
        <returns>Ein <see cref="T:System.Windows.Automation.Peers.ScrollBarAutomationPeer" /> für das <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />-Ereignis bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert den <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von <xref:System.Windows.Controls.Primitives.ScrollBar> in den Speicherort des <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignisses, das auftritt, während der Benutzer die UMSCHALTTASTE drückt. Das Ereignis wird durch Festlegen von <xref:System.Windows.RoutedEventArgs.Handled%2A> in den Ereignisdaten `e` auf behandelt `true` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />-Ereignis bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung speichert die Position des Mausklicks, sodass der <xref:System.Windows.Controls.Primitives.ScrollBar> einen Bildlauf zu dieser Position als Reaktion auf einen durchführen kann <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> .  
  
   
  
## Examples  
 Ein <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> tritt auf, wenn der Benutzer im Menü, das angezeigt wird, wenn der Benutzer mit der rechten Maustaste auf den klickt, einen Bildlauf **hier** auswählt <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); void set(System::Windows::Controls::Orientation value); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob die <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertikal oder horizontal angezeigt wird.</summary>
        <value>Ein <see cref="T:System.Windows.Controls.Orientation" />-Enumerationswert, der definiert, ob <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal oder vertikal angezeigt wird. Der Standardwert ist <see cref="F:System.Windows.Controls.Orientation.Vertical" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die- <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> Eigenschaft für ein-Steuerelement festgelegt wird <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 [!code-csharp[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#orientation)]
 [!code-vb[ScrollBarSnips#Orientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#orientation)]
 [!code-xaml[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#orientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft vergrößert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Bild-ab-Taste drückt.  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_PageDownCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. PageDownCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft verringert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Seiten Schaltfläche auf der linken Seite von drückt <xref:System.Windows.Controls.Primitives.Thumb> . Die folgende Abbildung zeigt die Seiten Schaltflächen in einer <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 ![Die unterschiedlichen Teile einer Scrollleiste](~/add/media/scrollbarpagebutton.png "Die unterschiedlichen Teile einer Scrollleiste")  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_PageLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. PageLeftCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der horizontalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert zunimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> um den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft vergrößert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer auf die Seiten Schaltfläche rechts neben drückt <xref:System.Windows.Controls.Primitives.Thumb> . Die folgende Abbildung zeigt die Seiten Schaltflächen in einer <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 ![Die unterschiedlichen Teile einer Scrollleiste](~/add/media/scrollbarpagebutton.png "Die unterschiedlichen Teile einer Scrollleiste")  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_PageRightCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. PageRightCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> einen großen Schritt in der vertikalen Richtung des <see cref="T:System.Windows.Controls.Primitives.Track" /> verschiebt, in der der Wert abnimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl <xref:System.Windows.Controls.Primitives.Track.Value%2A> wird der von <xref:System.Windows.Controls.Primitives.Track> in der <xref:System.Windows.Controls.Primitives.ScrollBar> durch den Wert der- <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> Eigenschaft reduziert.  
  
 Dieser Befehl tritt auf, wenn der Benutzer die Bild-auf-Taste drückt.  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_PageUpCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. PageUpCommand**`"/>`  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand> in einer benutzerdefinierten <xref:System.Windows.Controls.Primitives.ScrollBar> Stilvorlage angegeben wird.  
  
 [!code-xaml[ScrollBarTemplateExample#PageUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.Primitives.ScrollEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.Primitives.ScrollEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As ScrollEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::Primitives::ScrollEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " Usage="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Category("Behavior")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Behavior")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.ScrollEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt einmal oder mehrmals auf, wenn der Inhalt einer <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschoben wird, während der Benutzer den <see cref="P:System.Windows.Controls.Primitives.Track.Thumb" /> mit dem Mauszeiger bewegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt in der Regel mehrmals auf, wenn der Benutzer den <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> von <xref:System.Windows.Controls.Primitives.ScrollBar> durchziehen von ändert <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> . Es gibt keine Beschränkung für die Häufigkeit, mit der dieses Ereignis ausgelöst wird, wenn die <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> Position gezogen wird.  
  
 Dieses Ereignis wird nicht ausgelöst, wenn der <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> des <xref:System.Windows.Controls.Primitives.ScrollBar> Steuer Elements im Code geändert wird.  
  
<a name="routedEventInfo_Scroll"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Controls.Primitives.ScrollEventHandler>|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie einem-Steuerelement einen Ereignishandler für das <xref:System.Windows.Controls.Primitives.ScrollBar.Scroll> -Ereignis zuweist <xref:System.Windows.Controls.Primitives.ScrollBar> und wie der Ereignishandler im Code definiert wird.  
  
 [!code-xaml[ScrollBarSnips#Scroll](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scroll)]  
  
 [!code-csharp[ScrollBarSnips#ScrollHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#scrollhandler)]
 [!code-vb[ScrollBarSnips#ScrollHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#scrollhandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollHereCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollHereCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollHereCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollHereCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollHereCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollHereCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> an den Punkt verschiebt, an dem durch einen Mausklick das <see cref="T:System.Windows.Controls.ContextMenu" /> in der <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> aufgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl tritt auf, wenn der Benutzer einen Bildlauf **hier** aus den Optionen auswählt <xref:System.Windows.Controls.ContextMenu> . Der wird <xref:System.Windows.Controls.ContextMenu> <xref:System.Windows.Controls.Primitives.ScrollBar> angezeigt, wenn der Benutzer den Mauszeiger über das hält <xref:System.Windows.Controls.Primitives.ScrollBar> und mit der rechten Maustaste drückt. Dieses Menü enthält Optionen zum Durchführen eines Bildlaufs <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 Dieser Befehl ist für eine, <xref:System.Windows.Controls.Primitives.ScrollBar> die Teil eines <xref:System.Windows.Controls.ScrollViewer> -Steuer Elements ist und von ausgeführt wird <xref:System.Windows.Controls.ScrollViewer> .  
  
<a name="xamlTextUsage_ScrollHereCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. ScrollHereCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottomCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToBottomCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToBottomCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToBottomCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToBottomCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToBottomCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar> tritt diese Bewegung auf, wenn der Benutzer die STRG + Ende-Taste drückt.  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_ScrollToBottomCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. ScrollTo bottomcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der den Inhalt zur unteren rechten Ecke eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Steuerelements verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem- <xref:System.Windows.Controls.ScrollViewer> Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToEndCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. ScrollTo endcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHomeCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHomeCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHomeCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHomeCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHomeCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHomeCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der den Inhalt zur oberen linken Ecke eines <see cref="T:System.Windows.Controls.ScrollViewer" />-Steuerelements verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem- <xref:System.Windows.Controls.ScrollViewer> Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToHomeCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. ScrollTo homecommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine horizontale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> zu dem Wert verschiebt, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem- <xref:System.Windows.Controls.ScrollViewer> Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToHorizontalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. scrollskhorizontaloffsetcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToLeftEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToLeftEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToLeftEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToLeftEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToLeftEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Minimum" />-Wert einer horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl tritt auf, wenn der Benutzer die Tastenkombination Strg + Home für einen horizontalen drückt <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_ScrollToLeftEndCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. scrolltoleftendcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToRightEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToRightEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToRightEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToRightEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToRightEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert einer horizontalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl tritt auf, wenn der Benutzer die Tasten STRG + Ende für einen horizontalen drückt <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_ScrollToRightEndCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. scrolltorightendcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTopCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToTopCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToTopCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToTopCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToTopCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToTopCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> zum <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />-Wert einer vertikalen <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verschiebt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer vertikalen <xref:System.Windows.Controls.Primitives.ScrollBar> tritt diese Bewegung auf, wenn der Benutzer die Strg + Home-Taste drückt.  
  
 Wenn Sie ein-Element <xref:System.Windows.Controls.Primitives.ScrollBar> als Teil eines-Steuer Elements implementieren <xref:System.Windows.Controls.ScrollViewer> , führt den folgenden <xref:System.Windows.Controls.ScrollViewer> Befehl aus.  
  
<a name="xamlTextUsage_ScrollToTopCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. ScrollTo topcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Befehl, der eine vertikale <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> in einem <see cref="T:System.Windows.Controls.ScrollViewer" /> zu dem Wert verschiebt, der in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird nur mit einem- <xref:System.Windows.Controls.ScrollViewer> Steuerelement verwendet.  
  
<a name="xamlTextUsage_ScrollToVerticalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 `<`*Objekt* *Eigenschaft* `="` **ScrollBar. scrollskverticaloffsetcommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Track">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.Track Track { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.Track Track" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Track As Track" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::Track ^ Track { System::Windows::Controls::Primitives::Track ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Track : System.Windows.Controls.Primitives.Track" Usage="System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.Track</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Controls.Primitives.Track" /> für ein <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement ab.</summary>
        <value>Der <see cref="T:System.Windows.Controls.Primitives.Track" />, der mit einem <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />-Steuerelement verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine typische Stilvorlage für ein- <xref:System.Windows.Controls.Primitives.ScrollBar> Steuerelement enthält ein- <xref:System.Windows.Controls.Primitives.Track> Steuerelement, das Nebeneinander von zwei-Steuerelementen umgeben ist <xref:System.Windows.Controls.Button> .  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie auf das-Steuerelement zugreifen <xref:System.Windows.Controls.Primitives.Track> , das mit einem-Steuerelement verwendet wird <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 [!code-csharp[ScrollBarSnips#Track](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#track)]
 [!code-vb[ScrollBarSnips#Track](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#track)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSize">
      <MemberSignature Language="C#" Value="public double ViewportSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewportSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ViewportSize : double with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des aktuell sichtbaren verschiebbaren Inhalts ab bzw. legt diesen fest.</summary>
        <value>Die Größe des aktuell sichtbaren Teils des bildlauffähigen Inhalts. Die Standardeinstellung ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheiten, die für verwendet werden, <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> sind die gleichen Einheiten, die zum Beschreiben der Länge des Inhalts verwendet werden. Einige Beispiele sind Textzeilen oder Textseiten.  
  
 Der Wert der- <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> Eigenschaft wird verwendet, um die Größe des Steuer Elements zu berechnen <xref:System.Windows.Controls.Primitives.Thumb> , das als Indikator für gleitenden Wert in einem-Steuerelement angezeigt wird <xref:System.Windows.Controls.Primitives.ScrollBar> . Die <xref:System.Windows.Controls.Primitives.Thumb> Größe des Steuer Elements stellt die Größe des <xref:System.Windows.Controls.ScrollViewer> Inhalts eines Steuer Elements dar, das sichtbar ist.  Wenn 25 Prozent des <xref:System.Windows.Controls.ScrollViewer> Inhalts eines Steuer Elements sichtbar sind, <xref:System.Windows.Controls.Primitives.Thumb> belegt 25 Prozent der Spur in der <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 Sie können entscheiden, welche Einheiten <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> verwendet.  Wenn Sie diese Eigenschaft festlegen, stellen Sie sicher, dass die <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> Eigenschaften,, <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> und <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> dieselben Einheiten verwenden.  
  
 In der folgenden Abbildung wird gezeigt <xref:System.Windows.Controls.Primitives.Thumb> , wie die Größe den sichtbaren Inhalt widerspiegelt.  
  
 ![Die Länge und Ziehpunktgröße einer ScrollBar](~/add/media/scrollbarthumbsize.png "Die Länge und Ziehpunktgröße einer ScrollBar")  
  
<a name="dependencyPropertyInfo_ViewportSize"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie das auf einem-Steuerelement festgelegt wird <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> <xref:System.Windows.Controls.Primitives.ScrollBar> .  
  
 [!code-csharp[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#viewport)]
 [!code-vb[ScrollBarSnips#Viewport](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#viewport)]
 [!code-xaml[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#viewport)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
