<Type Name="Roles" FullName="System.Web.Security.Roles">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e4341b0577af2b91bb4cce3b802b7e04466f310" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30550794" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Roles" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Roles extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.Roles" />
  <TypeSignature Language="VB.NET" Value="Public Class Roles" />
  <TypeSignature Language="C++ CLI" Value="public ref class Roles abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet die Benutzermitgliedschaft in Rollen für die Autorisierungsüberprüfung in einer ASP.NET-Anwendung. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rollenverwaltung für ASP.NET können Sie zum Verwalten der Autorisierung für Ihre Anwendung basierend auf Gruppen von Benutzern, die als Rollen bezeichnet. Durch Zuweisen von Benutzern zu Rollen, können Sie den Zugriff auf verschiedene Teile oder Funktionen Ihrer Webanwendung basierend auf Rolle anstatt oder zusätzlich zu steuern, Autorisierung basierend auf Benutzernamen angeben. Z. B. eine Mitarbeiter-Anwendung möglicherweise Rollen wie z. B. Manager, Mitarbeiter, Direktoren und usw., in denen unterschiedliche Berechtigungen für die einzelnen Rollen angegeben sind.  
  
 Benutzer können mehr als einer Rolle angehören. Wenn Ihre Website ein Diskussionsforum ist, können einige Benutzer z. B. in der Rolle von Elementen und Moderatoren sein. Sie jede Rolle können so definiert verschiedene Administratorrechte für den Standort verfügen, und ein Benutzer in beiden Rollen würde dann beide Sätze von Berechtigungen verfügen.  
  
 Um Rollenverwaltung für Ihre ASP.NET-Anwendung zu aktivieren, verwenden Sie das Element der `system.web` in der Datei "Web.config" für Ihre Anwendung im Abschnitt, wie im folgenden Beispiel gezeigt.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
  <roleManager defaultProvider="SqlProvider"   
    enabled="true"  
    cacheRolesInCookie="true"  
    cookieName=".ASPROLES"  
    cookieTimeout="30"  
    cookiePath="/"  
    cookieRequireSSL="false"  
    cookieSlidingExpiration="true"  
    cookieProtection="All" >  
    <providers>  
      <add  
        name="SqlProvider"  
        type="System.Web.Security.SqlRoleProvider"  
        connectionStringName="SqlServices"  
        applicationName="SampleApplication" />  
      </providers>  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Sie können die Autorisierungsregeln in der Konfigurationsdatei für Ihre Webanwendung oder programmgesteuert im Code angeben. Z. B. im folgende Abschnitt aus einer Datei "Web.config" erfordert, dass Benutzer (durch das Verweigern von anonymer Benutzern) anmelden und dann kann nur Benutzer in der "Administratoren" Zugriff haben.  
  
```  
<authorization>  
  <deny users="?" />  
  <allow roles="Administrators" />  
  <deny users="*" />  
</authorization>  
```  
  
 Bei Verwendung der `authorization` Abschnitt in der Datei "Web.config" Ihrer Anwendung Autorisierung basierend auf Rollen, Benutzer der Anwendung angeben muss eine authentifizierte Benutzeridentität angeben. Sie können Benutzer mit Windows-oder Formularauthentifizierung authentifizieren. Anonyme Benutzer können zu einer Rolle zugewiesen werden. Rollen können verwendet werden, unabhängig von oder in Verbindung mit der ASP.NET <xref:System.Web.Security.Membership> Klassen.  
  
 Um die Rollenmitgliedschaft programmgesteuert zu überprüfen, können Sie die <xref:System.Web.Security.Roles> Klasse oder die <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> Eigenschaft mit der <xref:System.Web.Security.Roles.IsUserInRole%2A> -Methode, oder Sie können die <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> Eigenschaft mit der <xref:System.Security.Principal.IPrincipal.IsInRole%2A?displayProperty=nameWithType> Methode. Beispielcode, der Mitgliedschaft in Datenbankrolle programmgesteuert überprüft werden, finden Sie im Beispielabschnitt in diesem Thema.  
  
 Die <xref:System.Web.Security.Roles> Klasse können Sie auch zum Erstellen und Löschen von Rollen und Benutzer hinzufügen oder Entfernen von Benutzern Rollen.  
  
> [!NOTE]
>  Wenn Sie Ihre Anwendung für die Verwendung konfiguriert haben die <xref:System.Web.Security.WindowsTokenRoleProvider> -Klasse kann nicht geändert werden, Rollen oder Rollenmitgliedschaften. Die <xref:System.Web.Security.WindowsTokenRoleProvider> Classverifies Mitgliedschaft in der Windows-Sicherheit nur gruppiert. In diesem Fall müssen Sie verwenden Windows-Benutzerkontenverwaltung anstelle von ASP.NET-Rollen erstellen und Löschen von Gruppen und Gruppenmitgliedschaften verwalten.  
  
 Sie können die Rolleninformationen in mehreren Datenquellen speichern.  
  
-   Sie können die <xref:System.Web.Security.WindowsTokenRoleProvider> -Klasse zum Abrufen von Rolleninformationen basierend auf der Mitgliedschaft in der Windows-Gruppen.  
  
-   Sie können die Rolleninformationen in einer SQL Server-Datenbank speichern, indem Sie mit der <xref:System.Web.Security.SqlRoleProvider> Klasse.  
  
-   Wenn Sie vorhandenen Rolleninformationen oder Rolleninformationen in speichern und Abrufen von Informationen aus einer Datenquelle als Windows, ein Autorisierungsspeicher oder SQL Server werden soll, können Sie einen benutzerdefinierten Rollenanbieter durch implementieren eine Klasse erstellen, die erbt<xref:System.Web.Security.RoleProvider> abstrakte Klasse. Weitere Informationen finden Sie unter [Implementieren eines Rollenanbieters](http://msdn.microsoft.com/library/851671ce-bf9b-43f2-aba4-bc9d28b11c7d).  
  
 Wenn der Browser des Benutzers Cookies akzeptiert, können Sie Rolleninformationen für diesen Benutzer in einem Cookie auf dem Computer des Benutzers speichern. Für jede Seitenanforderung liest ASP.NET der Rolleninformationen für diesen Benutzer aus dem Cookie. Dies kann die Leistung verbessern, durch Verringern der Kommunikation mit der Datenquelle zum Abrufen von Rolleninformationen erforderlich. Wenn der Rolleninformationen für einen Benutzer zu viel Zeit in einem Cookie gespeichert ist, wird ASP.NET speichert nur die zuletzt verwendete Rolleninformationen im Cookie und dann zusätzliche Informationen in der Datenquelle nach Bedarf gesucht. Wenn der Browser des Benutzers keine Cookies unterstützt oder Cookies sind deaktiviert, wird die Rolleninformationen nicht in einem Cookie zwischengespeichert.  
  
 Sie können die Zuverlässigkeit der durch Angabe in einem Cookie zwischengespeicherte Rollennamen verbessern einer <xref:System.Web.Security.Roles.CookieProtectionValue%2A> Eigenschaft, wenn Sie ASP.NET-Rollen konfigurieren. Die Standardeinstellung <xref:System.Web.Security.Roles.CookieProtectionValue%2A> ist `All`, die verschlüsselt Rollennamen im Cookie und überprüft, dass der Inhalt von Cookies nicht geändert wurden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Datei "Web.config" für eine Anwendung so konfiguriert, die ASP.NET-Mitgliedschaft und ASP.NET-Rollen verwenden, und verwenden Sie die <xref:System.Web.Security.SqlRoleProvider> zum Speichern von Informationen zu Mitgliedschaft und Rollen in einer SQL Server-Datenbank. Benutzer werden bei der Formularauthentifizierung authentifiziert, und nur Benutzer in der "Administratoren" Zugriff auf die Anwendung zulässig sind.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
    <authorization>  
      <deny users="?" />  
      <allow roles="Administrators" />  
      <deny users="*" />  
    </authorization>  
  
    <membership defaultProvider="AspNetSqlProvider" userIsOnlineTimeWindow="15">  
    </membership>  
  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="true"  
      cookieSlidingExpiration="true"  
      cookieProtection="All" >  
  
      <providers>  
        <clear />  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="SampleApplication" />  
        </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Im folgenden Codebeispiel wird überprüft programmgesteuert an, ob der angemeldete Benutzer in der "Administratoren" ist, bevor der Benutzer zu Rollen anderer Benutzer anzeigen.  
  
  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddUsersToRole">
      <MemberSignature Language="C#" Value="public static void AddUsersToRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRole(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUsersToRole (usernames As String(), roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUsersToRole(cli::array &lt;System::String ^&gt; ^ usernames, System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Ein Zeichenfolgenarray mit Benutzernamen, die der angegebenen Rolle hinzugefügt werden sollen.</param>
        <param name="roleName">Die Rolle, der die angegebenen Benutzernamen hinzugefügt werden sollen.</param>
        <summary>Fügt der angegebenen Rolle die angegebenen Benutzer hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.AddUsersToRole%2A> Methode ruft den Standardrollenanbieter, um die angegebenen Benutzer die angegebene Rolle in der Datenquelle zuzuordnen.  
  
 Wenn Ihre Anwendung verwendet die <xref:System.Web.Security.SqlRoleProvider> Klasse, die Datenbankupdates, die während des Aufrufs ausgeführt werden die <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> Methode innerhalb einer Transaktion erfolgen. Wenn ein Fehler aufgetreten ist, z. B. einen Benutzernamen ein, der bereits in einer bestimmten Rolle ist, die Transaktion ein Rollback aus, und keine Updates ausgeführt werden.  
  
> [!NOTE]
>  Benutzernamen und Rollennamen dürfen keine Kommas enthalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine oder mehrere Benutzer zu einer Rolle hinzugefügt oder entfernt einen Benutzer aus einer Rolle, die basierend auf Benutzereingaben. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.  
  
 - oder -   
  
 Eines der Elemente in <paramref name="usernames" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 Eines der Elemente in <paramref name="usernames" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="usernames" /> enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUsersToRoles">
      <MemberSignature Language="C#" Value="public static void AddUsersToRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUsersToRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUsersToRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Ein Zeichenfolgenarray mit Benutzernamen, die den angegebenen Rollen hinzugefügt werden sollen.</param>
        <param name="roleNames">Ein Zeichenfolgenarray mit Rollennamen, denen die angegebenen Benutzernamen hinzugefügt werden sollen.</param>
        <summary>Fügt den angegebenen Rollen die angegebenen Benutzer hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.AddUsersToRoles%2A> Methode ruft den Standardrollenanbieter, um die angegebenen Benutzer den angegebenen Rollen in der Datenquelle zuzuordnen.  
  
 Wenn Ihre Anwendung verwendet die <xref:System.Web.Security.SqlRoleProvider> Klasse, die Datenbankupdates, die während des Aufrufs ausgeführt werden die <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> Methode innerhalb einer Transaktion erfolgen. Wenn ein Fehler aufgetreten ist, z. B. einen Benutzernamen ein, der bereits in einer bestimmten Rolle ist, die Transaktion ein Rollback aus, und keine Updates ausgeführt werden.  
  
> [!NOTE]
>  Benutzernamen und Rollennamen dürfen keine Kommas enthalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine oder mehrere Rollen einen oder mehrere Benutzer hinzugefügt. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/adduserstorolescs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.Roles#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/adduserstorolesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Eine der Rollen in <paramref name="roleNames" /> ist <see langword="null" />.  
  
 - oder -   
  
 Einer der Benutzer in <paramref name="usernames" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine der Rollen in <paramref name="roleNames" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 Einer der Benutzer in <paramref name="usernames" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="roleNames" /> enthält ein doppeltes Element.  
  
 - oder -   
  
 <paramref name="usernames" /> enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRole">
      <MemberSignature Language="C#" Value="public static void AddUserToRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUserToRole (username As String, roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUserToRole(System::String ^ username, System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Der Benutzername, der der angegebenen Rolle hinzugefügt werden soll.</param>
        <param name="roleName">Die Rolle, der der angegebenen Benutzernamen hinzugefügt werden soll.</param>
        <summary>Fügt der angegebenen Rolle den angegebenen Benutzer hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.AddUserToRole%2A> Methode ruft den Standardrollenanbieter, um den angegebenen Benutzer die angegebene Rolle in der Datenquelle zuzuordnen.  
  
> [!NOTE]
>  Benutzernamen und Rollennamen dürfen keine Kommas enthalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel fügt einen Benutzer einer Rolle. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.Roles#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="username" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.  
  
 - oder -   
  
 Der Benutzer ist bereits der angegebenen Rolle zugewiesen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRoles">
      <MemberSignature Language="C#" Value="public static void AddUserToRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRoles(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUserToRoles (username As String, roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUserToRoles(System::String ^ username, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">Der Benutzername, der den angegebenen Rollen hinzugefügt werden soll.</param>
        <param name="roleNames">Ein Zeichenfolgenarray mit Rollen, denen der angegebene Benutzername hinzugefügt werden soll.</param>
        <summary>Fügt den angegebenen Rollen den angegebenen Benutzer hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.AddUserToRoles%2A> Methode ruft den Standardrollenanbieter, um den angegebenen Benutzer den angegebenen Rollen in der Datenquelle zuzuordnen.  
  
 Wenn Ihre Anwendung verwendet die <xref:System.Web.Security.SqlRoleProvider> Klasse, die Datenbankupdates, die während des Aufrufs ausgeführt werden die <xref:System.Web.Security.Roles.AddUserToRoles%2A> Methode innerhalb einer Transaktion erfolgen. Wenn ein Fehler aufgetreten ist, z. B. einen Benutzernamen ein, der bereits in einer bestimmten Rolle ist, die Transaktion ein Rollback aus, und keine Updates ausgeführt werden.  
  
> [!NOTE]
>  Benutzernamen und Rollennamen dürfen keine Kommas enthalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine oder mehrere Rollen ein Benutzers hinzugefügt. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolescs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.Roles#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolesvb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Eine der Rollen in <paramref name="roleNames" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine der Rollen in <paramref name="roleNames" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="username" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="roleNames" /> enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Anwendung ab, für die Rolleninformationen gespeichert und abgerufen werden sollen, oder legt diesen fest.</summary>
        <value>Der Name der Anwendung, für die Rolleninformationen gespeichert und abgerufen werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft wird verwendet, durch die <xref:System.Web.Security.Roles> Klasse zuordnen von Benutzern und Rollen mit verschiedenen Anwendungen. Dadurch wird die gleiche Datenquelle verwenden, um Benutzer- und Rolleninformationen zu speichern, ohne dass Konflikte zwischen benutzernamenduplikate oder doppelte Rollennamen, aus denen mehrere Anwendungen. Mehrere ASP.NET-Anwendungen können die gleiche Datenquelle verwenden, indem derselbe Wert in der <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft. Sie können festlegen, die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft programmgesteuert, oder Sie können es deklarativ festgelegt in der Konfigurationsdatei für die Web-Anwendung mithilfe der `applicationName` Attribut.  
  
 Wenn Ihre Webanwendung verwendet wird die <xref:System.Web.Security.SqlRoleProvider> Klasse und einen Wert für nicht angegeben ist die `applicationName` Attribut in der Konfigurationsdatei der <xref:System.Web.HttpRequest.ApplicationPath%2A?displayProperty=nameWithType> Eigenschaftswert für die aktuelle <xref:System.Web.HttpContext.Request%2A?displayProperty=nameWithType> Eigenschaft wird verwendet.  
  
> [!CAUTION]
>  Da eine einzelne Rolle Anbieter Standardinstanz, für alle Anforderungen vom verwendet wird ein <xref:System.Web.HttpApplication> -Objekt können mehrere Anforderungen gleichzeitig ausgeführt und versucht, legen Sie die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaftswert. Die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft ist nicht für mehrere Schreibvorgänge threadsicher sind, und ändern die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaftswert kann zu unerwartetem Verhalten für mehrere Benutzer einer Anwendung führen. Vermeiden Sie beim Schreiben von Code, damit Benutzer festlegen können die <xref:System.Web.Security.Roles.ApplicationName%2A> -Eigenschaft, sofern nicht erforderlich. Ein Beispiel für eine Anwendung in dem das Festlegen der <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft kann erforderlich sein, sollte eine verwaltende Anwendung, die Daten der Rolle für mehrere Anwendungen verwaltet wird. Eine solche Anwendung sollte einen Einzelbenutzer-Anwendung und nicht um eine Webanwendung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die `applicationName` -Attribut auf `MyApplication`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheRolesInCookie">
      <MemberSignature Language="C#" Value="public static bool CacheRolesInCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CacheRolesInCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CacheRolesInCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CacheRolesInCookie As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CacheRolesInCookie { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Rollen des aktuellen Benutzers in einem Cookie zwischengespeichert werden.</summary>
        <value>
          <see langword="true" />, wenn die Rollen des aktuellen Benutzers in einem Cookie zwischengespeichert werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> -Eigenschaftensatz auf `true` Rolleninformationen für jeden Benutzer wird in der Datei "Web.config" in einem Cookie gespeichert. Wenn Rollenverwaltung überprüft, ob ein Benutzer in einer bestimmten Rolle ist, wird des Rollencookies überprüft, bevor der Rollenanbieter aufgerufen wird, um die Liste der Rollen in der Datenquelle zu überprüfen. Das Cookie wird dynamisch aktualisiert, um die zuletzt überprüften Rollennamen zwischenzuspeichern.  
  
 Sie können die Zuverlässigkeit der durch Angabe in einem Cookie zwischengespeicherte Rollennamen verbessern einer <xref:System.Web.Security.Roles.CookieProtectionValue%2A> Eigenschaft, wenn Sie ASP.NET-Rollen konfigurieren. Die Standardeinstellung <xref:System.Web.Security.Roles.CookieProtectionValue%2A> ist `All`, die verschlüsselt Rollennamen im Cookie und überprüft, dass der Inhalt von Cookies nicht geändert wurden.  
  
> [!NOTE]
>  Da Rollennamen abgesehen von der Datenquelle zwischengespeichert werden können, ist es möglich, dass Änderungen an Rollenverwaltung in der Datenquelle nicht in die zwischengespeicherten Werte widergespiegelt werden würde. In diesem Fall muss der Benutzer zu schließen und erneut öffnen Sie ihren Browser, um den Wert des zwischengespeicherten Cookies zu löschen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die `cacheRolesInCookie` -Attribut auf `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
   </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieName">
      <MemberSignature Language="C#" Value="public static string CookieName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookieName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookieName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Cookies ab, in dem Rollennamen zwischengespeichert werden.</summary>
        <value>Der Name des Cookies, in dem Rollennamen zwischengespeichert werden. Der Standardname lautet .ASPXROLES.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie den Namen des Cookies, in denen Rollen zwischengespeichert werden, für die Anwendung, durch Festlegen der `cookieName` Attribut in der Datei "Web.config", damit Ihre ASP.NET-Anwendung. Dies ist nützlich, wenn Sie ein Cookie für Ihre Anwendung eindeutig identifizieren möchten oder wenn ein Cookie für mehrere Anwendungen, z. B. ein Cookie Domäne gemeinsam verwendet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die `cookieName` -Attribut auf. ASPROLES FESTGELEGT.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookiePath">
      <MemberSignature Language="C#" Value="public static string CookiePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookiePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookiePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookiePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookiePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für das Cookie mit den zwischengespeicherten Rollennamen ab.</summary>
        <value>Der Pfad des Cookies, in dem Rollennamen zwischengespeichert werden. Der Standardwert ist /.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie den Pfad des Cookies, in denen Rollen zwischengespeichert werden, für die Anwendung, durch Festlegen der `cookiePath` Attribut in der Datei "Web.config", damit Ihre ASP.NET-Anwendung. Weitere Informationen zu Cookies finden Sie unter <xref:System.Web.HttpCookie.Path%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die  `cookiePath` /MyApplication-Attribut.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieProtectionValue">
      <MemberSignature Language="C#" Value="public static System.Web.Security.CookieProtection CookieProtectionValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.Security.CookieProtection CookieProtectionValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieProtectionValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieProtectionValue As CookieProtection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::CookieProtection CookieProtectionValue { System::Web::Security::CookieProtection get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.CookieProtection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie in einem Cookie zwischengespeicherte Rollennamen geschützt werden.</summary>
        <value>Einer der <see cref="T:System.Web.Security.CookieProtection" />-Enumerationswerte, der angibt, wie in einem Cookie zwischengespeicherte Rollennamen geschützt werden. Der Standardwert ist <see langword="All" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie den Schutz des Cookies, in denen Rollen zwischengespeichert werden, für die Anwendung, durch Festlegen der `cookieProtection` Attribut in der Datei "Web.config", damit Ihre ASP.NET-Anwendung. Die `cookieProtection` -Attribut nimmt eine <xref:System.Web.Security.CookieProtection> -Enumerationswert ab, der angibt, ob die Rollennamen verschlüsselt sind, überprüft, beide oder keines von beiden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt `cookieProtection` -Attribut `Encrypted`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieRequireSSL">
      <MemberSignature Language="C#" Value="public static bool CookieRequireSSL { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieRequireSSL" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieRequireSSL" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieRequireSSL As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookieRequireSSL { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob zum Zurücksenden des Rollennamencookies an den Server SSL erforderlich ist.</summary>
        <value>
          <see langword="true" />, wenn zum Zurücksenden des Rollennamencookies an den Server SSL erforderlich ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, ob SSL (Secure Sockets Layer) erforderlich ist, Zurückgeben des Rollennamencookies an den Server in Ihrer Anwendung durch Festlegen der `cookieRequireSSL` Attribut in der Datei "Web.config", damit Ihre ASP.NET-Anwendung. Weitere Informationen finden Sie unter <xref:System.Web.HttpCookie.Secure%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt `cookieRequireSSL` auf `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieSlidingExpiration">
      <MemberSignature Language="C#" Value="public static bool CookieSlidingExpiration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieSlidingExpiration" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieSlidingExpiration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookieSlidingExpiration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Datum und Uhrzeit für den Ablauf der Gültigkeit des Rollennamencookies in regelmäßigen Abständen zurückgesetzt werden.</summary>
        <value>
          <see langword="true" />, wenn Datum und Uhrzeit für den Ablauf der Gültigkeit des Rollennamencookies in regelmäßigen Abständen zurückgesetzt werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, ob Cookie Ablaufdatum Rollennamen und mit jeder Antwort mithilfe zurückgesetzt wird der `cookieSlidingExpiration` Attribut in der Datei "Web.config", damit Ihre ASP.NET-Anwendung. Wenn `true`, den Ablauf der Cookies wird anfänglich auf das aktuelle Datum und die Uhrzeit festgelegt sowie die <xref:System.Web.Security.Roles.CookieTimeout%2A> in Minuten. Während der Benutzer die ASP.NET-Anwendung aktiv zu verwenden weiterhin, das Ablaufdatum und die Uhrzeit des Cookies werden automatisch aktualisiert werden ist kleiner als die Hälfte der <xref:System.Web.Security.Roles.CookieTimeout%2A> verbleibenden. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Web.HttpCookie.Expires%2A>-Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Er gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> Eigenschaft `false`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="false"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieTimeout">
      <MemberSignature Language="C#" Value="public static int CookieTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CookieTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CookieTimeout { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Minuten bis zum Ablauf der Gültigkeit des Rollencookies ab.</summary>
        <value>Eine ganze Zahl, die die Anzahl von Minuten bis zum Ablauf der Gültigkeit des Rollencookies angibt. Der Standardwert ist 30 Minuten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.CookieTimeout%2A> Eigenschaft wird verwendet, wenn die <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> Eigenschaft ist `true` und gibt der Time-to-live, in Minuten für das Rollencookie. Festlegen der <xref:System.Web.Security.Roles.CookieTimeout%2A> -Wert, fügen Sie der `cookieTimeout` auf das Element in der Datei "Web.config" für die ASP.NET-Anwendung Attribut, und geben Sie einen ganzzahligen Wert.  
  
 Wenn <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> ist `false`, diese Eigenschaft wird ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die <xref:System.Web.Security.Roles.CookieTimeout%2A> Eigenschaft bis 30 Minuten.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
  <add  
    name="SqlProvider"  
    type="System.Web.Security.SqlRoleProvider"  
    connectionStringName="SqlServices"  
    applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePersistentCookie">
      <MemberSignature Language="C#" Value="public static bool CreatePersistentCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CreatePersistentCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CreatePersistentCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CreatePersistentCookie As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CreatePersistentCookie { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Rollennamencookie sitzungsbasiert oder permanent ist.</summary>
        <value>
          <see langword="true" />, wenn das Rollennamencookie ein permanentes Cookie ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.CreatePersistentCookie%2A> -Eigenschaftswert festgelegt ist, in der Konfiguration für eine ASP.NET-Anwendung mit der `createPersistentCookie` Attribut des Konfigurationselements.  
  
 Wenn `false`das Rollennamencookie ein Sitzungscookie, wird das Cookie ist, also verloren, wenn der Browser geschlossen wird. Wenn `true`, das Rollennamencookie ist ein permanentes Cookie, das über mehrere Browsersitzungen hinweg verfügbar ist. Das Ablaufdatum permanentes Cookie und die Uhrzeit auf das aktuelle Datum und die Uhrzeit festgelegt sind sowie die <xref:System.Web.Security.Roles.CookieTimeout%2A> Wert in Minuten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRole">
      <MemberSignature Language="C#" Value="public static void CreateRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.CreateRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateRole (roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateRole(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der zu erstellenden Rolle.</param>
        <summary>Fügt der Datenquelle eine neue Rolle hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.CreateRole%2A> Methode fügt einen Rollennamen mit der Datenquelle. <xref:System.Web.Security.Roles.CreateRole%2A> Ruft die <xref:System.Web.Security.RoleProvider.CreateRole%2A> Methode von der Standard-Rollenanbieter, um die angegebene Rolle mit der Datenquelle hinzuzufügen.  
  
> [!NOTE]
>  Rollennamen darf keine Kommas enthalten.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Rolle in der Datenquelle an. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  In diesem Beispiel enthält ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Übersicht über Skriptangriffe](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.  
  
 - oder -   
  
 <paramref name="roleName" /> enthält ein Komma.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteCookie">
      <MemberSignature Language="C#" Value="public static void DeleteCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteCookie();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht das Cookie, in dem Rollennamen zwischengespeichert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.DeleteCookie%2A> Methode löscht den Inhalt des Cookies, die zum Zwischenspeichern von Rollennamen verwendet wird. Weitere Informationen zum Zwischenspeichern von Rollennamen finden Sie unter <xref:System.Web.Security.Roles.CacheRolesInCookie%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die <xref:System.Web.Security.Roles.DeleteCookie%2A> Methode, um alle deaktivieren zwischengespeicherten Rollennamen an, wenn ein Benutzer anmeldet. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  In diesem Beispiel enthält ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Übersicht über Skriptangriffe](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/logincs.aspx#5)]
 [!code-aspx-vb[System.Web.Security.Roles#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/loginvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteRole">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt eine Rolle aus der Datenquelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeleteRole (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeleteRole(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der zu löschenden Rolle.</param>
        <summary>Entfernt eine Rolle aus der Datenquelle.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="roleName" /> aus der Datenquelle gelöscht wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.DeleteRole%2A> -Methode entfernt einen Rollennamen, aus der Datenquelle. <xref:System.Web.Security.Roles.DeleteRole%2A> Ruft die <xref:System.Web.Security.RoleProvider.DeleteRole%2A> Methode von der Standard-Rollenanbieter, um die angegebene Rolle aus der Datenquelle zu entfernen.  
  
 Wenn die Rolle von identifiziert die `roleName` Parameter ein oder mehrere Mitglieder hat, und klicken Sie dann eine Ausnahme ausgelöst und die Rolle nicht gelöscht werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Rolle aus der Datenquelle gelöscht. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" /> weist einen oder mehrere Mitglieder auf.  
  
 - oder -   
  
 Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName, bool throwOnPopulatedRole) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeleteRole (roleName As String, throwOnPopulatedRole As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeleteRole(System::String ^ roleName, bool throwOnPopulatedRole);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="throwOnPopulatedRole" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der zu löschenden Rolle.</param>
        <param name="throwOnPopulatedRole">Wenn der Wert <see langword="true" /> ist und <c>roleName</c> über einen oder mehrere Mitglieder verfügt, wird eine Ausnahme ausgelöst.</param>
        <summary>Entfernt eine Rolle aus der Datenquelle.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="roleName" /> aus der Datenquelle gelöscht wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.DeleteRole%2A> -Methode entfernt einen Rollennamen, aus der Datenquelle. <xref:System.Web.Security.Roles.DeleteRole%2A> Ruft die <xref:System.Web.Security.RoleProvider.DeleteRole%2A> Methode von der Standard-Rollenanbieter, um die angegebene Rolle aus der Datenquelle zu entfernen.  
  
 Wenn `throwOnPopulatedRole` ist `true`, wird eine Ausnahme ausgelöst und die Rolle wird nicht gelöscht werden, wenn die Rolle von identifiziert die `roleName` Parameter hat ein oder mehrere Elemente. Wenn `throwOnPopulatedRole` ist `false`, und klicken Sie dann die Rolle, ob sie leer oder nicht ist gelöscht werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Rolle aus der Datenquelle gelöscht. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" /> verfügt über mindestens ein Mitglied, und <paramref name="throwOnPopulatedRole" /> ist <see langword="true" />.  
  
 - oder -   
  
 Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public static string Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Domain { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der Domäne des Rollennamencookies ab.</summary>
        <value>Die <see cref="P:System.Web.HttpCookie.Domain" /> des Rollennamencookies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.Domain%2A> -Eigenschaftswert festgelegt ist, in der Konfiguration für eine ASP.NET-Anwendung mit der `domain` Attribut des Konfigurationselements.  
  
 Wenn kein Wert, in der Konfiguration für das Domänenattribut angegeben wird die <xref:System.Web.Security.Roles.Domain%2A> -Eigenschaft gibt `null` und die Rollennamen Cookie-Domäne wird standardmäßig auf das Verhalten von der <xref:System.Web.HttpCookie> <xref:System.Web.HttpCookie.Domain%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public static bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Rollenverwaltung für die aktuelle Webanwendung aktiviert ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn Rollenverwaltung aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die `enabled` -Attribut auf `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] FindUsersInRole (string roleName, string usernameToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] FindUsersInRole(string roleName, string usernameToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.FindUsersInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindUsersInRole (roleName As String, usernameToMatch As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ FindUsersInRole(System::String ^ roleName, System::String ^ usernameToMatch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="usernameToMatch" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Die Rolle, in der gesucht werden soll.</param>
        <param name="usernameToMatch">Der zu suchende Benutzername.</param>
        <summary>Ruft eine Liste der Benutzer ab, die eine angegebene Rolle innehaben, und deren Benutzername mit dem angegebenen Benutzernamen übereinstimmt.</summary>
        <returns>Ein Zeichenfolgenarray, das die Namen aller Benutzer enthält, deren Benutzername mit <paramref name="usernameToMatch" /> übereinstimmt und die Mitglieder der angegebenen Rolle sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.FindUsersInRole%2A> Gibt eine Liste von Benutzern in einer Rolle, in dem eine Übereinstimmung des angegebenen enthält den Benutzernamen `usernameToMatch` für die konfigurierte `applicationName`. Beispielsweise, wenn die `usernameToMatch` Parameter auf "User", und klicken Sie dann auf die Benutzer "Benutzer1", "Benutzer2", "user3" festgelegt ist und usw. zurückgegeben. Benutzer werden in alphabetischer Reihenfolge nach Benutzername zurückgegeben.  
  
 Die <xref:System.Web.Security.SqlRoleProvider> führt die Suche mit einer LIKE-Klausel für die `usernameToMatch` Parameter. Platzhalter, die von SQL Server unterstützt werden, wie in Klauseln verwendet werden können die `usernameToMatch` Parameterwert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.FindUsersInRole%2A> -Methode zum Anzeigen der Rollenmitgliedschaft basierend auf Benutzereingaben. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  In diesem Beispiel enthält ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Übersicht über Skriptangriffe](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#11](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/FindUsersInRolecs.aspx#11)]
 [!code-aspx-vb[System.Web.Security.Roles#11](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/FindUsersInRolevb.aspx#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" /> (<see langword="Nothing" /> in Visual Basic).  
  
 - oder -   
  
 <paramref name="usernameToMatch" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="usernameToMatch" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllRoles">
      <MemberSignature Language="C#" Value="public static string[] GetAllRoles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetAllRoles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetAllRoles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllRoles () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetAllRoles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Liste aller Rollen für die Anwendung ab.</summary>
        <returns>Ein Zeichenfolgenarray, das die Namen aller Rollen enthält, die in der Datenquelle für die Anwendung gespeichert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.GetAllRoles%2A> Methodenaufrufe der <xref:System.Web.Security.RoleProvider.GetAllRoles%2A?displayProperty=nameWithType> Methode von der Standard-Rollenanbieter, um eine Liste aller Rollen für eine Anwendung aus der Datenquelle abzurufen. Nur die Rollen für die Anwendung, die im angegebenen die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetAllRoles%2A> Methode zum Abrufen der Liste der Rollen für eine Anwendung, und binden die Ergebnisse in einem <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  In diesem Beispiel enthält ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Übersicht über Skriptangriffe](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRolesForUser">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Liste der Rollen ab, die ein Benutzer innehat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRolesForUser () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetRolesForUser();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Liste der Rollen des gegenwärtig angemeldeten Benutzers ab.</summary>
        <returns>Ein Zeichenfolgenarray, das die Namen aller Rollen des gegenwärtig angemeldeten Benutzers enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.GetRolesForUser%2A> Methodenaufrufe der <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> Methode von den Standardrollenanbieter für die abzurufenden aus den Daten Quelle die Rollen der gegenwärtig angemeldeten Benutzer. Der derzeit angemeldete Benutzer wird anhand der <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> Eigenschaft des aktuellen <xref:System.Web.HttpContext?displayProperty=nameWithType>, oder durch <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> für nicht-HTTP-Hostingumgebungen. Wenn kein Benutzer angemeldet ist, wird eine Ausnahme ausgelöst. Nur die Rollen für die Anwendung, die im angegebenen die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft abgerufen werden.  
  
 Wenn <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> ist `true`, klicken Sie dann die Ergebnisse der <xref:System.Web.Security.Roles.GetRolesForUser%2A> Methode aus der Rolle ""-Cache, anstatt des angegebenen Rollenanbieters zurückgegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetRolesForUser%2A> Methode, um eine Liste der Rollen für einen angegebenen Benutzer abrufen und binden die zurückgegebenen Rollen an, eine <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gegenwärtig ist kein Benutzer angemeldet.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser (string username);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser(string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRolesForUser (username As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetRolesForUser(System::String ^ username);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Der Benutzer, für den eine Liste der Rollen zurückgegeben werden soll.</param>
        <summary>Ruft eine Liste der Rollen ab, die ein Benutzer innehat.</summary>
        <returns>Ein Zeichenfolgenarray, das die Namen aller Rollen des angegebenen Benutzers enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.GetRolesForUser%2A> Methodenaufrufe der <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> Methode von den Standardrollenanbieter für die abzurufenden aus den Daten Datenquelle die Rollen, die der Benutzer innehat. Nur die Rollen für die Anwendung, die im angegebenen die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft abgerufen werden.  
  
 Wenn `username` ist gleich der aktuellen angemeldeten Benutzer und <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> ist `true`, die Ergebnisse der <xref:System.Web.Security.Roles.GetRolesForUser%2A> aus dem Rollencache und nicht der angegebenen Methode zurückgegeben werden <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetRolesForUser%2A> Methode, um eine Liste der Rollen für einen angegebenen Benutzer abrufen und binden die zurückgegebenen Rollen an, eine <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="username" /> enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] GetUsersInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetUsersInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetUsersInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUsersInRole (roleName As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetUsersInRole(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Die Rolle, für die die Liste der Benutzer abgerufen werden soll.</param>
        <summary>Ruft eine Liste der Benutzer mit der angegebenen Rolle ab.</summary>
        <returns>Ein Zeichenfolgenarray mit den Namen aller Benutzer, die Mitglieder der angegebenen Rolle sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.GetUsersInRole%2A> Methodenaufrufe der <xref:System.Web.Security.RoleProvider.GetUsersInRole%2A> Methode von den Standard-Rollenanbieter zum Abrufen der Namen der Benutzer einer Rolle aus der Datenquelle zugeordnet. Nur die Rollen für die Anwendung, die im angegebenen die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.GetUsersInRole%2A> Methode zum Abrufen einer Liste der Benutzer in einer bestimmten Rolle und bindet die Ergebnisse in einem <xref:System.Web.UI.WebControls.GridView> Steuerelement. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUserInRole">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Benutzer die angegebene Rolle innehat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUserInRole (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUserInRole(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der Rolle, in der gesucht werden soll.</param>
        <summary>Ruft einen Wert ab, der angibt, ob der gegenwärtig angemeldete Benutzer die angegebene Rolle innehat. Die API sollte nur im Kontext eines ASP.NET-Anforderungsthreads aufgerufen werden und ist in diesem speziellen Anwendungsfall threadsicher.</summary>
        <returns>
          <see langword="true" />, wenn der gegenwärtig angemeldete Benutzer die angegebene Rolle innehat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.IsUserInRole%2A> Methodenaufrufe der <xref:System.Web.Security.RoleProvider.IsUserInRole%2A?displayProperty=nameWithType> Methode von der Standard-Rollenanbieter, um zu bestimmen, ob der gegenwärtig angemeldete Benutzer einer Rolle aus der Datenquelle für die Anwendung zugeordnet, die im angegebenen ist die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft. Der derzeit angemeldete Benutzer wird anhand der <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> Eigenschaft des aktuellen <xref:System.Web.HttpContext?displayProperty=nameWithType>, oder durch <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> für nicht-HTTP-Hostingumgebungen. Wenn kein Benutzer angemeldet ist, wird eine Ausnahme ausgelöst. Nur die Rollen für die Anwendung, die im angegebenen die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft abgerufen werden.  
  
 Wenn <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> ist `true`, klicken Sie dann `roleName` für den Rollencache statt des angegebenen Rollenanbieters überprüft werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel überprüft programmgesteuert an, ob der gegenwärtig angemeldete Benutzer in der "Administratoren" ist, bevor der Benutzer rolleneinstellungen für die Anwendung angezeigt. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.  
  
 - oder -   
  
 Gegenwärtig ist kein Benutzer angemeldet.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUserInRole (username As String, roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUserInRole(System::String ^ username, System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Der Name des zu suchenden Benutzers.</param>
        <param name="roleName">Der Name der Rolle, in der gesucht werden soll.</param>
        <summary>Ruft einen Wert ab, der angibt, ob der angegebene Benutzer die angegebene Rolle innehat. Die API sollte nur im Kontext eines ASP.NET-Anforderungsthreads aufgerufen werden und ist in diesem speziellen Anwendungsfall threadsicher.</summary>
        <returns>
          <see langword="true" />, wenn der angegebene Benutzer die angegebene Rolle innehat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.IsUserInRole%2A> Methodenaufrufe der <xref:System.Web.Security.RoleProvider.IsUserInRole%2A> Methode von der Standard-Rollenanbieter, um zu bestimmen, ob ein Benutzername einer Rolle aus der Datenquelle für die Anwendung zugeordnet, die im angegebenen ist die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft.  
  
 Wenn `username` gleich dem aktuellen Benutzer angemeldet ist und die <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> Eigenschaftswert ist `true`, `roleName` kann für den Rollencache und nicht dem angegebenen überprüft werden <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel überprüft programmgesteuert an, ob ein Benutzer in der "Administratoren" ist, bevor der Benutzer rolleneinstellungen für die Anwendung angezeigt. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="username" /> enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCachedResults">
      <MemberSignature Language="C#" Value="public static int MaxCachedResults { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxCachedResults" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.MaxCachedResults" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxCachedResults As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxCachedResults { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Rollennamen ab, die für einen Benutzer zwischengespeichert werden sollen.</summary>
        <value>Die maximale Anzahl von Rollennamen, die für einen Benutzer zwischengespeichert werden sollen. Der Standard ist 25.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.MaxCachedResults%2A> Eigenschaft festgelegt ist, mit der `maxCachedResults` Konfigurationsattribut. Der Wert, der die `maxCachedResults` Konfigurationsattribut muss auf einen ganzzahligen Wert größer als 0 (null) festgelegt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Element in der `system.web` Abschnitt der Datei "Web.config" für eine ASP.NET-Anwendung. Es gibt an, dass die Anwendung verwendet ein <xref:System.Web.Security.SqlRoleProvider> Instanz und legt die `maxCachedResults` Attribut auf 10.  
  
```  
<roleManager  
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All"   
  maxCachedResults="10" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProvider Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProvider Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Provider" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Provider As RoleProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::RoleProvider ^ Provider { System::Web::Security::RoleProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardrollenanbieter für die Anwendung ab.</summary>
        <value>Der Standardrollenanbieter für die Anwendung, der als Klasse verfügbar gemacht wird, die die abstrakte <see cref="T:System.Web.Security.RoleProvider" />-Klasse erbt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.Provider%2A> Eigenschaft können Sie direkt auf den Standardrollenanbieter für eine Anwendung verweisen. Dies wird häufig verwendet, um benutzerdefinierte Member des Rollenanbieters zuzugreifen, die nicht Teil der <xref:System.Web.Security.RoleProvider> abstrakte Klasse.  
  
 Z. B. die <xref:System.Web.Security.WindowsTokenRoleProvider> Klasse schließt eine Überladung von der <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> Methode, die Ihnen ermöglicht zu bestimmen, ob ein Benutzer in einer allgemeinen Windows-Rolle mithilfe einer <xref:System.Security.Principal.WindowsBuiltInRole> Enumerationswert. Einen Verweis auf die <xref:System.Web.Security.WindowsTokenRoleProvider> -Klasse für eine Anwendung mit abgerufen werden kann die <xref:System.Web.Security.Roles.Provider%2A> Eigenschaft und umgewandelt werden kann, als eine <xref:System.Web.Security.WindowsTokenRoleProvider> zum Verweisen auf die <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> überladen.  
  
 Wenn mehrere Rollenanbieter für eine Anwendung konfiguriert sind, können Sie mit anderen Rollenanbieter zugreifen der <xref:System.Web.Security.Roles.Providers%2A> Auflistung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird wandelt den Standardrollenanbieter als eine <xref:System.Web.Security.WindowsTokenRoleProvider> und überprüft, ob der gegenwärtig angemeldete Benutzer in der "Administratoren" ist, bevor der Benutzer rolleneinstellungen für die Anwendung angezeigt. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.WindowsTokenRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/CS/ViewRoles2cs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/VB/ViewRoles2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Providers" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Providers As RoleProviderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::RoleProviderCollection ^ Providers { System::Web::Security::RoleProviderCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der Rollenanbieter für die ASP.NET-Anwendung ab.</summary>
        <value>Eine <see cref="T:System.Web.Security.RoleProviderCollection" />, die die für die ASP.NET-Anwendung konfigurierten Rollenanbieter enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.Providers%2A> -Eigenschaft verweist auf alle für eine Anwendung aktivierten Rollenanbieter, in der Datei "Web.config" hinzugefügt einschließlich Anbietern. Sie können steuern, welche Rolle Anbieter mithilfe einer Anwendung zur Verfügung sind die `providers` Element des Abschnitts in der Datei "Web.config" für Ihre Anwendung.  
  
 Das folgende Beispiel zeigt einen Abschnitt, der alle vorhandenen Anbieter (z. B. die in der Datei "Machine.config" angegeben) entfernt und fügt eine <xref:System.Web.Security.SqlRoleProvider> Instanz entsprechend den Rollenanbieter für die Anwendung.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=MySqlServer;Integrated Security=SSPI;Initial Catalog=aspnetdb;" />  
  </connectionStrings>  
  
  <system.web>  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="false"  
      cookieSlidingExpiration="true"  
      cookieProtection="Encrypted">  
  
      <providers>  
        <clear/>  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="MyApplication" />  
         </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Sie erhalten einen stark typisierten Verweis auf einen Anbieter aus der <xref:System.Web.Security.Roles.Providers%2A> Auflistung nach Namen des Rollenanbieters Indizierung und ihn in den gewünschten Typ umwandeln.  
  
 Sie erhalten einen Verweis auf den Standardanbieter für eine Anwendung mit der <xref:System.Web.Security.Roles.Provider%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel listet Anbieter, die für eine Anwendung und ihren entsprechenden Typen aktiviert.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/Providerscs.aspx#7)]
 [!code-aspx-vb[System.Web.Security.Roles#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/Providersvb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUserFromRole (username As String, roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUserFromRole(System::String ^ username, System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Der Benutzer, der aus der angegebenen Rolle entfernt werden soll.</param>
        <param name="roleName">Die Rolle, aus der der angegebene Benutzer entfernt werden soll.</param>
        <summary>Entfernt den angegebenen Benutzer aus der angegebenen Rolle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.RemoveUserFromRole%2A> Methode ruft den Standardrollenanbieter, um den angegebenen Benutzer aus der angegebenen Rolle in der Datenquelle zu entfernen.  
  
   
  
## Examples  
 Das folgende Codebeispiel entfernt einen Benutzer aus einer Rolle. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 <paramref name="username" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRoles(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUserFromRoles (username As String, roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUserFromRoles(System::String ^ username, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">Der Benutzer, der aus den angegebenen Rollen entfernt werden soll.</param>
        <param name="roleNames">Ein Zeichenfolgenarray mit Rollennamen, aus denen der angegebene Benutzer entfernt werden soll.</param>
        <summary>Entfernt den angegebenen Benutzer aus den angegebenen Rollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> Methode ruft den Standardrollenanbieter, um den angegebenen Benutzer aus den angegebenen Rollen in der Datenquelle zu entfernen.  
  
 Wenn die Anwendung für die Verwendung konfiguriert ist die <xref:System.Web.Security.SqlRoleProvider> Klasse, die Datenbankupdates, die während des Aufrufs ausgeführt werden die <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> Methode innerhalb einer Transaktion erfolgen. Wenn ein Fehler aufgetreten ist, z. B. einen Benutzernamen ein, der nicht in einer bestimmten Rolle ist, die Transaktion ein Rollback aus, und keine Updates ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> Methode, um einen Benutzer aus einer oder mehreren Rollen zu entfernen. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUserFromRolescs.aspx#10)]
 [!code-aspx-vb[System.Web.Security.Roles#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUserFromRolesvb.aspx#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Eine der Rollen in <paramref name="roleNames" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="username" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine der Rollen in <paramref name="roleNames" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="username" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="roleNames" /> enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRole(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUsersFromRole (usernames As String(), roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUsersFromRole(cli::array &lt;System::String ^&gt; ^ usernames, System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Ein Zeichenfolgenarray mit Benutzernamen, die aus den angegebenen Rollen entfernt werden sollen.</param>
        <param name="roleName">Der Name der Rolle, aus der die angegebenen Benutzer entfernt werden sollen.</param>
        <summary>Entfernt die angegebenen Benutzer aus der angegebenen Rolle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> Methode ruft den Standardrollenanbieter, um die angegebenen Benutzer aus der angegebenen Rolle in der Datenquelle zu entfernen.  
  
 Wenn die Anwendung verwendet die <xref:System.Web.Security.SqlRoleProvider> Klasse, die Datenbankupdates, die während des Aufrufs ausgeführt werden die <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> Methode innerhalb einer Transaktion erfolgen. Wenn ein Fehler aufgetreten ist, z. B. einen Benutzernamen ein, der nicht in einer bestimmten Rolle ist, die Transaktion ein Rollback aus, und keine Updates ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> Methode, um einen oder mehrere Benutzer aus einer Rolle entfernen. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolecs.aspx#9)]
 [!code-aspx-vb[System.Web.Security.Roles#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolevb.aspx#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" />.  
  
 - oder -   
  
 Einer der Benutzernamen in <paramref name="usernames" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 Einer der Benutzernamen in <paramref name="usernames" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="usernames" /> enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUsersFromRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUsersFromRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Ein Zeichenfolgenarray mit Benutzernamen, die aus den angegebenen Rollen entfernt werden sollen.</param>
        <param name="roleNames">Ein Zeichenfolgenarray mit Rollennamen, aus denen die angegebenen Benutzer entfernt werden sollen.</param>
        <summary>Entfernt die angegebenen Benutzernamen aus den angegebenen Rollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> Methode ruft den Standardrollenanbieter, um die angegebenen Benutzer aus den angegebenen Rollen in der Datenquelle zu entfernen.  
  
 Wenn die Anwendung verwendet die <xref:System.Web.Security.SqlRoleProvider> Klasse, die Datenbankupdates, die während des Aufrufs ausgeführt werden die <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> Methode innerhalb einer Transaktion erfolgen. Wenn ein Fehler aufgetreten ist, z. B. einen Benutzernamen ein, der nicht in einer bestimmten Rolle ist, die Transaktion ein Rollback aus, und keine Updates ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> -Methode zum Entfernen von einem oder mehreren Benutzern aus einer oder mehreren Rollen basierend auf Benutzereingaben. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolescs.aspx#8)]
 [!code-aspx-vb[System.Web.Security.Roles#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolesvb.aspx#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Eine der in <paramref name="roleNames" /> angegebenen Rollen ist <see langword="null" />.  
  
 - oder -   
  
 Einer der in <paramref name="usernames" /> angegebenen Benutzer ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine der in <paramref name="roleNames" /> angegebenen Rollen ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 Einer der in <paramref name="usernames" /> angegebenen Benutzer ist eine leere Zeichenfolge oder enthält ein Komma (,).  
  
 - oder -   
  
 <paramref name="roleNames" /> enthält ein doppeltes Element.  
  
 - oder -   
  
 <paramref name="usernames" /> enthält ein doppeltes Element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="RoleExists">
      <MemberSignature Language="C#" Value="public static bool RoleExists (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RoleExists(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RoleExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RoleExists (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool RoleExists(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Der Name der Rolle, die in der Datenquelle gesucht werden soll.</param>
        <summary>Ruft einen Wert ab, der angibt, ob der angegebene Rollenname bereits in der Rollendatenquelle vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn der Rollenname bereits in der Datenquelle vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Security.Roles.RoleExists%2A> Methodenaufrufe der `RoleExists` Methode von der Standard-Rollenanbieter, um zu bestimmen, ob der Name der Rolle in der Datenquelle für die Anwendung vorhanden ist, die im angegebenen die <xref:System.Web.Security.Roles.ApplicationName%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.Security.Roles.RoleExists%2A> Methode, um zu bestimmen, ob ein Rollenname bereits vor dem Erstellen der Rolle. Ein Beispiel der Datei "Web.config", die mit der Rollenverwaltung kann, finden Sie unter <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  In diesem Beispiel enthält ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Übersicht über Skriptangriffe](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> ist <see langword="null" /> (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> ist eine leere Zeichenfolge oder enthält ein Komma (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Rollenverwaltung ist nicht aktiviert.</exception>
      </Docs>
    </Member>
  </Members>
</Type>