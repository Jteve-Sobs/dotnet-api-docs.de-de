<Type Name="WindowsIdentity" FullName="System.Security.Principal.WindowsIdentity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8bff5dc58a615f589b28c2a3a07851cb50ee8a59" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55312503" /></Metadata><TypeSignature Language="C#" Value="public class WindowsIdentity : System.Security.Claims.ClaimsIdentity, IDisposable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsIdentity extends System.Security.Claims.ClaimsIdentity implements class System.IDisposable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable, class System.Security.Principal.IIdentity" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsIdentity" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsIdentity&#xA;Inherits ClaimsIdentity&#xA;Implements IDeserializationCallback, IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsIdentity : System::Security::Claims::ClaimsIdentity, IDisposable, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type WindowsIdentity = class&#xA;    inherit ClaimsIdentity&#xA;    interface IIdentity&#xA;    interface IDeserializationCallback&#xA;    interface ISerializable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsIdentity</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Principal.IIdentity</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Windows-Benutzer dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Security.Principal.WindowsIdentity.GetCurrent%2A> Methode zum Erstellen einer <xref:System.Security.Principal.WindowsIdentity> -Objekt, das den aktuellen Benutzer darstellt.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung von Membern der <xref:System.Security.Principal.WindowsIdentity> Klasse.  Ein Beispiel zur Vorgehensweise erhalten Sie eine Windows-Konto durch einen Aufruf, der nicht verwalteten Win32-token `LogonUser` -Funktion, und verwenden, die token eines anderen Benutzers, finden Sie unter den <xref:System.Security.Principal.WindowsImpersonationContext> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#1)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (IntPtr userToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int userToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (userToken As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(IntPtr userToken);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : nativeint -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity userToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="userToken" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="userToken">Das Kontotoken für den Benutzer, für den der Code ausgeführt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch das angegebene Windows-Kontotoken dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Security.Principal.WindowsIdentity>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>|`Negotiate`|  
|<xref:System.Security.Principal.WindowsAccountType>|`Normal`|  
|<xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A>|`false`|  
  
> [!NOTE]
>  Sie können das Token durch dargestellt abrufen `userToken` durch Aufrufen von nicht verwaltetem Code, z. B. die Win32-API `LogonUser` Funktion. Immer frei `userToken` durch den Aufruf der Win32-API `CloseHandle` Funktion. Weitere Informationen zum Aufrufen von nicht verwalteten Codes finden Sie unter [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userToken" /> ist 0.  
  
- oder - 
 <paramref name="userToken" /> ist dupliziert und für Identitätswechsel ungültig.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Win32-Fehler.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WindowsIdentity (System.Security.Principal.WindowsIdentity identity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity identity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (identity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WindowsIdentity(System::Security::Principal::WindowsIdentity ^ identity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity identity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.WindowsIdentity" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="identity">Das Objekt, aus dem die neue Instanz von <see cref="T:System.Security.Principal.WindowsIdentity" /> erstellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse unter Verwendung des angegebenen <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (string sUserPrincipalName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string sUserPrincipalName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (sUserPrincipalName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(System::String ^ sUserPrincipalName);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : string -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity sUserPrincipalName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="sUserPrincipalName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sUserPrincipalName">Der UPN des Benutzers, für den der Code ausgeführt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch den angegebenen UPN (User Principal Name, Benutzerprinzipalname) dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein UPN weist das Format *Benutzername*@*Domainname*.com, das heißt, eine e-Mail-Adresse. Der UPN im identifizierten `sUserPrincipalName` dient zum Abrufen eines Tokens für den Benutzer über die Win32-API `LsaLogonUser` Funktion. Im Gegenzug wird dieses Token zur Identifizierung des Benutzers verwendet. Eine Ausnahme kann aufgrund von die Unfähigkeit, melden Sie sich mit den angegebenen UPN zurückgegeben werden.  
  
> [!NOTE]
>  Dieser Konstruktor ist für die Verwendung nur auf Computern, die Windows Server 2003 oder höher Domänen angehören, gedacht. Für frühere Domänentypen ist eine Ausnahme ausgelöst. Diese Einschränkung ist aufgrund der Tatsache, dass dieser Konstruktor verwendet die [KERB_S4U_LOGON Struktur](https://go.microsoft.com/fwlink/?LinkId=143533), der erste wurde in Windows Server 2003 eingeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Windows hat den Windows NT-Statuscode STATUS_ACCESS_DENIED zurückgegeben.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Der Computer ist nicht mit einer Domäne verbunden, in der Windows 2003 oder höher ausgeführt wird.  
  
- oder - 
Auf dem Computer wird nicht Windows 2003 oder höher ausgeführt.  
  
- oder - 
Der Benutzer ist kein Mitglied der Domäne, in der sich der Computer befindet.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (IntPtr userToken, string type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int userToken, string type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (userToken As IntPtr, type As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(IntPtr userToken, System::String ^ type);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : nativeint * string -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity (userToken, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="userToken" Type="System.IntPtr" />
        <Parameter Name="type" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userToken">Das Kontotoken für den Benutzer, für den der Code ausgeführt wird.</param>
        <param name="type">(Nur für Informationszwecke.) Der zur Identifizierung des Benutzers verwendete Authentifizierungstyp.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch das angegebene Windows-Kontotoken und den angegebenen Authentifizierungstyp dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Security.Principal.WindowsIdentity>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Security.Principal.WindowsAccountType>|`Normal`|  
|<xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A>|`false`|  
  
 Der Wert des der `type` Parameter dient zum Festlegen der <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Parameter. Wenn `type` ist `null`, legt das System die Sicherheit <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> zu `Negotiate` auf Windows Vista und höheren Versionen des Windows-Betriebssystems und zum `Kerberos` in früheren Versionen des Windows-Betriebssystems. Das Sicherheitssystem wird dieser Wert nicht verwendet. Es ist nur zu Informationszwecken.  
  
> [!NOTE]
>  Sie können das Token durch dargestellt abrufen `userToken` durch Aufrufen von nicht verwaltetem Code, z. B. die Win32-API `LogonUser` Funktion. Immer frei `userToken` durch den Aufruf der Win32-API `CloseHandle` Funktion. Weitere Informationen zum Aufrufen von nicht verwalteten Codes finden Sie unter [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung von der <xref:System.Security.Principal.WindowsIdentity.%23ctor%2A> Konstruktor eine neue Instanz der Erstellung der <xref:System.Security.Principal.WindowsIdentity> Klasse für den Benutzer, die durch das angegebene Windows-Kontotoken und den angegebenen Authentifizierungstyp dargestellt wird. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#4)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#4)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userToken" /> ist 0.  
  
- oder - 
 <paramref name="userToken" /> ist dupliziert und für Identitätswechsel ungültig.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Win32-Fehler.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt mit den Kontoinformationen für den Benutzer.</param>
        <param name="context">Ein Objekt, das die Merkmale des Streams angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch Informationen in einem <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Stream dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eine <see cref="T:System.Security.Principal.WindowsIdentity" /> kann nicht prozessübergreifend serialisiert werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Win32-Fehler.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (string sUserPrincipalName, string type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string sUserPrincipalName, string type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (sUserPrincipalName As String, type As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(System::String ^ sUserPrincipalName, System::String ^ type);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : string * string -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity (sUserPrincipalName, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="sUserPrincipalName" Type="System.String" />
        <Parameter Name="type" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sUserPrincipalName">Der UPN des Benutzers, für den der Code ausgeführt wird.</param>
        <param name="type">(Nur für Informationszwecke.) Der zur Identifizierung des Benutzers verwendete Authentifizierungstyp.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch den angegebenen UPN (User Principal Name, Benutzerprinzipalname) und den angegebenen Authentifizierungstyp dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der `type` Parameter dient zum Festlegen der <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Parameter. Wenn `type` ist `null`, legt das System die Sicherheit <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> zu `Negotiate` auf Windows Vista und höheren Versionen des Windows-Betriebssystems und zum `Kerberos` in früheren Versionen des Windows-Betriebssystems. Das Sicherheitssystem wird dieser Wert nicht verwendet. Es ist nur zu Informationszwecken.  
  
 Der UPN im identifizierten `sUserPrincipalName` dient zum Abrufen eines Tokens für den Benutzer über die Win32-API `LsaLogonUser` Funktion. Im Gegenzug wird dieses Token zur Identifizierung des Benutzers verwendet. Eine Ausnahme kann aufgrund von die Unfähigkeit, melden Sie sich mit den angegebenen UPN zurückgegeben werden.  
  
> [!NOTE]
>  Dieser Konstruktor ist für die Verwendung nur auf Computern, die Windows Server 2003 oder höher Domänen angehören, gedacht. Für frühere Domänentypen ist eine Ausnahme ausgelöst. Diese Einschränkung ist aufgrund der Tatsache, dass dieser Konstruktor verwendet die [KERB_S4U_LOGON Struktur](https://go.microsoft.com/fwlink/?LinkId=143533), der erste wurde in Windows Server 2003 eingeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Windows hat den Windows NT-Statuscode STATUS_ACCESS_DENIED zurückgegeben.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Der Computer ist nicht mit einer Domäne verbunden, in der Windows 2003 oder höher ausgeführt wird.  
  
- oder - 
Auf dem Computer wird nicht Windows 2003 oder höher ausgeführt.  
  
- oder - 
Der Benutzer ist kein Mitglied der Domäne, in der sich der Computer befindet.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (IntPtr userToken, string type, System.Security.Principal.WindowsAccountType acctType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int userToken, string type, valuetype System.Security.Principal.WindowsAccountType acctType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (userToken As IntPtr, type As String, acctType As WindowsAccountType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(IntPtr userToken, System::String ^ type, System::Security::Principal::WindowsAccountType acctType);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : nativeint * string * System.Security.Principal.WindowsAccountType -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity (userToken, type, acctType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="userToken" Type="System.IntPtr" />
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="acctType" Type="System.Security.Principal.WindowsAccountType" />
      </Parameters>
      <Docs>
        <param name="userToken">Das Kontotoken für den Benutzer, für den der Code ausgeführt wird.</param>
        <param name="type">(Nur für Informationszwecke.) Der zur Identifizierung des Benutzers verwendete Authentifizierungstyp.</param>
        <param name="acctType">Einer der Enumerationswerte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch das angegebene Windows-Kontotoken, den angegebenen Authentifizierungstyp und den angegebenen Windows-Kontotyp dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Security.Principal.WindowsIdentity>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A>|`false`|  
  
 Der Wert des der `type` Parameter dient zum Festlegen der <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Parameter. Wenn `type` ist `null`, legt das System die Sicherheit <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> zu `Negotiate` auf Windows Vista und höheren Versionen des Windows-Betriebssystems und zum `Kerberos` in früheren Versionen des Windows-Betriebssystems. Das Sicherheitssystem wird dieser Wert nicht verwendet. Es ist nur zu Informationszwecken.  
  
> [!NOTE]
>  Sie können das Token durch dargestellt abrufen `userToken` durch Aufrufen von nicht verwaltetem Code, z. B. die Win32-API `LogonUser` Funktion. Immer frei `userToken` durch den Aufruf der Win32-API `CloseHandle` Funktion. Weitere Informationen zum Aufrufen von nicht verwalteten Codes finden Sie unter [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung von der <xref:System.Security.Principal.WindowsIdentity.%23ctor%2A> Konstruktor eine neue Instanz der Erstellung der <xref:System.Security.Principal.WindowsIdentity> Klasse für den Benutzer, die durch das angegebene Windows-Kontotoken, den angegebenen Authentifizierungstyp und den angegebenen Windows-Kontotyp dargestellt wird. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#7)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#7)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userToken" /> ist 0.  
  
- oder - 
 <paramref name="userToken" /> ist dupliziert und für Identitätswechsel ungültig.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Win32-Fehler.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsIdentity (IntPtr userToken, string type, System.Security.Principal.WindowsAccountType acctType, bool isAuthenticated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int userToken, string type, valuetype System.Security.Principal.WindowsAccountType acctType, bool isAuthenticated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (userToken As IntPtr, type As String, acctType As WindowsAccountType, isAuthenticated As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsIdentity(IntPtr userToken, System::String ^ type, System::Security::Principal::WindowsAccountType acctType, bool isAuthenticated);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsIdentity : nativeint * string * System.Security.Principal.WindowsAccountType * bool -&gt; System.Security.Principal.WindowsIdentity" Usage="new System.Security.Principal.WindowsIdentity (userToken, type, acctType, isAuthenticated)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="userToken" Type="System.IntPtr" />
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="acctType" Type="System.Security.Principal.WindowsAccountType" />
        <Parameter Name="isAuthenticated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userToken">Das Kontotoken für den Benutzer, für den der Code ausgeführt wird.</param>
        <param name="type">(Nur für Informationszwecke.) Der zur Identifizierung des Benutzers verwendete Authentifizierungstyp.</param>
        <param name="acctType">Einer der Enumerationswerte.</param>
        <param name="isAuthenticated"><see langword="true" />, um anzugeben, dass der Benutzer authentifiziert ist, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsIdentity" />-Klasse für den Benutzer, der durch das angegebene Windows-Kontotoken, den angegebenen Authentifizierungstyp, den angegebenen Windows-Kontotyp und den angegebenen Authentifizierungsstatus dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der `type` Parameter dient zum Festlegen der <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Parameter. Wenn `type` ist `null`, legt das System die Sicherheit <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> zu `Negotiate` auf Windows Vista und höheren Versionen des Windows-Betriebssystems und zum `Kerberos` in früheren Versionen des Windows-Betriebssystems. Das Sicherheitssystem wird dieser Wert nicht verwendet. Es ist nur zu Informationszwecken.  
  
 Sie können das Token durch dargestellt abrufen `userToken` durch Aufrufen von nicht verwaltetem Code, z. B. die Win32-API `LogonUser` Funktion. Immer frei `userToken` durch den Aufruf der Win32-API `CloseHandle` Funktion. Weitere Informationen zum Aufrufen von nicht verwalteten Codes finden Sie unter [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung von der <xref:System.Security.Principal.WindowsIdentity.%23ctor%2A> Konstruktor, um eine neue Instanz der erstellen die <xref:System.Security.Principal.WindowsIdentity> Klasse für den Benutzer, die durch das angegebene Windows-Kontotoken, den angegebenen Authentifizierungstyp, den angegebenen Windows-Kontotyp dargestellt wird und die Authentication-Status wird angegeben. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#17)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#17)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userToken" /> ist 0.  
  
- oder - 
 <paramref name="userToken" /> ist dupliziert und für Identitätswechsel ungültig.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Win32-Fehler.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AccessToken">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeAccessTokenHandle AccessToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeAccessTokenHandle AccessToken" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.AccessToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessToken As SafeAccessTokenHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeAccessTokenHandle ^ AccessToken { Microsoft::Win32::SafeHandles::SafeAccessTokenHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessToken : Microsoft.Win32.SafeHandles.SafeAccessTokenHandle" Usage="System.Security.Principal.WindowsIdentity.AccessToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeAccessTokenHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft dieses <see cref="T:Microsoft.Win32.SafeHandles.SafeAccessTokenHandle" /> für diese <see cref="T:System.Security.Principal.WindowsIdentity" />-Instanz ab.</summary>
        <value>Gibt einen Wert vom Typ <see cref="T:Microsoft.Win32.SafeHandles.SafeAccessTokenHandle" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationType">
      <MemberSignature Language="C#" Value="public override sealed string AuthenticationType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationType" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.AuthenticationType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property AuthenticationType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationType : string" Usage="System.Security.Principal.WindowsIdentity.AuthenticationType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Principal.IIdentity.AuthenticationType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zur Identifizierung des Benutzers verwendeten Authentifizierungstyp ab.</summary>
        <value>Der zur Identifizierung des Benutzers verwendete Authentifizierungstyp.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft dient nur zu Informationszwecken; Es wird nicht vom Sicherheitssystem verwendet. Auf Windows Vista und höheren Versionen des Windows-Betriebssystems, der Standardwert für diese Eigenschaft ist `Negotiate`, die wählt des besten Security Support Providers (SSP) basierend auf Kunden-Sicherheitsrichtlinie. Ist der Wert der Standardeigenschaft für frühere Versionen des Windows-Betriebssystems `Kerberos`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Windows hat den Windows NT-Statuscode STATUS_ACCESS_DENIED zurückgegeben.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.  
  
- oder - 
Der Computer ist nicht mit einer Domäne verbunden, in der Windows 2003 oder höher ausgeführt wird.  
  
- oder - 
Auf dem Computer wird nicht Windows 2003 oder höher ausgeführt.  
  
- oder - 
Der Benutzer ist kein Mitglied der Domäne, in der sich der Computer befindet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Claims">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; Claims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; Claims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.Claims" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Claims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ Claims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Claims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsIdentity.Claims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsIdentity/&lt;get_Claims&gt;d__95))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsIdentity/&lt;get_Claims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsIdentity/&lt;get_Claims&gt;d__79))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Ansprüche für den Benutzer ab, der durch diese Windows-Identität dargestellt wird.</summary>
        <value>Eine Sammlung von Ansprüchen für dieses <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.Security.Claims.ClaimsIdentity Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Claims.ClaimsIdentity Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Claims::ClaimsIdentity ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Security.Claims.ClaimsIdentity" Usage="windowsIdentity.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues Objekt, das eine Kopie der aktuellen Instanz darstellt.</summary>
        <returns>Eine Kopie der aktuellen Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultIssuer">
      <MemberSignature Language="C#" Value="public const string DefaultIssuer;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultIssuer" />
      <MemberSignature Language="DocId" Value="F:System.Security.Principal.WindowsIdentity.DefaultIssuer" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultIssuer As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultIssuer;" />
      <MemberSignature Language="F#" Value="val mutable DefaultIssuer : string" Usage="System.Security.Principal.WindowsIdentity.DefaultIssuer" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert den Namen des standardmäßigen <see cref="T:System.Security.Claims.ClaimsIdentity" />-Ausstellers.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsIdentity.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Ansprüche ab, die den <see cref="F:System.Security.Claims.ClaimTypes.WindowsDeviceClaim" />-Eigenschaftsschlüssel aufweisen.</summary>
        <value>Eine Sammlung von Ansprüchen, die den <see cref="F:System.Security.Claims.ClaimTypes.WindowsDeviceClaim" />-Eigenschaftsschlüssel aufweisen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Security.Principal.WindowsIdentity" /> verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="windowsIdentity.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Security.Principal.WindowsIdentity" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Security.Principal.WindowsIdentity.Dispose%2A> auf, wenn Sie <xref:System.Security.Principal.WindowsIdentity> nicht mehr benötigen. Die <xref:System.Security.Principal.WindowsIdentity.Dispose%2A>-Methode bewirkt, dass <xref:System.Security.Principal.WindowsIdentity> nicht mehr verwendet werden kann. Nach dem Aufruf <xref:System.Security.Principal.WindowsIdentity.Dispose%2A>, Sie müssen alle Verweise auf Freigeben der <xref:System.Security.Principal.WindowsIdentity> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Security.Principal.WindowsIdentity> belegt wurde. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Security.Principal.WindowsIdentity.Dispose%2A> auf, bevor Sie den letzten Verweis auf das <xref:System.Security.Principal.WindowsIdentity> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Security.Principal.WindowsIdentity>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="windowsIdentity.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Security.Principal.WindowsIdentity" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Security.Principal.WindowsIdentity> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die zuvor von einem früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WindowsIdentity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WindowsIdentity ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="windowsIdentity.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der aktuellen Instanz reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> Dieser Member wird in .NET Framework, Version 2.0 und nachfolgenden Versionen entfernt.


Diese Methode wird von Anwendungscode nicht aufgerufen werden. Es wird automatisch während der Garbagecollection aufgerufen werden, es sei denn, durch den Garbage Collector-Finalisierung wurde deaktiviert. Weitere Informationen finden Sie unter <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> und <xref:System.Object.Finalize>. Diese Methode überschreibt <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnonymous">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.WindowsIdentity GetAnonymous ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Principal.WindowsIdentity GetAnonymous() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.GetAnonymous" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAnonymous () As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Principal::WindowsIdentity ^ GetAnonymous();" />
      <MemberSignature Language="F#" Value="static member GetAnonymous : unit -&gt; System.Security.Principal.WindowsIdentity" Usage="System.Security.Principal.WindowsIdentity.GetAnonymous " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt zurück, das Sie als Sentinelwert im Code verwenden können, um einen anonymen Benutzer darzustellen. Der Eigenschaftswert stellt nicht die integrierte anonyme Identität dar, die vom Windows-Betriebssystem verwendet wird.</summary>
        <returns>Ein Objekt, das einen anonymen Benutzer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt eine leere <xref:System.Security.Principal.WindowsIdentity> -Objekt, das Ihnen ermöglicht, die Vorgänge als anonyme behandelt werden sollen. Den Wert der Eigenschaft entspricht keinen anonymen Benutzer von Windows und kann nicht für den Identitätswechsel verwendet werden. Beachten Sie auch, dass die von dieser Eigenschaft zurückgegebene Identität nicht statisch ist. Jeder Aufruf von <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> eine andere anonyme Identität zurück.  
  
 Sie können die <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> Eigenschaft zum Ermitteln des Rückgabewerts <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A>. Allerdings <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> erkennt sowohl die anonyme Windows-Identität und die anonyme Identität, die von dieser Methode zurückgegeben. Um die letztere Identitäten zu verwenden, Zwischenspeichern der <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> Rückgabewert statt der <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> Eigenschaft.  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung von der <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> -Methode zur Rückgabe einer <xref:System.Security.Principal.WindowsIdentity> Objekt, das einen anonymen Windows-Benutzer darstellt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#15)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#15)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt zurück, das den aktuellen Windows-Benutzer darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.WindowsIdentity GetCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Principal.WindowsIdentity GetCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.GetCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrent () As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Principal::WindowsIdentity ^ GetCurrent();" />
      <MemberSignature Language="F#" Value="static member GetCurrent : unit -&gt; System.Security.Principal.WindowsIdentity" Usage="System.Security.Principal.WindowsIdentity.GetCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt zurück, das den aktuellen Windows-Benutzer darstellt.</summary>
        <returns>Ein Objekt, das den aktuellen Benutzer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende Code zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.GetCurrent%2A> -Methode zur Rückgabe einer <xref:System.Security.Principal.WindowsIdentity> -Objekt, das den aktuellen Windows-Benutzer darstellt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#13)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#13)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.WindowsIdentity GetCurrent (bool ifImpersonating);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Principal.WindowsIdentity GetCurrent(bool ifImpersonating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.GetCurrent(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrent (ifImpersonating As Boolean) As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Principal::WindowsIdentity ^ GetCurrent(bool ifImpersonating);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : bool -&gt; System.Security.Principal.WindowsIdentity" Usage="System.Security.Principal.WindowsIdentity.GetCurrent ifImpersonating" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifImpersonating" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ifImpersonating"><see langword="true" />, um nur die <see cref="T:System.Security.Principal.WindowsIdentity" /> zurückzugeben, wenn der Thread gerade einen Identitätswechsel ausführt. <see langword="false" />, um die <see cref="T:System.Security.Principal.WindowsIdentity" /> des Threads zurückzugeben, wenn er einen Identitätswechsel ausführt, oder die <see cref="T:System.Security.Principal.WindowsIdentity" /> des Prozesses, wenn der Thread gerade keinen Identitätswechsel ausführt.</param>
        <summary>Gibt ein <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt zurück, das eine Windows-Identität für den Thread oder den Prozess darstellt, je nach Wert des <paramref name="ifImpersonating" />-Parameters.</summary>
        <returns>Ein Objekt, das einen Windows-Benutzer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `ifImpersonating` ist `true` und der Thread keinen Identitätswechsel ausführt, die zurückgegebene <xref:System.Security.Principal.WindowsIdentity> Objekt hat keinen Wert.  Wenn `ifImpersonating` ist `false` und der Thread einen Identitätswechsel ausführt, wird die <xref:System.Security.Principal.WindowsIdentity> für den Thread zurückgegeben wird.  Wenn `ifImpersonating` ist `false` und der Thread keinen Identitätswechsel ausführt, wird die <xref:System.Security.Principal.WindowsIdentity> für den Prozess zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.WindowsIdentity GetCurrent (System.Security.Principal.TokenAccessLevels desiredAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Principal.WindowsIdentity GetCurrent(valuetype System.Security.Principal.TokenAccessLevels desiredAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.GetCurrent(System.Security.Principal.TokenAccessLevels)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrent (desiredAccess As TokenAccessLevels) As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Principal::WindowsIdentity ^ GetCurrent(System::Security::Principal::TokenAccessLevels desiredAccess);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Security.Principal.TokenAccessLevels -&gt; System.Security.Principal.WindowsIdentity" Usage="System.Security.Principal.WindowsIdentity.GetCurrent desiredAccess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="desiredAccess" Type="System.Security.Principal.TokenAccessLevels" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="desiredAccess">Eine bitweise Kombination der Enumerationswerte.</param>
        <summary>Gibt ein <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt zurück, das den aktuellen Windows-Benutzer darstellt, der die angegebene gewünschte Tokenzugriffsebene verwendet.</summary>
        <returns>Ein Objekt, das den aktuellen Benutzer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `desiredAccess` Parameter gibt an, einer Zugriffsmaske, die die angeforderten Typen des Zugriffs auf das Zugriffstoken identifiziert. Diese angeforderten Zugriffstypen werden verglichen, mit der Tokens discretionary Access Control List (DACL), um zu bestimmen, welche Typen von Zugriff gewährt oder verweigert werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IdentityReferenceCollection Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IdentityReferenceCollection Groups" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.Groups" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Groups As IdentityReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IdentityReferenceCollection ^ Groups { System::Security::Principal::IdentityReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Security.Principal.IdentityReferenceCollection" Usage="System.Security.Principal.WindowsIdentity.Groups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IdentityReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gruppen ab, zu denen der aktuelle Windows-Benutzer gehört.</summary>
        <value>Ein Objekt, das die Gruppen darstellt, zu denen der Windows-Benutzer gehört.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.Groups%2A> Eigenschaft, um die Identitätsverweise für die Gruppen anzuzeigen, der aktuelle Benutzer angehört.  Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#20)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Impersonate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermöglicht es, im Code die Identität eines anderen Windows-Benutzers anzunehmen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Impersonate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.WindowsImpersonationContext Impersonate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Principal.WindowsImpersonationContext Impersonate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.Impersonate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Impersonate () As WindowsImpersonationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Principal::WindowsImpersonationContext ^ Impersonate();" />
      <MemberSignature Language="F#" Value="abstract member Impersonate : unit -&gt; System.Security.Principal.WindowsImpersonationContext&#xA;override this.Impersonate : unit -&gt; System.Security.Principal.WindowsImpersonationContext" Usage="windowsIdentity.Impersonate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsImpersonationContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt die Identität des durch das <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekt dargestellten Benutzers an.</summary>
        <returns>Ein Objekt, das den Windows-Benutzer vor dem Identitätswechsel darstellt. Es kann dazu verwendet werden, in den Kontext des ursprünglichen Benutzers zurückzukehren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf Windows NT-Plattformen muss der aktuelle Benutzer über ausreichende Berechtigungen zum Identitätswechsel zugelassen haben.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie eine Windows-Kontotokens durch Aufrufen von nicht verwalteten Win32 `LogonUser` -Funktion, und wie Sie die Verwendung des Tokens, die Identität eines anderen Benutzers annehmen, und klicken Sie dann auf die ursprüngliche Identität.  
  
 [!code-cpp[WindowsIdentity Impersonation#1](~/samples/snippets/cpp/VS_Snippets_CLR/WindowsIdentity Impersonation/CPP/source.cpp#1)]
 [!code-csharp[WindowsIdentity Impersonation#1](~/samples/snippets/csharp/VS_Snippets_CLR/WindowsIdentity Impersonation/CS/source.cs#1)]
 [!code-vb[WindowsIdentity Impersonation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WindowsIdentity Impersonation/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine anonyme Identität hat versucht, einen Identitätswechsel durchzuführen.</exception>
        <exception cref="T:System.Security.SecurityException">Win32-Fehler.</exception>
        <block subset="none" type="overrides"><para>Da Microsoft Windows 98 und Windows Millennium Edition (Windows Me) nicht Benutzertoken verfügen, auf diesen Plattformen kein Identitätswechsel möglich.</para></block>
        <block subset="none" type="usage"><para>Nach der Verwendung von <see cref="M:System.Security.Principal.WindowsIdentity.Impersonate" />, es ist wichtig, rufen Sie die <see cref="M:System.Security.Principal.WindowsImpersonationContext.Undo" /> Methode, um den Identitätswechsel zu beenden.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Impersonate">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.WindowsImpersonationContext Impersonate (IntPtr userToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Principal.WindowsImpersonationContext Impersonate(native int userToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Impersonate (userToken As IntPtr) As WindowsImpersonationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Principal::WindowsImpersonationContext ^ Impersonate(IntPtr userToken);" />
      <MemberSignature Language="F#" Value="static member Impersonate : nativeint -&gt; System.Security.Principal.WindowsImpersonationContext" Usage="System.Security.Principal.WindowsIdentity.Impersonate userToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsImpersonationContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userToken" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="userToken">Das Handle eines Windows-Kontotokens. Dieses Token wird normalerweise durch einen Aufruf von nicht verwaltetem Code abgerufen, z. B. durch einen Aufruf der <see langword="LogonUser" />-Funktion der Win32-API.</param>
        <summary>Nimmt die Identität des durch das angegebene Benutzertoken dargestellten Benutzers an.</summary>
        <returns>Ein Objekt, das den Windows-Benutzer vor dem Identitätswechsel darstellt. Es kann dazu verwendet werden, in den Kontext des ursprünglichen Benutzers zurückzukehren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf Windows NT-Plattformen muss der aktuelle Benutzer über ausreichende Berechtigungen zum Identitätswechsel zugelassen haben.  
  
> [!NOTE]
>  Aufrufen der <xref:System.Security.Principal.WindowsIdentity.Impersonate%28System.IntPtr%29> -Methode mit einem `userToken` Wert <xref:System.IntPtr.Zero> entspricht dem Aufruf der Win32 `RevertToSelf` Funktion. Wenn ein anderer Benutzer derzeit ein Identitätswechsel ausgeführt wird, wird die Kontrolle für den ursprünglichen Benutzer zurückgesetzt.  
  
 Weitere Informationen zum Aufrufen von nicht verwaltetem Code finden Sie unter [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie eine Windows-Kontotokens durch Aufrufen von nicht verwalteten Win32 `LogonUser` -Funktion, und wie Sie die Verwendung des Tokens, die Identität eines anderen Benutzers annehmen, und klicken Sie dann auf die ursprüngliche Identität.  
  
 [!code-csharp[WindowsIdentity Impersonation2#1](~/samples/snippets/csharp/VS_Snippets_CLR/windowsidentity impersonation2/cs/source.cs#1)]
 [!code-vb[WindowsIdentity Impersonation2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/windowsidentity impersonation2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Windows hat den Windows NT-Statuscode STATUS_ACCESS_DENIED zurückgegeben.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die ordnungsgemäßen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf das Prinzipalobjekt bearbeiten und Zugriff auf nicht verwalteten Code. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> und <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Da Microsoft Windows 98 und Windows Millennium Edition (Windows Me) nicht Benutzertoken verfügen, auf diesen Plattformen kein Identitätswechsel möglich.</para></block>
        <block subset="none" type="usage"><para>Nach der Verwendung von <see cref="M:System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)" />, es ist wichtig, rufen Sie die <see cref="M:System.Security.Principal.WindowsImpersonationContext.Undo" /> Methode, um den Identitätswechsel zu beenden.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Security.Principal.WindowsIdentity.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Identitätswechselebene für den Benutzer ab.</summary>
        <value>Einer der Enumerationswerte, der die Personifikationsebene angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beschreibt die für die Verbindung mit WMI zu verwendende Ebene des Identitätswechsels.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.ImpersonationLevel%2A> Eigenschaft, um die Ebene des Identitätswechsels für den aktuellen Benutzer anzuzeigen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#21)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAnonymous">
      <MemberSignature Language="C#" Value="public virtual bool IsAnonymous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnonymous" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.IsAnonymous" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAnonymous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAnonymous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnonymous : bool" Usage="System.Security.Principal.WindowsIdentity.IsAnonymous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Benutzerkonto vom System als anonymes Konto identifiziert wird.</summary>
        <value><see langword="true" />, wenn das Benutzerkonto ein anonymes Konto ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> Eigenschaft erkennt, sowohl die anonyme Windows-Identität und die anonyme Identität, die von zurückgegeben wird das <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> Methode.  
  
 In ASP.NET-basierten Anwendungen sind anonyme Konten in der Regel nur nur auftritt, wenn anonymer Zugriff von Internet Information Services (IIS) zulässig ist.  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> Eigenschaft, um festzustellen, ob das Benutzerkonto vom System als anonymes Konto identifiziert wird. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#9)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#9)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Security.Principal.WindowsIdentity.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Principal.IIdentity.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Benutzer von Windows authentifiziert wurde.</summary>
        <value><see langword="true" />, wenn der Benutzer authentifiziert wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGuest">
      <MemberSignature Language="C#" Value="public virtual bool IsGuest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGuest" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.IsGuest" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGuest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGuest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGuest : bool" Usage="System.Security.Principal.WindowsIdentity.IsGuest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Benutzerkonto vom System als <see cref="F:System.Security.Principal.WindowsAccountType.Guest" />-Konto identifiziert wird.</summary>
        <value><see langword="true" />, wenn das Benutzerkonto ein <see cref="F:System.Security.Principal.WindowsAccountType.Guest" />-Konto ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende Code zeigt die Verwendung von der <xref:System.Security.Principal.WindowsIdentity.IsGuest%2A> Eigenschaft, um ein Rückgabewert, der angibt, ob das Benutzerkonto, das als identifiziert wird eine <xref:System.Security.Principal.WindowsAccountType.Guest> Konto durch das System. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#12)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#12)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSystem">
      <MemberSignature Language="C#" Value="public virtual bool IsSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSystem" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.IsSystem" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSystem : bool" Usage="System.Security.Principal.WindowsIdentity.IsSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Benutzerkonto vom System als <see cref="F:System.Security.Principal.WindowsAccountType.System" />-Konto identifiziert wird.</summary>
        <value><see langword="true" />, wenn das Benutzerkonto ein <see cref="F:System.Security.Principal.WindowsAccountType.System" />-Konto ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende Code zeigt die Verwendung von der <xref:System.Security.Principal.WindowsIdentity.IsSystem%2A> Eigenschaft, um ein Rückgabewert, der angibt, ob das Benutzerkonto, das als identifiziert wird eine <xref:System.Security.Principal.WindowsAccountType.System> Konto durch das System. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#11)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#11)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Security.Principal.WindowsIdentity.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Principal.IIdentity.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Windows-Anmeldenamen des Benutzers ab.</summary>
        <value>Der Windows-Anmeldename des Benutzers, für den der Code ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Anmeldename ist im Format "Domäne\Benutzername".  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.Name%2A> Eigenschaft, um Windows-Anmeldenamen des Benutzers abzurufen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#8)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#8)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Security.Principal.SecurityIdentifier Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.SecurityIdentifier Owner" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As SecurityIdentifier" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::SecurityIdentifier ^ Owner { System::Security::Principal::SecurityIdentifier ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Security.Principal.SecurityIdentifier" Usage="System.Security.Principal.WindowsIdentity.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.SecurityIdentifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sicherheits-ID für den Tokenbesitzer ab.</summary>
        <value>Ein Objekt für den Tokenbesitzer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die SID identifiziert eindeutig einen Benutzer oder eine Gruppe für alle Windows NT-Implementierungen.  Die zurückgegebene SID identifiziert die Standardbesitzer SID an, die auf die neu erstellte Objekte angewendet werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.Owner%2A> Eigenschaft, um die Sicherheits-ID für den Tokenbesitzer anzuzeigen.  Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse  
  
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#19)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunImpersonated">
      <MemberSignature Language="C#" Value="public static void RunImpersonated (Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunImpersonated(class Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunImpersonated(Microsoft::Win32::SafeHandles::SafeAccessTokenHandle ^ safeAccessTokenHandle, Action ^ action);" />
      <MemberSignature Language="F#" Value="static member RunImpersonated : Microsoft.Win32.SafeHandles.SafeAccessTokenHandle * Action -&gt; unit" Usage="System.Security.Principal.WindowsIdentity.RunImpersonated (safeAccessTokenHandle, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="safeAccessTokenHandle" Type="Microsoft.Win32.SafeHandles.SafeAccessTokenHandle" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="action" Type="System.Action" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="safeAccessTokenHandle">Das SafeAccessTokenHandle der imitierten Windows-Identität.</param>
        <param name="action">Die auszuführende System.Action.</param>
        <summary>Führt die angegebene Aktion als imitierte Windows-Identität aus. Statt einen imitierten Methodenaufruf zu verwenden und die Funktion in <see cref="T:System.Security.Principal.WindowsImpersonationContext" /> auszuführen, können Sie <see cref="M:System.Security.Principal.WindowsIdentity.RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)" /> verwenden und die Funktion direkt als Parameter angeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity> Klasse, um die Identität eines Benutzers.  
  
> [!WARNING]
>  In diesem Beispiel fordert den Benutzer zur Eingabe eines Kennworts an den Konsolenbildschirm. Das Kennwort werden auf dem Bildschirm angezeigt, da das Konsolenfenster maskierten Eingabe nicht systemintern unterstützt wird.  
  
```csharp  
// The following example demonstrates the use of the WindowsIdentity class to impersonate a user.   
// IMPORTANT NOTE:   
// This sample asks the user to enter a password on the console screen.   
// The password will be visible on the screen, because the console window   
// does not support masked input natively.  
  
using System;  
using System.Runtime.InteropServices;  
using System.Security;  
using System.Security.Principal;  
using Microsoft.Win32.SafeHandles;  
  
public class ImpersonationDemo  
{  
    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]  
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword,  
        int dwLogonType, int dwLogonProvider, out SafeAccessTokenHandle phToken);  
  
    public static void Main()  
    {  
        // Get the user token for the specified user, domain, and password using the   
        // unmanaged LogonUser method.   
        // The local machine name can be used for the domain name to impersonate a user on this machine.  
        Console.Write("Enter the name of the domain on which to log on: ");  
        string domainName = Console.ReadLine();  
  
        Console.Write("Enter the login of a user on {0} that you wish to impersonate: ", domainName);  
        string userName = Console.ReadLine();  
  
        Console.Write("Enter the password for {0}: ", userName);  
  
        const int LOGON32_PROVIDER_DEFAULT = 0;  
        //This parameter causes LogonUser to create a primary token.   
        const int LOGON32_LOGON_INTERACTIVE = 2;  
  
        // Call LogonUser to obtain a handle to an access token.   
        SafeAccessTokenHandle safeAccessTokenHandle;  
        bool returnValue = LogonUser(userName, domainName, Console.ReadLine(),  
            LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,  
            out safeAccessTokenHandle);  
  
        if (false == returnValue)  
        {  
            int ret = Marshal.GetLastWin32Error();  
            Console.WriteLine("LogonUser failed with error code : {0}", ret);  
            throw new System.ComponentModel.Win32Exception(ret);  
        }  
  
        Console.WriteLine("Did LogonUser Succeed? " + (returnValue ? "Yes" : "No"));  
        // Check the identity.  
        Console.WriteLine("Before impersonation: " + WindowsIdentity.GetCurrent().Name);  
  
        // Note: if you want to run as unimpersonated, pass  
        //       'SafeAccessTokenHandle.InvalidHandle' instead of variable 'safeAccessTokenHandle'  
        WindowsIdentity.RunImpersonated(  
            safeAccessTokenHandle,  
            // User action  
            () =>  
            {  
                // Check the identity.  
                Console.WriteLine("During impersonation: " + WindowsIdentity.GetCurrent().Name);  
            }  
            );  
  
        // Check the identity again.  
        Console.WriteLine("After impersonation: " + WindowsIdentity.GetCurrent().Name);  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunImpersonated&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T RunImpersonated&lt;T&gt; (Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, Func&lt;T&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T RunImpersonated&lt;T&gt;(class Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, class System.Func`1&lt;!!T&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.RunImpersonated``1(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Func{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T RunImpersonated(Microsoft::Win32::SafeHandles::SafeAccessTokenHandle ^ safeAccessTokenHandle, Func&lt;T&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member RunImpersonated : Microsoft.Win32.SafeHandles.SafeAccessTokenHandle * Func&lt;'T&gt; -&gt; 'T" Usage="System.Security.Principal.WindowsIdentity.RunImpersonated (safeAccessTokenHandle, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="safeAccessTokenHandle" Type="Microsoft.Win32.SafeHandles.SafeAccessTokenHandle" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="func" Type="System.Func&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des Objekts, das von der Funktion verwendet und zurückgegeben wird.</typeparam>
        <param name="safeAccessTokenHandle">Das SafeAccessTokenHandle der imitierten Windows-Identität.</param>
        <param name="func">Die auszuführende System.Func.</param>
        <summary>Führt die angegebene Funktion als imitierte Windows-Identität aus. Statt einen imitierten Methodenaufruf zu verwenden und die Funktion in <see cref="T:System.Security.Principal.WindowsImpersonationContext" /> auszuführen, können Sie <see cref="M:System.Security.Principal.WindowsIdentity.RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)" /> verwenden und die Funktion direkt als Parameter angeben.</summary>
        <returns>Das Ergebnis der Funktion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity> Klasse, um die Identität eines Benutzers.  
  
> [!WARNING]
>  In diesem Beispiel fordert den Benutzer zur Eingabe eines Kennworts an den Konsolenbildschirm. Das Kennwort werden auf dem Bildschirm angezeigt, da das Konsolenfenster maskierten Eingabe nicht systemintern unterstützt wird.  
  
```csharp  
// The following example demonstrates the use of the WindowsIdentity class to impersonate a user.   
// IMPORTANT NOTE:   
// This sample asks the user to enter a password on the console screen.   
// The password will be visible on the screen, because the console window   
// does not support masked input natively.  
  
using System;  
using System.Runtime.InteropServices;  
using System.Security;  
using System.Security.Principal;  
using Microsoft.Win32.SafeHandles;  
  
public class ImpersonationDemo  
{  
    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]  
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword,  
        int dwLogonType, int dwLogonProvider, out SafeAccessTokenHandle phToken);  
  
    public static void Main()  
    {  
        // Get the user token for the specified user, domain, and password using the   
        // unmanaged LogonUser method.   
        // The local machine name can be used for the domain name to impersonate a user on this machine.  
        Console.Write("Enter the name of the domain on which to log on: ");  
        string domainName = Console.ReadLine();  
  
        Console.Write("Enter the login of a user on {0} that you wish to impersonate: ", domainName);  
        string userName = Console.ReadLine();  
  
        Console.Write("Enter the password for {0}: ", userName);  
  
        const int LOGON32_PROVIDER_DEFAULT = 0;  
        //This parameter causes LogonUser to create a primary token.   
        const int LOGON32_LOGON_INTERACTIVE = 2;  
  
        // Call LogonUser to obtain a handle to an access token.   
        SafeAccessTokenHandle safeAccessTokenHandle;  
        bool returnValue = LogonUser(userName, domainName, Console.ReadLine(),  
            LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,  
            out safeAccessTokenHandle);  
  
        if (false == returnValue)  
        {  
            int ret = Marshal.GetLastWin32Error();  
            Console.WriteLine("LogonUser failed with error code : {0}", ret);  
            throw new System.ComponentModel.Win32Exception(ret);  
        }  
  
        Console.WriteLine("Did LogonUser Succeed? " + (returnValue ? "Yes" : "No"));  
        // Check the identity.  
        Console.WriteLine("Before impersonation: " + WindowsIdentity.GetCurrent().Name);  
  
        // Note: if you want to run as unimpersonated, pass  
        //       'SafeAccessTokenHandle.InvalidHandle' instead of variable 'safeAccessTokenHandle'  
        WindowsIdentity.RunImpersonated(  
            safeAccessTokenHandle,  
            // User action  
            () =>  
            {  
                // Check the identity.  
                Console.WriteLine("During impersonation: " + WindowsIdentity.GetCurrent().Name);  
            }  
            );  
  
        // Check the identity again.  
        Console.WriteLine("After impersonation: " + WindowsIdentity.GetCurrent().Name);  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle des Deserialisierungsereignisses.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und wird nach Abschluss der Deserialisierung durch das Deserialisierungsereignis aufgerufen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Ein Objekt mit den zum Serialisieren der <see cref="T:System.Collections.Hashtable" /> erforderlichen Informationen.</param>
        <param name="context">Ein Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für die <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Ruft das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den logischen Kontextinformationen ab, die zum erneuten Erstellen des Ausführungskontexts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird ein <xref:System.Runtime.Serialization.SerializationInfo> rufen Sie mit den logischen Kontextinformationen. Während der Deserialisierung der ausführungskontextobjekts wiederhergestellt ist, aus der <xref:System.Runtime.Serialization.SerializationInfo> über den Stream übertragenen.  
  
 Weitere Informationen finden Sie unter <xref:System.Runtime.Serialization.SerializationInfo>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Token">
      <MemberSignature Language="C#" Value="public virtual IntPtr Token { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Token" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.Token" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Token As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Token { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Token : nativeint" Usage="System.Security.Principal.WindowsIdentity.Token" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Windows-Kontotoken für den Benutzer ab.</summary>
        <value>Das Handle des dem aktuellen Ausführungsthread zugeordneten Zugriffstokens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist Version nicht explizit die Kontotoken, das von zurückgegebene der <xref:System.Security.Principal.WindowsIdentity.Token%2A> Eigenschaft. Das Token wird freigegeben, indem die <xref:System.Security.Principal.WindowsIdentity.Dispose%2A> -Methode, die Sie im Code aufrufen können. <xref:System.Security.Principal.WindowsIdentity.Dispose%2A> wird auch automatisch vom Garbage Collector aufgerufen werden.  
  
> [!NOTE]
>  Die Konto-Token, die von zurückgegeben wird die <xref:System.Security.Principal.WindowsIdentity.Token%2A> Eigenschaft ist ein Duplikat von der Windows-Token, das zum Erstellen der <xref:System.Security.Principal.WindowsIdentity> Objekt aus, und wird von .NET Framework automatisch freigegeben. Dies unterscheidet sich von der Kontotoken (die `userToken` Parameter für den Konstruktor), dient zum Erstellen der <xref:System.Security.Principal.WindowsIdentity> Objekt. `userToken` ist eine Windows-Kontotoken, die durch einen Aufruf erstellt wird `LogonUser` und muss geschlossen werden, um einen Speicherverlust zu vermeiden.  
  
   
  
## Examples  
 Der folgende Code zeigt die Verwendung der <xref:System.Security.Principal.WindowsIdentity.IsSystem%2A> Eigenschaft, um das Windows-Kontotoken für den Benutzer abzurufen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Principal.WindowsIdentity> Klasse.  
  
 [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CPP/windowsidentitymembers.cpp#14)]
 [!code-csharp[System.Security.Principal.WindowsIdentity_AllMembers#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/CS/windowsidentitymembers.cs#14)]
 [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsIdentity_AllMembers/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.SecurityIdentifier User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.SecurityIdentifier User" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As SecurityIdentifier" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::SecurityIdentifier ^ User { System::Security::Principal::SecurityIdentifier ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.SecurityIdentifier" Usage="System.Security.Principal.WindowsIdentity.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.SecurityIdentifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Sicherheits-ID für den Benutzer ab.</summary>
        <value>Ein Objekt für den Benutzer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die SID identifiziert eindeutig einen Benutzer oder eine Gruppe für alle Windows NT-Implementierungen.  
  
> [!NOTE]
>  Die <xref:System.Security.Principal.WindowsIdentity> zurückgegebenes Objekt der <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> Methode ist nicht identisch mit den anonymen Benutzer von Windows. Diese Eigenschaft ruft `null` für einen anonymen Benutzer, der durch dargestellt die <xref:System.Security.Principal.WindowsIdentity> zurückgegebenes Objekt der <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> Methode; er erhält nicht die SID, die einen anonymen Windows-Benutzer darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsIdentity.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsIdentity.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Ansprüche ab, die den <see cref="F:System.Security.Claims.ClaimTypes.WindowsUserClaim" />-Eigenschaftsschlüssel aufweisen.</summary>
        <value>Eine Sammlung von Ansprüchen, die den <see cref="F:System.Security.Claims.ClaimTypes.WindowsUserClaim" />-Eigenschaftsschlüssel aufweisen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>