<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="60f3b2074766909f84cb92cbbded6dadfa1d4e18" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75068738" /></Metadata><TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <TypeSignature Language="F#" Value="type WindowsPrincipal = class&#xA;    inherit ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht es Code, die Windows-Gruppenmitgliedschaft eines Windows-Benutzers zu überprüfen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Principal.WindowsPrincipal>-Klasse wird hauptsächlich verwendet, um die Rolle eines Windows-Benutzers zu überprüfen. Mit den <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType>-Methoden Überladungen können Sie die Benutzerrolle mithilfe verschiedener Rollen Kontexte überprüfen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methoden Überladungen verwendet werden. Die <xref:System.Security.Principal.WindowsBuiltInRole>-Enumeration wird als Quelle für die relativen Bezeichner (RIDs) verwendet, mit denen die integrierten Rollen identifiziert werden. Die RIDs werden zum Bestimmen der Rollen des aktuellen Prinzipals verwendet.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsPrincipal : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsPrincipal" Usage="new System.Security.Principal.WindowsPrincipal ntIdentity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">Das Objekt, aus dem die neue Instanz von <see cref="T:System.Security.Principal.WindowsPrincipal" /> erstellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsPrincipal" />-Klasse unter Verwendung des angegebenen <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein neues <xref:System.Security.Principal.WindowsPrincipal>-Objekt aus dem aktuellen <xref:System.Security.Principal.WindowsIdentity>-Objekt erstellt.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ntIdentity" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__10))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Windows-Geräteansprüche von diesem Prinzipal ab.</summary>
        <value>Eine Sammlung aller Windows-Geräteansprüche von diesem Prinzipal.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Security.Principal.IIdentity" Usage="System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity Identity { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Identity As IIdentity" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Identität des aktuellen Principals ab.</summary>
        <value>Das <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekts des aktuellen Prinzips.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird der Name des Benutzers mit der <xref:System.Security.Principal.WindowsPrincipal.Identity%2A>-Eigenschaft des <xref:System.Security.Principal.WindowsPrincipal>-Objekts abgerufen.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der aktuelle Prinzipal zu einer angegebenen Windows-Benutzergruppe gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt vier über Ladungen für diese Methode. Aus Leistungsgründen wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung dringend empfohlen.  
  
> [!IMPORTANT]
>  Die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>-Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member IsInRole : int -&gt; bool&#xA;override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">Die RID der Windows-Benutzergruppe, die auf den Status der Mitgliedschaft des Prinzipals geprüft werden soll.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zur Windows-Benutzergruppe mit der angegebenen relativen ID (RID) gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, d. h. in einer bestimmten Rolle, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Testen auf neu erstellte Rollen Informationen, wie z. b. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, sich abzumelden und sich anzumelden, um die Weitergabe von Rollen Informationen in der Domäne zu erzwingen. Wenn dies nicht der Fall ist, kann der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test `false`zurückgeben. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 Aus Leistungsgründen wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung als bevorzugte Überladung zum Ermitteln der Rolle des Benutzers empfohlen.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, für die Administratorrechte erforderlich sind, können Sie Ihre Rolle mithilfe des Dialog Felds "Zustimmung" dynamisch erhöhen. Der Code, mit dem die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>-Methode ausgeführt wird, zeigt nicht das Zustimmungs Dialogfeld an. Der Code gibt false zurück, wenn Sie sich in der Standardbenutzer Rolle befinden, auch wenn Sie sich in der integrierten Gruppe "Administratoren" befinden. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie als Administrator ausführen möchten.  
  
 Relative Bezeichner (RIDs) sind Komponenten der Sicherheits-ID (SID) einer Windows-Benutzergruppe und werden unterstützt, um plattformübergreifende Lokalisierungs Probleme zu vermeiden. Viele Benutzerkonten, lokale Gruppen und globale Gruppen verfügen über einen standardmäßigen RID-Wert, der in allen Versionen von Windows konstant ist.  
  
 Die RID für die Rolle "BUILTIN\Administrators" lautet z. b. 0x220. Die Verwendung von 0x220 als Eingabeparameter für die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>-Methode führt dazu, dass `true` zurückgegeben werden, wenn der aktuelle Prinzipal ein Administrator ist.  
  
 In den folgenden Tabellen sind die standardmäßigen Rid-Werte aufgeführt.  
  
|Integrierte Benutzer|RID|  
|---------------------|---------|  
|Domainname\administrator|0x1F4|  
|Domainname\guest|0x1F5|  
  
|Integrierte globale Gruppen|RID|  
|-----------------------------|---------|  
|Domainname\domain Admins|0x200|  
|Domainname\domäne Benutzer|0x201|  
|Domainname\domain Gäste|0x202|  
  
|Integrierte lokale Gruppen|RID|  
|----------------------------|---------|  
|VORDEFINIERT\Administratoren|0x220|  
|BUILTIN\Users|0x221|  
|Builtin\gäste|0x222|  
|Builtin\account-Operatoren|0x224|  
|VORDEFINIERT\Server-Operatoren|0x225|  
|Builtin\print-Operatoren|0x226|  
|VORDEFINIERT\Sicherungs-Operatoren|0x227|  
|Builtin\replicator|0x228|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methoden veranschaulicht. Die <xref:System.Security.Principal.WindowsBuiltInRole>-Enumeration wird als Quelle für die RIDs verwendet, mit denen die integrierten Rollen identifiziert werden. Die RIDs werden zum Bestimmen der Rollen des aktuellen Prinzipals verwendet.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool&#xA;override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sid">Ein <see cref="T:System.Security.Principal.SecurityIdentifier" />, der eine Windows-Benutzergruppe eindeutig identifiziert.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zur Windows-Benutzergruppe mit der angegebenen Sicherheits-ID (SID) gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dem <xref:System.Security.Principal.SecurityIdentifier> wird ein Benutzer oder eine Gruppe auf Windows 2000-, Windows Server-und Windows XP-Implementierungen eindeutig identifiziert. Beim Testen auf neu erstellte Rollen Informationen, wie z. b. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, sich abzumelden und sich anzumelden, um die Weitergabe von Rollen Informationen in der Domäne zu erzwingen. Wenn dies nicht der Fall ist, kann der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test `false`zurückgeben. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, für die Administratorrechte erforderlich sind, können Sie Ihre Rolle mithilfe des Dialog Felds "Zustimmung" dynamisch erhöhen. Der Code, mit dem die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>-Methode ausgeführt wird, zeigt nicht das Zustimmungs Dialogfeld an. Der Code gibt false zurück, wenn Sie sich in der Standardbenutzer Rolle befinden, auch wenn Sie sich in der integrierten Gruppe "Administratoren" befinden. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie als Administrator ausführen möchten.  
  
 Aus Leistungsgründen ist dies die bevorzugte Überlastung, um die Rolle eines Benutzers zu bestimmen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType>-Methode veranschaulicht. Der <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid>-Enumerationswert wird verwendet, um zu bestimmen, ob der aktuelle Prinzipal ein Administrator ist. Das vollständige Codebeispiel finden Sie in der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType>-Methode.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sid" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Windows hat einen Win32-Fehler zurückgegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool&#xA;override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Einer der <see cref="T:System.Security.Principal.WindowsBuiltInRole" />-Werte.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zu der Windows-Benutzergruppe mit der angegebenen <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Testen auf neu erstellte Rollen Informationen, wie z. b. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, sich abzumelden und sich anzumelden, um die Weitergabe von Rollen Informationen in der Domäne zu erzwingen. Wenn dies nicht der Fall ist, kann der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test `false`zurückgeben. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 Aus Leistungsgründen wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung als bevorzugte Überladung zum Ermitteln der Rolle des Benutzers empfohlen.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, für die Administratorrechte erforderlich sind, können Sie Ihre Rolle mithilfe des Dialog Felds "Zustimmung" dynamisch erhöhen. Der Code, mit dem die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>-Methode ausgeführt wird, zeigt nicht das Zustimmungs Dialogfeld an. Der Code gibt false zurück, wenn Sie sich in der Standardbenutzer Rolle befinden, auch wenn Sie sich in der integrierten Gruppe "Administratoren" befinden. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie als Administrator ausführen möchten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Security.Principal.WindowsBuiltInRole>-Enumeration verwendet, um zu bestimmen, ob der aktuelle Prinzipal ein <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>ist. Das vollständige Codebeispiel finden Sie in der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType>-Methode.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="role" /> ist kein gültiger <see cref="T:System.Security.Principal.WindowsBuiltInRole" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (string role);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(string role) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As String) As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::String ^ role);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="F#" Value="abstract member IsInRole : string -&gt; bool&#xA;override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">Der Name der Windows-Benutzergruppe, für die die Mitgliedschaft überprüft werden soll.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zu der Windows-Benutzergruppe mit dem angegebenen Namen gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Testen auf neu erstellte Rollen Informationen, wie z. b. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, sich abzumelden und sich anzumelden, um die Weitergabe von Rollen Informationen in der Domäne zu erzwingen. Wenn dies nicht der Fall ist, kann der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test `false`zurückgeben. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 Aus Leistungsgründen wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung als bevorzugte Überladung zum Ermitteln der Rolle des Benutzers empfohlen.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, für die Administratorrechte erforderlich sind, können Sie Ihre Rolle mithilfe des Dialog Felds "Zustimmung" dynamisch erhöhen. Der Code, mit dem die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>-Methode ausgeführt wird, zeigt nicht das Zustimmungs Dialogfeld an. Der Code gibt false zurück, wenn Sie sich in der Standardbenutzer Rolle befinden, auch wenn Sie sich in der integrierten Gruppe "Administratoren" befinden. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, indem Sie mit der rechten Maustaste auf das Anwendungssymbol klicken und angeben, dass Sie als Administrator ausführen möchten.  
  
 Für integrierte Rollen sollte die `role` Zeichenfolge die Form "Builtin\\*rolenamehere*" aufweisen. Wenn Sie z. b. die Mitgliedschaft in der Windows-Administrator Rolle testen möchten, sollte die Zeichenfolge, die die Rolle repräsentiert, "BUILTIN\Administrators" lauten. Beachten Sie, dass der umgekehrte Schrägstrich mit Escapezeichen versehen werden muss. In der folgenden Tabelle sind die integrierten Rollen aufgeführt.  
  
> [!NOTE]
>  Die Schreibweise für die integrierten Rollen im Zeichen folgen Format unterscheidet sich von der Schreibweise, die in der <xref:System.Security.Principal.WindowsBuiltInRole> Enumeration verwendet wird. Die Schreibweise für einen Administrator in der-Enumeration lautet beispielsweise "Administrator", nicht "Administratoren". Wenn Sie diese Überladung verwenden, verwenden Sie die Schreibweise für die Rolle aus der folgenden Tabelle.  
  
|Integrierte lokale Gruppen|  
|----------------------------|  
|VORDEFINIERT\Administratoren|  
|BUILTIN\Users|  
|Builtin\gäste|  
|Builtin\account-Operatoren|  
|VORDEFINIERT\Server-Operatoren|  
|Builtin\print-Operatoren|  
|VORDEFINIERT\Sicherungs-Operatoren|  
|Builtin\replicator|  
  
 Für Computer spezifische Rollen sollte die `role` Zeichenfolge die Form "MachineName\\*rolenamehere*" aufweisen.  
  
 Für domänenspezifische Rollen sollte die `role` Zeichenfolge die Form "Domainname\\*rolenamehere*" aufweisen; beispielsweise `"SomeDomain\Domain Users`".  
  
> [!NOTE]
>  In der .NET Framework-Version 1,0 wird die Groß-/Kleinschreibung für den `role`-Parameter beachtet. In der .NET Framework Version 1,1 und höher wird die Groß-/Kleinschreibung vom `role`-Parameter nicht beachtet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType>-Methode veranschaulicht.  
  
 Die Zeichen folgen `BUILTIN\Administrators` und `BUILTIN\Users` werden verwendet, um zu bestimmen, ob es sich beim aktuellen Prinzipal um einen Administrator oder einen Benutzer handelt. Das vollständige Codebeispiel finden Sie in der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType>-Methode.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, das Prinzipal Objekt zu bearbeiten. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Windows-Benutzeransprüche von diesem Prinzipal ab.</summary>
        <value>Eine Sammlung aller Windows-Benutzeransprüche von diesem Prinzipal.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
