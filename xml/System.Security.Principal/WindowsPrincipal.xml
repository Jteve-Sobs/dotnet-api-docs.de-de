<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6f2b067005e56e12a01c0f99fc6ba3158cfeae33" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53458836" /></Metadata><TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <TypeSignature Language="F#" Value="type WindowsPrincipal = class&#xA;    inherit ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht es Code, die Windows-Gruppenmitgliedschaft eines Windows-Benutzers zu überprüfen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Principal.WindowsPrincipal> Klasse wird hauptsächlich verwendet, um die Rolle eines Windows-Benutzers zu überprüfen. Die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> Überladungen der Methode können Sie die Benutzerrolle zu überprüfen, indem Sie andere Rolle Kontexte verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Überladungen der Methode. Die <xref:System.Security.Principal.WindowsBuiltInRole> -Enumeration werden als Quelle für den relativen Bezeichnern (RIDs), die die integrierten Rollen zu identifizieren. Die RIDs werden verwendet, um zu bestimmen, die Rollen des aktuellen Prinzipals.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsPrincipal : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsPrincipal" Usage="new System.Security.Principal.WindowsPrincipal ntIdentity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">Das Objekt, aus dem die neue Instanz von <see cref="T:System.Security.Principal.WindowsPrincipal" /> erstellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Principal.WindowsPrincipal" />-Klasse unter Verwendung des angegebenen <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Security.Principal.WindowsPrincipal> Objekt aus dem aktuellen <xref:System.Security.Principal.WindowsIdentity> Objekt.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ntIdentity" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__10))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Windows-Geräteansprüche von diesem Prinzipal ab.</summary>
        <value>Eine Sammlung aller Windows-Geräteansprüche von diesem Prinzipal.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Security.Principal.IIdentity" Usage="System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Identität des aktuellen Principals ab.</summary>
        <value>Das <see cref="T:System.Security.Principal.WindowsIdentity" />-Objekts des aktuellen Prinzips.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel ruft den Namen des Benutzers ab, indem die <xref:System.Security.Principal.WindowsPrincipal.Identity%2A> Eigenschaft der <xref:System.Security.Principal.WindowsPrincipal> Objekt.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der aktuelle Prinzipal zu einer angegebenen Windows-Benutzergruppe gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt vier Überladungen dieser Methode ein. Aus Leistungsgründen die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung wird dringend empfohlen.  
  
> [!IMPORTANT]
>  Die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">Die RID der Windows-Benutzergruppe, die auf den Status der Mitgliedschaft des Prinzipals geprüft werden soll.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zur Windows-Benutzergruppe mit der angegebenen relativen ID (RID) gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, d. h. in einer bestimmten Rolle, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Testen von neu erstellten Rolle-Informationen, z. B. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, melden Sie sich ab und melden Sie sich bei um die Weitergabe von Informationen innerhalb der Domäne zu erzwingen. Nicht auf diese Weise kann dazu führen, dass die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test zurückzugebenden `false`. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 Aus Leistungsgründen die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung wird empfohlen, wie die vorzuziehen Überladung für die Rolle des Benutzers bestimmen.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, die Administratorrechte erforderlich sind, können Sie Ihre Rolle dynamisch erhöhen, mithilfe der im Dialogfeld "Zustimmung". Der Code, der ausgeführt wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode zeigt das Dialogfeld "Zustimmung" nicht an. Der Code gibt "false", wenn Sie in der standard-Benutzerrolle befinden, auch wenn Sie in der integrierten Administratorgruppe sind. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, durch einen Rechtsklick auf das Symbol der Anwendung und gibt an, dass Sie als Administrator ausführen möchten.  
  
 Relative IDs (RIDs) sind Komponenten einer Windows-Benutzergruppe Sicherheits-ID (SID) und werden unterstützt, um die von Cross-Platform-Lokalisierungsprobleme zu vermeiden. Viele Benutzerkonten, lokalen Gruppen und globalen Gruppen haben einen Standard-RID-Wert, der in allen Versionen von Windows konstant ist.  
  
 Beispielsweise ist der RID-Speicherplatz für die Rolle "BUILTIN\Administrators" 0x220. Mithilfe von 0x220 als Eingabeparameter für die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> -Methode führt zum `true` wird zurückgegeben, wenn der aktuelle Prinzipal ein Administrator ist.  
  
 Die folgenden Tabellen enthalten die RID-Standardwerte.  
  
|Integrierte Benutzer|RID|  
|---------------------|---------|  
|DOMAINNAME\Administrator|0x1F4|  
|DOMAINNAME\Guest|0x1F5|  
  
|Integrierte globale Gruppen|RID|  
|-----------------------------|---------|  
|DOMAINNAME\Domänen-Admins|0 x 200|  
|DOMAINNAME\Domänen Benutzer|0 x 201 an|  
|DOMAINNAME\Domänen-Gäste|0x202|  
  
|Lokale Standardgruppen|RID|  
|----------------------------|---------|  
|VORDEFINIERT\Administratoren|0x220|  
|BUILTIN\Users|0x221|  
|BUILTIN\Guests|0x222|  
|BUILTIN\Konten-Operatoren|0x224|  
|Vordefiniert\server-Operatoren|0x225|  
|BUILTIN\Druck-Operatoren|0x226|  
|Vordefiniert\Sicherungs-Operatoren|0x227|  
|BUILTIN\Replicator|0x228|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methoden. Die <xref:System.Security.Principal.WindowsBuiltInRole> -Enumeration werden als Quelle für die RIDs, die die integrierten Rollen zu identifizieren. Die RIDs werden verwendet, um zu bestimmen, die Rollen des aktuellen Prinzipals.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" />
      </Parameters>
      <Docs>
        <param name="sid">Ein <see cref="T:System.Security.Principal.SecurityIdentifier" />, der eine Windows-Benutzergruppe eindeutig identifiziert.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zur Windows-Benutzergruppe mit der angegebenen Sicherheits-ID (SID) gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Principal.SecurityIdentifier> eindeutig identifiziert wird, einen Benutzer oder eine Gruppe in Windows 2000, Windows Server und Windows XP-Implementierungen. Beim Testen von neu erstellten Rolle-Informationen, z. B. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, melden Sie sich ab und melden Sie sich bei um die Weitergabe von Informationen innerhalb der Domäne zu erzwingen. Nicht auf diese Weise kann dazu führen, dass die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test zurückzugebenden `false`. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, die Administratorrechte erforderlich sind, können Sie Ihre Rolle dynamisch erhöhen, mithilfe der im Dialogfeld "Zustimmung". Der Code, der ausgeführt wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode zeigt das Dialogfeld "Zustimmung" nicht an. Der Code gibt "false", wenn Sie in der standard-Benutzerrolle befinden, auch wenn Sie in der integrierten Administratorgruppe sind. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, durch einen Rechtsklick auf das Symbol der Anwendung und gibt an, dass Sie als Administrator ausführen möchten.  
  
 Aus Leistungsgründen ist dies die vorzuziehen-Überladung verwenden, um die Rolle eines Benutzers zu bestimmen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType> Methode. Die <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid> Enumerationswert wird verwendet, um festzustellen, ob der aktuelle Prinzipal ein Administrator ist. Das vollständige Codebeispiel finden Sie unter den <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sid" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Windows hat einen Win32-Fehler zurückgegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Einer der <see cref="T:System.Security.Principal.WindowsBuiltInRole" />-Werte.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zu der Windows-Benutzergruppe mit der angegebenen <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Testen von neu erstellten Rolle-Informationen, z. B. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, melden Sie sich ab und melden Sie sich bei um die Weitergabe von Informationen innerhalb der Domäne zu erzwingen. Nicht auf diese Weise kann dazu führen, dass die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test zurückzugebenden `false`. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 Aus Leistungsgründen die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung wird empfohlen, wie die vorzuziehen Überladung für die Rolle des Benutzers bestimmen.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, die Administratorrechte erforderlich sind, können Sie Ihre Rolle dynamisch erhöhen, mithilfe der im Dialogfeld "Zustimmung". Der Code, der ausgeführt wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode zeigt das Dialogfeld "Zustimmung" nicht an. Der Code gibt "false", wenn Sie in der standard-Benutzerrolle befinden, auch wenn Sie in der integrierten Administratorgruppe sind. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, durch einen Rechtsklick auf das Symbol der Anwendung und gibt an, dass Sie als Administrator ausführen möchten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Security.Principal.WindowsBuiltInRole> Enumeration wird verwendet, um zu bestimmen, ob der aktuelle Prinzipal ist ein <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>. Das vollständige Codebeispiel finden Sie unter den <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="role" /> ist kein gültiger <see cref="T:System.Security.Principal.WindowsBuiltInRole" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">Der Name der Windows-Benutzergruppe, für die die Mitgliedschaft überprüft werden soll.</param>
        <summary>Bestimmt, ob der aktuelle Prinzipal zu der Windows-Benutzergruppe mit dem angegebenen Namen gehört.</summary>
        <returns><see langword="true" />, wenn der aktuelle Prinzipal Mitglied der angegebenen Windows-Benutzergruppe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Testen von neu erstellten Rolle-Informationen, z. B. einen neuen Benutzer oder eine neue Gruppe, ist es wichtig, melden Sie sich ab und melden Sie sich bei um die Weitergabe von Informationen innerhalb der Domäne zu erzwingen. Nicht auf diese Weise kann dazu führen, dass die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Test zurückzugebenden `false`. Diese Methode wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
 Aus Leistungsgründen die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> Überladung wird empfohlen, wie die vorzuziehen Überladung für die Rolle des Benutzers bestimmen.  
  
> [!NOTE]
>  Unter Windows Vista werden die Berechtigungen eines Benutzers über die Benutzerkontensteuerung (User Account Control, UAC) bestimmt. Als Mitglied der integrierten Administratorgruppe sind Ihnen zwei Zugriffstoken für die Laufzeit zugewiesen: ein Standardbenutzertoken und ein Administratorzugriffstoken. Standardmäßig verwenden Sie die Standardbenutzerrolle. Wenn Sie versuchen, eine Aufgabe auszuführen, die Administratorrechte erforderlich sind, können Sie Ihre Rolle dynamisch erhöhen, mithilfe der im Dialogfeld "Zustimmung". Der Code, der ausgeführt wird die <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Methode zeigt das Dialogfeld "Zustimmung" nicht an. Der Code gibt "false", wenn Sie in der standard-Benutzerrolle befinden, auch wenn Sie in der integrierten Administratorgruppe sind. Sie können Ihre Berechtigungen erhöhen, bevor Sie den Code ausführen, durch einen Rechtsklick auf das Symbol der Anwendung und gibt an, dass Sie als Administrator ausführen möchten.  
  
 Für integrierte Rollen die `role` Zeichenfolge muss im Format "BUILTIN\\*Rollenname*". Um für die Mitgliedschaft in der Windows-Administratorrolle zu testen, sollten die Zeichenfolge, die Darstellung der Rolle z. B. "BUILTIN\Administrators" sein. Beachten Sie, dass möglicherweise der umgekehrten Schrägstrich mit Escapezeichen versehen werden muss. Die folgende Tabelle enthält die integrierten Rollen.  
  
> [!NOTE]
>  Die Schreibweise für die integrierten Rollen in einem Format unterscheidet sich von der Schreibung, die der <xref:System.Security.Principal.WindowsBuiltInRole> Enumeration. Beispielsweise ist die Schreibweise für einen Administrator in der Enumeration "Administrator", nicht "Administratoren". Wenn Sie diese Überladung verwenden, verwenden Sie die Schreibweise für die Rolle aus der folgenden Tabelle.  
  
|Lokale Standardgruppen|  
|----------------------------|  
|VORDEFINIERT\Administratoren|  
|BUILTIN\Users|  
|BUILTIN\Guests|  
|BUILTIN\Konten-Operatoren|  
|Vordefiniert\server-Operatoren|  
|BUILTIN\Druck-Operatoren|  
|Vordefiniert\Sicherungs-Operatoren|  
|BUILTIN\Replicator|  
  
 Für Computer-spezifischen Rollen die `role` Zeichenfolge muss im Format "MachineName\\*Rollenname*".  
  
 Für Domäne-spezifischen Rollen die `role` Zeichenfolge muss im Format "Domänenname\\*Rollenname*", z. B. `"SomeDomain\Domain Users`".  
  
> [!NOTE]
>  In .NET Framework, Version 1.0 der `role` Parameter wird die Groß-/Kleinschreibung beachtet. In .NET Framework, Version 1.1 und höher die `role` Parameter wird die Groß-/Kleinschreibung.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> Methode.  
  
 Die Zeichenfolgen `BUILTIN\Administrators` und `BUILTIN\Users` werden verwendet, um zu bestimmen, ob der aktuelle Prinzipal ein Administrator oder ein Benutzer ist. Das vollständige Codebeispiel finden Sie unter den <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Windows-Benutzeransprüche von diesem Prinzipal ab.</summary>
        <value>Eine Sammlung aller Windows-Benutzeransprüche von diesem Prinzipal.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>