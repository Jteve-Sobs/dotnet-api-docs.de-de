<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata><Meta Name="ms.openlocfilehash" Value="20df13c34037aa52df60f68fc3617e828b5625fa" /><Meta Name="ms.sourcegitcommit" Value="10aa513a7461eb2abbf8d1e35d2a045d4e5a9be7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/09/2019" /><Meta Name="ms.locfileid" Value="67665126" /></Metadata><TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt verschiedene Methoden zum Verwenden und Veröffentlichen von Remoteobjekten und -proxys bereit. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Dienstanbieter, der Umgang mit Problemen wie Aktivierung, Verwaltung der Lebensdauer oder Transaktionen sind, müssen Sie keine Proxyverweisen und Objektverweisen zu unterscheiden. Die Remoteinfrastruktur verwendet von transparenten Proxys, die den Eindruck zu vermitteln, die dem Client die Remoteobjekte befinden. Proxys erreichen dies, indem Sie Weiterleitung der Aufrufe, die auf die tatsächlichen Objekte an Remotestandorten ein Zugriff darauf.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Proxy für ein bekanntes Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">Der <see cref="T:System.Type" /> eines bekannten Objekts auf der Serverseite, mit dem Sie eine Verbindung herstellen möchten.</param>
        <param name="url">Die URL der Serverklasse.</param>
        <summary>Erstellt einen Proxy für ein bekanntes Objekt, wenn der <see cref="T:System.Type" /> und die URL angegeben sind.</summary>
        <returns>Ein Proxy für das Remoteobjekt, der auf einen Endpunkt zeigt, der von dem angegebenen bekannten Objekt unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Proxyobjekt verweist auf einen Endpunkt, von dem angegebenen bekannten Objekt unterstützt. Bis für den Proxy eine Methode aufgerufen wird, werden keine Nachrichten über das Netzwerk gesendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> Methode, um einen Proxy für ein bekanntes Objekt zu erstellen.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer hat keine Berechtigung zum Konfigurieren von Remotingtypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">Der <see cref="T:System.Type" /> des bekannten Objekts, mit dem Sie eine Verbindung herstellen möchten.</param>
        <param name="url">Die URL des bekannten Objekts.</param>
        <param name="data">Channelspezifische Daten. Kann <see langword="null" /> sein.</param>
        <summary>Erstellt einen Proxy für ein bekanntes Objekt, wenn der <see cref="T:System.Type" />, die URL und channelspezifische Daten angegeben sind.</summary>
        <returns>Ein Proxy, der auf einen Endpunkt zeigt, der von dem angeforderten bekannten Objekt unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Proxyobjekt verweist auf einen Endpunkt, von dem angegebenen bekannten Objekt unterstützt. Bis für den Proxy eine Methode aufgerufen wird, werden keine Nachrichten über das Netzwerk gesendet.  
  
 Die `data` Objekt wird verwendet, um Informationen an den Kanal kommunizieren und wird zum Übergeben der <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer hat keine Berechtigung zum Konfigurieren von Remotingtypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Objekt, dessen Verbindung mit dem entsprechenden Channel getrennt werden soll.</param>
        <summary>Verhindert, dass ein Objekt über die registrierten Remotechannels weitere Meldungen empfängt.</summary>
        <returns><see langword="true" />, wenn die Verbindung des Objekts mit den registrierten Remotechannels erfolgreich getrennt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> Methode, um einem Objekt und die Remotingkanäle getrennt.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="obj" />-Parameter ist ein Proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer hat keine Berechtigung zum Konfigurieren von Remotingtypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Das Remoteobjekt, dessen Methode Sie aufrufen möchten.</param>
        <param name="reqMsg">Die Meldung für einen Methodenaufruf an die Methode des angegebenen Remoteobjekts.</param>
        <summary>Stellt eine Verbindung mit dem angegebenen Remoteobjekt her und führt die bereitgestellte <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> für dieses aus.</summary>
        <returns>Die Antwort der Remotemethode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Methode wird in besonderen Fällen vom Server zum Weiterleiten des angegebenen Methodenaufrufs an eine andere, möglicherweise ein Remoteobjekt, Objekt verwendet. Diese Methode kann aufgerufen werden, nur, wenn der Aufrufer im geeigneten Kontext befindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> Methode, um Methodenaufrufe auf Remoteobjekte weitergeleitet.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Die Methode wurde nicht aus dem systemeigenen Kontext des Objekts aufgerufen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Der Proxy des Remoteobjekts, dem angeforderte Botensenken zugeordnet sind.</param>
        <summary>Gibt eine Kette von Botensenken zurück, die beim Senden von Meldungen an das vom angegebenen Proxy dargestellte Remoteobjekt verwendet werden sollen.</summary>
        <returns>Eine Kette von Botensenken, die dem angegebenen Proxy zugeordnet sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Botensenken sind senken, die gesendet werden, zusammen mit den <xref:System.Runtime.Remoting.ObjRef> eines Objekts, das beim Zurückgeben von auf dieses Objekt Nachrichten verwendet wird. Die aktuelle Methode gibt die Botensenken, die während der Kommunikation zwischen dem Proxy des Objekts und das Objekt selbst verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das der Lebensdauerdienst abgerufen werden soll.</param>
        <summary>Gibt ein Lebensdauerdienstobjekt zurück, das die Richtlinien für die Lebensdauer des angegebenen Objekts steuert.</summary>
        <returns>Das Objekt, das die Lebensdauer von <paramref name="obj" /> steuert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Objekt werden für den Standarddienst für die Lebensdauer eines Objekts vom Typ <xref:System.Runtime.Remoting.Lifetime.ILease>. Wenn die `obj` Parameter `null`, gibt die Methode zurück `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> Methode, um einen Lebensdauerlease für das angegebene Objekt abzurufen.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Zum Kompilieren und dieses Beispiel ausführen, müssen Sie kompilieren, und führen einen Server, timerserver.exe und Kompilieren einer freigegebenen Bibliothek timerserver.dll.  
  
 Die Quelle für timerserver.exe lautet:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 Die Quelle für timerserver.dll lautet:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Die Methodenmeldung, aus der die Methodenbasis extrahiert wird.</param>
        <summary>Gibt die Methodenbasis der angegebenen <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> zurück.</summary>
        <returns>Die aus dem <paramref name="msg" />-Parameter extrahierte Methodenbasis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dadurch wird bestimmt, die Methodenbasis der <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, und <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> Eigenschaften <xref:System.Runtime.Remoting.Messaging.IMethodMessage> und wird von den Klassen implementieren, verwendet der <xref:System.Runtime.Remoting.Messaging.IMethodMessage> Schnittstelle. Consumer der <xref:System.Runtime.Remoting.Messaging.IMethodMessage> Klassen verweisen sollten die <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Entweder hat der direkte Aufrufer keine Berechtigungen für die Infrastruktur, oder mindestens einer der Aufrufer an höherer Position im Aufrufstapel hat keine Berechtigung zum Abrufen von Typinformationen nicht öffentlicher Member.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu serialisierende Objekt.</param>
        <param name="info">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />, in die das Objekt serialisiert wird.</param>
        <param name="context">Die Quelle und das Ziel der Serialisierung.</param>
        <summary>Serialisiert den angegebenen Marshal als Verweisobjekt in die bereitgestellte <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter oder der <paramref name="info" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Das <see cref="T:System.MarshalByRefObject" />, für das ein URI angefordert wird.</param>
        <summary>Ruft den URI für das angegebene Objekt ab.</summary>
        <returns>Der URI des angegebenen Objekts, sofern vorhanden, oder <see langword="null" />, wenn das Objekt noch nicht gemarshallt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Proxy, der mit dem Objekt verbunden ist, für das Sie eine <see cref="T:System.Runtime.Remoting.ObjRef" /> erstellen möchten.</param>
        <summary>Gibt die <see cref="T:System.Runtime.Remoting.ObjRef" /> zurück, die das Remoteobjekt aus dem angegebenen Proxy darstellt.</summary>
        <returns>Eine <see cref="T:System.Runtime.Remoting.ObjRef" />, die das Remoteobjekt darstellt, mit dem der angegebene Proxy verbunden ist, oder <see langword="null" />, wenn das Objekt oder der Proxy nicht gemarshallt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Runtime.Remoting.ObjRef> ist eine serialisierbare Darstellung eines Objekts verwendet, um einen Objektverweis über eine Anwendungsdomänengrenze hinweg übertragen. Erstellen einer <xref:System.Runtime.Remoting.ObjRef> für ein Objekt als Marshalling bezeichnet wird. Die <xref:System.Runtime.Remoting.ObjRef> können übertragen werden über einen Kanal in einer anderen Anwendungsdomäne (ggf. auf einem anderen Prozess oder Computer). Einmal in die andere Anwendungsdomäne die <xref:System.Runtime.Remoting.ObjRef> müssen zum Erstellen eines Proxys für das Objekt, das in der Regel an das eigentliche Objekt verbundenen analysiert werden. Dieser Vorgang wird als Unmarshalling bezeichnet. Beim Rückgängigmachen des Marshallens, die <xref:System.Runtime.Remoting.ObjRef> wird analysiert, um die des Remoteobjekts und sowohl der transparente Proxy zu extrahieren und <xref:System.Runtime.Remoting.Proxies.RealProxy> Objekte werden erstellt.  
  
 Ein <xref:System.Runtime.Remoting.ObjRef> enthält Informationen zur Beschreibung der <xref:System.Type> und die Klasse des Objekts, das gemarshallt wird, ein URI, der angegebenen Objektinstanz und Kommunikation eindeutig identifiziert, verwandte Informationen dazu, wie die Anwendung zu erreichen, in denen das Objekt befindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Abrufen einer <xref:System.Runtime.Remoting.ObjRef> Instanz für das angegebene Objekt.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Ein transparenter Proxy.</param>
        <summary>Gibt den echten Proxy zurück, der sich hinter dem angegebenen transparenten Proxy befindet.</summary>
        <returns>Die echte Proxyinstanz hinter dem transparenten Proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Client, der ein Objekt über jede Art von Remotegrenze verwendet tatsächlich verwendet einen transparenten Proxy für das Objekt. Der transparente Proxy vermittelt den Eindruck, dass das eigentliche Objekt auf dem Client befindet. Er erreicht dies durch die Weiterleitung der Aufrufe, die auf ihn an das eigentliche Objekt, das über die Remotinginfrastruktur.  
  
 Der transparente Proxy basiert auf einer Instanz einer verwalteten Common Language Runtime-Klasse des Typs <xref:System.Runtime.Remoting.Proxies.RealProxy>. Die <xref:System.Runtime.Remoting.Proxies.RealProxy> implementiert einen Teil der Funktionen, die zum Weiterleiten der Vorgänge von dem transparenten Proxy benötigt.  
  
 Ein Proxyobjekt die zugeordnete Semantik von verwalteten Objekten wie z. B. die automatische speicherbereinigung, Unterstützung für Member und Methoden erbt und auf neue Geräteklassen Formular erweitert werden kann. Der Proxy fungiert als ein Objekt von derselben Klasse wie das Remoteobjekt (transparenter Proxy), und es ist auch ein verwaltetes Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">Der URI des Objekts, dessen <see cref="T:System.Type" /> angefordert wird.</param>
        <summary>Gibt den <see cref="T:System.Type" /> des Objekts mit dem angegebenen URI zurück.</summary>
        <returns>Der <see cref="T:System.Type" /> des Objekts mit dem angegebenen URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da Remoting Endpunkte mithilfe von URIs, identifiziert die <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> Methode ist sehr nützlich, in die austauschbaren Teile der Remoting-Infrastruktur (z. B. Channelsenken, dynamische senken und Kontextsenken), mit denen <xref:System.Runtime.Remoting.Messaging.IMessage> Objekte um, da die aktuelle Methode gibt das Objekt zugeordneten Typ aus dem URI zurück.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Entweder hat der direkte Aufrufer keine Berechtigungen für die Infrastruktur, oder mindestens einer der Aufrufer an höherer Position im Aufrufstapel hat keine Berechtigung zum Abrufen von Typinformationen nicht öffentlicher Member.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">um die Typinformationen nicht öffentlicher Member abzurufen. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Die <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />, für die eine Sitzungs-ID angefordert wird.</param>
        <summary>Ruft eine Sitzungs-ID für eine Meldung ab.</summary>
        <returns>Eine Sitzungs-ID-Zeichenfolge, die die aktuelle Sitzung eindeutig bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Sitzungs-ID kann für Objekte in der gleichen Anwendung zurückgegeben werden, aber diese Methode gibt nie die gleiche Sitzungs-ID für zwei Objekte in anderen remote-Anwendungen zurück.  
  
 Weitere Informationen zum Identifizieren von Sitzungen und Sitzungs-IDs finden Sie unter ASP.Net [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die Sitzungs-ID-Zeichenfolge für die aktuelle Sitzung abrufen.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Die Meldung, die einen Aufruf der betreffenden Methode enthält.</param>
        <summary>Gibt einen booleschen Wert zurück, der angibt, ob die Methode in der angegebenen Meldung überladen ist.</summary>
        <returns><see langword="true" />, wenn die in <paramref name="msg" /> aufgerufene Methode überladen ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Das zu überprüfende Objekt.</param>
        <summary>Gibt einen booleschen Wert zurück, der angibt, ob sich das Objekt, das vom angegebenen transparenten Proxy angegeben wird, in einer anderen Anwendungsdomäne als das Objekt befindet, das die aktuelle Methode aufgerufen hat.</summary>
        <returns><see langword="true" />, wenn sich das Objekt außerhalb der aktuellen Anwendungsdomäne befindet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Anwendungsdomänen finden Sie unter [Anwendungsdomänen](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Anwendungsdomänen</related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Das zu überprüfende Objekt.</param>
        <summary>Gibt einen booleschen Wert zurück, der angibt, ob sich das vom angegebenen Proxy dargestellte Objekt in einem anderen Kontext als das Objekt befindet, das die aktuelle Methode aufgerufen hat.</summary>
        <returns><see langword="true" />, wenn sich das Objekt außerhalb des aktuellen Kontexts befindet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Kontext ist eine geordnete Sequenz von Eigenschaften, die eine Umgebung für die Objekte zu definieren, die sich darin befinden. Kontexte werden während der Aktivierung für Objekte erstellt, die Konfiguration erforderlich ist, dass bestimmte automatische Dienste, solche Synchronisierung, Transaktionen, just-in-Time-Aktivierung, Sicherheit und So weiter. In einem Kontext können sich mehrere Objekte befinden.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Die betreffende Methode.</param>
        <summary>Gibt einen booleschen Wert zurück, der angibt, ob der Client, der die in der angegebenen Meldung angegebene Methode aufgerufen hat, vor dem Fortsetzen des Vorgangs darauf wartet, dass der Server die Verarbeitung der Methode beendet.</summary>
        <returns><see langword="true" />, wenn die Methode unidirektional ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine unidirektionale Methode aufgerufen wird, wartet der Client nicht für den Server aus, um die Verarbeitung der Nachricht abzuschließen. Die Methode gibt zurück, um die Anwendung ohne Kenntnis davon, ob der Server die Nachricht erfolgreich verarbeitet. Methoden werden als eine Möglichkeit, mithilfe der <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 Unidirektionale Methoden können nicht über einen Rückgabewert oder Out-Parameter haben.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit Infrastrukturcode. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Der Verweis auf das zu überprüfende Objekt.</param>
        <summary>Gibt einen booleschen Wert zurück, der angibt, ob es sich bei dem angegebenen Objekt um einen transparenten Proxy oder ein echtes Objekt handelt.</summary>
        <returns>Ein boolescher Wert, der angibt, ob es sich bei dem im <paramref name="proxy" />-Parameter angegebenen Objekt um einen transparenten Proxy oder ein echtes Objekt handelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Client, der ein Objekt über jede Art von Remotegrenze verwendet tatsächlich verwendet einen transparenten Proxy für das Objekt. Der transparente Proxy vermittelt den Eindruck, dass das eigentliche Objekt auf dem Client befindet. Er erreicht dies durch die Weiterleitung der Aufrufe, die auf ihn an das eigentliche Objekt, das über die Remotinginfrastruktur.  
  
 Der transparente Proxy ist selbst die untergebracht, die von einer Instanz einer verwalteten Common Language Runtime-Klasse des Typs <xref:System.Runtime.Remoting.Proxies.RealProxy>. Die <xref:System.Runtime.Remoting.Proxies.RealProxy> implementiert einen Teil der Funktionen, die zum Weiterleiten der Vorgänge von dem transparenten Proxy benötigt. Ein Proxyobjekt die zugeordnete Semantik von verwalteten Objekten wie z. B. die automatische speicherbereinigung, Unterstützung für Member und Methoden erbt und auf neue Geräteklassen Formular erweitert werden kann. Daher ist der Proxy dual aufgebaut; Einerseits muss als ein Objekt von derselben Klasse wie das Remoteobjekt (transparenter Proxy) fungiert, und auf der anderen ist es ein verwaltetes Objekt selbst.  
  
 Ein Proxyobjekt kann verwendet werden, ohne Berücksichtigung der Remote-Untereinheiten innerhalb einer <xref:System.AppDomain>. Anwendungen müssen Proxyverweisen und Objektverweisen nicht unterscheiden. Allerdings müssen Dienstanbieter Umgang mit Problemen wie Aktivierung, Verwaltung der Aufgabenlebensdauer und Transaktionen um solche Unterschiede zu machen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> Methode, um zu bestimmen, ob ein Objekt einen Proxy oder ein echtes Objekt handelt. Der vollständige Beispielcode, finden Sie im Beispiel für die <xref:System.Runtime.Remoting.Messaging.AsyncResult> Klasse.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Eine intern definierte Konstante, die die Stufe in einem Remotingaustausch kennzeichnet.</param>
        <summary>Protokolliert die Stufe in einem Remotingaustausch in einem externen Debugger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein `"REMOTING_PERF"` Vorverarbeitungssymbol an die Methode angewendet wird, mithilfe der <xref:System.Diagnostics.ConditionalAttribute> Attribut.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert das angegebene <see cref="T:System.MarshalByRefObject" /> in eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse, die für die Übertragung zwischen Anwendungsdomänen und über ein Netzwerk serialisiert werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Das zu konvertierende Objekt.</param>
        <summary>Übernimmt ein <see cref="T:System.MarshalByRefObject" />, registriert dieses in der Remotinginfrastruktur und konvertiert es in eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse.</summary>
        <returns>Eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse, die das im <paramref name="Obj" />-Parameter angegebene Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Runtime.Remoting.ObjRef> ist eine serialisierbare Darstellung eines Objekts verwendet, um einen Objektverweis über eine Anwendungsdomänengrenze hinweg übertragen. Erstellen einer <xref:System.Runtime.Remoting.ObjRef> für ein Objekt als Marshalling bezeichnet wird. Die <xref:System.Runtime.Remoting.ObjRef> können übertragen werden über einen Kanal in einer anderen Anwendungsdomäne (ggf. auf einem anderen Prozess oder Computer). Einmal in die andere Anwendungsdomäne die <xref:System.Runtime.Remoting.ObjRef> müssen zum Erstellen eines Proxys für das Objekt, das in der Regel an das eigentliche Objekt verbundenen analysiert werden. Dieser Vorgang wird als Unmarshalling bezeichnet.  
  
 Ein <xref:System.Runtime.Remoting.ObjRef> enthält Informationen zur Beschreibung der <xref:System.Type> und die Klasse des Objekts, das gemarshallt wird, ein URI, der angegebenen Objektinstanz und Kommunikation eindeutig identifiziert, verwandte Informationen zur Verwendung von t in dem das Objekt befindet.  
  
 Während des Marshallens wird der Kontext des aktuellen Threads verwendet wird, nicht den Kontext aktiv war, wenn das Objekt erstellt wurde. Wenn ein URI nicht explizit durch festgelegt wurde die <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> -Methode, sie wird automatisch generiert, durch die Identity-Remotinginfrastruktur.  
  
 Sie können keinen URI mit einem Proxy zuordnen, für die aus zwei Gründen: der URI generiert wurde, auf der Serverseite für das Objekt, das sie darstellt oder das Objekt bekannt ist, in diesem Fall wird der URI bezeichnet. Aus diesem Grund ist wenn die `Obj` Parameter ein Proxy ist, wird eine Ausnahme ausgelöst werden. Für benutzerdefinierte Proxys wird diese Einschränkung gelockert, da der transparente Proxy als das Server-Objekt behandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Der <paramref name="Obj" />-Parameter ist ein Objektproxy.</exception>
        <exception cref="T:System.Security.SecurityException">Mindestens einer der Aufrufer an höherer Position im Aufrufstapel verfügt nicht über die Berechtigung zum Konfigurieren von Remotetypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Anwendungsdomänen</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Das zu konvertierende Objekt.</param>
        <param name="URI">Der angegebene URI, mit dem die neue <see cref="T:System.Runtime.Remoting.ObjRef" /> initialisiert werden soll. Kann <see langword="null" /> sein.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.MarshalByRefObject" /> in eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse mit dem angegebenen URI.</summary>
        <returns>Eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse, die das im <paramref name="Obj" />-Parameter angegebene Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Runtime.Remoting.ObjRef> ist eine serialisierbare Darstellung eines Objekts verwendet, um einen Objektverweis über eine Anwendungsdomänengrenze hinweg übertragen. Erstellen einer <xref:System.Runtime.Remoting.ObjRef> für ein Objekt als Marshalling bezeichnet wird. Die <xref:System.Runtime.Remoting.ObjRef> können übertragen werden über einen Kanal in einer anderen Anwendungsdomäne (ggf. auf einem anderen Prozess oder Computer). Einmal in die andere Anwendungsdomäne die <xref:System.Runtime.Remoting.ObjRef> müssen zum Erstellen eines Proxys für das Objekt, das in der Regel an das eigentliche Objekt verbundenen analysiert werden. Dieser Vorgang wird als Unmarshalling bezeichnet.  
  
 Ein <xref:System.Runtime.Remoting.ObjRef> enthält Informationen zur Beschreibung der <xref:System.Type> und die Klasse des Objekts, das gemarshallt wird, ein URI, der angegebenen Objektinstanz und Kommunikation eindeutig identifiziert, verwandte Informationen zur Verwendung von t in dem das Objekt befindet.  
  
 Während des Marshallens wird der Kontext des aktuellen Threads verwendet wird, nicht den Kontext aktiv war, wenn das Objekt erstellt wurde.  
  
 Sie können keinen URI mit einem Proxy zuordnen, für die aus zwei Gründen: der URI generiert wurde, auf der Serverseite für das Objekt, das sie darstellt oder das Objekt bekannt ist, in diesem Fall wird der URI bezeichnet. Aus diesem Grund ist wenn die `Obj` Parameter ein Proxy ist, wird eine Ausnahme ausgelöst werden. Für benutzerdefinierte Proxys wird diese Einschränkung gelockert, da der transparente Proxy als das Server-Objekt behandelt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der aktuellen <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> Methode, um ein angegebenes Objekt gemarshallt.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> ist ein Objektproxy, und der <paramref name="URI" />-Parameter ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Mindestens einer der Aufrufer an höherer Position im Aufrufstapel verfügt nicht über die Berechtigung zum Konfigurieren von Remotetypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Anwendungsdomänen</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Das in eine <see cref="T:System.Runtime.Remoting.ObjRef" /> zu konvertierende Objekt.</param>
        <param name="ObjURI">Der URI, mit dem das im <paramref name="Obj" />-Parameter angegebene Objekt gemarshallt wird. Kann <see langword="null" /> sein.</param>
        <param name="RequestedType">Der <see cref="T:System.Type" />, als der <paramref name="Obj" /> gemarshallt wird. Kann <see langword="null" /> sein.</param>
        <summary>Übernimmt ein <see cref="T:System.MarshalByRefObject" /> und konvertiert dieses in eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse mit dem angegebenen URI und dem angegebenen <see cref="T:System.Type" />.</summary>
        <returns>Eine Instanz der <see cref="T:System.Runtime.Remoting.ObjRef" />-Klasse, die das im <paramref name="Obj" />-Parameter angegebene Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Runtime.Remoting.ObjRef> ist eine serialisierbare Darstellung eines Objekts verwendet, um einen Objektverweis über eine Anwendungsdomänengrenze hinweg übertragen. Erstellen einer <xref:System.Runtime.Remoting.ObjRef> für ein Objekt als Marshalling bezeichnet wird. Die <xref:System.Runtime.Remoting.ObjRef> können übertragen werden über einen Kanal in einer anderen Anwendungsdomäne (ggf. auf einem anderen Prozess oder Computer). Einmal in die andere Anwendungsdomäne die <xref:System.Runtime.Remoting.ObjRef> müssen zum Erstellen eines Proxys für das Objekt, das in der Regel an das eigentliche Objekt verbundenen analysiert werden. Dieser Vorgang wird als Unmarshalling bezeichnet.  
  
 Ein <xref:System.Runtime.Remoting.ObjRef> enthält Informationen zur Beschreibung der <xref:System.Type> und die Klasse des Objekts, das gemarshallt wird, ein URI, der angegebenen Objektinstanz und Kommunikation eindeutig identifiziert, verwandte Informationen zur Verwendung von t in dem das Objekt befindet.  
  
 Das angegebene <xref:System.Type> wird durch die Remotinginfrastruktur verwendet, um den Umfang der Hierarchie verfügbar gemachte Typ zu beschränken. Wenn Objekt A Objekt B abgeleitet wird abgeleitet von C-Objekt, z. B. und <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> aufgerufen wird, und klicken Sie dann der Client des Proxys zwischen C und B ist jedoch nicht in A. umgewandelt werden kann  
  
 Während des Marshallens wird der Kontext des aktuellen Threads verwendet wird, nicht den Kontext aktiv war, wenn das Objekt erstellt wurde.  
  
 Sie können keinen URI mit einem Proxy zuordnen, für die aus zwei Gründen: der URI generiert wurde, auf der Serverseite für das Objekt, das sie darstellt oder das Objekt bekannt ist, in diesem Fall wird der URI bezeichnet. Aus diesem Grund ist wenn die `Obj` Parameter ein Proxy ist, wird eine Ausnahme ausgelöst werden. Für benutzerdefinierte Proxys wird diese Einschränkung gelockert, da der transparente Proxy als das Server-Objekt behandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> ist ein Proxy eines Remoteobjekts, und der <paramref name="ObjUri" />-Parameter ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Mindestens einer der Aufrufer an höherer Position im Aufrufstapel verfügt nicht über die Berechtigung zum Konfigurieren von Remotetypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Anwendungsdomänen</related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für den ein URI festgelegt werden soll.</param>
        <param name="uri">Der URI, der dem angegebenen Objekt zugewiesen werden soll.</param>
        <summary>Legt den URI für den nachfolgenden Aufruf der <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />-Methode fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von der aktuellen Methode festgelegte URI wird verwendet, beim Marshallen des angegebenen Objekts.  
  
 Nach dem Marshallen der URI des angegebenen Objekts festgelegt ist, in die Zeichenfolge in die `uri` Parameter angefügt wird, auf die <xref:System.Guid> des aktuellen <xref:System.AppDomain>.  
  
 Wenn die aktuelle Anwendung auf einen HTTP-Port lauscht, sowohl der angegebenen Zeichenfolge die `uri` Parameter und die `uri` Zeichenfolge angefügt wird, auf die <xref:System.Guid> des aktuellen <xref:System.AppDomain> Route mit dem angegebenen Objekt. Beispiel: Wenn die Anwendung über HTTP-Port 9000 überwacht wird, dann beide `http://localhost:9000/objectUri`, und `http://localhost:9000/<appdomainguid>/objectUri` Route zu dem im angegebenen Objekt der `obj` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den URI festgelegt wird, die von verwendet werden, die <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> Methode, wenn das angegebene Objekt zu marshallen.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="obj" /> ist kein lokales Objekt, wurde bereits gemarshallt, oder die aktuelle Methode wurde bereits aufgerufen.</exception>
        <exception cref="T:System.Security.SecurityException">Mindestens einer der Aufrufer an höherer Position im Aufrufstapel verfügt nicht über die Berechtigung zum Konfigurieren von Remotetypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert eine angegebene <see cref="T:System.Runtime.Remoting.ObjRef" /> in ein Proxyobjekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">Die <see cref="T:System.Runtime.Remoting.ObjRef" />, die das Remoteobjekt darstellt, für das der Proxy gerade erstellt wird.</param>
        <summary>Akzeptiert eine <see cref="T:System.Runtime.Remoting.ObjRef" /> und erstellt daraus ein Proxyobjekt.</summary>
        <returns>Ein Proxy für das Objekt, das von der angegebenen <see cref="T:System.Runtime.Remoting.ObjRef" /> dargestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Runtime.Remoting.ObjRef> ist eine serialisierbare Darstellung eines Objekts verwendet, um einen Objektverweis über eine Anwendungsdomänengrenze hinweg übertragen. Erstellen einer <xref:System.Runtime.Remoting.ObjRef> für ein Objekt als Marshalling bezeichnet wird. Die <xref:System.Runtime.Remoting.ObjRef> können übertragen werden über einen Kanal in einer anderen Anwendungsdomäne (ggf. auf einem anderen Prozess oder Computer). Einmal in die andere Anwendungsdomäne die <xref:System.Runtime.Remoting.ObjRef> müssen zum Erstellen eines Proxys für das Objekt, das in der Regel an das eigentliche Objekt verbundenen analysiert werden. Dieser Vorgang wird als Unmarshalling bezeichnet. Beim Rückgängigmachen des Marshallens, die <xref:System.Runtime.Remoting.ObjRef> wird analysiert, um die des Remoteobjekts und sowohl der transparente Proxy zu extrahieren und <xref:System.Runtime.Remoting.Proxies.RealProxy> Objekte werden erstellt. Der Inhalt der analysierten <xref:System.Runtime.Remoting.ObjRef> wird an den transparenten Proxy hinzugefügt, bevor mit der common Language Runtime der transparente Proxy registriert wird.  
  
 Ein <xref:System.Runtime.Remoting.ObjRef> enthält Informationen zur Beschreibung der <xref:System.Type> und die Klasse des Objekts, das gemarshallt wird, ein URI, der angegebenen Objektinstanz und Kommunikation eindeutig identifiziert, verwandte Informationen zur Verwendung von t in dem das Objekt befindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie auf ein Objekt aufheben des Marshallens wird.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die im <paramref name="objectRef" />-Parameter angegebene <see cref="T:System.Runtime.Remoting.ObjRef" />-Instanz ist nicht wohlgeformt.</exception>
        <exception cref="T:System.Security.SecurityException">Mindestens einer der Aufrufer an höherer Position im Aufrufstapel verfügt nicht über die Berechtigung zum Konfigurieren von Remotetypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">Die <see cref="T:System.Runtime.Remoting.ObjRef" />, die das Remoteobjekt darstellt, für das der Proxy gerade erstellt wird.</param>
        <param name="fRefine"><see langword="true" />, um den Proxy dem Typ auf dem Server anzupassen, andernfalls <see langword="false" />.</param>
        <summary>Übernimmt eine <see cref="T:System.Runtime.Remoting.ObjRef" /> und erstellt daraus ein Proxyobjekt, das dem Typ auf dem Server angepasst wird.</summary>
        <returns>Ein Proxy für das Objekt, das von der angegebenen <see cref="T:System.Runtime.Remoting.ObjRef" /> dargestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Runtime.Remoting.ObjRef> ist eine serialisierbare Darstellung eines Objekts verwendet, um einen Objektverweis über eine Anwendungsdomänengrenze hinweg übertragen. Erstellen einer <xref:System.Runtime.Remoting.ObjRef> für ein Objekt als Marshalling bezeichnet wird. Die <xref:System.Runtime.Remoting.ObjRef> können übertragen werden über einen Kanal in einer anderen Anwendungsdomäne (ggf. auf einem anderen Prozess oder Computer). Einmal in die andere Anwendungsdomäne die <xref:System.Runtime.Remoting.ObjRef> müssen zum Erstellen eines Proxys für das Objekt, das in der Regel an das eigentliche Objekt verbundenen analysiert werden. Dieser Vorgang wird als Unmarshalling bezeichnet. Beim Rückgängigmachen des Marshallens, die <xref:System.Runtime.Remoting.ObjRef> wird analysiert, um die des Remoteobjekts und sowohl der transparente Proxy zu extrahieren und <xref:System.Runtime.Remoting.Proxies.RealProxy> Objekte werden erstellt. Der Inhalt der analysierten <xref:System.Runtime.Remoting.ObjRef> wird an den transparenten Proxy hinzugefügt, bevor mit der common Language Runtime der transparente Proxy registriert wird.  
  
 Ein <xref:System.Runtime.Remoting.ObjRef> enthält Informationen zur Beschreibung der <xref:System.Type> und die Klasse des Objekts, das gemarshallt wird, ein URI, der angegebenen Objektinstanz und Kommunikation eindeutig identifiziert, verwandte Informationen zur Verwendung von t in dem das Objekt befindet.  
  
 Beim ersten Mal erstellt, wird der Proxy des Typs ist <xref:System.MarshalByRefObject>. Wie Sie ihn in verschiedene Arten umwandeln, verfolgt des die Remoteinfrastruktur den am häufigsten verwendeten Typ, um zu vermeiden, unnötigerweise Laden des Typs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die im <paramref name="objectRef" />-Parameter angegebene <see cref="T:System.Runtime.Remoting.ObjRef" />-Instanz ist nicht wohlgeformt.</exception>
        <exception cref="T:System.Security.SecurityException">Mindestens einer der Aufrufer an höherer Position im Aufrufstapel verfügt nicht über die Berechtigung zum Konfigurieren von Remotetypen und Channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Konfiguration der Remotinginfrastruktur. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Berechtigungswert: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>