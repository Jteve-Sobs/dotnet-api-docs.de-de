<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f71f19f818c7bf30fbcfe76ff72b1a848912959d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65001086" /></Metadata><TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <TypeSignature Language="F#" Value="type DataContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den Haupteinstiegspunkt für das LINQ to SQL-Framework dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Data.Linq.DataContext> ist die Quelle aller Entitäten, die über eine Datenbankverbindung zugeordnet sind. Es verfolgt Änderungen, die Sie an allen abgerufenen Entitäten vorgenommen haben, und verwaltet einen "Identitäts Cache", mit dem sichergestellt wird, dass Entitäten, die mehrmals abgerufen werden, mithilfe derselben Objektinstanz dargestellt werden.  
  
 Im Allgemeinen ist eine <xref:System.Data.Linq.DataContext> -Instanz so konzipiert, dass Sie für eine "Arbeitseinheit" zuletzt verwendet wird, wenn die Anwendung diesen Begriff jedoch definiert. Eine <xref:System.Data.Linq.DataContext> ist einfach und kann nicht aufwendig erstellt werden. Eine typische [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Anwendung erstellt <xref:System.Data.Linq.DataContext> -Instanzen im Methoden Bereich oder als Member kurzlebiger Klassen, die einen logischen Satz verwandter Daten Bank Vorgänge darstellen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse. Die Verbindungszeichenfolge, die Sie verwenden, kann eine ADO.NET-Verbindungszeichenfolge sein. Sie können auch einen Dateinamen für eine SQL Server Express- oder SQL Server Compact-Datei angeben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Die Verbindung, die von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse durch Verweisen auf die Verbindung, die von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.Linq.DataContext> öffnet und schließt eine Datenbankverbindung nach Bedarf, wenn Sie eine geschlossene Verbindung oder eine Verbindungs Zeichenfolge bereitstellen. Im Allgemeinen sollten Sie nie für einen `Dispose` <xref:System.Data.Linq.DataContext>aufzurufen. Wenn Sie eine geöffnete Verbindung bereitstellen, <xref:System.Data.Linq.DataContext> wird Sie von nicht geschlossen. Instanziieren <xref:System.Data.Linq.DataContext> Sie daher nicht mit einer geöffneten Verbindung, es sei denn, Sie haben einen guten Grund dafür. In einer <xref:System.Transactions> Transaktion wird eine <xref:System.Data.Linq.DataContext> Verbindung nicht geöffnet oder geschlossen, um eine herauf Stufung zu vermeiden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (connection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Die Verbindung, die von .NET Framework verwendet wird.</param>
        <param name="mapping">Eine Quelle für die Zuordnung.</param>
        <summary>Initialisiert durch das Verweisen auf eine Verbindung und eine Zuordnungsquelle eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (fileOrServerOrConnection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Dieses Argument kann eines der folgenden sein: 
Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.  
  
Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  
  
Eine vollständige Verbindungszeichenfolge. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] übergibt die Zeichenfolge unverändert an den Anbieter.</param>
        <param name="mapping">Eine Quelle für die Zuordnung.</param>
        <summary>Initialisiert durch das Verweisen auf eine Dateiquelle und eine Zuordnungsquelle eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Dieses Argument kann eines der folgenden sein: Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.

Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  
  
Eine vollständige Verbindungszeichenfolge. LINQ to SQL übergibt die Zeichenfolge unverändert an den Anbieter.</param>
        <param name="connectionString">Dieses Argument kann eines der folgenden sein: Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.

Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  
  
Eine vollständige Verbindungszeichenfolge. LINQ to SQL übergibt die Zeichenfolge unverändert an den Anbieter.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse durch Verweisen auf eine Dateiquelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChangeConflicts : System.Data.Linq.ChangeConflictCollection" Usage="System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Objekten ab, die beim Aufrufen von <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> Parallelitätskonflikte verursacht haben.</summary>
        <value>Eine Sammlung von Objekten, die Parallelitätskonflikte verursacht haben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden Beispiel wird gezeigt, wie die Auflistung durchlaufen werden kann, um Konflikt Informationen abzurufen.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : int with get, set" Usage="System.Data.Linq.DataContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab (oder legt diesen fest), der das Zeitlimit (in Sekunden) für Abfragen erhöht, die andernfalls während der Standardzeitspanne zu einem Timeout führen würden.</summary>
        <value>Ein ganzzahliger Wert, der den Timeout Zeitraum (in Sekunden) für Abfragen erhöht, bei denen andernfalls während der Standard Timeout Spanne ein Timeout auftritt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft das Timeout (in Sekunden) des Befehls ab, das zum Ausführen generierter Befehle (`IDbCommands`) verwendet wird, oder legt diesen fest. Weitere Informationen finden Sie unter <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Wenn diese Eigenschaft nicht festgelegt ist, wird der Standard <xref:System.Data.IDbCommand.CommandTimeout%2A> Wert von für die Ausführung des Abfrage Befehls verwendet. Dieser Standardwert wird vom Speicher Anbieter festgelegt. Beachten Sie, dass einige Anbieter Ausnahmen auslösen können, wenn dieser Wert auf einen Wert ungleich 0 (null) festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Linq.DataContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Framework verwendete Verbindung ab.</summary>
        <value>Die Verbindung, die vom Framework verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um mit relationalem ADO.NET-Code zu interagieren.  
  
 Die zurückgegebene Verbindung wird geschlossen, sofern Sie nicht explizit vom Benutzer geöffnet wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="dataContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Datenbank auf dem Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name der Datenbank wird mithilfe des folgenden Algorithmus abgeleitet:  
  
1. Wenn eine Datenbank in der Verbindungs Zeichenfolge identifiziert wird, wird Ihr Name verwendet.  
1. Wenn ein <xref:System.Data.Linq.Mapping.DatabaseAttribute> -Attribut vorhanden ist <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> , wird die zugehörige-Eigenschaft als Name der Datenbank verwendet.  
1. Wenn in der Verbindungs Zeichenfolge kein Daten Bank Kennzeichen vorhanden ist und <xref:System.Data.Linq.DataContext> eine stark typisierte verwendet wird, wird eine Datenbank erstellt, <xref:System.Data.Linq.DataContext> die denselben Namen wie die erbende Klasse hat.  
1. Wenn eine schwach typisierte <xref:System.Data.Linq.DataContext> verwendet wird, wird eine Ausnahme ausgelöst.  
1. Wenn das <xref:System.Data.Linq.DataContext> mithilfe eines Datei namens erstellt wurde, wird die Datenbank erstellt, die dem Dateinamen entspricht.  
     
  
## Examples  
 Der folgende Code zeigt, wie Sie eine temporäre Datenbank einrichten und dann entfernen.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fb7f23c4-4572-4c38-9898-a287807d070c">Vorgehensweise: Dynamisches Erstellen einer Datenbank (LINQ to SQL)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4ed76327-54a7-414b-82a9-7579bfcec04b">SQL-CLR-Typenzuordnung (LINQ to SQL)</related>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodCallQuery : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="dataContext.CreateMethodCallQuery (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Elemente in der zurückgegebenen Auflistung.</typeparam>
        <param name="instance">Die Instanz des Methodenaufrufs (das aktuelle Objekt).</param>
        <param name="methodInfo">Die <see cref="T:System.Reflection.MethodInfo" />, die die .NET-Methode identifiziert, die einer Datenbankmethode entspricht.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt die der angegebenen .NET-Methode zugeordnete Tabellenwert-Datenbankfunktion aus.</summary>
        <returns>Von der Datenbankabfrage wurde eine Auflistung resultierender Werte zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> -Methode wird in automatisch generiertem Code verwendet und fungiert als Proxy für Datenbankfunktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="dataContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob die zugeordnete Datenbank geöffnet werden kann.</summary>
        <returns><see langword="true" />, wenn die angegebene Datenbank geöffnet werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Verbindung in der <xref:System.Data.Linq.DataContext.Connection%2A> -Eigenschaft, um zu versuchen, die zugehörige Datenbank zu öffnen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Methode verwendet, um zu bestimmen, ob eine Datenbank bereits vorhanden ist.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DeferredLoadingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob für 1:n- oder 1:1-Beziehungen ein verzögertes Laden stattfinden soll.</summary>
        <value><see langword="true" />, wenn das verzögerte Laden aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Code auf eine dieser Beziehungen zugreift, wird NULL zurückgegeben, wenn die Beziehung eins-zu-eins ist, und eine leere Auflistung wird zurückgegeben, wenn Sie 1: n ist. Die Beziehungen können weiterhin durch Festlegen der <xref:System.Data.Linq.DataContext.LoadOptions%2A> -Eigenschaft ausgefüllt werden.  
  
 Das Hauptszenario für diese Eigenschaft besteht darin, dass Sie ein Teil des Objektmodells extrahieren und es senden können (z. b. an einen Webdienst).  
  
> [!NOTE]
>  Wenn diese Eigenschaft auf `false` festgelegt wird, nachdem eine Abfrage ausgeführt wurde, wird eine Ausnahme ausgelöst. Weitere Informationen finden Sie im Abschnitt **gültige Modi** .  
  
## <a name="valid-modes"></a>Gültige Modi  
 Das verzögerte Laden erfordert die Objekt Nachverfolgung. Nur die folgenden drei Modi sind gültig:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>wird ignoriert und als abgeleitet `false`. Dieses Verhalten entspricht einem <xref:System.Data.Linq.DataContext>schreibgeschützten.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Diese Situation entspricht einem <xref:System.Data.Linq.DataContext> , mit dem Benutzer ein Objekt Diagramm mithilfe <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> von-Direktiven laden können. das verzögerte Laden wird jedoch nicht aktiviert.  
  
-   Beide werden auf `true`festgelegt. Dies ist die Standardeinstellung.  
  
 Die Flags können nicht geändert werden, nachdem eine Abfrage ausgeführt wurde. Jede Änderung nach der Ausführung der ersten Abfrage, von der verwendet <xref:System.Data.Linq.DataContext> wird, löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="dataContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die zugeordnete Datenbank.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Verbindung in der <xref:System.Data.Linq.DataContext.Connection%2A> -Eigenschaft, um die zu löschende Datenbank zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Datenbank gelöscht wird, die temporär erstellt wurde.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="dataContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressource frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteCommand : string * obj[] -&gt; int" Usage="dataContext.ExecuteCommand (command, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Der auszuführende SQL-Befehl.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: 
Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  
  
Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  
  
NULL-Parameter werden in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Befehle direkt in der Datenbank aus.</summary>
        <returns>Die Anzahl der vom ausgeführten Befehl geänderten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dieser Methode handelt es sich um einen Pass-Through [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] -Mechanismus für Fälle, in denen für ein bestimmtes Szenario nicht ausreichend bereitgestellt wird.  
  
 Die Syntax für den Befehl ist fast identisch mit der Syntax, die zum Erstellen eines ADO.net `DataCommand`verwendet wird. Der einzige Unterschied besteht darin, wie die Parameter angegeben werden. Insbesondere geben Sie Parameter an, indem Sie Sie in geschweifte Klammern ({...}) einschließen und beginnend mit 0 auflisten. Der-Parameter wird dem gleichmäßig nummerierten Objekt im Parameter Array zugeordnet.  
  
 `ExecuteQuery`und `ExecuteCommand` ermöglichen es Ihnen, eine Variable Anzahl von Argumenten für die Parameter Ersetzung anzugeben. Beispielsweise können Sie die Parameter angeben, wenn Sie ExecuteQuery\<TResult > aufrufen:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Ein weiteres Beispiel:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 Im folgenden Beispiel wird eine Verbindung geöffnet und ein SQL `UPDATE` -Befehl an die SQL-Engine weitergeleitet.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicDelete : obj -&gt; unit" Usage="dataContext.ExecuteDynamicDelete entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die gelöscht werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Löschen ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Löschvorgänge an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicInsert : obj -&gt; unit" Usage="dataContext.ExecuteDynamicInsert entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die eingefügt werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Einfügen ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Einfügevorgänge neu an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie die folgenden Überlegungen:  
  
-   Da die-Methode über einen geschützten Modifizierer verfügt, erfordert ihre Verwendung <xref:System.Data.Linq.DataContext>eine Unterklassen.  
  
-   Eine-Ausnahme wird ausgelöst, wenn dieser Vorgang nicht innerhalb eines <xref:System.Data.Linq.DataContext.SubmitChanges%2A> -Vorgangs aufgerufen wird. Es ist nicht vorgesehen, als eigenständigen Vorgang außerhalb des Gültigkeits Bereichs eines <xref:System.Data.Linq.DataContext.SubmitChanges%2A> -Vorgangs aufgerufen zu werden. <xref:System.Data.Linq.DataContext.SubmitChanges%2A>selbst ruft Überschreibungs Methoden auf, wenn Sie implementiert werden und die vorherigen Methoden in den Überschreibungs Methoden aufgerufen werden sollen.  
  
-   Es liegt in der Verantwortung des Entwicklers, die richtige Entität zu übergeben. Die-Implementierung überprüft, ob die übergebenen Entität nachverfolgt wird. Es liegt jedoch in der Verantwortung des Entwicklers, die Bestellung beizubehalten oder die gleiche Entität zweimal zu übergeben.  
  
-   Es liegt in der Verantwortung des Entwicklers, die richtige dynamische API aufzurufen. Beispielsweise kann in der `Update` Überschreibungs Methode nur die <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> -Methode aufgerufen werden. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] erkennt oder überprüft nicht, ob die aufgerufene dynamische Methode für den jeweiligen Vorgang gültig ist. Die Ergebnisse sind nicht definiert, wenn eine nicht anwendbare Methode aufgerufen wird (z. <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> b. das Aufrufen eines zu aktualisierenden Objekts).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicUpdate : obj -&gt; unit" Usage="dataContext.ExecuteDynamicUpdate entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die aktualisiert werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Aktualisieren ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Aktualisierungsvorgänge an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteMethodCall : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Data.Linq.IExecuteResult" Usage="dataContext.ExecuteMethodCall (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz des Methodenaufrufs (das aktuelle Objekt).</param>
        <param name="methodInfo">Bezeichnet die einer Datenbankmethode entsprechende .NET-Methode.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt die der angegebenen .NET-Methode zugeordnete gespeicherte Datenbankprozedur oder Skalarfunktion aus.</summary>
        <returns>Das Ergebnis (Ausgabeparameter und Rückgabewert) der Ausführung der angegebenen Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> -Methode wird in automatisch generiertem Code verwendet und fungiert als Proxy für Datenbankfunktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : Type * string * obj[] -&gt; System.Collections.IEnumerable" Usage="dataContext.ExecuteQuery (elementType, query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.  
  
Der Algorithmus für Vergleiche von Spalten im Ergebnis der Abfrage und Feldern oder Eigenschaften im Objekt funktioniert folgendermaßen: 
Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
Der Vergleich wird ausgeführt, indem zuerst unter Beachtung der Groß-/Kleinschreibung nach einer Übereinstimmung gesucht wird. Wenn dabei keine Übereinstimmung gefunden wird, wird die Suche erneut ausgeführt, dieses Mal jedoch, ohne die Groß- und Kleinschreibung zu beachten.  
  
Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts zurückgeben (mit Ausnahme derer, die mit Verzögerung geladen werden), wenn alle nachfolgend aufgeführten Bedingungen erfüllt sind: 
 <c>T</c> stellt eine Entität dar, die explizit von <see cref="T:System.Data.Linq.DataContext" /> überwacht wird.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> ist <see langword="true" />.  
  
Die Entität weist einen Primärschlüssel auf.  
  
Andernfalls wird eine Ausnahme ausgelöst.</param>
        <param name="query">Die SQL-Abfrage, die ausgeführt werden soll.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: 
Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  
  
Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  
  
Wenn ein Parameter <see langword="null" /> ist, wird dieser in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Abfragen direkt in der Datenbank aus.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung von Objekten, die von der Abfrage zurückgegeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result (requires 'Result : (new : unit -&gt; 'Result))&gt; (requires 'Result : (new : unit -&gt; 'Result))" Usage="dataContext.ExecuteQuery (query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Elemente in der zurückgegebenen Auflistung.</typeparam>
        <param name="query">Die SQL-Abfrage, die ausgeführt werden soll.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: 
Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  
  
Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  
  
NULL-Parameter werden in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Abfragen direkt in der Datenbank aus und gibt Objekte zurück.</summary>
        <returns>Eine Auflistung von der Abfrage zurückgegebener Objekte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dieser Methode handelt es sich um einen Pass-Through [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] -Mechanismus für Fälle, in denen kein bestimmtes Szenario bereitstellt.  
  
 Der Algorithmus für die Übereinstimmung von Spalten im Ergebnis der Abfrage mit Feldern und Eigenschaften im-Objekt funktioniert wie folgt:  
  
-   Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
-   Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
-   Der Vergleich wird ausgeführt, indem zuerst nach der Groß-/Kleinschreibung gesucht wird. Wenn eine solche Übereinstimmung nicht gefunden wird, findet eine nachfolgende Suche bei einer Suche ohne Berücksichtigung der Groß-/Kleinschreibung statt  
  
-   Die Abfrage muss alle nach verfolgten Felder und Eigenschaften des Objekts zurückgeben (abgesehen von denjenigen, die dem verzögerten Laden unterliegen), wenn Folgendes zutrifft:  
  
    -   , `<T>` Wenn eine Entität ist, die <xref:System.Data.Linq.DataContext>von explizit nachverfolgt wird.  
  
    -   ObjectTrackingEnabled ist "true".  
  
    -   Die Entität weist einen Primärschlüssel auf.  
  
     Andernfalls wird eine Ausnahme ausgelöst.  
  
-   In allen anderen Fällen kann die Abfrage nur eine Teilmenge der nach verfolgten Felder und Eigenschaften für das-Objekt abrufen.  
  
 Der folgende C# Code Ausschnitt zeigt eine Verwendung für diese Methode:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 In Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberSignature Language="F#" Value="member this.GetChangeSet : unit -&gt; System.Data.Linq.ChangeSet" Usage="dataContext.GetChangeSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die geänderten Objekte ab, die von <see cref="T:System.Data.Linq.DataContext" /> nachverfolgt werden.</summary>
        <returns>Der Satz von Objekten wird in Form von drei schreibgeschützten Auflistungen zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie die folgenden Überlegungen:  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A>kann Nebeneffekte haben, z. b. das Ableiten von Einfüge-und Lösch Vorgängen, die in <xref:System.Data.Linq.DataContext.SubmitChanges%2A>der Regel zum Zeitpunkt von ausgeführt werden. Beispielsweise können-Objekte, die in den folgenden Vorgängen verwendet werden, entsprechende abhergehörende Vorgänge in der folgenden Liste erstellen:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A>an <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601>Zuweisung zu NULL (möglicherweise aufgrund <xref:System.Data.Linq.EntitySet%601.Remove%2A> von <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>auf.  
  
-   Der Satz kann nicht nach Foreign Key-Einschränkungen geordnet werden.  
  
-   Von der Datenbank generierte Werte (z. b. Primär-und Fremdschlüssel Werte, Zeitstempel usw.) sind nicht verfügbar. Diese Informationen erfordern die Ausführung von Daten Bank Befehlen und ggf. die Weitergabe von abgerufenen Informationen (z. b. Fremdschlüssel aus Primärschlüssel).  
  
-   Der Satz von geänderten Objekten wird zum Zeitpunkt des Aufrufes berechnet. Nachfolgende Aufrufe <xref:System.Data.Linq.DataContext.SubmitChanges%2A> von können einen anderen Satz verursachen, wenn zusätzliche Änderungen vorgenommen werden.  
  
 Wenn keine Änderungen vorgenommen wurden, wird die Ausgabe wie folgt angezeigt:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetCommand : System.Linq.IQueryable -&gt; System.Data.Common.DbCommand" Usage="dataContext.GetCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Die Abfrage, für die SQL-Befehlsinformationen abgerufen werden sollen.</param>
        <summary>Ruft Informationen zu SQL-Befehlen ab, die von [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] generiert wurden.</summary>
        <returns>Das angeforderte Befehlsinformationsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur ein Getter und wirkt <xref:System.Data.Linq.DataContext> sich nicht auf den Status aus.  
  
 Beachten Sie die folgenden Überlegungen:  
  
-   Das Argument darf nicht NULL sein. Andernfalls wird eine NULL-Argument Ausnahme ausgelöst.  
  
-   Normale Abfrage Übersetzungs Ausnahmen, die [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] während der Abfrage Ausführung ausgelöst werden, gelten für eine Abfrage, die nicht übersetzt werden kann.  
  
-   Es wird nur der erste Abfragebefehl zurückgegeben. Insbesondere werden zusätzliche Befehle, die für Eager Loading (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) verwendet werden, nicht eingeschlossen.  
  
-   <xref:System.Data.Linq.DataContext>verfolgt nicht, was der Benutzer mit dem Befehl bewirkt. Beispielsweise werden Ergebnisse aus der Ausführung des zurückgegebenen Befehls nicht nachverfolgt und wirken <xref:System.Data.Linq.DataContext> sich nicht auf den Status aus.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetIDbCommand : System.Linq.IQueryable -&gt; System.Data.IDbCommand" Usage="dataContext.GetIDbCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTable : Type -&gt; System.Data.Linq.ITable" Usage="dataContext.GetTable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zurückzugebenden Objekte.</param>
        <summary>Gibt eine Auflistung von Objekten eines bestimmten Typs zurück; der Typ wird vom <paramref name="type" />-Parameter definiert.</summary>
        <returns>Eine Sammlung von Objekten, die vom <paramref name="type" />-Parameter definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine schwach typisierte Version von <xref:System.Data.Linq.DataContext.GetTable%2A>. Es ist wichtig, dass Sie über eine schwach typisierte Version verfügen, da es sich um eine gängige Vorgehensweise zum dynamischen Erstellen von Abfragen handelt. Es wäre unpraktisch, die Anwendung zu zwingen, die Reflektion zu verwenden, um die korrekte generische Methode aufzurufen.  
  
 Wenn für einen bestimmten Typ keine Auflistung vorhanden ist, wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberSignature Language="F#" Value="member this.GetTable : unit -&gt; System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="dataContext.GetTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Der Typ der zurückzugebenden Objekte.</typeparam>
        <summary>Gibt eine Auflistung von Objekten eines bestimmten Typs zurück; der Typ wird vom <paramref name="TEntity" />-Parameter definiert.</summary>
        <returns>Eine Sammlung von Objekten, die vom <paramref name="TEntity" />-Parameter definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt für Abfragen. Wenn eine stark typisierte <xref:System.Data.Linq.DataContext> erstellt wird, Kapseln neue generierte Eigenschaften Aufrufe dieser Methode. Beispielsweise wird eine `Customers` Eigenschaft generiert, die zurück `GetTable<Customer>`gibt.  
  
 Wenn für einen bestimmten Typ keine Auflistung vorhanden ist, wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LoadOptions : System.Data.Linq.DataLoadOptions with get, set" Usage="System.Data.Linq.DataContext.LoadOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Data.Linq.DataLoadOptions" /> ab, die diesem <see cref="T:System.Data.Linq.DataContext" /> zugeordnet sind, oder legt diese fest.</summary>
        <value>Die Optionen für das Laden verknüpfter Daten durch vorheriges Abrufen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft die Optionen ab oder legt diese fest, die verwendet werden, um das Vorabruf Verhalten für verzögerte geladene Elemente und die Mitgliedschaft verwandter Auflistungen zu definieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : System.IO.TextWriter with get, set" Usage="System.Data.Linq.DataContext.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Ziel zum Schreiben der SQL-Abfrage oder des Befehls ab oder legt es fest.</summary>
        <value>Der <see cref="T:System.IO.TextReader" />, der zum Schreiben des Befehls verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft `null` auf fest, um die Befehls Protokollierung zu deaktivieren  
  
   
  
## Examples  
 Im folgenden Beispiel wird generierten SQL-Code im Konsolenfenster angezeigt, bevor die Ergebnisse der Abfrage angezeigt werden.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mapping : System.Data.Linq.Mapping.MetaModel" Usage="System.Data.Linq.DataContext.Mapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Data.Linq.Mapping.MetaModel" /> ab, auf dem die Zuordnung basiert.</summary>
        <value>Die Zuordnung zwischen einer Datenbank und Domänenobjekten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectTrackingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Objektnachverfolgung aktiviert ist, oder legt den Wert fest.</summary>
        <value><see langword="true" />, wenn die Objektverfolgung aktiviert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `false` festgelegt wird, wird die Leistung beim Abruf verbessert, da weniger Elemente nachverfolgt werden müssen.  
  
 Eine Ausnahme wird ausgelöst:  
  
-   , Wenn die-Eigenschaft auf `false` festgelegt ist, nachdem eine Abfrage ausgeführt wurde.  
  
     Weitere Informationen finden Sie im Abschnitt gültige Modi in <xref:System.Data.Linq.DataContext>.  
  
-   , Wenn die-Eigenschaft auf `false` fest <xref:System.Data.Linq.DataContext.SubmitChanges%2A> gelegt ist und aufgerufen wird.  
  
 <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> `false`Wenn den Wert <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> hat, wird ignoriert und als behandelt. `false` In diesem Fall ist die <xref:System.Data.Linq.DataContext> schreibgeschützt.  
  
 Falls <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>`true` lautet, ist <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>`false`. In diesem Fall <xref:System.Data.Linq.DataContext> können Sie ein Objekt Diagramm mithilfe <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> von-Direktiven laden, das verzögerte Laden wird jedoch nicht aktiviert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.QueryCacheEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Objektstatus anhand von Daten in der Datenbank.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nach einem Fehler bei der vollständigen Parallelität nützlich, um Elemente für einen anderen Versuch in einen Zustand zu bringen. Sie aktualisiert den Zustand der primitiven Felder und Eigenschaften für die Objekte.  
  
> [!NOTE]
>  Wenn sich ein Objekt auf der n *-Seite einer* 1: n-Beziehung befindet, wird der Fremdschlüssel für das Objekt festgelegt, und der Objekt Zeiger für die andere Seite der Beziehung wird auf den neuen Wert festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entities">Die Auflistung von Entitäten, die aktualisiert werden soll.</param>
        <summary>Aktualisiert eine Auflistung von Entitätsobjekten anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj -&gt; unit" Usage="dataContext.Refresh (mode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entity">Das Objekt, das aktualisiert werden soll.</param>
        <summary>Aktualisiert ein Entitätsobjekt anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj[] -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entities">Das Array von Entitätsobjekten, das aktualisiert werden soll.</param>
        <summary>Aktualisiert ein Array von Entitätsobjekten anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die geänderten Objekte, die eingefügt, aktualisiert oder gelöscht werden sollen, und führt die entsprechenden Befehle zur Implementierung der Änderungen für die Datenbank aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Überschreibungs Methoden für INSERT, Update oder DELETE vorhanden sind, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> werden diese Methoden anstelle der Standard [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Befehle ausgeführt.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>startet eine Transaktion und führt ein Rollback aus, wenn eine <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Ausnahme während der Ausführung von auftritt. Dadurch wird jedoch kein Rollback für die Änderungen im Arbeitsspeicher durch <xref:System.Data.Linq.DataContext>geführt, und die Änderungen müssen manuell zurückgesetzt werden. Sie können mit einer neuen Instanz von <xref:System.Data.Linq.DataContext> beginnen, wenn die Änderungen im Speicher verworfen werden sollen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberSignature Language="F#" Value="member this.SubmitChanges : unit -&gt; unit" Usage="dataContext.SubmitChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Berechnet die geänderten Objekte, die eingefügt, aktualisiert oder gelöscht werden sollen, und führt die entsprechenden Befehle zur Implementierung der Änderungen für die Datenbank aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Überschreibungs Methoden für INSERT, Update oder DELETE vorhanden sind, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> werden diese Methoden anstelle der Standard [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Befehle ausgeführt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberSignature Language="F#" Value="abstract member SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit&#xA;override this.SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit" Usage="dataContext.SubmitChanges failureMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Die Aktion, die bei einem Fehler ausgeführt werden soll. Gültige Argumente sind: 
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Sendet Änderungen an abgerufenen Objekten an die zugrunde liegende Datenbank und gibt die Aktion an, die bei einem Fehler ausgeführt werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardfehler Modus <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>ist.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transaction : System.Data.Common.DbTransaction with get, set" Usage="System.Data.Linq.DataContext.Transaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine lokale Transaktion für [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] fest, um auf die Datenbank zuzugreifen, oder legt diese fest.</summary>
        <value>Das vom <see cref="T:System.Data.Linq.DataContext" /> beim Ausführen von Abfragen und Befehlen verwendete Transaktionsobjekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das primäre Szenario für diese Eigenschaft ist die Interoperabilität mit [!INCLUDE[vstecado](~/includes/vstecado-md.md)] relationalem Code. Verwenden Sie diese Eigenschaft z. b., wenn Sie `Create` eigene `Transaction` / `Delete` `Update` / Methoden schreiben, um die-Eigenschaft `Command` für das ADO-Objekt festzulegen.  
  
 Beachten Sie Folgendes:  
  
-   Wenn diese Eigenschaft nicht explizit festgelegt wurde, gibt der Getter NULL zurück.  
  
-   Wenn der Code in einem <xref:System.Transactions.Transaction> Kontext ausgeführt wird, wird durch das Festlegen dieser Eigenschaft eine Ausnahme ausgelöst.  
  
-   Wenn diese Eigenschaft festgelegt ist und ein <xref:System.Transactions.Transaction> neuer geöffnet wird, wird eine Ausnahme ausgelöst, wenn eine Abfrage oder ein Update ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.IDataReader" /> in Objekte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Zeile in der <xref:System.Data.IDataReader> wird in ein-Objekt <xref:System.Collections.Generic.IEnumerable%601>in konvertiert.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Beschreibung: Diese Methode wird verwendet, um ein vorhandenes <xref:System.Data.Common.DbDataReader> in-Objekte zu konvertieren. Jede Zeile in der <xref:System.Data.Common.DbDataReader> wird in ein-Objekt <xref:System.Collections.Generic.IEnumerable%601>in konvertiert.  
  
 **Generische Parameter:**  
  
 `T`: Siehe <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Metern**  
  
 `Query`: Weitere Informationen finden Sie in der <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>Beschreibung des Befehls unter.  
  
 `Parameters`: Weitere Informationen finden Sie in der <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>Beschreibung der Parameter unter.  
  
 **Rückgabetyp:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: Auflistung von-Objekten, die von der Konvertierung zurückgegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Linq.IMultipleResults" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Liste von Objekten, die durch die Konvertierung zurückgegeben werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : Type * System.Data.Common.DbDataReader -&gt; System.Collections.IEnumerable" Usage="dataContext.Translate (elementType, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.  
  
Der Algorithmus für Vergleiche von Spalten im Ergebnis und Feldern und Eigenschaften im Objekt funktioniert folgendermaßen: 
Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
Der Vergleich wird ausgeführt, indem zuerst unter Beachtung der Groß-/Kleinschreibung nach einer Übereinstimmung gesucht wird. Wenn dabei keine Übereinstimmung gefunden wird, wird die Suche erneut ausgeführt, dieses Mal jedoch, ohne die Groß- und Kleinschreibung zu beachten.  
  
Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts zurückgeben (mit Ausnahme derer, die mit Verzögerung geladen werden), wenn alle nachfolgend aufgeführten Bedingungen erfüllt sind: 
 <c>T</c> stellt eine Entität dar, die explizit von <see cref="T:System.Data.Linq.DataContext" /> überwacht wird.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> ist <see langword="true" />.  
  
Die Entität weist einen Primärschlüssel auf.  
  
Andernfalls wird eine Ausnahme ausgelöst.</param>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Liste von Objekten, die durch die Konvertierung zurückgegeben werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; seq&lt;'Result&gt;" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.</typeparam>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Auflistung von der Konvertierung zurückgegebener Objekte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>