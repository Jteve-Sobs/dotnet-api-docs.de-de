<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a42fd635959b32ca28abcf4d415b6d67f12f7c57" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51866880" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <TypeSignature Language="F#" Value="type DataContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den Haupteinstiegspunkt für das LINQ to SQL-Framework dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext> ist die Quelle aller Entitäten, die über eine datenbankverbindung zugeordnet. Es verfolgt Änderungen, die Sie für alle abgerufenen Entitäten vorgenommen und verwaltet einen "Identitäts-Cache", die garantiert, dass Entitäten mit mehr als einmal abgerufen durch dargestellt werden über die gleiche Objektinstanz.  
  
 Im Allgemeinen eine <xref:System.Data.Linq.DataContext> Instanz ist so konzipiert, für eine "Arbeitseinheit" Ihrer Anwendung dieser Begriff definiert. Ein <xref:System.Data.Linq.DataContext> ist nicht sehr umfangreich und ist nicht aufwendig zu erstellen. Eine typische [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Anwendung erstellt <xref:System.Data.Linq.DataContext> Datenbank-Vorgängen für die Instanzen im Geltungsbereich der Methode oder als Mitglied der kurzlebige Klassen, die einen logischen Satz darstellen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse. Die Verbindungszeichenfolge, die Sie verwenden, kann eine ADO.NET-Verbindungszeichenfolge sein. Sie können auch einen Dateinamen für eine SQL Server Express- oder SQL Server Compact-Datei angeben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Die Verbindung, die von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse durch Verweisen auf die Verbindung, die von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.Linq.DataContext> öffnet und schließt eine datenbankverbindung aus, nach Bedarf, wenn Sie eine geschlossene Verbindung oder eine Verbindungszeichenfolge angeben. Im Allgemeinen sollten nie muss `Dispose` auf eine <xref:System.Data.Linq.DataContext>. Wenn Sie angeben, dass eine offene Verbindung, die <xref:System.Data.Linq.DataContext> wird nicht geschlossen. Aus diesem Grund nicht instanziiert werden eine <xref:System.Data.Linq.DataContext> mit einer geöffneten Verbindung, wenn Sie einen guten Grund dazu haben. In einem <xref:System.Transactions> Transaktion eine <xref:System.Data.Linq.DataContext> nicht öffnen oder schließen Sie die Verbindung zur Höherstufung zu vermeiden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (connection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Die Verbindung, die von .NET Framework verwendet wird.</param>
        <param name="mapping">Eine Quelle für die Zuordnung.</param>
        <summary>Initialisiert durch das Verweisen auf eine Verbindung und eine Zuordnungsquelle eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (fileOrServerOrConnection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Dieses Argument kann eines der folgenden sein: 
Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.  
  
Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  
  
Eine vollständige Verbindungszeichenfolge. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] übergibt die Zeichenfolge unverändert an den Anbieter.</param>
        <param name="mapping">Eine Quelle für die Zuordnung.</param>
        <summary>Initialisiert durch das Verweisen auf eine Dateiquelle und eine Zuordnungsquelle eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Bei diesem Argument kann es sich um eines der folgenden handeln: Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.

Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  
  
Eine vollständige Verbindungszeichenfolge. LINQ to SQL übergibt die Zeichenfolge unverändert an den Anbieter.</param>
        <param name="connectionString">Bei diesem Argument kann es sich um eines der folgenden handeln: Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.

Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  
  
Eine vollständige Verbindungszeichenfolge. LINQ to SQL übergibt die Zeichenfolge unverändert an den Anbieter.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse durch Verweisen auf eine Dateiquelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChangeConflicts : System.Data.Linq.ChangeConflictCollection" Usage="System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Objekten ab, die beim Aufrufen von <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> Parallelitätskonflikte verursacht haben.</summary>
        <value>Eine Sammlung von Objekten, die Parallelitätskonflikte verursacht haben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das folgende Beispiel zeigt, wie die Auflistung durchlaufen werden kann, zum Abrufen von Informationen zu Konflikten.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : int with get, set" Usage="System.Data.Linq.DataContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt diesen fest, der den Timeoutwert für Abfragen erhöht, die andernfalls während der Standardtimeoutspanne zu einem Timeout führen würden.</summary>
        <value>Eine Ganzzahl, die den Timeoutwert für Abfragen erhöht, die andernfalls während der Standardtimeoutspanne zu einem Timeout führen würden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft ab oder legt diesen fest der Befehls-Timeoutwert verwendet, um generierte Befehle auszuführen (`IDbCommands`). Weitere Informationen finden Sie unter <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Wenn diese Eigenschaft nicht festgelegt ist, den Standardwert von <xref:System.Data.IDbCommand.CommandTimeout%2A> wird verwendet, für die abfrageausführung-Befehl. Dieser Standardwert wird vom Speicheranbieter festgelegt. Beachten Sie, dass einige Anbieter möglicherweise Ausnahmen auslösen, wenn dieser Wert auf einen Wert ungleich NULL festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Linq.DataContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Framework verwendete Verbindung ab.</summary>
        <value>Die Verbindung, die vom Framework verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, für die Zusammenarbeit mit relationalen ADO.NET-Code.  
  
 Die zurückgegebene Verbindung wird geschlossen werden, es sei denn, sie explizit vom Benutzer geöffnet wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="dataContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Datenbank auf dem Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name der Datenbank wird abgeleitet, mithilfe des folgenden Algorithmus:  
  
1. Wenn eine Datenbank in der Verbindungszeichenfolge identifiziert wird, wird der Name verwendet.  
1. Wenn eine <xref:System.Data.Linq.Mapping.DatabaseAttribute> -Attribut vorhanden ist, dessen <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> Eigenschaft wird als Name der Datenbank verwendet.  
1. Es ist keine Datenbank-Tag in die Verbindungszeichenfolge und einen stark typisierten <xref:System.Data.Linq.DataContext> verwendet wird, eine Datenbank mit dem gleichen Namen wie die <xref:System.Data.Linq.DataContext> erbende Klasse erstellt wird.  
1. Wenn eine schwach typisierte <xref:System.Data.Linq.DataContext> wird verwendet, wird eine Ausnahme ausgelöst.  
1. Wenn die <xref:System.Data.Linq.DataContext> wurde mit einem Dateinamen, wird die Datenbank entspricht dem Dateinamen erstellt.  
     
  
## Examples  
 Der folgende Code zeigt, wie eine temporäre Datenbank einrichten, und entfernen sie Sie dann.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fb7f23c4-4572-4c38-9898-a287807d070c">Gewusst wie: Dynamisches Erstellen einer neuen Datenbank (LINQ to SQL)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4ed76327-54a7-414b-82a9-7579bfcec04b">SQL-CLR-Typenzuordnung (LINQ to SQL)</related>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodCallQuery : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="dataContext.CreateMethodCallQuery (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Elemente in der zurückgegebenen Auflistung.</typeparam>
        <param name="instance">Die Instanz des Methodenaufrufs (das aktuelle Objekt).</param>
        <param name="methodInfo">Die <see cref="T:System.Reflection.MethodInfo" />, die die .NET-Methode identifiziert, die einer Datenbankmethode entspricht.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt die der angegebenen .NET-Methode zugeordnete Tabellenwert-Datenbankfunktion aus.</summary>
        <returns>Von der Datenbankabfrage wurde eine Auflistung resultierender Werte zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> Methode im automatisch generierten Code verwendet wird, und fungiert als Proxy für Datenbankfunktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="dataContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob die zugeordnete Datenbank geöffnet werden kann.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene Datenbank geöffnet werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Verbindung in der <xref:System.Data.Linq.DataContext.Connection%2A> Eigenschaft, um zu versuchen, öffnen Sie die zugeordnete Datenbank.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Methode, um festzustellen, ob eine Datenbank bereits vorhanden ist.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DeferredLoadingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob für 1:n- oder 1:1-Beziehungen ein verzögertes Laden stattfinden soll.</summary>
        <value>
          <see langword="true" />, wenn das verzögerte Laden aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn greift der Code eines dieser Beziehungen null wird zurückgegeben, wenn die Beziehung 1: 1 ist, und eine leere Auflistung zurückgegeben wird, wenn es sich um 1: n handelt. Die Beziehungen können immer noch gefüllt werden, durch Festlegen der <xref:System.Data.Linq.DataContext.LoadOptions%2A> Eigenschaft.  
  
 Das Hauptszenario für diese Eigenschaft ist, können Sie einen Teil des Objektmodells zu extrahieren, und senden sie Sie (z. B. an einen Webdienst).  
  
> [!NOTE]
>  Wenn diese Eigenschaft, um festgelegt wird `false` nachdem eine Abfrage ausgeführt wurde, wird eine Ausnahme ausgelöst. Finden Sie unter den **gültige Modi** Informationen weiter unten im Abschnitt.  
  
## <a name="valid-modes"></a>Gültige Modi  
 Verzögertes Laden ist die Objekt-nachverfolgung erforderlich. Die folgenden drei Modi sind gültig:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> wird ignoriert und abgeleitet `false`. Dieses Verhalten entspricht ein schreibgeschütztes <xref:System.Data.Linq.DataContext>.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Dies entspricht einer <xref:System.Data.Linq.DataContext> , mit der Benutzer beim Laden eines Objektdiagramms mithilfe von <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> Direktiven, sondern ermöglicht nicht das verzögerte Laden.  
  
-   Beide werden festgelegt, um `true`. Dies ist die Standardeinstellung.  
  
 Die Flags können nicht geändert werden, nachdem eine Abfrage ausgeführt wurde. Alle Änderungen nach der Ausführung der ersten Abfrage, die mithilfe <xref:System.Data.Linq.DataContext> löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="dataContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die zugeordnete Datenbank.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Verbindung in der <xref:System.Data.Linq.DataContext.Connection%2A> Eigenschaft zum Identifizieren der Datenbank gelöscht werden soll.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine Datenbank zu löschen, die vorübergehend erstellt wurde.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="dataContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressource frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteCommand : string * obj[] -&gt; int" Usage="dataContext.ExecuteCommand (command, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Der auszuführende SQL-Befehl.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: 
Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  
  
Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  
  
NULL-Parameter werden in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Befehle direkt in der Datenbank aus.</summary>
        <returns>Die Anzahl der vom ausgeführten Befehl geänderten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein Pass-Through-Mechanismus für Fälle, in denen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] kein entsprechendes für ein bestimmtes Szenario bereitgestellt wird.  
  
 Die Syntax des Befehls ist fast identisch mit der Syntax zum Erstellen einer ADO.NET `DataCommand`. Der einzige Unterschied besteht darin, wie die Parameter angegeben werden. Insbesondere in geschweiften Klammern ({...}) Geben Sie Parameter, und sie auflisten beginnend bei 0. Der Parameter ist für das gleichermaßen nummerierten Objekt im Parameterarray.  
  
 `ExecuteQuery` und `ExecuteCommand` können Sie eine Variable Anzahl von Argumenten für Vorlagenparameter angeben. Sie können z. B. die Parameter angeben, beim Aufrufen der ExecuteQuery\<TResult >:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Und ein weiteres Beispiel:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 Im folgenden Beispiel wird eine Verbindung geöffnet und übergibt Sie eine SQL `UPDATE` Befehl mit der SQL-Engine.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicDelete : obj -&gt; unit" Usage="dataContext.ExecuteDynamicDelete entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die gelöscht werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Löschen ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Löschvorgänge an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicInsert : obj -&gt; unit" Usage="dataContext.ExecuteDynamicInsert entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die eingefügt werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Einfügen ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Einfügevorgänge neu an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie Folgendes ein:  
  
-   Da die Methode einen protected-Modifizierer verfügt, muss dessen Verwendung Unterklassen <xref:System.Data.Linq.DataContext>.  
  
-   Eine Ausnahme ausgelöst, wenn dieser Vorgang nicht, innerhalb aufgerufen wird einer <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Vorgang. Es dient nicht als eigenständigen Vorgang außerhalb des Bereichs der aufzurufenden eine <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Vorgang. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> selbst überschreiben ruft Methoden, wenn sie implementiert werden, und die vorherigen Methoden innerhalb der außer Kraft setzen-Methoden aufgerufen werden sollen.  
  
-   Es ist die Verantwortung des Entwicklers um die richtige Entität übergeben. Die Implementierung stellt sicher, dass die übergebene Entität nachverfolgt wird. Es ist jedoch in der Verantwortung des Entwicklers zum Beibehalten der Reihenfolge oder in der gleichen Entität zweimal zu übergeben.  
  
-   Es ist die Verantwortung des Entwicklers um die richtige dynamische API aufzurufen. Z. B. in der `Update` -Überschreibungsmethode nur das <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> Methode kann aufgerufen werden. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] erkennt oder überprüft nicht, ob die aufgerufene dynamische Methode für den jeweiligen Vorgang gültig ist. Wenn eine nicht anwendbare Methode aufgerufen wird, sind die Ergebnisse nicht definiert (z. B. Aufrufen von <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> für ein Objekt aktualisiert werden).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicUpdate : obj -&gt; unit" Usage="dataContext.ExecuteDynamicUpdate entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die aktualisiert werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Aktualisieren ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Aktualisierungsvorgänge an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteMethodCall : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Data.Linq.IExecuteResult" Usage="dataContext.ExecuteMethodCall (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz des Methodenaufrufs (das aktuelle Objekt).</param>
        <param name="methodInfo">Bezeichnet die einer Datenbankmethode entsprechende .NET-Methode.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt die der angegebenen .NET-Methode zugeordnete gespeicherte Datenbankprozedur oder Skalarfunktion aus.</summary>
        <returns>Das Ergebnis (Ausgabeparameter und Rückgabewert) der Ausführung der angegebenen Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> Methode im automatisch generierten Code verwendet wird, und fungiert als Proxy für Datenbankfunktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : Type * string * obj[] -&gt; System.Collections.IEnumerable" Usage="dataContext.ExecuteQuery (elementType, query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.  
  
Der Algorithmus für Vergleiche von Spalten im Ergebnis der Abfrage und Feldern oder Eigenschaften im Objekt funktioniert folgendermaßen: 
Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
Der Vergleich wird ausgeführt, indem zuerst unter Beachtung der Groß-/Kleinschreibung nach einer Übereinstimmung gesucht wird. Wenn dabei keine Übereinstimmung gefunden wird, wird die Suche erneut ausgeführt, dieses Mal jedoch, ohne die Groß- und Kleinschreibung zu beachten.  
  
Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts zurückgeben (mit Ausnahme derer, die mit Verzögerung geladen werden), wenn alle nachfolgend aufgeführten Bedingungen erfüllt sind: 
 <c>T</c> stellt eine Entität dar, die explizit von <see cref="T:System.Data.Linq.DataContext" /> überwacht wird.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> ist <see langword="true" />.  
  
Die Entität weist einen Primärschlüssel auf.  
  
Andernfalls wird eine Ausnahme ausgelöst.</param>
        <param name="query">Die SQL-Abfrage, die ausgeführt werden soll.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: 
Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  
  
Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  
  
Wenn ein Parameter <see langword="null" /> ist, wird dieser in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Abfragen direkt in der Datenbank aus.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung von Objekten, die von der Abfrage zurückgegeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result (requires 'Result : (new : unit -&gt; 'Result))&gt; (requires 'Result : (new : unit -&gt; 'Result))" Usage="dataContext.ExecuteQuery (query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Elemente in der zurückgegebenen Auflistung.</typeparam>
        <param name="query">Die SQL-Abfrage, die ausgeführt werden soll.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: 
Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  
  
Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  
  
NULL-Parameter werden in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Abfragen direkt in der Datenbank aus und gibt Objekte zurück.</summary>
        <returns>Eine Auflistung von der Abfrage zurückgegebener Objekte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein Pass-Through-Mechanismus für Fälle, in denen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] bietet keine für ein bestimmtes Szenario.  
  
 Der Algorithmus für Vergleiche von Spalten im Resultset der Abfrage, die Felder und Eigenschaften im Objekt funktioniert folgendermaßen:  
  
-   Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
-   Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
-   Der Vergleich wird ausgeführt, indem zuerst Groß-/ Kleinschreibung gesucht wird. Wenn eine Übereinstimmung nicht gefunden wird, wird die Suche erneut nach einer Übereinstimmung der Groß-/Kleinschreibung.  
  
-   Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts (mit Ausnahme derer, verzögertes Laden) zurückgeben. wenn alle folgenden Bedingungen zutreffen:  
  
    -   Wenn `<T>` eine Entität explizit verfolgt wird die <xref:System.Data.Linq.DataContext>.  
  
    -   ObjectTrackingEnabled ist "true".  
  
    -   Die Entität weist einen Primärschlüssel auf.  
  
     Andernfalls wird eine Ausnahme ausgelöst.  
  
-   In allen anderen Fällen kann die Abfrage nur eine Teilmenge der überwachten Felder und Eigenschaften für das Objekt abrufen.  
  
 Der folgende c#-Codeausschnitt zeigt eine Verwendung dieser Methode:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 In Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberSignature Language="F#" Value="member this.GetChangeSet : unit -&gt; System.Data.Linq.ChangeSet" Usage="dataContext.GetChangeSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die geänderten Objekte ab, die von <see cref="T:System.Data.Linq.DataContext" /> nachverfolgt werden.</summary>
        <returns>Der Satz von Objekten wird in Form von drei schreibgeschützten Auflistungen zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie Folgendes ein:  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> Möglicherweise haben Nebeneffekte, wie die Ableitung von Einfüge- und Löschvorgänge, die in der Regel zum Zeitpunkt der ausgeführt werden <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Beispielsweise können Objekte, die in den folgenden Vorgängen verwendet werden, entsprechende abgeleitete Vorgänge in der folgenden Liste erstellen:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> um <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> null-Zuweisung (möglicherweise aufgrund von <xref:System.Data.Linq.EntitySet%601.Remove%2A> zu <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Die Gruppe kann entsprechend der foreign Key-Einschränkungen nicht sortiert werden.  
  
-   Datenbankgenerierten Werten (z. B. Primär- und Fremdschlüssel Schlüsselwerte, Zeitstempel und So weiter) sind nicht verfügbar. Solche Informationen erfordert die Ausführung von Datenbankbefehlen, und vielleicht die Weitergabe von abgerufenen Informationen (z. B. Fremdschlüssel aus Primärschlüssel).  
  
-   Der Satz von geänderten Objekten wird zum Zeitpunkt des Aufrufs berechnet. Nachfolgende Aufrufe von <xref:System.Data.Linq.DataContext.SubmitChanges%2A> kann einen anderen Satz erzeugen, wenn zusätzliche Änderungen vorgenommen werden.  
  
 Ausgabe, wenn keine Änderungen vorgenommen wurden, wird wie folgt angezeigt:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetCommand : System.Linq.IQueryable -&gt; System.Data.Common.DbCommand" Usage="dataContext.GetCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Die Abfrage, für die SQL-Befehlsinformationen abgerufen werden sollen.</param>
        <summary>Ruft Informationen zu SQL-Befehlen ab, die von [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] generiert wurden.</summary>
        <returns>Das angeforderte Befehlsinformationsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur ein Getter und hat keinen Einfluss auf <xref:System.Data.Linq.DataContext> Zustand.  
  
 Beachten Sie Folgendes ein:  
  
-   Das Argument muss ungleich Null sein. Andernfalls wird eine null-Argument-Ausnahme ausgelöst.  
  
-   Normale Abfrage Übersetzung Ausnahmen während der [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] abfrageausführung Bewerben Sie sich für eine Abfrage, die nicht übersetzt werden kann.  
  
-   Es wird nur der erste Abfragebefehl zurückgegeben. Insbesondere zusätzliche Befehle, die für eager Loading verwendet werden (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) sind nicht enthalten.  
  
-   <xref:System.Data.Linq.DataContext> Funktionsweise der Benutzer mit dem Befehl nachverfolgt nicht. Z. B. die Ergebnisse der Ausführung des Befehls zurückgegeben werden nicht nachverfolgt und haben keine Auswirkungen auf <xref:System.Data.Linq.DataContext> Zustand.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetIDbCommand : System.Linq.IQueryable -&gt; System.Data.IDbCommand" Usage="dataContext.GetIDbCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTable : Type -&gt; System.Data.Linq.ITable" Usage="dataContext.GetTable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zurückzugebenden Objekte.</param>
        <summary>Gibt eine Auflistung von Objekten eines bestimmten Typs zurück; der Typ wird vom <paramref name="type" />-Parameter definiert.</summary>
        <returns>Eine Sammlung von Objekten, die vom <paramref name="type" />-Parameter definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine schwach typisierte Version der <xref:System.Data.Linq.DataContext.GetTable%2A>. Es ist wichtig, um eine schwach typisierte Version zu erhalten, da sie relativ allgemein üblich, Abfragen dynamisch zu erstellen ist. Es wäre unpraktisch, die auf Reflektion verwenden, um die richtige generische Methode aufrufen zu erzwingen.  
  
 Wenn es keine Auflistung für einen bestimmten Typ ist, wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberSignature Language="F#" Value="member this.GetTable : unit -&gt; System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="dataContext.GetTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Der Typ der zurückzugebenden Objekte.</typeparam>
        <summary>Gibt eine Auflistung von Objekten eines bestimmten Typs zurück; der Typ wird vom <paramref name="TEntity" />-Parameter definiert.</summary>
        <returns>Eine Sammlung von Objekten, die vom <paramref name="TEntity" />-Parameter definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt für die Abfrage. Wenn ein stark typisiertes <xref:System.Data.Linq.DataContext> wird erstellte, die neue generierte Eigenschaften kapseln Aufrufe dieser Methode. Z. B. eine `Customers` -Eigenschaft generiert wird, die zurückgibt `GetTable<Customer>`.  
  
 Wenn es keine Auflistung für einen bestimmten Typ ist, wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LoadOptions : System.Data.Linq.DataLoadOptions with get, set" Usage="System.Data.Linq.DataContext.LoadOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Data.Linq.DataLoadOptions" /> ab, die diesem <see cref="T:System.Data.Linq.DataContext" /> zugeordnet sind, oder legt diese fest.</summary>
        <value>Die Optionen für das Laden verknüpfter Daten durch vorheriges Abrufen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft ab oder legt die Optionen, die zum Definieren der Vorabruf-Verhalten für verzögert geladene Elemente und Mitgliedschaft verknüpften Sammlungen verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : System.IO.TextWriter with get, set" Usage="System.Data.Linq.DataContext.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Ziel zum Schreiben der SQL-Abfrage oder des Befehls ab oder legt es fest.</summary>
        <value>Der <see cref="T:System.IO.TextReader" />, der zum Schreiben des Befehls verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `null` zum Deaktivieren der Protokollierung für Befehl.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die generierte SQL im Konsolenfenster angezeigt, bevor die Ergebnisse der Abfrage angezeigt.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mapping : System.Data.Linq.Mapping.MetaModel" Usage="System.Data.Linq.DataContext.Mapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Data.Linq.Mapping.MetaModel" /> ab, auf dem die Zuordnung basiert.</summary>
        <value>Die Zuordnung zwischen einer Datenbank und Domänenobjekten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectTrackingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Objektnachverfolgung aktiviert ist, oder legt den Wert fest.</summary>
        <value>
          <see langword="true" />, wenn die Objektverfolgung aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `false` verbessert die Leistung zum Zeitpunkt abrufen, da es weniger Elemente zu verfolgen.  
  
 Es wird eine Ausnahme ausgelöst:  
  
-   Wenn die Eigenschaft, um festgelegt ist `false` nachdem eine Abfrage ausgeführt wurde.  
  
     Weitere Informationen finden Sie im Abschnitt gültige Modi in <xref:System.Data.Linq.DataContext>.  
  
-   Wenn die Eigenschaft, um festgelegt ist `false` und <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird.  
  
 Wenn <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> ist `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> wird ignoriert und behandelt Sie als `false`. In diesem Fall die <xref:System.Data.Linq.DataContext> ist schreibgeschützt.  
  
 Falls <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>`true` lautet, ist <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>`false`. In diesem Fall <xref:System.Data.Linq.DataContext> können Sie ein Objektdiagramm mit <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> Direktiven, jedoch ermöglicht nicht das verzögerte Laden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.QueryCacheEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Objektstatus anhand von Daten in der Datenbank.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nützlich, nachdem ein optimistischer nebenläufigkeitsfehler, Elemente in einen Zustand für einen weiteren Versuch zu öffnen. Aktualisiert den Status der primitiven Feldern und Eigenschaften für die Objekte.  
  
> [!NOTE]
>  Wenn ein Objekt ist, auf die *viele* Seite einer 1: n Beziehung, die foreign Key für das Objekt festgelegt, und der Objektzeiger für die andere Seite der Beziehung wird auf den neuen Wert festgelegt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entities">Die Auflistung von Entitäten, die aktualisiert werden soll.</param>
        <summary>Aktualisiert eine Auflistung von Entitätsobjekten anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj -&gt; unit" Usage="dataContext.Refresh (mode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entity">Das zu aktualisierende Objekt.</param>
        <summary>Aktualisiert ein Entitätsobjekt anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj[] -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entities">Das Array von Entitätsobjekten, das aktualisiert werden soll.</param>
        <summary>Aktualisiert ein Array von Entitätsobjekten anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die geänderten Objekte, die eingefügt, aktualisiert oder gelöscht werden sollen, und führt die entsprechenden Befehle zur Implementierung der Änderungen für die Datenbank aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Methoden zum Überschreiben für INSERT-, Update- oder Delete, vorhanden sind <xref:System.Data.Linq.DataContext.SubmitChanges%2A> führt diese Methoden anstelle der standardmäßigen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Befehle.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Startet eine Transaktion und wird Rollback aus, wenn eine Ausnahme tritt auf, während <xref:System.Data.Linq.DataContext.SubmitChanges%2A> ausgeführt wird. Allerdings Dies führt kein Rollback die Änderungen im Arbeitsspeicher oder von verfolgt die <xref:System.Data.Linq.DataContext>; diese Änderungen müssen manuell rückgängig gemacht werden. Beginnen Sie mit der eine neue Instanz der <xref:System.Data.Linq.DataContext> Wenn die Änderungen im Speicher verworfen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberSignature Language="F#" Value="member this.SubmitChanges : unit -&gt; unit" Usage="dataContext.SubmitChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Berechnet die geänderten Objekte, die eingefügt, aktualisiert oder gelöscht werden sollen, und führt die entsprechenden Befehle zur Implementierung der Änderungen für die Datenbank aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Methoden zum Überschreiben für INSERT-, Update- oder Delete, vorhanden sind <xref:System.Data.Linq.DataContext.SubmitChanges%2A> führt diese Methoden anstelle der standardmäßigen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Befehle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberSignature Language="F#" Value="abstract member SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit&#xA;override this.SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit" Usage="dataContext.SubmitChanges failureMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Die Aktion, die bei einem Fehler ausgeführt werden soll. Gültige Argumente sind: 
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Sendet Änderungen an abgerufenen Objekten an die zugrunde liegende Datenbank und gibt die Aktion an, die bei einem Fehler ausgeführt werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardfehlermodus ist <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transaction : System.Data.Common.DbTransaction with get, set" Usage="System.Data.Linq.DataContext.Transaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine lokale Transaktion für [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] fest, um auf die Datenbank zuzugreifen, oder legt diese fest.</summary>
        <value>Das vom <see cref="T:System.Data.Linq.DataContext" /> beim Ausführen von Abfragen und Befehlen verwendete Transaktionsobjekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das primäre Szenario für diese Eigenschaft ist die Interoperabilität mit relationalen [!INCLUDE[vstecado](~/includes/vstecado-md.md)] Code. Verwenden Sie diese Eigenschaft beispielsweise, wenn Sie Ihren eigenen schreiben `Create` / `Update` / `Delete` Methoden zum Festlegen der `Transaction` Eigenschaft für das ADO `Command` Objekt.  
  
 Beachten Sie Folgendes:  
  
-   Wenn diese Eigenschaft nicht explizit festgelegt wurde, gibt Get-Methode null zurück.  
  
-   Wenn der Code, in ausgeführt wird einem <xref:System.Transactions.Transaction> Kontext, wenn diese Eigenschaft löst eine Ausnahme aus.  
  
-   Wenn diese Eigenschaft festgelegt und eine neue <xref:System.Transactions.Transaction> wird geöffnet, eine Ausnahme wird ausgelöst, wenn eine Abfrage oder Aktualisierung ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.IDataReader" /> in Objekte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Zeile in der <xref:System.Data.IDataReader> konvertiert wird, auf ein Objekt in der <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Beschreibung: Diese Methode wird zum Konvertieren einer vorhandenen <xref:System.Data.Common.DbDataReader> auf Objekte. Jede Zeile in der <xref:System.Data.Common.DbDataReader> konvertiert wird, auf ein Objekt in der <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Generische Parameter:**  
  
 `T`: Finden Sie unter <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Parameter:**  
  
 `Query`: Zeigt die Beschreibung für den Befehl unter <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: Zeigt die Beschreibung für den Parameter unter <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **-Rückgabetyp:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: Auflistung von Objekten, die durch die Konvertierung zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Linq.IMultipleResults" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Liste von Objekten, die durch die Konvertierung zurückgegeben werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : Type * System.Data.Common.DbDataReader -&gt; System.Collections.IEnumerable" Usage="dataContext.Translate (elementType, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.  
  
Der Algorithmus für Vergleiche von Spalten im Ergebnis und Feldern und Eigenschaften im Objekt funktioniert folgendermaßen: 
Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
Der Vergleich wird ausgeführt, indem zuerst unter Beachtung der Groß-/Kleinschreibung nach einer Übereinstimmung gesucht wird. Wenn dabei keine Übereinstimmung gefunden wird, wird die Suche erneut ausgeführt, dieses Mal jedoch, ohne die Groß- und Kleinschreibung zu beachten.  
  
Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts zurückgeben (mit Ausnahme derer, die mit Verzögerung geladen werden), wenn alle nachfolgend aufgeführten Bedingungen erfüllt sind: 
 <c>T</c> stellt eine Entität dar, die explizit von <see cref="T:System.Data.Linq.DataContext" /> überwacht wird.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> ist <see langword="true" />.  
  
Die Entität weist einen Primärschlüssel auf.  
  
Andernfalls wird eine Ausnahme ausgelöst.</param>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Liste von Objekten, die durch die Konvertierung zurückgegeben werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; seq&lt;'Result&gt;" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.</typeparam>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Auflistung von der Konvertierung zurückgegebener Objekte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>