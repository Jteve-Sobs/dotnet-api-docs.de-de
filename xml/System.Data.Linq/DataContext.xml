<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="614bf8b628b9e044f43fb12a554abe74af90df70" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174261" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den Haupteinstiegspunkt für das LINQ to SQL-Framework dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext> ist die Quelle der alle Entitäten, die über eine datenbankverbindung zugeordnet. Verfolgt alle abgerufenen Entitäten vorgenommenen Änderungen und verwaltet einen "Identitäts-Cache", die garantiert, dass Entitäten mehr als einmal abgerufen durch dargestellt werden mit der gleichen Objektinstanz.  
  
 Im Allgemeinen eine <xref:System.Data.Linq.DataContext> Instanz ist so konzipiert, für eine "Arbeitseinheit" jedoch dieser Begriff in der Anwendung definierten Klassentyps. Ein <xref:System.Data.Linq.DataContext> Protokoll ist kompakt und ist nicht aufwendig zu erstellen. Eine typische [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Anwendung erstellt <xref:System.Data.Linq.DataContext> Instanzen Methodenbereich oder als Mitglied der kurzlebige Klassen, die eine logische Sammlung von darstellen in Beziehung Datenbankvorgänge.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse. Die Verbindungszeichenfolge, die Sie verwenden, kann eine ADO.NET-Verbindungszeichenfolge sein. Sie können auch einen Dateinamen für eine SQL Server Express- oder SQL Server Compact-Datei angeben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Die Verbindung, die von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse durch Verweisen auf die Verbindung, die von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.Linq.DataContext> öffnet und schließt eine datenbankverbindung nach Bedarf, wenn Sie eine getrennte Verbindung oder eine Verbindungszeichenfolge angeben. Im Allgemeinen sollte nie notwendig Aufrufen `Dispose` auf eine <xref:System.Data.Linq.DataContext>. Wenn Sie eine geöffnete Verbindung Bereitstellen der <xref:System.Data.Linq.DataContext> wird nicht geschlossen. Aus diesem Grund nicht instanziieren einer <xref:System.Data.Linq.DataContext> mit einer hergestellten Verbindung, wenn Sie einen guten Grund dazu haben. In einem <xref:System.Transactions> Transaktion eine <xref:System.Data.Linq.DataContext> nicht öffnen oder schließen Sie eine Verbindung zur Höherstufung zu vermeiden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Die Verbindung, die von .NET Framework verwendet wird.</param>
        <param name="mapping">Eine Quelle für die Zuordnung.</param>
        <summary>Initialisiert durch das Verweisen auf eine Verbindung und eine Zuordnungsquelle eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Bei diesem Argument kann es sich um eines der folgenden handeln: Der Name einer Datei, in der sich eine SQL Server Express-Datenbank befindet.  Der Name eines Servers, auf dem sich eine Datenbank befindet. In diesem Fall verwendet der Anbieter die Standarddatenbank für einen Benutzer.  Eine vollständige Verbindungszeichenfolge. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] hat die Zeichenfolge unverändert an den Anbieter übergeben.</param>
        <param name="mapping">Eine Quelle für die Zuordnung.</param>
        <summary>Initialisiert durch das Verweisen auf eine Dateiquelle und eine Zuordnungsquelle eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">To be added.</param>
        <param name="connectionString">To be added.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse durch Verweisen auf eine Dateiquelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Objekten ab, die beim Aufrufen von <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> Parallelitätskonflikte verursacht haben.</summary>
        <value>Eine Sammlung von Objekten, die Parallelitätskonflikte verursacht haben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das folgende Beispiel zeigt, wie die Auflistung durchlaufen werden kann, um Konfliktinformationen abzurufen.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt diesen fest, der den Timeoutwert für Abfragen erhöht, die andernfalls während der Standardtimeoutspanne zu einem Timeout führen würden.</summary>
        <value>Eine Ganzzahl, die den Timeoutwert für Abfragen erhöht, die andernfalls während der Standardtimeoutspanne zu einem Timeout führen würden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft ab oder legt das Befehlstimeout generierten Befehle ausführen (`IDbCommands`). Weitere Informationen finden Sie unter <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Wenn diese Eigenschaft nicht festgelegt ist, den Standardwert von <xref:System.Data.IDbCommand.CommandTimeout%2A> wird verwendet, für die Ausführung der Abfrage-Befehl. Dieser Standardwert wird vom Speicheranbieter festgelegt. Beachten Sie, dass einige Anbieter möglicherweise Ausnahmen ausgelöst, wenn dieser Wert auf einen Wert ungleich 0 (null) festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Framework verwendete Verbindung ab.</summary>
        <value>Die Verbindung, die vom Framework verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, mit relationalen ADO.NET-Code zusammenarbeiten.  
  
 Die zurückgegebene Verbindung wird geschlossen werden, es sei denn, sie explizit vom Benutzer geöffnet wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Datenbank auf dem Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name der Datenbank wird mithilfe des folgenden Algorithmus abgeleitet:  
  
1. Wenn eine Datenbank in der Verbindungszeichenfolge angegeben ist, wird dessen Name verwendet.  
1. Wenn eine <xref:System.Data.Linq.Mapping.DatabaseAttribute> Attribut vorhanden ist, dessen <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> Eigenschaft wird als Name der Datenbank verwendet.  
1. Es ist keine Datenbank-Tag in die Verbindungszeichenfolge und einen stark typisierten <xref:System.Data.Linq.DataContext> verwendet wird, eine Datenbank mit dem gleichen Namen wie die <xref:System.Data.Linq.DataContext> erbende Klasse erstellt wird.  
1. Wenn eine schwach typisierte <xref:System.Data.Linq.DataContext> wird verwendet, wird eine Ausnahme ausgelöst.  
1. Wenn die <xref:System.Data.Linq.DataContext> erstellt wurde mit einem Dateinamen, die dem Dateinamen entsprechende Datenbank erstellt wird.  
     
  
## Examples  
 Der folgende Code zeigt, wie eine temporäre Datenbank einrichten und anschließend wieder löschen.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Elemente in der zurückgegebenen Auflistung.</typeparam>
        <param name="instance">Die Instanz des Methodenaufrufs (das aktuelle Objekt).</param>
        <param name="methodInfo">Die <see cref="T:System.Reflection.MethodInfo" />, die die CLR-Methode identifiziert, die mit die einer Datenbankmethode entspricht.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt die der angegebenen CLR-Methode zugeordnete Tabellenwert-Datenbankfunktion aus.</summary>
        <returns>Von der Datenbankabfrage wurde eine Auflistung resultierender Werte zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> Methode wird in automatisch generiertem Code verwendet und fungiert als Proxy für Datenbankfunktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob die zugeordnete Datenbank geöffnet werden kann.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene Datenbank geöffnet werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Verbindung in der <xref:System.Data.Linq.DataContext.Connection%2A> Eigenschaft versucht wird, öffnen Sie die zugeordnete Datenbank.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Methode, um zu bestimmen, ob eine Datenbank bereits vorhanden.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob für 1:n- oder 1:1-Beziehungen ein verzögertes Laden stattfinden soll.</summary>
        <value>
          <see langword="true" />, wenn das verzögerte Laden aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn greift der Code eines dieser Beziehungen null wird zurückgegeben, wenn die Beziehung 1: 1 ist, und eine leere Auflistung zurückgegeben wird, wird jedoch 1: n. Die Beziehungen können weiterhin ausgefüllt werden, durch Festlegen der <xref:System.Data.Linq.DataContext.LoadOptions%2A> Eigenschaft.  
  
 Das Hauptszenario für diese Eigenschaft ist, können Sie einen Teil des Objektmodells zu extrahieren und gesendet wird (z. B. an einen Webdienst).  
  
> [!NOTE]
>  Wenn diese Eigenschaft, um festgelegt wird `false` nach dem Ausführen einer Abfrage wird eine Ausnahme ausgelöst. Finden Sie unter der **gültige Modi** weiter unten im Abschnitt Weitere Informationen.  
  
## <a name="valid-modes"></a>Gültige Modi  
 Verzögertes Laden erfordert Objekt nachverfolgen. Die folgenden drei Modi sind gültig:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> wird ignoriert, und davon ausgegangen `false`. Dieses Verhalten entspricht ein schreibgeschütztes <xref:System.Data.Linq.DataContext>.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Dies entspricht einer <xref:System.Data.Linq.DataContext> , mit dem Benutzer mithilfe ein Objektdiagramms laden <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> Direktiven, sondern ermöglicht keine verzögertes Laden.  
  
-   Beide werden festgelegt, um `true`. Dies ist die Standardeinstellung.  
  
 Die Flags darf nicht geändert werden, nachdem eine Abfrage ausgeführt wurde. Jede Änderung nach der Ausführung der ersten Abfrage, die mit <xref:System.Data.Linq.DataContext> löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die zugeordnete Datenbank.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Verbindung in der <xref:System.Data.Linq.DataContext.Connection%2A> Eigenschaft zum Identifizieren der Datenbank gelöscht werden soll.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Löschen einer Datenbank, die vorübergehend erstellt wurde.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Data.Linq.DataContext" />-Klasse verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressource frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Der auszuführende SQL-Befehl.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  NULL-Parameter werden in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Befehle direkt in der Datenbank aus.</summary>
        <returns>Die Anzahl der vom ausgeführten Befehl geänderten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein Pass-Through-Mechanismus für Fälle, in denen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] leistet keinen adäquat für ein bestimmtes Szenario.  
  
 Die Syntax des Befehls ist fast identisch mit der Syntax verwendet, um ein ADO.NET erstellen `DataCommand`. Der einzige Unterschied besteht darin, wie die Parameter angegeben werden. Insbesondere in geschweiften Klammern ({...}) Geben Sie Parameter und aufzulisten beginnend mit 0. Der Parameter ist der gleichermaßen nummerierten Objekt im Parameters-Array zugeordnet.  
  
 `ExecuteQuery` und `ExecuteCommand` ermöglichen es Ihnen, eine Variable Anzahl von Argumenten für Vorlagenparameter angeben. Beispielsweise können Sie die Parameter angeben, beim Aufrufen der ExecuteQuery\<TResult >:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Sowie ein weiteres Beispiel:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 Im folgenden Beispiel wird eine Verbindung öffnet und übergibt eine SQL `UPDATE` Befehl mit der SQL-Datenbankmodul.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die gelöscht werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Löschen ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Löschvorgänge an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die eingefügt werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Einfügen ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Einfügevorgänge neu an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie Folgendes ein:  
  
-   Die Methode einen geschützten-Modifizierer aufweist, Verwendungsmöglichkeiten Quellformat, sodass Unterklassen <xref:System.Data.Linq.DataContext>.  
  
-   Eine Ausnahme wird ausgelöst, wenn dieser Vorgang nicht in aufgerufen wird ein <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Vorgang. Sie dient nicht als eigenständigen Vorgang außerhalb des Bereichs der aufzurufenden ein <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Vorgang. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> selbst überschreiben Aufrufe Methoden, wenn sie implementiert werden und die vorherigen Methoden innerhalb der Überschreibungsmethoden aufgerufen werden sollen.  
  
-   Es obliegt dem Entwickler, die richtige Entität übergeben. Die Implementierung stellt sicher, dass die übergebene Entität nachverfolgt wird. Es ist jedoch in der Verantwortung des Entwicklers zum Beibehalten der Reihenfolge oder in der gleichen Entität zweimal übergeben.  
  
-   Es obliegt dem Entwickler, die richtige dynamische API aufzurufen. Beispielsweise ist in der `Update` -Überschreibungsmethode nur das <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> Methode kann aufgerufen werden. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] erkennt oder überprüft nicht, ob die aufgerufene dynamische Methode für den jeweiligen Vorgang gültig ist. Die Ergebnisse sind nicht definiert, wenn eine nicht anwendbare Methode aufgerufen wird (z. B. durch Aufruf von <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> für ein Objekt aktualisiert werden).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die aktualisiert werden soll.</param>
        <summary>Wird in Überschreibungsmethoden zum Aktualisieren ausgeführt, um das Generieren und Ausführen von dynamischem SQL für Aktualisierungsvorgänge an [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zu delegieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siehe <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz des Methodenaufrufs (das aktuelle Objekt).</param>
        <param name="methodInfo">Bezeichnet die einer Datenbankmethode entsprechende CLR-Methode.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt die der angegebenen CLR-Methode zugeordnete gespeicherte Datenbankprozedur oder Skalarfunktion aus.</summary>
        <returns>Das Ergebnis (Ausgabeparameter und Rückgabewert) der Ausführung der angegebenen Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> Methode wird in automatisch generiertem Code verwendet und fungiert als Proxy für Datenbankfunktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.  Der Algorithmus für den Abgleich von Spalten im Ergebnis der Abfrage mit Feldern oder Eigenschaften im Objekt funktioniert folgendermaßen:  Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet wird, wird dieser Spaltenname im Resultset erwartet.  Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  Der Vergleich wird ausgeführt, indem zuerst unter Beachtung der Groß-/Kleinschreibung nach einer Übereinstimmung gesucht wird. Wenn dabei keine Übereinstimmung gefunden wird, wird die Suche erneut ausgeführt, dieses Mal jedoch, ohne die Groß- und Kleinschreibung zu beachten.  Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts zurückgeben (mit Ausnahme derer, die mit Verzögerung geladen werden), wenn alle nachfolgend aufgeführten Bedingungen erfüllt sind: <c>T</c> ist eine Entität, die explizit von <see cref="T:System.Data.Linq.DataContext" /> nachverfolgt wird.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> ist <see langword="true" />.  Die Entität weist einen Primärschlüssel auf.  Andernfalls wird eine Ausnahme ausgelöst.</param>
        <param name="query">Die SQL-Abfrage, die ausgeführt werden soll.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  Wenn ein Parameter <see langword="null" /> ist, wird dieser in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Abfragen direkt in der Datenbank aus.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung von Objekten, die von der Abfrage zurückgegeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Elemente in der zurückgegebenen Auflistung.</typeparam>
        <param name="query">Die SQL-Abfrage, die ausgeführt werden soll.</param>
        <param name="parameters">Das Parameterarray, das an den Befehl übergeben werden soll. Beachten Sie folgendes Verhalten: Wenn die Anzahl der Objekte im Array geringer ist als die höchste in der Befehlszeichenfolge identifizierte Anzahl, wird eine Ausnahme ausgelöst.  Wenn das Array Objekte enthält, auf die in der Befehlszeichenfolge nicht verwiesen wird, wird keine Ausnahme ausgelöst.  NULL-Parameter werden in <see langword="DBNull.Value" /> konvertiert.</param>
        <summary>Führt SQL-Abfragen direkt in der Datenbank aus und gibt Objekte zurück.</summary>
        <returns>Eine Auflistung von der Abfrage zurückgegebener Objekte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein Pass-Through-Mechanismus für Fälle, in denen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] leistet keinen für ein bestimmtes Szenario.  
  
 Der Algorithmus für die übereinstimmenden Spalten im Resultset der Abfrage, die Felder und Eigenschaften im Objekt funktioniert wie folgt:  
  
-   Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet werden, wird der Spaltenname im Resultset erwartet.  
  
-   Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  
  
-   Der Vergleich wird ausgeführt, indem zuerst ein Groß-/ Kleinschreibung gesucht. Wenn keine Übereinstimmung gefunden wird, tritt eine nachfolgende Suche für Groß-/Kleinschreibung.  
  
-   Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts (außer diejenigen verzögertes Laden) zurückgeben. wenn alle folgenden Bedingungen zutreffen:  
  
    -   Wenn `<T>` ist eine Entität explizit vom überwacht die <xref:System.Data.Linq.DataContext>.  
  
    -   ObjectTrackingEnabled ist "true".  
  
    -   Die Entität weist einen Primärschlüssel auf.  
  
     Andernfalls wird eine Ausnahme ausgelöst.  
  
-   In allen anderen Fällen kann die Abfrage nur eine Teilmenge der überwachten Felder und Eigenschaften für das Objekt abgerufen.  
  
 Der folgende C#-Codeausschnitt zeigt eine Verwendung für diese Methode:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 In Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die geänderten Objekte ab, die von <see cref="T:System.Data.Linq.DataContext" /> nachverfolgt werden.</summary>
        <returns>Der Satz von Objekten wird in Form von drei schreibgeschützten Auflistungen zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie Folgendes ein:  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> Möglicherweise haben Nebeneffekte, wie mithilfe eines Rückschlusses INSERT- und delete-Operationen, die zum Zeitpunkt des üblicherweise ausgeführt werden <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Objekte, die in den folgenden Vorgängen verwendet werden können z. B. entsprechende abgeleitete Vorgänge in der folgenden Liste erstellen:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> um <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> null-Zuweisung (möglicherweise aufgrund der <xref:System.Data.Linq.EntitySet%601.Remove%2A> auf <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Die Gruppe kann entsprechend der foreign Key-Einschränkungen nicht sortiert werden.  
  
-   Datenbankgenerierte Werte (z. B. Primär- und Fremdschlüssel Schlüsselwerte, Zeitstempel usw.) sind nicht verfügbar. Solche Informationen erfordert die Ausführung von Datenbankbefehlen und vielleicht die Weitergabe von abgerufenen Informationen (z. B. Fremdschlüssel aus Primärschlüssel).  
  
-   Der Satz von geänderten Objekten wird zum Zeitpunkt des Aufrufs berechnet. Nachfolgende Aufrufe <xref:System.Data.Linq.DataContext.SubmitChanges%2A> kann einen anderen Satz erzeugen, wenn zusätzliche Änderungen vorgenommen werden.  
  
 Ausgabe, wenn keine Änderungen vorgenommen wurden, sieht wie folgt aus:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Die Abfrage, für die SQL-Befehlsinformationen abgerufen werden sollen.</param>
        <summary>Ruft Informationen über SQL-Befehle ab, die von [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] generiert wurden.</summary>
        <returns>Das angeforderte Befehlsinformationsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur über einen Getter und hat keinen Einfluss auf <xref:System.Data.Linq.DataContext> Zustand.  
  
 Beachten Sie Folgendes ein:  
  
-   Das Argument muss ungleich Null sein. Andernfalls wird eine null-Argument-Ausnahme ausgelöst.  
  
-   Standardabfragen Übersetzung Ausnahmen während der [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] abfrageausführung gelten für eine Abfrage, die übersetzt werden kann.  
  
-   Es wird nur der erste Abfragebefehl zurückgegeben. Insbesondere zusätzliche Befehle, die für die unverzüglichem Laden verwendet werden (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) sind nicht enthalten.  
  
-   <xref:System.Data.Linq.DataContext> Leistungsumfang der Benutzer mit dem Befehl nachverfolgt nicht. Z. B. die Ergebnisse der Ausführung des Befehls zurückgegeben werden nicht nachverfolgt und haben keinen Einfluss auf <xref:System.Data.Linq.DataContext> Zustand.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zurückzugebenden Objekte.</param>
        <summary>Gibt eine Auflistung von Objekten eines bestimmten Typs zurück; der Typ wird vom <paramref name="type" />-Parameter definiert.</summary>
        <returns>Eine Sammlung von Objekten, die vom <paramref name="type" />-Parameter definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine schwach typisierte Version des <xref:System.Data.Linq.DataContext.GetTable%2A>. Es ist wichtig, eine schwach typisierte Version aufweisen, da sie relativ üblich Abfragen dynamisch zu erstellen ist. Es wäre unpraktisch, die auf Reflektion verwenden, um die richtige generische Methode aufrufen zu erzwingen.  
  
 Wenn es keine Auflistung für einen bestimmten Typ ist, wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Der Typ der zurückzugebenden Objekte.</typeparam>
        <summary>Gibt eine Auflistung von Objekten eines bestimmten Typs zurück; der Typ wird vom <paramref name="TEntity" />-Parameter definiert.</summary>
        <returns>Eine Sammlung von Objekten, die vom <paramref name="TEntity" />-Parameter definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt für die Abfrage. Wenn ein stark typisiertes <xref:System.Data.Linq.DataContext> wird erstellte, neue generierte Eigenschaften kapseln Aufrufe dieser Methode. Z. B. eine `Customers` Eigenschaft wird generiert, die zurückgibt `GetTable<Customer>`.  
  
 Wenn es keine Auflistung für einen bestimmten Typ ist, wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Data.Linq.DataLoadOptions" /> ab, die diesem <see cref="T:System.Data.Linq.DataContext" /> zugeordnet sind, oder legt diese fest.</summary>
        <value>Die Optionen für das Laden verknüpfter Daten durch vorheriges Abrufen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft ab oder legt die Optionen, die zum Definieren von Prefetch-Verhalten für verzögert geladene Elemente und Mitgliedschaft verknüpften Sammlungen verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Ziel zum Schreiben der SQL-Abfrage oder des Befehls ab oder legt es fest.</summary>
        <value>Der <see cref="T:System.IO.TextReader" />, der zum Schreiben des Befehls verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `null` Befehl Protokollierung zu deaktivieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die generierte SQL im Konsolenfenster angezeigt, bevor sie die Ergebnisse der Abfrage anzeigt.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Data.Linq.Mapping.MetaModel" /> ab, auf dem die Zuordnung basiert.</summary>
        <value>Die Zuordnung zwischen einer Datenbank und Domänenobjekten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Objektnachverfolgung aktiviert ist, oder legt den Wert fest.</summary>
        <value>
          <see langword="true" />, wenn die Objektverfolgung aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `false` verbessert die Leistung zum Zeitpunkt der Abruf, da es weniger Elemente zum Nachverfolgen gibt.  
  
 Eine Ausnahme ausgelöst:  
  
-   Wenn die Eigenschaft, um festgelegt wird `false` nach dem Ausführen einer Abfrage.  
  
     Weitere Informationen finden Sie im Abschnitt gültige Modi in <xref:System.Data.Linq.DataContext>.  
  
-   Wenn die Eigenschaft, um festgelegt wird `false` und <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird.  
  
 Wenn <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> ist `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> wird ignoriert und als behandelt `false`. In diesem Fall die <xref:System.Data.Linq.DataContext> ist schreibgeschützt.  
  
 Falls <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>`true` lautet, ist <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>`false`. In diesem Fall <xref:System.Data.Linq.DataContext> können Sie mithilfe ein Objektdiagramms laden <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> Direktiven, aber ermöglicht verzögertes Laden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Objektstatus anhand von Daten in der Datenbank.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode eignet sich nach einem Fehler durch vollständige Parallelität, um Elemente in einem Zustand für ein weiterer Versuch einzubinden. Es wird der Status der primitive Felder und Eigenschaften für die Objekte aktualisiert.  
  
> [!NOTE]
>  Wenn ein Objekt auf die *viele* Seite einer 1: n-Beziehung, der Fremdschlüssel für das Objekt festgelegt und der Objektzeiger für die andere Seite der Beziehung wird auf den neuen Wert festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entities">Die Auflistung von Entitäten, die aktualisiert werden soll.</param>
        <summary>Aktualisiert eine Auflistung von Entitätsobjekten anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entity">Das zu aktualisierende Objekt.</param>
        <summary>Aktualisiert ein Entitätsobjekt anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Ein Wert, der angibt, wie Konflikte bezüglich vollständiger Parallelität behandelt werden.</param>
        <param name="entities">Das Array von Entitätsobjekten, das aktualisiert werden soll.</param>
        <summary>Aktualisiert ein Array von Entitätsobjekten anhand des angegebenen Modus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die geänderten Objekte, die eingefügt, aktualisiert oder gelöscht werden sollen, und führt die entsprechenden Befehle zur Implementierung der Änderungen für die Datenbank aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Methoden zum Überschreiben für INSERT-, Update- oder Delete, vorhanden sind <xref:System.Data.Linq.DataContext.SubmitChanges%2A> führt diese Methoden anstelle der standardmäßigen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Befehle.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Startet eine Transaktion und Rollback wird, wenn eine Ausnahme tritt auf, während <xref:System.Data.Linq.DataContext.SubmitChanges%2A> ausgeführt wird. Allerdings Dies führt kein Rollback der Änderungen im Arbeitsspeicher oder von verfolgt die <xref:System.Data.Linq.DataContext>; diese Änderungen manuell zurückgesetzt werden müssen. Können Sie mit der eine neue Instanz starten der <xref:System.Data.Linq.DataContext> bei der Änderungen im Arbeitsspeicher verworfen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Berechnet die geänderten Objekte, die eingefügt, aktualisiert oder gelöscht werden sollen, und führt die entsprechenden Befehle zur Implementierung der Änderungen für die Datenbank aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Methoden zum Überschreiben für INSERT-, Update- oder Delete, vorhanden sind <xref:System.Data.Linq.DataContext.SubmitChanges%2A> führt diese Methoden anstelle der standardmäßigen [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Befehle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Die Aktion, die bei einem Fehler ausgeführt werden soll. Gültige Argumente sind:  <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Sendet Änderungen an abgerufenen Objekten an die zugrunde liegende Datenbank und gibt die Aktion an, die bei einem Fehler ausgeführt werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardfehlermodus ist <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine lokale Transaktion für [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], die für den Zugriff auf die Datenbank verwendet wird, oder legt diese fest.</summary>
        <value>Das vom <see cref="T:System.Data.Linq.DataContext" /> beim Ausführen von Abfragen und Befehlen verwendete Transaktionsobjekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Hauptszenario für diese Eigenschaft ist die Interoperabilität mit relationalen [!INCLUDE[vstecado](~/includes/vstecado-md.md)] Code. Verwenden Sie diese Eigenschaft beispielsweise, wenn Sie ein eigenes schreiben `Create` / `Update` / `Delete` Methoden zum Festlegen der `Transaction` -Eigenschaft für das ADO `Command` Objekt.  
  
 Beachten Sie Folgendes:  
  
-   Wenn diese Eigenschaft nicht explizit festgelegt wurde, gibt der Getter für eine null zurück.  
  
-   Wenn der Code, in ausgeführt wird einem <xref:System.Transactions.Transaction> Kontext, wenn diese Eigenschaft löst eine Ausnahme aus.  
  
-   Wenn diese Eigenschaft festgelegt und eine neue <xref:System.Transactions.Transaction> wird geöffnet, eine Ausnahme wird ausgelöst, wenn eine Abfrage oder Aktualisierung ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.IDataReader" /> in Objekte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Zeile in der <xref:System.Data.IDataReader> konvertiert ein Objekt in der <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Beschreibung: Diese Methode wird verwendet, um das Konvertieren einer vorhandenen <xref:System.Data.Common.DbDataReader> auf Objekte. Jede Zeile in der <xref:System.Data.Common.DbDataReader> konvertiert ein Objekt in der <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Generische Parameter:**  
  
 `T`: Finden Sie unter <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Parameter:**  
  
 `Query`: Finden Sie in der Beschreibung für den Befehl unter <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: Finden Sie in der Beschreibung von Parametern unter <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **Rückgabetyp:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: Auflistung von Objekten, die durch die Konvertierung zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Liste von Objekten, die durch die Konvertierung zurückgegeben werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.  Der Algorithmus für den Abgleich von Spalten im Ergebnis mit Feldern und Eigenschaften im Objekt funktioniert folgendermaßen: Wenn ein Feld oder eine Eigenschaft einem bestimmten Spaltennamen zugeordnet wird, wird dieser Spaltenname im Resultset erwartet.  Wenn ein Feld oder eine Eigenschaft nicht zugeordnet werden, wird im Resultset eine Spalte mit dem gleichen Namen wie das Feld oder die Eigenschaft erwartet.  Der Vergleich wird ausgeführt, indem zuerst unter Beachtung der Groß-/Kleinschreibung nach einer Übereinstimmung gesucht wird. Wenn dabei keine Übereinstimmung gefunden wird, wird die Suche erneut ausgeführt, dieses Mal jedoch, ohne die Groß- und Kleinschreibung zu beachten.  Die Abfrage muss alle überwachten Felder und Eigenschaften des Objekts zurückgeben (mit Ausnahme derer, die mit Verzögerung geladen werden), wenn alle nachfolgend aufgeführten Bedingungen erfüllt sind: <c>T</c> ist eine Entität, die explizit von <see cref="T:System.Data.Linq.DataContext" /> nachverfolgt wird.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> ist <see langword="true" />.  Die Entität weist einen Primärschlüssel auf.  Andernfalls wird eine Ausnahme ausgelöst.</param>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Liste von Objekten, die durch die Konvertierung zurückgegeben werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der <see cref="T:System.Collections.Generic.IEnumerable`1" />-Typ für die Rückgabe.</typeparam>
        <param name="reader">Der zu konvertierende <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Konvertiert einen vorhandenen <see cref="T:System.Data.Common.DbDataReader" /> in Objekte.</summary>
        <returns>Eine Auflistung von der Konvertierung zurückgegebener Objekte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>