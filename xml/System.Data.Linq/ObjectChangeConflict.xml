<Type Name="ObjectChangeConflict" FullName="System.Data.Linq.ObjectChangeConflict">
  <Metadata><Meta Name="ms.openlocfilehash" Value="edd987391fd5eefaae292c1620741c3020cea5f0" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="78953802" /></Metadata><TypeSignature Language="C#" Value="public sealed class ObjectChangeConflict" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ObjectChangeConflict extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.ObjectChangeConflict" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ObjectChangeConflict" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectChangeConflict sealed" />
  <TypeSignature Language="F#" Value="type ObjectChangeConflict = class" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Updateversuch mit mindestens einem Konflikt bezüglich vollständiger Parallelität dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Szenario schlägt ein Aktualisierungs Versuch fehl, da die Daten Bank Werte seit dem letzten Lesen des Clients aktualisiert wurden.  
  
 Im folgenden Beispiel wird gezeigt, wie Informationen zu Objekten in Konflikt abgerufen werden.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsDeleted">
      <MemberSignature Language="C#" Value="public bool IsDeleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDeleted" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.ObjectChangeConflict.IsDeleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDeleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDeleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDeleted : bool" Usage="System.Data.Linq.ObjectChangeConflict.IsDeleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Objekt, das von einem Konflikt betroffen ist, aus der Datenbank gelöscht wurde.</summary>
        <value><see langword="True" />, wenn das Objekt gelöscht wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsResolved">
      <MemberSignature Language="C#" Value="public bool IsResolved { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsResolved" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.ObjectChangeConflict.IsResolved" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsResolved As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsResolved { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsResolved : bool" Usage="System.Data.Linq.ObjectChangeConflict.IsResolved" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Konflikte für dieses Objekt bereits gelöst wurden.</summary>
        <value><see langword="True" />, wenn die Konflikte gelöst wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist schreibgeschützt und wird automatisch aktualisiert, wenn Konflikte aufgelöst werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemberConflicts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Data.Linq.MemberChangeConflict&gt; MemberConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Data.Linq.MemberChangeConflict&gt; MemberConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.ObjectChangeConflict.MemberConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MemberConflicts As ReadOnlyCollection(Of MemberChangeConflict)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Data::Linq::MemberChangeConflict ^&gt; ^ MemberConflicts { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Data::Linq::MemberChangeConflict ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberConflicts : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Data.Linq.MemberChangeConflict&gt;" Usage="System.Data.Linq.ObjectChangeConflict.MemberConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Data.Linq.MemberChangeConflict&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung aller Memberkonflikte ab, aufgrund derer das Update nicht ordnungsgemäß durchgeführt werden konnte.</summary>
        <value>Eine Auflistung von Memberkonflikten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Object">
      <MemberSignature Language="C#" Value="public object Object { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Object" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.ObjectChangeConflict.Object" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Object As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Object { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Object : obj" Usage="System.Data.Linq.ObjectChangeConflict.Object" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das von einem Konflikt betroffen ist.</summary>
        <value>Das Objekt, das von einem Konflikt betroffen ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resolve">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst Memberkonflikte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public void Resolve ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resolve() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.ObjectChangeConflict.Resolve" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resolve ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resolve();" />
      <MemberSignature Language="F#" Value="member this.Resolve : unit -&gt; unit" Usage="objectChangeConflict.Resolve " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst Memberkonflikte durch Beibehalten aktueller Werte und Zurücksetzen der ursprünglichen Werte der Baseline zur Übereinstimmung mit den aktuelleren Datenbankwerten.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public void Resolve (System.Data.Linq.RefreshMode refreshMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resolve(valuetype System.Data.Linq.RefreshMode refreshMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.ObjectChangeConflict.Resolve(System.Data.Linq.RefreshMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resolve (refreshMode As RefreshMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resolve(System::Data::Linq::RefreshMode refreshMode);" />
      <MemberSignature Language="F#" Value="member this.Resolve : System.Data.Linq.RefreshMode -&gt; unit" Usage="objectChangeConflict.Resolve refreshMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Linq.RefreshMode" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Die entsprechende Option von <see cref="T:System.Data.Linq.RefreshMode" />.</param>
        <summary>Löst Memberkonflikte mit dem angegebenen <see cref="T:System.Data.Linq.RefreshMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den folgenden Beispielen wird gezeigt, welche Ergebnisse erzeugt werden, indem die verschiedenen Werte für <xref:System.Data.Linq.RefreshMode>verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die aktuellen Werte mit Werten aus der Datenbank überschrieben.  
  
 [!code-csharp[System.Data.Linq.RefreshMode#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.refreshmode/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.RefreshMode#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.refreshmode/vb/module1.vb#1)]  
  
 Im folgenden Beispiel wird gezeigt, wie Sie den ursprünglichen Wert mit den Werten austauschen können, die aus der Datenbank abgerufen wurden. Die aktuellen Werte werden nicht geändert.  
  
 [!code-csharp[System.Data.Linq.RefreshMode#2](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.refreshmode/cs/program.cs#2)]
 [!code-vb[System.Data.Linq.RefreshMode#2](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.refreshmode/vb/module1.vb#2)]  
  
 Im folgenden Beispiel werden die aktuellen Werte aufbewahrt, die geändert wurden, aber die anderen Werte werden mit Daten bankwerten aktualisiert.  
  
 [!code-csharp[System.Data.Linq.RefreshMode#3](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.refreshmode/cs/program.cs#3)]
 [!code-vb[System.Data.Linq.RefreshMode#3](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.refreshmode/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public void Resolve (System.Data.Linq.RefreshMode refreshMode, bool autoResolveDeletes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resolve(valuetype System.Data.Linq.RefreshMode refreshMode, bool autoResolveDeletes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.ObjectChangeConflict.Resolve(System.Data.Linq.RefreshMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resolve (refreshMode As RefreshMode, autoResolveDeletes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resolve(System::Data::Linq::RefreshMode refreshMode, bool autoResolveDeletes);" />
      <MemberSignature Language="F#" Value="member this.Resolve : System.Data.Linq.RefreshMode * bool -&gt; unit" Usage="objectChangeConflict.Resolve (refreshMode, autoResolveDeletes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="autoResolveDeletes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Die entsprechende Option von <see cref="T:System.Data.Linq.RefreshMode" />.</param>
        <param name="autoResolveDeletes"><see langword="true" />, wenn Konflikte aufgrund von geänderten Objekten, die aus der Datenbank entfernt wurden, automatisch gelöst werden.</param>
        <summary>Löst Memberkonflikte durch Beibehalten aktueller Werte und Zurücksetzen der ursprünglichen Werte der Baseline.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
