<Type Name="Table&lt;TEntity&gt;" FullName="System.Data.Linq.Table&lt;TEntity&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8f2e2c57717f41b8415d2d08b9d484756b3b8509" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30390584" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Table&lt;TEntity&gt; : System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource, System.Data.Linq.ITable, System.Linq.IQueryable&lt;TEntity&gt;, System.Linq.IQueryProvider where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Table`1&lt;class TEntity&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource, class System.Data.Linq.ITable, class System.Linq.IQueryable, class System.Linq.IQueryable`1&lt;!TEntity&gt;, class System.Linq.IQueryProvider" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.Table`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Table(Of TEntity)&#xA;Implements IEnumerable(Of TEntity), IListSource, IQueryable(Of TEntity), IQueryProvider, ITable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class Table sealed : System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource, System::Data::Linq::ITable, System::Linq::IQueryable&lt;TEntity&gt;, System::Linq::IQueryProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Data.Linq.ITable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TEntity">Der Typ der Daten in der Tabelle.</typeparam>
    <summary>Stellt eine Tabelle für einen bestimmten Typ in der zugrunde liegenden Datenbank dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse ermöglicht das Ausführen von Abfragen mit der Tabelle hinzufügen, entfernen und Objekte anzufügen.  
  
 Eine Anwendung zugreifen kann eine <xref:System.Data.Linq.Table%601> -Instanz über <xref:System.Data.Linq.DataContext.GetTable%2A> oder indem Sie eine stark typisierte Eigenschaft für den stark typisierten <xref:System.Data.Linq.DataContext>. Wenn der Designer ein DataContext-Objekt generiert, generiert es also Eigenschaften, um die Darstellung der einzelnen Tabellen. Zum Beispiel:  
  
```  
[global::System.Data.Linq.Mapping.DatabaseAttribute(Name="SignOffTool")]  
public partial class DataClasses1DataContext : System.Data.Linq.DataContext {  
   public System.Data.Linq.Table<User> Users {  
      get {  
         return this.GetTable<User>();  
      }  
   }  
}  
```  
  
 Für diesen stark typisierten DataContext erreichen Sie die abzurufende Eigenschaft Benutzer `Table<User>`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt eine Entität an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `Attach` Methoden mit Entitäten, die in einem erstellt wurden <xref:System.Data.Linq.DataContext>in einem Client serialisiert und deserialisiert dann zurück (mit der Absicht an, führen Sie ein Update oder Löschvorgang). Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Sie sollten nicht versuchen, `Attach` eine Entität, die nicht über die Serialisierung getrennt wurde. Entitäten, die nicht serialisiert wurden verwalten weiterhin Zuordnungen mit verzögerten ladenprogrammen, die unerwartete Ergebnisse verursachen können, wenn die Entität von einem zweiten Datenkontext nachverfolgt wird.  
  
 Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
 `Attach` Fügt alle Entitäten im Objektdiagramm des angegebenen Objekts. Um beispielsweise den folgenden C#-Code:  
  
```  
using (SampleDataContext db = new SampleDataContext()) {  
    Employee employee = new Employee { employeeId = 1 };  
  
    Master master = new Master();  
    master.Employee = employee;  
  
    Child child = new Child();  
    child.Employee = employee;  
  
    db.Employees.Attach(employee);  
  
    master.Child = child;  
  
    db.Masters.InsertOnSubmit(master);  
  
    db.SubmitChanges();  
}  
  
```  
  
 Wird von der entsprechende Visual Basic-Code:  
  
```  
Using db As New SampleDataContext()    Dim employee As New Employee With { .employeeId = 1 }  
  
    Dim master As New Master()  
    master.Employee = employee  
  
    Dim child As New Child()  
    child.Employee = employee  
  
    db.Employees.Attach(employee)  
  
    master.Child = child  
  
    db.Masters.InsertOnSubmit(master)  
  
    db.SubmitChanges()  
  
End Using  
```  
  
 Aufrufen von `Attach` auf `Employee` fügt Mitarbeiter Master und untergeordnetes Element, da die `Employee` hat Beziehungen zu Master und untergeordneten. Sie müssen explizit aufrufen, `InsertOnSubmit` zur Änderung des Zustands von angefügt zu eingefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Die ursprünglichen Werte der Entität, die angefügt werden soll.</param>
        <summary>Fügt eine getrennte Entität einem neuen <see cref="T:System.Data.Linq.DataContext" /> an, wenn ursprüngliche Werte für Prüfungen der vollständigen Parallelität benötigt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `Attach` Methoden mit Entitäten, die in einem erstellt wurden <xref:System.Data.Linq.DataContext>in einem Client serialisiert und deserialisiert dann zurück, um eine Aktualisierung auszuführen oder Löschvorgang. Da die neue <xref:System.Data.Linq.DataContext> hat keine Möglichkeit, der durch das Nachverfolgen, was die ursprünglichen Werte für eine Entität getrennt wurde, der Client ist dafür verantwortlich, diese Werte bereitstellen. In dieser Version von <xref:System.Data.Linq.Table%601.Attach%2A>, wird davon ausgegangen, dass die Entität in den ursprünglichen Wert Zustand befinden. Nach dem Aufrufen dieser Methode können Sie dann ihre Felder, z. B. mit zusätzlichen Daten, die vom Client gesendete aktualisieren.  
  
 Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
 Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Sie sollten nicht versuchen, `Attach` eine Entität, die nicht über die Serialisierung getrennt wurde. Entitäten, die nicht serialisiert wurden verwalten weiterhin Zuordnungen mit verzögerten ladenprogrammen, die unerwartete Ergebnisse verursachen können, wenn die Entität von einem zweiten Datenkontext nachverfolgt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity, bool asModified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.Attach(`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity, asModified As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity, bool asModified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die angefügt werden soll.</param>
        <param name="asModified">
          <see langword="true" />, um die Entität als geändert anzufügen; <see langword="false" />, um die Entität als nicht geändert anzufügen.</param>
        <summary>Fügt eine Entität im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Anfügen *veränderten*, die Entität muss entweder Mitglied Version deklarieren oder müssen nicht in Konflikt updateüberprüfung einbezogen. Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity, TEntity original);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity, !TEntity original) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.Attach(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity, original As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity, TEntity original);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="original" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die angefügt werden soll.</param>
        <param name="original">Eine Instanz des gleichen Entitätstyps mit Datenmembern, die die ursprünglichen Werte enthalten.</param>
        <summary>Fügt eine Entität im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an, indem sowohl die Entität als auch ihr ursprünglicher Zustand angegeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden Beispiel die `Customer` -Objekt bereits ordnungsgemäß konfiguriert ist. Sie können Aufrufen `Attach` ohne die Updates wiedergeben.  
  
 Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
   
  
## Examples  
 [!code-csharp[DLinqNTier#4](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#4)]
 [!code-vb[DLinqNTier#4](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AttachAll&lt;TSubEntity&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn anfügen geändert wurde, wird die Entität muss entweder Mitglied Version deklarieren oder muss nicht in Konflikt updateüberprüfung einbezogen.  
  
 Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
 Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AttachAll&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void AttachAll&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachAll&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.AttachAll``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachAll(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void AttachAll(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Der Typ der anzufügenden Entitäten.</typeparam>
        <param name="entities">Die Auflistung von Entitäten.</param>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt alle Entitäten einer Auflistung in ein neues <xref:System.Data.Linq.DataContext>. Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
 Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachAll&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void AttachAll&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities, bool asModified) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachAll&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.AttachAll``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachAll(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity), asModified As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void AttachAll(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities, bool asModified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Der Typ der anzufügenden Entitäten.</typeparam>
        <param name="entities">Die Auflistung von Entitäten.</param>
        <param name="asModified">
          <see langword="true" />, wenn das Objekt über einen timestamp-Member oder RowVersion-Member verfügt, <see langword="false" />, wenn ursprüngliche Werte für die Prüfung auf vollständige Parallelität verwendet werden sollen.</param>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt alle Entitäten einer Auflistung an der <xref:System.Data.Linq.DataContext> entweder in einer *geändert* oder *unveränderte* Zustand. Wenn anfügen geändert wurde, wird die Entität muss entweder Mitglied Version deklarieren oder muss nicht in Konflikt updateüberprüfung einbezogen. Wenn als unverändert angefügt wurde, wird davon ausgegangen, dass die Entität den ursprünglichen Wert darstellen. Nach dem Aufrufen dieser Methode können die Felder der Entität mit anderen Informationen aus dem Client vor geändert werden <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird. Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Wenn eine neue Entität angehängt wird, verzögerte Ladeprogramme für alle untergeordneten Sammlungen (z. B. `EntitySet` Auflistungen von Entitäten aus verknüpften Tabellen) initialisiert werden. Wenn <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird, werden Mitglieder von untergeordneten Sammlungen abgelegt sind ein `Unmodified` Zustand. Sie müssen explizit aufrufen, um Mitglied einer untergeordneten Sammlung zu aktualisieren, `Attach` und diese Entität angeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie aktualisieren einen `Order` auf einem anderen Objekt <xref:System.Data.Linq.DataContext> Instanz. Im Beispiel wird davon ausgegangen, dass Sie eine Verbindung mit einer Datenbank besteht und eine [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Datei dafür (in diesem Fall wird der Northwind-Beispieldatenbank).  
  
 [!code-csharp[DLinqNTier#1](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#1)]
 [!code-vb[DLinqNTier#1](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#1)]  
  
 Im folgenden Beispiel ein Entitätsobjekt angefügt werden verfügt über eine foreign Key-Beziehung mit einem anderen Objekt und im Cache gespeichert, aber nicht angefügt. Beim Aufruf <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, `ChangeProcessor` Fügt eine `Insert` Vorgang für die foreign Key-Objekte. Dies ist ein Nebeneffekt, wenn eine Entitätsinstanz erneut verwendet ein anderes ist <xref:System.Data.Linq.DataContext> Instanz. Aus diesem Grund [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] erneute Verwendung von Objekten nicht unterstützt.  
  
 [!code-csharp[DlinqNTier#7](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#7)]
 [!code-vb[DlinqNTier#7](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#7)]  
  
 Das folgende Beispiel zeigt ein Szenario, in der Kunde A verfügt über alle Aufträge abgebrochen, und Kunden B hat den Besitz von ihnen übernommen. Sie können alle Aufträge des Kunden ein gleichzeitig anfügen.  
  
 [!code-csharp[DlinqNTier#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#3)]
 [!code-vb[DlinqNTier#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.Context" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Context As DataContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataContext ^ Context { System::Data::Linq::DataContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Data.Linq.DataContext" /> ab, der zum Abrufen der <see cref="T:System.Data.Linq.Table`1" /> verwendet wurde.</summary>
        <value>Der Datenkontext, der verwendet wurde, um diese Tabelle abzurufen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteAllOnSubmit&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void DeleteAllOnSubmit&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteAllOnSubmit&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.DeleteAllOnSubmit``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteAllOnSubmit(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void DeleteAllOnSubmit(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Der Typ der zu löschenden Elemente.</typeparam>
        <param name="entities">Die zu löschenden Entitäten.</param>
        <summary>Ändert den Zustand aller Entitäten in der Auflistung in <see langword="pending delete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschwinden die Entitäten, die mit dieser Methode in der ausstehenden abgelegt werden nicht aus den Abfrageergebnissen, bis <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird. Getrennte Entitäten müssen angefügt werden, bevor sie gelöscht werden können. Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Der folgende C#-Codeausschnitt zeigt eine Verwendung für diese Methode:  
  
```  
IEnumerable<Customer> customersWithoutOrders = (from c in db.Customers  
   where c.Orders.Count == 0  
   select c).ToList();  
  
db.Customers.DeleteAllOnSubmit(customersWithoutOrders);  
db.SubmitChanges();  
```  
  
 In Visual Basic:  
  
```  
Dim customersWithoutOrders As IEnumerable(Of Customer) = (From c In db.Customers _   
    Where c.Orders.Count = 0 _   
    Select c).ToList()  
  
db.Customers.DeleteAllOnSubmit(customersWithoutOrders)  
db.SubmitChanges()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteOnSubmit">
      <MemberSignature Language="C#" Value="public void DeleteOnSubmit (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteOnSubmit(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.DeleteOnSubmit(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteOnSubmit (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteOnSubmit(TEntity entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die gelöscht werden soll.</param>
        <summary>Ändert den Zustand einer Entität aus dieser Tabelle in <see langword="pending delete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entfernte Entität nicht aus den Abfrageergebnissen erst nach dem ausgeblendet <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wird. Getrennte Entitäten müssen zuerst angefügt werden, bevor sie gelöscht werden können. Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
> [!NOTE]
>  Kaskadierte Löschvorgänge werden von [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nicht unterstützt bzw. erkannt. Wenn eine Zeile in einer Tabelle zu löschen, die Einschränkungen gelten sollen, müssen Sie entweder die `ON DELETE CASCADE` -Regel in der foreign Key-Einschränkung in der Datenbank, oder verwenden Sie eigenen Code zunächst die untergeordneten Objekte löschen, die verhindern, dass das übergeordnete Objekt gelöscht werden. Andernfalls wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.Table#3](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.table/cs/program.cs#3)]
 [!code-vb[System.Data.Linq.Table#3](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.table/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator ab, der die Auflistung durchläuft.</summary>
        <returns>Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModifiedMembers">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ModifiedMemberInfo[] GetModifiedMembers (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.Linq.ModifiedMemberInfo[] GetModifiedMembers(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetModifiedMembers(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModifiedMembers (entity As TEntity) As ModifiedMemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::Linq::ModifiedMemberInfo&gt; ^ GetModifiedMembers(TEntity entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ModifiedMemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, aus der das Array abgerufen werden soll.</param>
        <summary>Gibt ein Array von geänderten Membern mit den aktuellen und den ursprünglichen Werten zurück.</summary>
        <returns>Ein Array von geänderten Membern mit den aktuellen und den ursprünglichen Werten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNewBindingList">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IBindingList GetNewBindingList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.IBindingList GetNewBindingList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetNewBindingList" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNewBindingList () As IBindingList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::IBindingList ^ GetNewBindingList();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IBindingList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Liste zum Binden an eine Datenquelle.</summary>
        <returns>Eine neue <see cref="T:System.ComponentModel.IBindingList" /> zum Binden an eine Datenquelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Liste unterstützt Standardvorgänge wie Hinzufügungen, löschungen, einfügungen und Updates, aber speichert müssen explizit vom Programmierer verwaltet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOriginalEntityState">
      <MemberSignature Language="C#" Value="public TEntity GetOriginalEntityState (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TEntity GetOriginalEntityState(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetOriginalEntityState(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOriginalEntityState (entity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TEntity GetOriginalEntityState(TEntity entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, deren ursprünglicher Zustand zurückgegeben werden soll.</param>
        <summary>Gibt eine <see cref="T:System.Data.Linq.Table`1" />-Instanz zurück, die den ursprünglichen Zustand der Entität enthält.</summary>
        <returns>Eine <see cref="T:System.Data.Linq.Table`1" />-Instanz, die den ursprünglichen Zustand der Entität enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den ursprünglichen Zustand der Entität zurück, da entweder erstellt oder mit dem aktuellen angefügt wurde <xref:System.Data.Linq.DataContext>. Muss der originalen Zustand einer Entität, die serialisiert und deserialisiert wurde von einem unabhängigen Nachverfolgungsmechanismus bereitgestellt und angegeben wird, wenn die Entität an einen neuen angefügt ist <xref:System.Data.Linq.DataContext>. Weitere Informationen finden Sie unter [Datenabruf und CUD-Operationen in N-Tier-Anwendungen (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAllOnSubmit&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void InsertAllOnSubmit&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAllOnSubmit&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.InsertAllOnSubmit``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertAllOnSubmit(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void InsertAllOnSubmit(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Der Typ der einzufügenden Elemente.</typeparam>
        <param name="entities">Die Entitäten, die hinzugefügt werden sollen.</param>
        <summary>Fügt dem <see cref="T:System.Data.Linq.DataContext" /> alle Entitäten einer Auflistung im Zustand <see langword="pending insert" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die hinzugefügten Entitäten werden nicht in den Abfrageergebnissen erst nach dem <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertOnSubmit">
      <MemberSignature Language="C#" Value="public void InsertOnSubmit (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertOnSubmit(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.InsertOnSubmit(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertOnSubmit (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertOnSubmit(TEntity entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die hinzugefügt werden soll.</param>
        <summary>Fügt dieser <see cref="T:System.Data.Linq.Table`1" /> eine Entität mit dem Status <see langword="pending insert" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die hinzugefügte Entität wird nicht in den Abfrageergebnissen angezeigt, aus dieser Tabelle erst nach <xref:System.Data.Linq.DataContext.SubmitChanges%2A> aufgerufen wurde.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.Table#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.table/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.Table#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.table/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.Linq.ITable.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der in dieser <see cref="T:System.Data.Linq.Table`1" />-Instanz enthaltene Entitätstyp über einen Primärschlüssel verfügt.</summary>
        <value>
          <see langword="true" />, wenn der Entitätstyp nicht über einen Primärschlüssel verfügt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;TEntity&gt; IEnumerable&lt;TEntity&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Collections#Generic#IEnumerable&lt;TEntity&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of TEntity) Implements IEnumerable(Of TEntity).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;TEntity&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
        <returns>Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
        <returns>Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung eine Auflistung von <see cref="T:System.Collections.IList" />-Objekten ist.</summary>
        <value>
          <see langword="true" />, wenn die Auflistung eine Auflistung von <see cref="T:System.Collections.IList" />-Objekten ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Collections.IList" /> zurück, die an eine Datenquelle eines Objekts gebunden werden kann, das selbst keine <see cref="T:System.Collections.IList" /> implementiert.</summary>
        <returns>Eine <see cref="T:System.Collections.IList" />, die an eine Datenquelle gebunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="System.Data.Linq.ITable.Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hiermit können deserialisierte Entitäten einer neuen Instanz eines <see cref="T:System.Data.Linq.DataContext" /> zugeordnet werden, damit sie in der Datenbank aktualisiert oder gelöscht werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="System.Data.Linq.ITable.Attach">
      <MemberSignature Language="C#" Value="void ITable.Attach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.Attach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#Attach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Attach (entity As Object) Implements ITable.Attach" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.Attach(System::Object ^ entity) = System::Data::Linq::ITable::Attach;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.Attach(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die angefügt werden soll.</param>
        <summary>Fügt dem <see cref="T:System.Data.Linq.DataContext" /> eine unveränderte Entität hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.Attach">
      <MemberSignature Language="C#" Value="void ITable.Attach (object entity, bool asModified);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.Attach(object entity, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#Attach(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub Attach (entity As Object, asModified As Boolean) Implements ITable.Attach" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.Attach(System::Object ^ entity, bool asModified) = System::Data::Linq::ITable::Attach;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.Attach(System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die angefügt werden soll.</param>
        <param name="asModified">
          <see langword="true" />, um die Entität als geändert anzufügen; <see langword="false" />, um die Entität als nicht geändert anzufügen.</param>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.Attach">
      <MemberSignature Language="C#" Value="void ITable.Attach (object entity, object original);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.Attach(object entity, object original) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#Attach(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Attach (entity As Object, original As Object) Implements ITable.Attach" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.Attach(System::Object ^ entity, System::Object ^ original) = System::Data::Linq::ITable::Attach;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.Attach(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="original" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die angefügt werden soll.</param>
        <param name="original">Eine Instanz des gleichen Entitätstyps mit Datenmembern, die die ursprünglichen Werte enthalten.</param>
        <summary>Fügt eine Entität im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an, indem sowohl die Entität als auch ihr ursprünglicher Zustand angegeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="System.Data.Linq.ITable.AttachAll">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="System.Data.Linq.ITable.AttachAll">
      <MemberSignature Language="C#" Value="void ITable.AttachAll (System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.AttachAll(class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#AttachAll(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Sub AttachAll (entities As IEnumerable) Implements ITable.AttachAll" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.AttachAll(System::Collections::IEnumerable ^ entities) = System::Data::Linq::ITable::AttachAll;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.AttachAll(System.Collections.IEnumerable)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="entities">Die Auflistung von Entitäten, die angehängt werden soll.</param>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.AttachAll">
      <MemberSignature Language="C#" Value="void ITable.AttachAll (System.Collections.IEnumerable entities, bool asModified);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.AttachAll(class System.Collections.IEnumerable entities, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#AttachAll(System.Collections.IEnumerable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub AttachAll (entities As IEnumerable, asModified As Boolean) Implements ITable.AttachAll" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.AttachAll(System::Collections::IEnumerable ^ entities, bool asModified) = System::Data::Linq::ITable::AttachAll;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.AttachAll(System.Collections.IEnumerable,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entities">Die Auflistung von Entitäten, die angehängt werden soll.</param>
        <param name="asModified">
          <see langword="true" />, um die Entitäten als geändert anzufügen; <see langword="false" />, um die Entitäten als nicht geändert anzufügen.</param>
        <summary>Fügt alle Entitäten einer Auflistung im veränderten oder unveränderten Zustand an den <see cref="T:System.Data.Linq.DataContext" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.DeleteAllOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.DeleteAllOnSubmit (System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.DeleteAllOnSubmit(class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#DeleteAllOnSubmit(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Sub DeleteAllOnSubmit (entities As IEnumerable) Implements ITable.DeleteAllOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.DeleteAllOnSubmit(System::Collections::IEnumerable ^ entities) = System::Data::Linq::ITable::DeleteAllOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.DeleteAllOnSubmit(System.Collections.IEnumerable)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="entities">Die Entitäten, die entfernt werden.</param>
        <summary>Ändert den Zustand aller Entitäten in der Auflistung in <see langword="pending delete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.DeleteOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.DeleteOnSubmit (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.DeleteOnSubmit(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#DeleteOnSubmit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub DeleteOnSubmit (entity As Object) Implements ITable.DeleteOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.DeleteOnSubmit(System::Object ^ entity) = System::Data::Linq::ITable::DeleteOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.DeleteOnSubmit(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die entfernt werden soll.</param>
        <summary>Ändert den Zustand einer Entität aus dieser Tabelle in <see langword="pending delete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
> [!NOTE]
>  Kaskadierte Löschvorgänge werden von [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nicht unterstützt bzw. erkannt. Wenn eine Zeile in einer Tabelle zu löschen, die Einschränkungen gelten sollen, müssen Sie entweder die `ON DELETE CASCADE` -Regel in der foreign Key-Einschränkung in der Datenbank, oder verwenden Sie eigenen Code zunächst die untergeordneten Objekte löschen, die verhindern, dass das übergeordnete Objekt gelöscht werden. Andernfalls wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.GetModifiedMembers">
      <MemberSignature Language="C#" Value="System.Data.Linq.ModifiedMemberInfo[] ITable.GetModifiedMembers (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Data.Linq.ModifiedMemberInfo[] System.Data.Linq.ITable.GetModifiedMembers(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#GetModifiedMembers(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetModifiedMembers (entity As Object) As ModifiedMemberInfo() Implements ITable.GetModifiedMembers" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Data::Linq::ModifiedMemberInfo&gt; ^ System.Data.Linq.ITable.GetModifiedMembers(System::Object ^ entity) = System::Data::Linq::ITable::GetModifiedMembers;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.GetModifiedMembers(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("NOT IMPLEMENTED YET")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ModifiedMemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, aus der die geänderten Member abgerufen werden.</param>
        <summary>Gibt ein Array von geänderten Membern mit den aktuellen und den ursprünglichen Werten zurück.</summary>
        <returns>Ein Array von geänderten Membern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.GetOriginalEntityState">
      <MemberSignature Language="C#" Value="object ITable.GetOriginalEntityState (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Data.Linq.ITable.GetOriginalEntityState(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#GetOriginalEntityState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetOriginalEntityState (entity As Object) As Object Implements ITable.GetOriginalEntityState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Data.Linq.ITable.GetOriginalEntityState(System::Object ^ entity) = System::Data::Linq::ITable::GetOriginalEntityState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.GetOriginalEntityState(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("NOT IMPLEMENTED YET")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, auf deren ursprünglichen Zustand zugegriffen werden soll.</param>
        <summary>Ruft ursprüngliche Werte einer angegebenen Entität ab.</summary>
        <returns>Eine Kopie der ursprünglichen Entität.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.InsertAllOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.InsertAllOnSubmit (System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.InsertAllOnSubmit(class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#InsertAllOnSubmit(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Sub InsertAllOnSubmit (entities As IEnumerable) Implements ITable.InsertAllOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.InsertAllOnSubmit(System::Collections::IEnumerable ^ entities) = System::Data::Linq::ITable::InsertAllOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.InsertAllOnSubmit(System.Collections.IEnumerable)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="entities">Die Auflistung von Entitäten, die hinzugefügt werden soll.</param>
        <summary>Fügt dem <see cref="T:System.Data.Linq.DataContext" /> alle Entitäten einer Sammlung im Zustand <see langword="pending insert" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.InsertOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.InsertOnSubmit (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.InsertOnSubmit(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#InsertOnSubmit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub InsertOnSubmit (entity As Object) Implements ITable.InsertOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.InsertOnSubmit(System::Object ^ entity) = System::Data::Linq::ITable::InsertOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.InsertOnSubmit(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, die hinzugefügt werden soll.</param>
        <summary>Fügt der Tabelle eine Entität mit dem Status <see langword="pending insert" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Data.Linq.ITable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.ElementType">
      <MemberSignature Language="C#" Value="Type System.Linq.IQueryable.ElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Linq.IQueryable.ElementType" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#Linq#IQueryable#ElementType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ElementType As Type Implements IQueryable.ElementType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System.Linq.IQueryable.ElementType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der Element(e) ab, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die diesem Objekt zugeordnet ist.</summary>
        <value>Der Typ der Element(e), die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die diesem Objekt zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.Expression">
      <MemberSignature Language="C#" Value="System.Linq.Expressions.Expression System.Linq.IQueryable.Expression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.Expression System.Linq.IQueryable.Expression" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#Linq#IQueryable#Expression" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expression As Expression Implements IQueryable.Expression" />
      <MemberSignature Language="C++ CLI" Value="property System::Linq::Expressions::Expression ^ System.Linq.IQueryable.Expression { System::Linq::Expressions::Expression ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ausdrucksbaumstruktur ab, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</summary>
        <value>Die <see cref="T:System.Linq.Expressions.Expression" />, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.Provider">
      <MemberSignature Language="C#" Value="System.Linq.IQueryProvider System.Linq.IQueryable.Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider System.Linq.IQueryable.Provider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#Linq#IQueryable#Provider" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Provider As IQueryProvider Implements IQueryable.Provider" />
      <MemberSignature Language="C++ CLI" Value="property System::Linq::IQueryProvider ^ System.Linq.IQueryable.Provider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abfrageanbieter ab, der dieser Datenquelle zugeordnet ist.</summary>
        <value>Der <see cref="T:System.Linq.IQueryProvider" />, der dieser Datenquelle zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.CreateQuery">
      <MemberSignature Language="C#" Value="System.Linq.IQueryable IQueryProvider.CreateQuery (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Linq.IQueryable System.Linq.IQueryProvider.CreateQuery(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#CreateQuery(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Linq::IQueryable ^ System.Linq.IQueryProvider.CreateQuery(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::CreateQuery;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Der Abfrageausdruck, aus dem die Evaluierung ausgeführt wird.</param>
        <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryProvider>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.CreateQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="System.Linq.IQueryable&lt;TResult&gt; IQueryProvider.CreateQuery&lt;TResult&gt; (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Linq.IQueryable`1&lt;!!TResult&gt; System.Linq.IQueryProvider.CreateQuery&lt;TResult&gt;(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#CreateQuery``1(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA; virtual System::Linq::IQueryable&lt;TResult&gt; ^ System.Linq.IQueryProvider.CreateQuery(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::CreateQuery;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Daten in der Tabelle.</typeparam>
        <param name="expression">Der Abfrageausdruck, aus dem die Evaluierung ausgeführt wird.</param>
        <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryProvider>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.Execute">
      <MemberSignature Language="C#" Value="object IQueryProvider.Execute (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Linq.IQueryProvider.Execute(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#Execute(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Linq.IQueryProvider.Execute(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::Execute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Der Abfrageausdruck, der ausgeführt werden soll.</param>
        <summary>Führt die Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
        <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryProvider>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.Execute&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="TResult IQueryProvider.Execute&lt;TResult&gt; (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !!TResult System.Linq.IQueryProvider.Execute&lt;TResult&gt;(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#Execute``1(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA; virtual TResult System.Linq.IQueryProvider.Execute(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::Execute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ der Daten in der Tabelle.</typeparam>
        <param name="expression">Der Abfrageausdruck, der ausgeführt werden soll.</param>
        <summary>Führt die stark typisierte Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
        <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.Linq.Table%601>-Instanz in eine <xref:System.Linq.IQueryProvider>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die die Tabelle darstellt.</summary>
        <returns>Eine Zeichenfolgendarstellung der Tabelle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>