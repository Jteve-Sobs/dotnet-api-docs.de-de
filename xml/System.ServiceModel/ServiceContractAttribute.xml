<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fb2b00ca39d4b9351107149e5bb15cfed1540466" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75159790" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.7.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-uwp-10.0;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt an, dass eine Schnittstelle oder eine Klasse einen Dienstvertrag in einer WCF-Anwendung (Windows Communication Foundation) definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie das <xref:System.ServiceModel.ServiceContractAttribute>-Attribut in einer Schnittstelle (oder Klasse), um einen Dienstvertrag zu definieren. Verwenden Sie dann das <xref:System.ServiceModel.OperationContractAttribute>-Attribut in einer oder mehreren Klassenmethoden (oder Schnittstellenmethoden), um die Dienstvertragvorgänge zu definieren. Wenn der Dienstvertrag implementiert und mit einer [Bindung](~/docs/framework/wcf/bindings.md) und einem <xref:System.ServiceModel.EndpointAddress> Objekt kombiniert wird, wird der Dienstvertrag für die Verwendung durch Clients verfügbar gemacht. Eine Übersicht über den Prozess mit einfachen Beispielen finden Sie im [Tutorial zu](~/docs/framework/wcf/getting-started-tutorial.md)den ersten Schritten. Weitere Informationen zum Erstellen von Dienstverträgen finden Sie unter [Entwerfen und Implementieren von Diensten](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Die von einem <xref:System.ServiceModel.ServiceContractAttribute> wiedergegebenen Informationen und seine Schnittstelle hängen lose mit dem Web Services Description Language (WSDL)-`<portType>`-Element zusammen. Ein Dienstvertrag wird auf der Dienst Seite verwendet, um anzugeben, was der Dienst Endpunkt für Aufrufer verfügbar macht. Er wird außerdem auf Clientseite verwendet, um den Vertrag des Endpunkts anzugeben, mit dem der Client kommuniziert, und um im Fall von Duplexverträgen den Rückrufvertrag anzugeben (unter Verwendung der <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>-Eigenschaft), den der Client implementieren muss, um an einer Duplexkonversation teilzunehmen.  
  
> [!NOTE]
>  Eine Schnittstelle oder Klasse, der <xref:System.ServiceModel.ServiceContractAttribute> zugeordnet ist, muss mindestens eine Methode aufweisen, die mit dem <xref:System.ServiceModel.OperationContractAttribute>-Attribut markiert ist, um Funktionen bereitstellen zu können. Im Beispielabschnitt finden Sie ein Codebeispiel, in dem die beiden Attribute auf einfache Weise zum Definieren und Implementieren eines Diensts eingesetzt werden.  
  
 Verwenden Sie die <xref:System.ServiceModel.ServiceContractAttribute>-Eigenschaften, um den Dienstvertrag zu ändern.  
  
-   Die <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A>-Eigenschaft gibt den Namen des Dienstelements in der zu verwendenden Konfigurationsdatei an.  
  
-   Die <xref:System.ServiceModel.ServiceContractAttribute.Name%2A>-Eigenschaft und die <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A>-Eigenschaft steuern den Namen und den Namespace des Vertrags im WSDL-`<portType>`-Element.  
  
-   Die <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>-Eigenschaft gibt an, ob der Vertrag eine Bindung erfordert, die Sitzungen unterstützt.  
  
-   Die <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>-Eigenschaft gibt den Rückgabevertrag in einer bidirektionalen (Duplex-) Konversation an.  
  
-   Die <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A>-Eigenschaft und die <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>-Eigenschaft geben an, ob alle den Vertrag unterstützenden Nachrichten einen expliziten <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>-Wert haben, und wenn ja, welcher Stufe sie angehören.  
  
 Dienste implementieren Dienstverträge, die den von einem Diensttyp unterstützten Datenaustausch darstellen. Eine Dienstklasse kann einen Dienstvertrag implementieren (durch Implementierung einer mit <xref:System.ServiceModel.ServiceContractAttribute> markierten Schnittstelle, die Methoden aufweist, die mit <xref:System.ServiceModel.OperationContractAttribute> markiert sind), oder sie kann mit <xref:System.ServiceModel.ServiceContractAttribute> markiert werden und das <xref:System.ServiceModel.OperationContractAttribute>-Attribut auf seine eigenen Methoden anwenden. (Wenn eine Klasse eine Schnittstelle implementiert, die mit <xref:System.ServiceModel.ServiceContractAttribute>gekennzeichnet ist, kann Sie nicht selbst mit <xref:System.ServiceModel.ServiceContractAttribute>markiert werden.) Methoden für Dienst Typen, die mit dem <xref:System.ServiceModel.OperationContractAttribute> gekennzeichnet sind, werden als Teil eines Standard Dienstvertrags behandelt, der durch den Diensttyp selbst angegeben wird. Einzelheiten zu Dienstvorgängen finden Sie unter <xref:System.ServiceModel.OperationContractAttribute>.  
  
 Standardmäßig sind die <xref:System.ServiceModel.ServiceContractAttribute.Name%2A>-Eigenschaft und die <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A>-Eigenschaft der Name des Vertragstyps bzw. `http://tempuri.org`, und <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> ist <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Es wird empfohlen, dass Dienstverträge ihre Namen, Namespaces und Schutzebenen explizit mit diesen Eigenschaften festlegen. Dadurch können zwei Ziele erreicht werden. Erstens wird dabei ein Vertrag erstellt, der nicht direkt mit den Informationen zum verwalteten Typ verbunden ist und es Ihnen dadurch ermöglicht, Ihren verwalteten Code und Ihre verwalteten Namespaces umzugestalten, ohne den in WSDL angegebenen Vertrag zu brechen. Zweitens wird der Laufzeit durch die explizite Anforderung einer bestimmten Schutzebene beim Vertrag selbst ermöglicht zu prüfen, ob die Bindungskonfiguration diese Sicherheitsebene unterstützt, wodurch verhindert wird, dass durch eine unzureichende Konfiguration vertrauliche Informationen weitergegeben werden. Weitere Informationen zu Schutz Ebenen finden Sie Untergrund Legendes zur [Schutz Ebene](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Um einen Dienst für die Verwendung durch Client Anwendungen verfügbar zu machen, erstellen Sie eine Host Anwendung, um den Dienst Endpunkt bei Windows Communication Foundation (WCF) zu registrieren. Sie können WCF-Dienste mit Windows Activation Services (was), in Konsolen Anwendungen, Windows-Dienst Anwendungen, ASP.NET-Anwendungen, Windows Forms Anwendungen oder einer beliebigen anderen Art von Anwendungsdomäne hosten.  
  
 Das Hosten in WAS ähnelt stark dem Erstellen einer ASP.NET-Anwendung. Weitere Informationen finden Sie unter Vorgehens [Weise: Hosten eines WCF-Diensts in IIS](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md).  
  
 Clients verwenden entweder die Dienstvertragsschnittstelle (die mit <xref:System.ServiceModel.ServiceContractAttribute> markierte Schnittstelle), um einen Kanal für den Dienst zu erstellen, oder sie verwenden die Clientobjekte (die die Typinformationen der Dienstvertragsschnittstelle mit der <xref:System.ServiceModel.ClientBase%601>-Klasse kombinieren), um mit dem Dienst zu kommunizieren. Weitere Informationen zu Client Kanälen für Dienste finden Sie in der <xref:System.ServiceModel.ChannelFactory%601>-Klasse und in der [Übersicht über den WCF-Client](~/docs/framework/wcf/wcf-client-overview.md).  
  
 Durch Verwendung einer <xref:System.ServiceModel.ServiceContractAttribute>-Klasse oder -Schnittstelle zum Erben von einer anderen <xref:System.ServiceModel.ServiceContractAttribute>-Klasse oder -Schnittstelle wird der übergeordnete Vertrag erweitert. Wenn z.&#160;B. eine `IChildContract`-Schnittstelle mit <xref:System.ServiceModel.ServiceContractAttribute> markiert ist und von der Dienstvertragsschnittstelle `IParentContract`erbt, enthält der `IChildContract`-Dienstvertrag die Methoden von `IParentContract` und `IChildContract`. Das Erweitern von Verträgen (ob für Klassen oder Schnittstellen) ähnelt stark dem Erweitern verwalteter Klassen und Schnittstellen.  
  
 Die flexibelste Herangehensweise an das Erstellen von Diensten ist die Definition von Dienstvertragsschnittstellen und die anschließende Implementierung dieser Schnittstellen durch die Dienstklasse. (Dies ist auch die einfachste Möglichkeit, um ihre Dienste zu erstellen, wenn Sie Dienstverträge implementieren müssen, die von anderen definiert wurden.) Die direkte Erstellung von Diensten durch das Markieren einer Klasse mit <xref:System.ServiceModel.ServiceContractAttribute> und deren Methoden mit <xref:System.ServiceModel.OperationContractAttribute> funktioniert, wenn der Dienst nur einen Vertrag verfügbar macht (dieser Vertrag kann jedoch durch mehr als einen Endpunkt verfügbar gemacht werden).  
  
 Verwenden Sie die <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>-Eigenschaft, um einen anderen Dienstvertrag anzugeben, der, wenn er an den ursprünglichen Dienstvertrag gebunden ist, einen Nachrichtenaustausch definiert, der auf zwei Arten unabhängig durchlaufen werden kann. Ausführliche Informationen finden Sie unter <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie <xref:System.ServiceModel.ServiceContractAttribute> auf eine Schnittstelle angewendet wird, um einen Dienstvertrag mit einer Dienstmethode zu definieren, die durch <xref:System.ServiceModel.OperationContractAttribute> angegeben wird. In diesem Fall ist die erforderliche Schutzebene der Bindungen für alle Nachrichten <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 Im Codebeispiel wird dieser Vertrag dann über die `SampleService`-Klasse implementiert.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 Im folgenden Codebeispiel wird eine einfache Konfigurationsdatei für den vorangehenden Dienst gezeigt, die einen Endpunkt erstellt.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 Im folgenden Codebeispiel wird ein einfacher Client gezeigt, der den vorangehenden `SampleService` aufruft.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/036fae20-7c55-4002-b71d-ac4466e167a3">Definieren von Dienstverträgen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/192be927-6be2-4fda-98f0-e513c4881acc">Hosting eines Diensts</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7cf21bfe-23bd-46aa-8033-609f851dbf76">Übersicht über die Dienst Erstellung</related>
    <related type="Article" href="https://msdn.microsoft.com/library/28dfff47-d95b-4cc2-9d5c-b3b9ba71fd50">Erstellen eines Clients</related>
    <related type="Article" href="https://msdn.microsoft.com/library/d780af9f-73c5-42db-9e52-077a5e4de7fe">Proxy Erstellung (Übersicht)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.ServiceContractAttribute" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor erstellt eine Instanz des Attributs ohne Sitzungsanforderungen, ohne Rückrufvertrag und mit Standardname und Namespace.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Rückrufvertrags ab oder legt ihn fest, wenn es sich beim Vertrag um einen Duplexvertrag handelt.</summary>
        <value>Ein <see cref="T:System.Type" />, der den Rückrufvertrag angibt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie in der <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>-Eigenschaft eine Schnittstelle an, die den erforderlichen gegenteiligen Vertrag in einem bidirektionalen (oder Duplex Nachrichtenaustausch) darstellt. Dies ermöglicht es Clientanwendungen, auf eingehende Vorgangsaufrufe zu überwachen, die die Dienstanwendung der Serverseite unabhängig von der Clientaktivität senden kann. Rückrufverträge mit unidirektionalen Vorgängen repräsentieren Aufrufe vom Dienst, die der Client verarbeiten kann.  
  
> [!NOTE]
>  Das <xref:System.ServiceModel.ServiceContractAttribute>-Attribut wird bei Rückruf Verträgen ignoriert. Um das Laufzeitverhalten von Rückruf Objekten zu konfigurieren, verwenden Sie die <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Dienst gezeigt, der einen Rückruf Vertrag angibt, der angibt, dass ein Dienst vom Typ `IDuplexHello` über einen Korrespondenten verfügen muss, der einen Dienst vom Typ "`IHelloCallbackContract`" implementiert. Außerdem implementiert `IHelloCallbackContract` eine unidirektionale Rückruf Methode, die es dem Dienst ermöglicht, den Client aufzurufen, ohne auf eine Antwort zu warten, um einen verteilten, ereignisgesteuerten Client zu unterstützen.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen ab, mit dem der Dienst in einer Anwendungskonfigurationsdatei gesucht wird, oder legt ihn fest.</summary>
        <value>Der Name, mit dem das Dienstelement in einer Anwendungskonfigurationsdatei gesucht wird. Der Standardwert ist der Name der Dienstimplementierungsklasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zum Festlegen des Werts, mit dem das Konfigurationssystem einen Vertragswert in der Konfigurationsdatei eingibt, finden Sie unter <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dem Member eine Schutzebene zugewiesen wurde.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />-Eigenschaft nicht <see cref="F:System.Net.Security.ProtectionLevel.None" /> ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A>-Eigenschaft gibt an, ob für den Vertrag ein anderer Wert als `false` der Schutz Ebene festgelegt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen für das <see langword="&lt;portType&gt;" />-Element in Web Services Description Language (WSDL) ab oder legt ihn fest.</summary>
        <value>Der Standardwert ist der Name der Klasse oder Schnittstelle, auf den <see cref="T:System.ServiceModel.ServiceContractAttribute" /> angewendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die Eigenschaften "<xref:System.ServiceModel.ServiceContractAttribute.Name%2A>" und "<xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A>", um den Namen und den Namespace des `<portType>` Elements in WSDL zu steuern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Eigenschaften <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> und <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> der <xref:System.ServiceModel.ServiceContractAttribute> verwendet werden, um die entsprechenden Werte in WSDL festzulegen.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Das folgende Codebeispiel zeigt einen Windows Communication Foundation (WCF)-Client für den vorangehenden Dienst, der WSDL mit dem [Service Model Metadata Utility-Tool (Svcutil. exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)importiert hat. Dieser Client verwendet einen `HelloWorldProxy` Client anstelle eines `SampleServiceProxy` Clients (wie dies bei dem Beispiel im Beispiel Abschnitt von <xref:System.ServiceModel.ServiceContractAttribute>) der Fall ist.  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace des <see langword="&lt;portType&gt;" />-Elements in der Web Services Description Language (WSDL) ab oder legt ihn fest.</summary>
        <value>Der WSDL-Namespace des <see langword="&lt;portType&gt;" />-Elements. Der Standardwert ist <c>"http://tempuri.org"</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Eigenschaften <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> und <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> der <xref:System.ServiceModel.ServiceContractAttribute> verwendet werden, um die entsprechenden Werte in WSDL festzulegen.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Das folgende Codebeispiel zeigt einen Windows Communication Foundation (WCF)-Client für den vorangehenden Dienst, der WSDL mit dem [Service Model Metadata Utility-Tool (Svcutil. exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)importiert hat. Dieser Client verwendet einen `HelloWorldClient` Client anstelle eines `SampleServiceClient` Clients (wie dies bei dem Beispiel im Beispiel Abschnitt von <xref:System.ServiceModel.ServiceContractAttribute>) der Fall ist.  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die Bindung für den Vertrag den Wert der <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />-Eigenschaft unterstützen muss.</summary>
        <value>Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte. Der Standardwert ist <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>-Eigenschaft, um den Grad anzugeben, in dem die Vertragsbindung Verschlüsselung, digitale Signaturen oder beides für Endpunkte erfordert, die den Vertrag verfügbar machen. Der hier festgelegte Wert ist der Standardwert für alle Vorgangsmeldungen einschließlich der Fehler.  
  
 Dabei ist wichtig zu bedenken, dass das Schutzverhalten zur Laufzeit die Kombination der Schutzebenenwerte der folgenden Eigenschaften ist. Diese Eigenschaften verfügen über eine hierarchische Struktur. Mit der Festlegung des äußersten Werts wird die Standardeinstellung für alle engeren Bereiche festgelegt, es sei denn, es wird ausdrücklich ein anderer Wert für einen engeren Bereich definiert. In diesem Fall bleibt der äußere Wert der Standardwert für alle engeren Bereiche mit Ausnahme des ausdrücklich festgelegten Werts.  
  
 Wenn beispielsweise <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> auf <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> festgelegt ist und für keine weiteren engeren Bereiche Schutzebeneneinstellungen definiert sind, werden alle Nachrichten in einem Vorgangsvertrag verschlüsselt und signiert. Wenn aber für einen dieser Vorgänge <xref:System.ServiceModel.OperationContractAttribute> auf <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> festgelegt ist, werden die Nachrichten für diesen Vorgang signiert, alle anderen Nachrichten im Vertrag werden jedoch verschlüsselt und signiert.  
  
 Ausführliche Informationen zu Schutz Ebenen und deren Annahmen und Bereichen finden Sie Untergrund Legendes zur [Schutz Ebene](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Die Bereiche, für die diese Werte festgelegt wurden:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 Die <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType>-Eigenschaft für <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 Die <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType>-Eigenschaft für <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Wenn im Vertrag nicht ausdrücklich eine Schutzebene festgelegt ist und die zugrunde liegende Bindung Sicherheitsfunktionen (auf der Transport- oder Nachrichtenebene) unterstützt, ist die effektive Schutzebene für den gesamten Vertrag <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Wenn die Bindung keine Sicherheitsfunktionen (wie beispielsweise <xref:System.ServiceModel.BasicHttpBinding>) unterstützt, ist die effektive <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> für den gesamten Vertrag <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Im Ergebnis können Clients abhängig von der Endpunktbindung unterschiedlichen Nachrichten- oder Transportebenenschutz auch dann anfordern, wenn im Vertrag <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> angegeben ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist keiner der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob Sitzungen zugelassen, nicht zugelassen oder erforderlich sind, oder legt dies fest.</summary>
        <value>Ein <see cref="T:System.ServiceModel.SessionMode" />, der angibt, ob Sitzungen zugelassen, nicht zugelassen oder erforderlich sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>-Eigenschaft, um Bindungen anzufordern, die Sitzungen zwischen Endpunkten unterstützen. Eine Sitzung ist eine Möglichkeit zur Korrelation von Nachrichten, die zwischen zwei oder mehr Endpunkten ausgetauscht werden. Wenn Ihr Dienst Kanal Sitzungen unterstützt, können Sie die <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A>-Eigenschaft verwenden, um die Beziehung zwischen Instanzen der Dienstvertrags Implementierung und der Kanal Sitzung anzugeben. Wenn eine Bindung keine Sitzungen unterstützt, wird eine Ausnahme ausgelöst.  
  
 Wenn beispielsweise die Eigenschaft <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> auf <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> festgelegt ist und die Eigenschaft <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> auf <xref:System.ServiceModel.InstanceContextMode.PerSession>festgelegt ist, können Clients die gleiche Verbindung verwenden, um wiederholte Aufrufe desselben Dienst Objekts durchführen.  
  
 Weitere Informationen zu Sitzungen und Dienst Instanzen finden Sie unter [Verwenden von Sitzungen](~/docs/framework/wcf/using-sessions.md) und [Sitzungen, Instanziierung und](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)Parallelität.  
  
> [!NOTE]
>  Ein Kanal, der Sitzungen unterstützt, unterstützt die Standardzuordnung einer Dienstinstanz zu einer bestimmten Sitzung. Unterschiedliche Sitzungsimplementierungen unterstützen jedoch unterschiedliche Funktionen zusätzlich zur sitzungsbasierten Instanziierungssteuerung. WCF bietet vier Typen von Sitzungen, die Sie verwenden können, um Sitzungs basiertes Anwendungsverhalten bereitzustellen. jeder Sitzungstyp bietet ein zusätzliches Verhalten, das für den Typ der Sitzung spezifisch ist.  
  
1.  Der <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> unterstützt Sicherheits Sitzungen, bei denen sich beide Kommunikations enden auf einen Verschlüsselungs-und/oder digitalen Signatur Prozess geeinigt haben. Alle Nachrichten werden mit dieser spezifischen sicheren Konversation korreliert. Weitere Informationen finden Sie unter [Sichern von Diensten](~/docs/framework/wcf/securing-services.md). Beispielsweise wird in der <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType>, die sowohl Sicherheits Sitzungen als auch zuverlässige Sitzungen unterstützt, standardmäßig nur eine sichere Sitzung verwendet, mit der Nachrichten verschlüsselt und signiert werden.  
  
2.  Der <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> unterstützt die Sitzungen, die von den TCP/IP-Verbindungen verfügbar gemacht werden, um sicherzustellen, dass alle Nachrichten von der Verbindungs Sitzung auf Socketebene korreliert werden  
  
3.  Der <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>, der die WS-ReliableMessaging-Spezifikation implementiert, bietet Unterstützung für zuverlässige Sitzungen, in denen Nachrichten in der richtigen Reihenfolge übermittelt werden, und ermöglicht selbst dann Vertrauen, wenn Nachrichten während der Konversation über mehrere Knoten übertragen werden. Weitere Informationen finden Sie unter [zuverlässige Sitzungen](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  Der <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> stellt MSMQ-Datagrammsitzungen bereit. Weitere Informationen finden Sie unter [Warteschlangen in WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Beachten Sie, dass das Festlegen der <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>-Eigenschaft nicht den Typ der Sitzung angibt, die der Vertrag benötigt, sondern nur, dass eine Sitzung erforderlich ist.  
  
   
  
## Examples  
 Der folgende Dienstvertrag erfordert, dass konfigurierte Bindungen Sitzungen verwenden, wenn Sie mit `SampleDuplexHello` Dienst Implementierungen interagieren.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist keiner der <see cref="T:System.ServiceModel.SessionMode" />-Werte.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
