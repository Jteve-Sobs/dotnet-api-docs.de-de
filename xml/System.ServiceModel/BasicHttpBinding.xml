<Type Name="BasicHttpBinding" FullName="System.ServiceModel.BasicHttpBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="be71019584f46010430634388d4955156867ac10" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75160250" /></Metadata><TypeSignature Language="C#" Value="public class BasicHttpBinding : System.ServiceModel.HttpBindingBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BasicHttpBinding extends System.ServiceModel.HttpBindingBase implements class System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.BasicHttpBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class BasicHttpBinding&#xA;Inherits HttpBindingBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class BasicHttpBinding : System::ServiceModel::HttpBindingBase" />
  <TypeSignature Language="F#" Value="type BasicHttpBinding = class&#xA;    inherit HttpBindingBase&#xA;    interface IBindingRuntimePreferences" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Http</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.7.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.HttpBindingBase</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.ServiceModel.Channels.Binding</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IBindingRuntimePreferences</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Bindung dar, die ein Windows Communication Foundation-Dienst (WCF) zum Konfigurieren und Verfügbarmachen von Endpunkten verwenden kann, die mit ASMX-basierten Webdiensten und -clients sowie mit anderen Diensten kommunizieren können, die mit WS-I Basic Profile 1.1 konform sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceModel.BasicHttpBinding> verwendet HTTP als Transport zum Senden von SOAP 1.1-Nachrichten. Ein Dienst kann diese Bindung zum Verfügbarmachen von mit WS-I BP 1.1 konformen Endpunkten verwenden, wie z.&#160;B. Endpunkte für ASMX-Clients. Ebenso kann ein Client die <xref:System.ServiceModel.BasicHttpBinding> für die Kommunikation mit Diensten verwenden, die Endpunkte verfügbar machen, die WS-I BP 1,1 entsprechen, wie z. b. asmx-Webdienste oder Windows Communication Foundation (WCF)-Dienste, die mit dem <xref:System.ServiceModel.BasicHttpBinding>konfiguriert sind.  
  
 Sicherheit ist standardmäßig deaktiviert, kann jedoch aktiviert werden, indem der <xref:System.ServiceModel.BasicHttpSecurityMode> auf einen anderen Wert als <xref:System.ServiceModel.BasicHttpSecurityMode.None> im <xref:System.ServiceModel.BasicHttpBinding.%23ctor%28System.ServiceModel.BasicHttpSecurityMode%29>-Konstruktor festgelegt wird. Standardmäßig wird "Text"-Nachrichtencodierung und UTF-8-Textcodierung verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht, wie die <xref:System.ServiceModel.BasicHttpBinding> in einer Anwendungskonfigurationsdatei konfiguriert wird.  
  
  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.ServiceModel.BasicHttpBinding> programmgesteuert konfiguriert wird.  
  
 [!code-csharp[S_UEBasicHttpBinding#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/service.cs#1)]
 [!code-vb[S_UEBasicHttpBinding#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.BasicHttpBinding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BasicHttpBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BasicHttpBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.BasicHttpBinding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert des verwendeten <xref:System.ServiceModel.BasicHttpSecurityMode> ist <xref:System.ServiceModel.BasicHttpSecurityMode.None>, wodurch angegeben wird, dass die SOAP-Nachricht nicht gesichert und der Client nicht authentifiziert ist.  
  
   
  
## Examples  
 [!code-csharp[S_UEBasicHttpBinding#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/service.cs#2)]
 [!code-vb[S_UEBasicHttpBinding#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/service.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BasicHttpBinding (System.ServiceModel.BasicHttpSecurityMode securityMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ServiceModel.BasicHttpSecurityMode securityMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.#ctor(System.ServiceModel.BasicHttpSecurityMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (securityMode As BasicHttpSecurityMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BasicHttpBinding(System::ServiceModel::BasicHttpSecurityMode securityMode);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.BasicHttpBinding : System.ServiceModel.BasicHttpSecurityMode -&gt; System.ServiceModel.BasicHttpBinding" Usage="new System.ServiceModel.BasicHttpBinding securityMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityMode" Type="System.ServiceModel.BasicHttpSecurityMode" />
      </Parameters>
      <Docs>
        <param name="securityMode">Der Wert von <see cref="T:System.ServiceModel.BasicHttpSecurityMode" />, der den Sicherheitstyp angibt, der für die SOAP-Nachricht und den Client verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.BasicHttpBinding" />-Klasse mit einem von der Bindung verwendeten Sicherheitstyp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert des verwendeten <xref:System.ServiceModel.BasicHttpSecurityMode> ist <xref:System.ServiceModel.BasicHttpSecurityMode.None>, wodurch angegeben wird, dass die SOAP-Nachricht nicht gesichert und der Client nicht authentifiziert ist.  
  
   
  
## Examples  
 [!code-csharp[S_UEBasicHttpBinding#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/snippets.cs#3)]
 [!code-vb[S_UEBasicHttpBinding#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/snippets.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BasicHttpBinding (string configurationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configurationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configurationName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BasicHttpBinding(System::String ^ configurationName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.BasicHttpBinding : string -&gt; System.ServiceModel.BasicHttpBinding" Usage="new System.ServiceModel.BasicHttpBinding configurationName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configurationName" Type="System.String" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="configurationName">Der Bindungskonfigurationsname für das <see cref="T:System.ServiceModel.Configuration.BasicHttpBindingElement" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.BasicHttpBinding" />-Klasse mit einer durch ihren Konfigurationsnamen angegebenen Bindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel initialisiert eine neue <xref:System.ServiceModel.BasicHttpBinding>-Klasse mit einer Bindung, die vom `myBinding`-Konfigurationsnamen angegeben wird. In der Konfigurationsdatei des Diensts muss ein Bindungsabschnitt erstellt werden.  
  
 [!code-csharp[S_UEBasicHttpBinding#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/snippets.cs#5)]
 [!code-vb[S_UEBasicHttpBinding#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/snippets.vb#5)]  
  
 Dann wird der Name der Bindungskonfiguration im Aufruf des <xref:System.ServiceModel.BasicHttpBinding>-Konstruktors angegeben.  
  
 [!code-csharp[S_UEBasicHttpBinding#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/snippets.cs#4)]
 [!code-vb[S_UEBasicHttpBinding#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Die Bindung mit dem Konfigurationsnamen <paramref name="configurationName" /> wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowCookies">
      <MemberSignature Language="C#" Value="public bool AllowCookies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCookies" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.AllowCookies" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCookies As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCookies { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCookies : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.AllowCookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob der Client Cookies akzeptiert und bei zukünftigen Anfragen weiterleitet.</summary>
        <value><see langword="true" />, wenn Cookies zulässig sind, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Diese Eigenschaft wird aus Gründen der Benutzerfreundlichkeit zum Interagieren mit ASMX-Webdiensten, die Cookies verwenden, bereitgestellt. Wenn Cookies vom Client akzeptiert werden, indem die Eigenschaft auf `true` festgelegt wird, werden Cookies, die vom Server zurückgegeben werden, automatisch in alle zukünftigen Clientanforderungen für diesen Dienst kopiert.

## Examples

Im folgenden Beispiel wird diese Eigenschaft festgelegt, um anzugeben, dass alle Cookies vom Server in zukünftige Client Anforderungen kopiert werden sollen:

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.AllowCookies = true;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.BuildChannelFactory``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (parameters As BindingParameterCollection) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingParameterCollection -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="basicHttpBinding.BuildChannelFactory parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Der Kanaltyp, der von der Kanalfactory erzeugt wird.</typeparam>
        <param name="parameters">Gibt die Anforderungen für die erstellte Channelfactory an.</param>
        <summary>Erstellt den Kanalfactorystapel auf dem Client, der einen festgelegten Kanaltyp erstellt und der die Funktionen erfüllt, die von einer Auflistung von Bindungsparametern festgelegt werden.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> vom Typ <paramref name="TChannel" />, der die von der Auflistung festgelegten Funktionen erfüllt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassProxyOnLocal">
      <MemberSignature Language="C#" Value="public bool BypassProxyOnLocal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BypassProxyOnLocal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.BypassProxyOnLocal" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassProxyOnLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BypassProxyOnLocal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BypassProxyOnLocal : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.BypassProxyOnLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob der Proxyserver bei lokalen Adressen umgangen werden soll.</summary>
        <value><see langword="true" />, um den Proxyserver bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Eine Internetressource gilt als lokal, wenn sie über eine lokale Adresse verfügt. Eine lokale Adresse befindet sich auf demselben Computer, LAN oder Intranet und wird durch das Fehlen eines Zeitraums (\.) wie in den URIs `http://webserver/` und `http://localhost/`identifiziert, syntaktisch.

Durch Festlegen der BypassProxyOnLocal-Eigenschaft wird bestimmt, ob mit dem <xref:System.ServiceModel.BasicHttpBinding> konfigurierte Endpunkte den Proxy Server beim Zugriff auf lokale Ressourcen verwenden.

Wenn BypassProxyOnLocal `true`ist, wird bei Anforderungen an lokale Internet Ressourcen der Proxy Server nicht verwendet. Verwenden Sie den Hostnamen (statt `localhost`), wenn Clients bei der Kommunikation mit Diensten auf dem gleichen Computer einen Proxy verwenden sollen, wenn diese Eigenschaft auf `true` festgelegt ist.

Wenn BypassProxyOnLocal `false`ist, werden alle Internet Anforderungen an nicht-localhost-URIs über den Proxy Server hergestellt. Bei Anforderungen an URIs mit localhost wird der Proxy Server unabhängig von der BypassProxyOnLocal-Einstellung nicht verwendet.
  
## Examples

Im folgenden Beispiel wird diese Eigenschaft festgelegt, um anzugeben, dass der Proxy für lokale Ressourcen umgangen werden soll.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.BypassProxyOnLocal = true;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1" 
                 bypassProxyOnLocal="true">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>
  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBindingElements">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElementCollection CreateBindingElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElementCollection CreateBindingElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.CreateBindingElements" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateBindingElements () As BindingElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElementCollection ^ CreateBindingElements();" />
      <MemberSignature Language="F#" Value="override this.CreateBindingElements : unit -&gt; System.ServiceModel.Channels.BindingElementCollection" Usage="basicHttpBinding.CreateBindingElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElementCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine geordnete Sammlung von Bindungselementen, die in der aktuellen Bindung enthalten sind, und gibt sie zurück.</summary>
        <returns>Die <see cref="T:System.ServiceModel.Channels.BindingElementCollection" />, die den geordneten Stapel von Bindungselementen enthält, die von der <see cref="T:System.ServiceModel.BasicHttpBinding" /> beschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wichtig ist die Reihenfolge der Bindungselemente. Sie spiegelt die Reihenfolge wider, in der die Protokollkanäle und Transportkanäle erstellt und gestapelt werden. Diese Auflistung von Bindungselementen ist eine neue Auflistung, die geändert werden kann. Mit ihr kann anschließend eine <xref:System.ServiceModel.Channels.CustomBinding> erstellt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine geordnete Auflistung der Bindungselemente in der aktuellen Bindung erstellt.  
  
 [!code-csharp[S_UEBasicHttpBinding#26](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/client.cs#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHttpCookieContainer">
      <MemberSignature Language="C#" Value="public bool EnableHttpCookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHttpCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.EnableHttpCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHttpCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHttpCookieContainer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHttpCookieContainer : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.EnableHttpCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. To enable Http CookieContainer, use the AllowCookies property instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der HTTP-Cookiecontainer aktiviert ist, oder legt den Wert fest.</summary>
        <value><see langword="true" />, wenn der HTTP-Cookiecontainer aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnvelopeVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EnvelopeVersion EnvelopeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EnvelopeVersion EnvelopeVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.EnvelopeVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvelopeVersion As EnvelopeVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EnvelopeVersion ^ EnvelopeVersion { System::ServiceModel::EnvelopeVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvelopeVersion : System.ServiceModel.EnvelopeVersion" Usage="System.ServiceModel.BasicHttpBinding.EnvelopeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EnvelopeVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die SOAP-Version ab, die für Nachrichten verwendet wird, die von dieser Bindung verarbeitet werden.</summary>
        <value>Der Wert der <see cref="T:System.ServiceModel.EnvelopeVersion" />, die mit dieser Bindung verwendet wird. Der Wert ist immer SOAP 1.1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  

SOAP 1.1 ist der einzige Wert, der mit dieser Bindung verwendet werden kann.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostNameComparisonMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.HostNameComparisonMode HostNameComparisonMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.HostNameComparisonMode HostNameComparisonMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.HostNameComparisonMode" />
      <MemberSignature Language="VB.NET" Value="Public Property HostNameComparisonMode As HostNameComparisonMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::HostNameComparisonMode HostNameComparisonMode { System::ServiceModel::HostNameComparisonMode get(); void set(System::ServiceModel::HostNameComparisonMode value); };" />
      <MemberSignature Language="F#" Value="member this.HostNameComparisonMode : System.ServiceModel.HostNameComparisonMode with get, set" Usage="System.ServiceModel.BasicHttpBinding.HostNameComparisonMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.HostNameComparisonMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Hostname verwendet wird, um beim Abgleich des URI den Dienst zu erreichen, oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.ServiceModel.HostNameComparisonMode" />-Wert, der angibt, ob der Hostname zum Erreichen des Diensts bei übereinstimmendem URI verwendet wird. Der Standardwert lautet <see cref="F:System.ServiceModel.HostNameComparisonMode.StrongWildcard" />, wodurch der Hostname beim Abgleich ignoriert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

Im folgenden Beispiel wird diese Eigenschaft so festgelegt, dass eine genaue Übereinstimmung erforderlich ist.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.HostNameComparisonMode = HostNameComparisonMode.Exact;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
                 hostNameComparisonMode ="Exact">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.BasicHttpBinding.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(524288)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Speicherkapazität in Byte ab, die vom Manager der Nachrichtenpuffer verwendet werden kann, die Nachrichten aus dem Kanal empfangen, oder legt diese fest.</summary>
        <value>Die maximale Speicherkapazität in Byte, die vom Puffer-Manager für Nachrichten verwendet werden kann. Der Standardwert ist 524288 (0x80000) Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der <xref:System.ServiceModel.Channels.BufferManager> reduziert den Pufferaufwand durch Verwendung eines Pufferpools. Puffer sind zur Verarbeitung von Nachrichten durch den Dienst erforderlich, wenn sie aus dem Kanal eintreffen. Wenn die Speicherkapazität des Pufferpools zur Verarbeitung der Nachrichten nicht ausreicht, muss der <xref:System.ServiceModel.Channels.BufferManager> zusätzliche Speicherkapazität aus dem CLR-Heap zuweisen. Dadurch wird die Auslastung der Garbage Collection erhöht. Eine umfangreiche Zuweisung aus dem CLR-Garbage Heap ist ein Hinweis darauf, dass die Pufferpool Größe zu klein ist, und dass die Leistung durch eine Erhöhung des maxbufferpoolsize-Limits durch eine höhere Zuweisung verbessert werden kann.

## Examples

Im folgenden Beispiel wird diese Eigenschaft auf das Doppelte des Standardwerts festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
// Use double the default value
binding.MaxBufferPoolSize = 0x80000 * 2;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1">

          <!-- set pool size to double default of 0x80000 -->
          maxBufferPoolSize = 0x100000

          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferSize">
      <MemberSignature Language="C#" Value="public int MaxBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MaxBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferSize : int with get, set" Usage="System.ServiceModel.BasicHttpBinding.MaxBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe in Byte für einen Puffer ab, der Nachrichten von einem Kanal empfängt.</summary>
        <value>Die maximale Größe eines Puffers in Byte, in dem Nachrichten gespeichert werden, während sie für einen mit dieser Bindung konfigurierten Endpunkt verarbeitet werden. Der Standardwert ist 65.536 Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Wenn die Speicherkapazität des Puffers zum Speichern der Nachricht während der Verarbeitung nicht ausreicht, muss aus dem CLR-Heap zusätzliche Speicherkapazität zugewiesen werden. Dadurch wird die Auslastung der Garbage Collection erhöht. Eine umfangreiche Zuweisung aus dem CLR-Heap der Garbage Collection weist darauf hin, dass die Größe des Nachrichtenpuffers nicht ausreichend ist und dass die Leistung durch eine größere Zuweisung infolge einer höheren Zuweisung verbessert werden kann.

Der Wert der MaxBufferSize-Eigenschaft und deren Bedeutung ist unterschiedlich, je nachdem, ob die Nachrichten gepuffert oder über den Kanal gestreamt werden, über den Sie empfangen werden:

- Für gepufferte Transporte (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> auf <xref:System.ServiceModel.TransferMode.Buffered?displayProperty=nameWithType>) ist dieser Wert immer gleich dem von der <xref:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize>-Eigenschaft angegebenen Wert.

- Bei gestreamten Übertragungen (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> auf <xref:System.ServiceModel.TransferMode.Streamed?displayProperty=nameWithType> festgelegt) müssen nur die SOAP-Header gepuffert werden, um die Nachricht zu erstellen. Der Text kann bei Bedarf gestreamt werden. In diesem Fall ist MaxBufferSize kleiner als oder gleich <xref:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize>, wobei <xref:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize> die Größe der gesamten Nachricht (Header und Text) einschränkt und MaxBufferSize nur die Größe der SOAP-Header einschränkt.

Die hier vorgenommenen Einschränkungen der Puffergröße dienen zum Optimieren der Leistung des Nachrichtenaustauschs. Wenn eine Nachricht den maximal zulässigen Wert für den Puffer überschreitet, wird sie nicht verworfen. Stattdessen wird mehr Speicherplatz aus dem CLR-Heap angefordert, was die Auslastung der Garbage Collection stärker erhöht als die Verwendung der Puffer.

> [!NOTE]
> Die Einstellungen für "MaxBufferSize" und "MaxReceivedMessageSize" sind lokale Verhaltens Einstellungen. Dies bedeutet, dass sie nicht in Metadaten an andere Endpunkte übertragen werden. Wenn Sie einen Dienstproxy mit einer maximalen Nachrichtengröße von 2&#160;GB für Metadaten erstellen, weist der Proxy auch weiterhin einen Standardwert von 64&#160;KB auf. Lokale Administratoren können so die entsprechenden Grenzwerte für Nachrichten und Nachrichtenpuffer kontrollieren.
  
## Examples


Im folgenden Beispiel wird **MaxBufferSize** auf 1 Million Bytes festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
            
// set to one million
binding.MaxBufferSize = 1000000;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Nachrichtengröße in Byte ab, die in einem Kanal empfangen werden kann, der mit dieser Bindung konfiguriert wurde, oder legt diese fest.</summary>
        <value>Die maximale Größe (in Byte) für eine Meldung, die von der Bindung verarbeitet wird. Der Standardwert ist 65.536 Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die Größe der Nachrichten, die von Diensten mithilfe von BasicHttpBinding empfangen werden können, wird durch die Menge an Arbeitsspeicher begrenzt, die für jede Nachricht reserviert wird. Auf diese Weise sollen DoS-ähnliche Angriffe möglichst reduziert werden.

Es ist außerdem eine <xref:System.ServiceModel.BasicHttpBinding.MaxBufferSize>-Eigenschaft für die <xref:System.ServiceModel.BasicHttpBinding> vorhanden:

Für gepufferte Transporte (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> festgelegt auf <xref:System.ServiceModel.TransferMode.Buffered>). Dieser Wert ist immer gleich dem von MaxReceivedMessageSize angegebenen Wert.

Bei gestreamten Übertragungen (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> auf <xref:System.ServiceModel.TransferMode.Streamed> festgelegt) müssen nur die SOAP-Header gepuffert werden, um die Nachricht zu erstellen. Der Text kann bei Bedarf gestreamt werden. In diesem Fall ist <xref:System.ServiceModel.BasicHttpBinding.MaxBufferSize> kleiner oder gleich MaxReceivedMessageSize, wobei MaxReceivedMessageSize die Größe der gesamten Nachricht (Header und Text) einschränkt und <xref:System.ServiceModel.BasicHttpBinding.MaxBufferSize> die Größe der SOAP-Header einschränkt.

## Examples

Im folgenden Beispiel wird MaxReceivedMessageSize auf 1 Million Bytes festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();

// Use double the default value
binding.MaxReceivedMessageSize = 65536 * 2;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
                 maxReceivedMessageSize = "1000000">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageEncoding">
      <MemberSignature Language="C#" Value="public System.ServiceModel.WSMessageEncoding MessageEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.WSMessageEncoding MessageEncoding" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MessageEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageEncoding As WSMessageEncoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::WSMessageEncoding MessageEncoding { System::ServiceModel::WSMessageEncoding get(); void set(System::ServiceModel::WSMessageEncoding value); };" />
      <MemberSignature Language="F#" Value="member this.MessageEncoding : System.ServiceModel.WSMessageEncoding with get, set" Usage="System.ServiceModel.BasicHttpBinding.MessageEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.WSMessageEncoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob MTOM oder Text verwendet wird, um SOAP-Nachrichten zu codieren.</summary>
        <value>Der Wert von <see cref="T:System.ServiceModel.WSMessageEncoding" />, der angibt, ob MTOM oder Text/XML zum Codieren von SOAP-Nachrichten verwendet wird. Der Standardwert ist <see cref="F:System.ServiceModel.WSMessageEncoding.Text" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird MessageEncoding auf Text festgelegt.  
  
 [!code-csharp[S_UEBasicHttpBinding#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/client.cs#19)]  
  
 Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProxyAddress">
      <MemberSignature Language="C#" Value="public Uri ProxyAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ProxyAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.ProxyAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property ProxyAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ ProxyAddress { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProxyAddress : Uri with get, set" Usage="System.ServiceModel.BasicHttpBinding.ProxyAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die URI-Adresse des HTTP-Proxys ab oder legt sie fest.</summary>
        <value>Eine <see cref="T:System.Uri" />, die als Adresse für den HTTP-Proxy dient. Der Standardwert ist NULL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Wenn die <xref:System.ServiceModel.BasicHttpBinding.UseDefaultWebProxy> auf `true`festgelegt ist, wird die Standardadresse verwendet, und der Wert des Satzes proxyAddress wird ignoriert.

## Examples

Im folgenden Beispiel wird ProxyAddress auf Anwendungseinstellungen festgelegt.

```csharp
// Get base address from app settings in configuration
Uri baseAddress = new Uri(ConfigurationManager.AppSettings["baseAddress"]);

BasicHttpBinding binding = new BasicHttpBinding();

binding.ProxyAddress = baseAddress;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
                 proxyAddress = "http://myProxy">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReaderQuotas">
      <MemberSignature Language="C#" Value="public System.Xml.XmlDictionaryReaderQuotas ReaderQuotas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDictionaryReaderQuotas ReaderQuotas" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.ReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Property ReaderQuotas As XmlDictionaryReaderQuotas" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlDictionaryReaderQuotas ^ ReaderQuotas { System::Xml::XmlDictionaryReaderQuotas ^ get(); void set(System::Xml::XmlDictionaryReaderQuotas ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReaderQuotas : System.Xml.XmlDictionaryReaderQuotas with get, set" Usage="System.ServiceModel.BasicHttpBinding.ReaderQuotas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDictionaryReaderQuotas</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Beschränkungen der Komplexität von SOAP-Meldungen ab oder legt Beschränkungen fest, die von Endpunkten verarbeitet werden können, die mit dieser Bindung konfiguriert werden.</summary>
        <value>Der <see cref="T:System.Xml.XmlDictionaryReaderQuotas" />, der die Komplexitätseinschränkungen angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die Beschränkungen schützen vor DOS-Angriffen (Denial Of Service), die versuchen, die Nachrichtenkomplexität zum Binden von Endpunkt-Verarbeitungsressourcen zu verwenden. Zu anderen Komplexitätseinschränkungen gehören Elemente wie zum Beispiel die maximale Elementtiefe und die maximale Länge für den Zeichenfolgeninhalt innerhalb der Nachricht.

## Examples

Im folgenden Beispiel werden Readerkontingenten auf Anwendungseinstellungen festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
XmlDictionaryReaderQuotas readerQuotas = new XmlDictionaryReaderQuotas();
readerQuotas.MaxArrayLength = 25 * 1024;
        
binding.ReaderQuotas = readerQuotas;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1">
          <readerQuotas maxBytesPerRead ="1000" 
                        maxDepth="100"/>

          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.BasicHttpBinding.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das URI-Transportschema für die Kanäle und die Listener ab, die mit dieser Bindung konfiguriert werden.</summary>
        <value>„https“, wenn der Sicherheitsmodus im Transportbindungselement auf <see cref="F:System.ServiceModel.BasicHttpSecurityMode.Transport" /> oder <see cref="F:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential" /> festgelegt ist, andernfalls „http“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

Im folgenden Beispiel wird das aktuelle Schema abgerufen.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
string thisScheme = binding.Scheme;
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Security">
      <MemberSignature Language="C#" Value="public System.ServiceModel.BasicHttpSecurity Security { get; set; }" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.BasicHttpSecurity Security" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.Security" />
      <MemberSignature Language="VB.NET" Value="Public Property Security As BasicHttpSecurity" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::BasicHttpSecurity ^ Security { System::ServiceModel::BasicHttpSecurity ^ get(); void set(System::ServiceModel::BasicHttpSecurity ^ value); };" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.BasicHttpSecurity with get, set" Usage="System.ServiceModel.BasicHttpBinding.Security" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.ServiceModel.BasicHttpSecurity Security { get; }" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Security As BasicHttpSecurity" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::BasicHttpSecurity ^ Security { System::ServiceModel::BasicHttpSecurity ^ get(); };" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.BasicHttpSecurity" Usage="System.ServiceModel.BasicHttpBinding.Security" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.BasicHttpSecurity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Sicherheitstyp ab, der mit dieser Bindung verwendet wird.</summary>
        <value>Die mit dieser Bindung verwendete <see cref="T:System.ServiceModel.BasicHttpSecurity" />. Der Standardwert ist <see cref="F:System.ServiceModel.BasicHttpSecurityMode.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird die SOAP-Nachricht nicht geschützt, und der Client wird nicht authentifiziert. Wenn Sie einen anderen als den standardmäßigen Sicherheitstyp verwenden möchten, verwenden Sie den <xref:System.ServiceModel.BasicHttpBinding.%23ctor%28System.ServiceModel.BasicHttpSecurityMode%29>-Konstruktor.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Security`-Eigenschaft abgerufen.  
  
 [!code-csharp[S_UEBasicHttpBinding#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/client.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeEnableHttpCookieContainer">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeEnableHttpCookieContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeEnableHttpCookieContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeEnableHttpCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeEnableHttpCookieContainer () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeEnableHttpCookieContainer();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeEnableHttpCookieContainer : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeEnableHttpCookieContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob der HTTP-Cookiecontainer die Serialisierung aktivieren soll.</summary>
        <returns><see langword="true" />, wenn der HTTP-Cookiecontainer die Serialisierung aktivieren soll; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReaderQuotas">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReaderQuotas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReaderQuotas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReaderQuotas () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReaderQuotas();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReaderQuotas : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeReaderQuotas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob die für die Komplexität der SOAP-Nachrichtenstruktur geltenden Einschränkungswerte serialisiert werden sollen.</summary>
        <returns><see langword="true" />, wenn Readerkontingente serialisiert werden sollen, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSecurity">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeSecurity" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSecurity () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSecurity();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSecurity : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Sicherheitseinstellungen serialisiert werden sollen, und zwar basierend darauf, ob die Serialisierung bereits erfolgt, beispielsweise auf der Nachrichten- oder Transportebene.</summary>
        <returns><see langword="true" />, wenn die Sicherheit serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTextEncoding">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTextEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTextEncoding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeTextEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTextEncoding () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTextEncoding();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTextEncoding : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeTextEncoding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Einstellungen für die Textcodierung serialisiert werden sollen.</summary>
        <returns><see langword="true" />, wenn die Textcodierung serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously">
      <MemberSignature Language="C#" Value="bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.System#ServiceModel#Channels#IBindingRuntimePreferences#ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ReceiveSynchronously As Boolean Implements IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ServiceModel::Channels::IBindingRuntimePreferences::ReceiveSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eingehende Anforderungen synchron oder asynchron gehandhabt werden.</summary>
        <value>Immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

Dieses Beispiel ruft den ReceiveSynchronously-Wert ab.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
IBindingRuntimePreferences s = (binding as IBindingRuntimePreferences);
bool receiveSynchronously = s.ReceiveSynchronously;
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding TextEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding TextEncoding" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.TextEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ TextEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextEncoding : System.Text.Encoding with get, set" Usage="System.ServiceModel.BasicHttpBinding.TextEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.EncodingConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeichencodierung ab oder legt die Zeichencodierung fest, die für den Meldungstext verwendet wird.</summary>
        <value>Die <see cref="T:System.Text.Encoding" />-Einstellung, die die verwendete Zeichencodierung angibt. Der Standardwert ist <see cref="T:System.Text.UTF8Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

Im folgenden Beispiel wird TextEncoding auf <xref:System.Text.Encoding.Unicode?displayProperty=nameWithType>festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.TextEncoding = System.Text.Encoding.Unicode;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
          textEncoding = "UnicodeFffeTextEncoding">

          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>
  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransferMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransferMode TransferMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.TransferMode TransferMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.TransferMode" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferMode As TransferMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransferMode TransferMode { System::ServiceModel::TransferMode get(); void set(System::ServiceModel::TransferMode value); };" />
      <MemberSignature Language="F#" Value="member this.TransferMode : System.ServiceModel.TransferMode with get, set" Usage="System.ServiceModel.BasicHttpBinding.TransferMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransferMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Nachrichten gepuffert oder gestreamt gesendet werden, oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.ServiceModel.TransferMode" />, der angibt, ob Nachrichten gepuffert oder gestreamt gesendet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

Im folgenden Beispiel wird TransferMode auf <xref:System.ServiceModel.TransferMode.Streamed>festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.TransferMode = TransferMode.Streamed;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultWebProxy">
      <MemberSignature Language="C#" Value="public bool UseDefaultWebProxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultWebProxy" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.UseDefaultWebProxy" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultWebProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultWebProxy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultWebProxy : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.UseDefaultWebProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob der automatisch konfigurierte HTTP-Proxy des Systems bei Verfügbarkeit verwendet werden soll.</summary>
        <value><see langword="true" />, wenn der automatisch konfigurierte HTTP-Proxy des Systems bei Verfügbarkeit verwendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Es ist ein Fehler, dass dieser `true` und <xref:System.ServiceModel.BasicHttpBinding.ProxyAddress> nicht NULL ist.

## Examples

In diesem Beispiel wird der Wert von UseDefaultWebProxy auf `false`festgelegt.

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.UseDefaultWebProxy = false;
```

Der Wert dieser Eigenschaft kann auch in der Konfigurationsdatei festgelegt werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
