<Type Name="ServiceHost" FullName="System.ServiceModel.ServiceHost">
  <Metadata><Meta Name="ms.openlocfilehash" Value="04f76fc37757c93c7888cb66fa3475ae48623e69" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78787367" /></Metadata><TypeSignature Language="C#" Value="public class ServiceHost : System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceHost extends System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceHost" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceHost&#xA;Inherits ServiceHostBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceHost : System::ServiceModel::ServiceHostBase" />
  <TypeSignature Language="F#" Value="type ServiceHost = class&#xA;    inherit ServiceHostBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.ServiceHostBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Host für Dienste bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementiert den Host, der vom Windows Communication Foundation (WCF)-Dienstmodell-Programmiermodell verwendet wird.  
  
 Verwenden Sie die <xref:System.ServiceModel.ServiceHost>-Klasse, um einen Dienst für die Verwendung durch Client Anwendungen zu konfigurieren und verfügbar zu machen, wenn Sie nicht Internetinformationsdienste (IIS) oder Windows Activation Services (was) verwenden, um einen Dienst verfügbar zu machen. Sowohl IIS als auch WAS interagieren für Sie mit einem <xref:System.ServiceModel.ServiceHost>-Objekt.  
  
 Um einen Dienst für die Verwendung durch Aufrufer verfügbar zu machen, erfordert WCF eine umfassende Dienst Beschreibung (dargestellt durch die <xref:System.ServiceModel.Description.ServiceDescription>-Klasse). Die <xref:System.ServiceModel.ServiceHost>-Klasse erstellt eine <xref:System.ServiceModel.Description.ServiceDescription> aus dem Diensttyp und den Konfigurationsinformationen und verwendet diese Beschreibung dann, um <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> Objekte für jeden Endpunkt in der Beschreibung zu erstellen.  
  
 Verwenden Sie ein <xref:System.ServiceModel.ServiceHost> Objekt, um einen Dienst zu laden, Endpunkte zu konfigurieren, Sicherheitseinstellungen anzuwenden und Listener zu starten, um eingehende Anforderungen zu verarbeiten.  
  
   
  
## Examples  
 [!code-csharp[S_SelfHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#1)]
 [!code-vb[S_SelfHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_selfhost/vb/wholeenchilada.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.ServiceModel.ServiceHost" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ServiceHost ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ServiceHost();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.ServiceModel.ServiceHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt zwei Konstruktoren, mit denen eine Instanz der <xref:System.ServiceModel.ServiceHost>-Klasse erstellt wird. Verwenden Sie den <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Type%2CSystem.Uri%5B%5D%29>-Konstruktor, der den Diensttyp in den meisten Fällen als Eingabeparameter annimmt. Mit diesem Konstruktor kann der Host bei Bedarf neue Dienste erstellen. Verwenden Sie stattdessen den <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29>-Konstruktor nur, wenn der Dienst Host eine bestimmte Singleton Instanz des Diensts verwenden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceHost (object singletonInstance, params Uri[] baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object singletonInstance, class System.Uri[] baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor(System.Object,System.Uri[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (singletonInstance As Object, ParamArray baseAddresses As Uri())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceHost(System::Object ^ singletonInstance, ... cli::array &lt;Uri ^&gt; ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.ServiceHost : obj * Uri[] -&gt; System.ServiceModel.ServiceHost" Usage="new System.ServiceModel.ServiceHost (singletonInstance, baseAddresses)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="singletonInstance" Type="System.Object" />
        <Parameter Name="baseAddresses" Type="System.Uri[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="singletonInstance">Die Instanz des gehosteten Diensts.</param>
        <param name="baseAddresses">Ein <see cref="T:System.Array" /> vom Typ <see cref="T:System.Uri" />, das die Basisadressen für den gehosteten Dienst enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.ServiceHost" />-Klasse mit der angegebenen Dienstinstanz und ihrer Basisadresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor als Alternative zum Implementieren eines benutzerdefinierten <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType>, wenn Sie eine bestimmte Objektinstanz für die Verwendung durch einen Singleton-Dienst bereitstellen möchten. Diese Überladung empfiehlt sich, wenn der Dienstimplementierungstyp schwer zu erstellen ist (wenn er z.&#160;B. keinen öffentlichen Standardkonstruktor implementiert, der über keine Parameter verfügt).  
  
 Beachten Sie Folgendes: Wenn ein Objekt für diese Überladung bereitgestellt wird, funktionieren einige Funktionen im Zusammenhang mit dem Windows Communication Foundation (WCF)-Instanziierungsverhalten anders. Das Aufrufen von <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> hat z. b. keine Auswirkung, wenn eine bekannte Objektinstanz mithilfe dieser Konstruktorüberladung bereitgestellt wird. Dementsprechend werden auch alle anderen Instanzfreigabemechanismen ignoriert. Der <xref:System.ServiceModel.ServiceHost> verhält sich immer so, als ob die <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> -Eigenschaft für alle Vorgänge auf <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> festgelegt ist.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost2#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost2/cs/service.cs#1)]
 [!code-vb[S_UEServiceHost2#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost2/vb/service.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="singletonInstance" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceHost (Type serviceType, params Uri[] baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type serviceType, class System.Uri[] baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor(System.Type,System.Uri[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serviceType As Type, ParamArray baseAddresses As Uri())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceHost(Type ^ serviceType, ... cli::array &lt;Uri ^&gt; ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.ServiceHost : Type * Uri[] -&gt; System.ServiceModel.ServiceHost" Usage="new System.ServiceModel.ServiceHost (serviceType, baseAddresses)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
        <Parameter Name="baseAddresses" Type="System.Uri[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="serviceType">Der Typ des gehosteten Diensts.</param>
        <param name="baseAddresses">Ein Array vom Typ <see cref="T:System.Uri" />, das die Basisadressen für den gehosteten Dienst enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.ServiceHost" />-Klasse mit dem angegebenen Diensttyp und seiner Basisadresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn Sie über den Diensttyp verfügen und bei Bedarf neue Instanzen davon erstellen können, auch wenn Sie eine Singletoninstanz benötigen. Verwenden Sie stattdessen den <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29>-Konstruktor nur, wenn der Dienst Host eine bestimmte Singleton Instanz des Diensts verwenden soll.  
  
   
  
## Examples  
 In diesem Beispiel wird veranschaulicht, wie die <xref:System.ServiceModel.ServiceHost>-Klasse zum Hosten eines Windows Communication Foundation Diensts verwendet wird:  
  
 [!code-csharp[S_UEServiceHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#1)]
 [!code-vb[S_UEServiceHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddServiceEndpoint">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem gehosteten Dienst einen Dienstendpunkt hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, string address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, string address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddServiceEndpoint (implementedContract As Type, binding As Binding, address As String) As ServiceEndpoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * string -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="implementedContract">Der <see cref="T:System.Type" /> des Vertrags für den hinzugefügten Endpunkt.</param>
        <param name="binding">Die <see cref="T:System.ServiceModel.Channels.Binding" />-Einstellung für den hinzugefügten Endpunkt.</param>
        <param name="address">Die Adresse für den hinzugefügten Endpunkt.</param>
        <summary>Fügt dem gehosteten Dienst einen Dienstendpunkt mit einem angegebenen Vertrag, einer Bindung und einer Endpunktadresse hinzu.</summary>
        <returns>Der <see cref="T:System.ServiceModel.Description.ServiceEndpoint" />, der dem gehosteten Dienst hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UEServiceHost#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#3)]
 [!code-vb[S_UEServiceHost#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> oder <paramref name="binding" /> oder <paramref name="address" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddServiceEndpoint (implementedContract As Type, binding As Binding, address As Uri) As ServiceEndpoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">Der <see cref="T:System.Type" /> des Vertrags für den hinzugefügten Endpunkt.</param>
        <param name="binding">Die <see cref="T:System.ServiceModel.Channels.Binding" />-Einstellung für den hinzugefügten Endpunkt.</param>
        <param name="address">Der <see cref="T:System.Uri" />, der die Adresse für den hinzugefügten Endpunkt enthält.</param>
        <summary>Fügt dem gehosteten Dienst einen Dienstendpunkt mit einem angegebenen Vertrag, einer Bindung und einem URI mit der Endpunktadresse hinzu.</summary>
        <returns>Der <see cref="T:System.ServiceModel.Description.ServiceEndpoint" />, der dem gehosteten Dienst hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UEServiceHost#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#4)]
 [!code-vb[S_UEServiceHost#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> oder <paramref name="binding" /> oder <paramref name="address" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, string address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, string address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.String,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddServiceEndpoint (implementedContract As Type, binding As Binding, address As String, listenUri As Uri) As ServiceEndpoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * string * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">Der <see cref="T:System.Type" /> des Vertrags für den hinzugefügten Endpunkt.</param>
        <param name="binding">Die <see cref="T:System.ServiceModel.Channels.Binding" />-Einstellung für den hinzugefügten Endpunkt.</param>
        <param name="address">Die Endpunktadresse für den Dienst.</param>
        <param name="listenUri">Der <see cref="T:System.Uri" />, an dem die Dienstendpunkte lauschen können.</param>
        <summary>Fügt dem gehosteten Dienst einen Dienstendpunkt mit einem angegebenen Vertrag, einer Bindung, einer Endpunktadresse und einem URI, an dem der Dienst lauscht, hinzu.</summary>
        <returns>Der <see cref="T:System.ServiceModel.Description.ServiceEndpoint" />, der dem gehosteten Dienst hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Version der Methode, wenn Sie über mehrere Endpunkte verfügen, die am gleichen URI lauschen müssen.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#5)]
 [!code-vb[S_UEServiceHost#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> oder <paramref name="binding" /> oder <paramref name="address" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, Uri address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddServiceEndpoint (implementedContract As Type, binding As Binding, address As Uri, listenUri As Uri) As ServiceEndpoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * Uri * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">Der <see cref="T:System.Type" /> des Vertrags für den hinzugefügten Endpunkt.</param>
        <param name="binding">Die <see cref="T:System.ServiceModel.Channels.Binding" />-Einstellung für den hinzugefügten Endpunkt.</param>
        <param name="address">Der <see cref="T:System.Uri" />, der die Adresse für den hinzugefügten Endpunkt enthält.</param>
        <param name="listenUri">Der <see cref="T:System.Uri" />, an dem die Dienstendpunkte lauschen können.</param>
        <summary>Fügt dem gehosteten Dienst einen Dienstendpunkt mit einem angegebenen Vertrag, einer Bindung, einem URI mit der Endpunktadresse und einem URI, den der Dienst überwacht, hinzu.</summary>
        <returns>Der <see cref="T:System.ServiceModel.Description.ServiceEndpoint" />, der dem gehosteten Dienst hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Version der Methode, wenn Sie über mehrere Endpunkte verfügen, die am gleichen URI lauschen müssen.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#6)]
 [!code-vb[S_UEServiceHost#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> oder <paramref name="binding" /> oder <paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Verträge werden nicht initialisiert, oder die Vertragsschlüssel können nicht gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void ApplyConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ApplyConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.ApplyConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ApplyConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ApplyConfiguration();" />
      <MemberSignature Language="F#" Value="override this.ApplyConfiguration : unit -&gt; unit" Usage="serviceHost.ApplyConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lädt die Dienstbeschreibung aus der Konfigurationsdatei und wendet sie auf die Laufzeit an, die erstellt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDescription">
      <MemberSignature Language="C#" Value="protected override System.ServiceModel.Description.ServiceDescription CreateDescription (out System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Description.ContractDescription&gt; implementedContracts);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ServiceModel.Description.ServiceDescription CreateDescription([out] class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Description.ContractDescription&gt;&amp; implementedContracts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.CreateDescription(System.Collections.Generic.IDictionary{System.String,System.ServiceModel.Description.ContractDescription}@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDescription (ByRef implementedContracts As IDictionary(Of String, ContractDescription)) As ServiceDescription" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::ServiceModel::Description::ServiceDescription ^ CreateDescription([Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Description::ContractDescription ^&gt; ^ % implementedContracts);" />
      <MemberSignature Language="F#" Value="override this.CreateDescription : IDictionary -&gt; System.ServiceModel.Description.ServiceDescription" Usage="serviceHost.CreateDescription implementedContracts" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceDescription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContracts" Type="System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Description.ContractDescription&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="implementedContracts">Das <see cref="T:System.Collections.Generic.IDictionary`2" /> mit Schlüsselpaaren eines Typs (<see cref="T:System.String" />, <see cref="T:System.ServiceModel.Description.ContractDescription" />), der die verschlüsselten Verträge des gehosteten Diensts enthält, die implementiert wurden.</param>
        <summary>Erstellt eine Beschreibung des gehosteten Diensts.</summary>
        <returns>Eine <see cref="T:System.ServiceModel.Description.ServiceDescription" /> des gehosteten Diensts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um Vertragsbeschreibungen aus benutzerdefinierten Programmiermodellen zu erstellen. Überschreiben Sie die entsprechende Basisklassen Methode, <xref:System.ServiceModel.ServiceHostBase.CreateDescription%28System.Collections.Generic.IDictionary%7BSystem.String%2CSystem.ServiceModel.Description.ContractDescription%7D%40%29>, um das angepasste Modell zu implementieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ des gehosteten Diensts ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="InitializeDescription">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine Beschreibung des auf der Grundlage seines Typ oder seiner Instanz gehosteten Dienst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entfernt die Anforderung, Basisadressen als Teil <xref:System.ServiceModel.ServiceHost.%23ctor%2A>zu übergeben. Klassen, die von <xref:System.ServiceModel.ServiceHost> erben, können <xref:System.ServiceModel.ServiceHost.%23ctor%2A> aufzurufen und dann einen der <xref:System.ServiceModel.ServiceHost.InitializeDescription%2A> aufzurufen, wenn eine Basisadresse verfügbar ist. Auf diese Weise wird das Service Model Metadata Utility Tool (Svcutil.exe) implementiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (object singletonInstance, System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(object singletonInstance, class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.InitializeDescription(System.Object,System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (singletonInstance As Object, baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(System::Object ^ singletonInstance, System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="override this.InitializeDescription : obj * System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHost.InitializeDescription (singletonInstance, baseAddresses)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="singletonInstance" Type="System.Object" />
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="singletonInstance">Die Instanz des gehosteten Diensts.</param>
        <param name="baseAddresses">Die <see cref="T:System.ServiceModel.UriSchemeKeyedCollection" />, die die Basisadressen für den gehosteten Dienst enthält.</param>
        <summary>Initialisiert eine Beschreibung des auf der Grundlage seiner Instanz und der angegebenen Basisadressen gehosteten Dienst.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="singletonInstance" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (Type serviceType, System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(class System.Type serviceType, class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.InitializeDescription(System.Type,System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (serviceType As Type, baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(Type ^ serviceType, System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="override this.InitializeDescription : Type * System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHost.InitializeDescription (serviceType, baseAddresses)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="serviceType">Der <see cref="T:System.Type" /> des gehosteten Diensts.</param>
        <param name="baseAddresses">Die <see cref="T:System.ServiceModel.UriSchemeKeyedCollection" />, die die Basisadressen für den gehosteten Dienst enthält.</param>
        <summary>Initialisiert eine Beschreibung des auf der Grundlage seines Typs und der angegebenen Basisadressen gehosteten Dienst.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="serviceHost.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verwirft gehostete Dienste, wenn der Diensthost geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.ServiceModel.ServiceHost.OnClosed%2A>-Methode überschreiben, müssen Sie die Basis sicherstellen. Die OnClosed-Methode wird aufgerufen, auch wenn eine Ausnahme auftritt. Dies wird im folgenden Code veranschaulicht.  
  
```  
protected override void OnClosed()  
{  
    try  
    {  
        if (FaultFlagService.faultFlag == ThrowDuring.OnClosed)  
        {  
            FaultFlagService.faultFlag = ThrowDuring.Never;  
            throw new ServiceActivationException("Faulting the service because FaultFlagService.faultFlag = ThrowDuring.OnClosed");  
        }  
    }  
    finally  
    {  
        base.OnClosed();  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SingletonInstance">
      <MemberSignature Language="C#" Value="public object SingletonInstance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SingletonInstance" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHost.SingletonInstance" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SingletonInstance As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SingletonInstance { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SingletonInstance : obj" Usage="System.ServiceModel.ServiceHost.SingletonInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Singletoninstanz des gehosteten Diensts ab.</summary>
        <value>Das gehostete Dienstobjekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie den <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29>-Konstruktor, um eine Singleton Instanz des Dienstanbieter zu initialisieren, der gehostet werden soll, wenn Sie die Instanz des Dienstanbieter steuern möchten, der verwendet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
