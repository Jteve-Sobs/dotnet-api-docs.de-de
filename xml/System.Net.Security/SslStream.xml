<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="595c8b079b56e602a81ac703884f6eee7a00231b" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691845" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <TypeSignature Language="VB.NET" Value="Public Class SslStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SslStream : System::Net::Security::AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen für die Client/Server-Kommunikation verwendeten Datenstrom bereit, der das Sicherheitsprotokoll Secure Socket Layer (SSL) zur Authentifizierung des Servers und optional des Clients verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der SSL-Protokolle Vertraulichkeit und Integrität, die Meldungen mit übertragen geprüft bieten eine <xref:System.Net.Security.SslStream>. Eine SSL-Verbindung, z. B. von <xref:System.Net.Security.SslStream>, sollten werden verwendet, wenn Kommunikation vertraulichen Informationen zwischen einem Client und einem Server. Mithilfe einer <xref:System.Net.Security.SslStream> hilft zu verhindern, dass Benutzer lesen und manipulieren Informationen, während es bei der Übertragung im Netzwerk befindet.  
  
 Ein <xref:System.Net.Security.SslStream> Instanz überträgt Daten mit einem Stream, den Sie angeben, für die Erstellung der <xref:System.Net.Security.SslStream>. Wenn Sie diese zugrunde liegenden Stream bereitstellen, haben Sie die Option zur Angabe, ob das Schließen der <xref:System.Net.Security.SslStream> schließt auch die zugrunde liegenden Stream. In der Regel die <xref:System.Net.Security.SslStream> Klasse wird verwendet, mit der <xref:System.Net.Sockets.TcpClient> und <xref:System.Net.Sockets.TcpListener> Klassen. Die <xref:System.Net.Sockets.TcpClient.GetStream%2A> Methode bietet eine <xref:System.Net.Sockets.NetworkStream> geeignet für die Verwendung mit der <xref:System.Net.Security.SslStream> Klasse.  
  
 Nach dem Erstellen einer <xref:System.Net.Security.SslStream>, den Server und optional der Client authentifiziert werden müssen. Der Server muss ein X509 bereitgestellt, Zertifikat, stellt seine Identitätsnachweis her und kann anfordern, dass der Client dies auch tun. Authentifizierung muss erfolgen, bevor übertragen Informationen mithilfe einer <xref:System.Net.Security.SslStream>. Clients initiieren die Authentifizierung mit den synchronen <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> -Methoden, die blockiert werden, bis die Authentifizierung abgeschlossen wurde, oder den asynchronen <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> -Methoden, die Wartezeit für die Authentifizierung abgeschlossen nicht blockieren. Server initiieren die Authentifizierung mit den synchronen <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> oder asynchrone <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden. Sowohl Client als auch Server müssen die Authentifizierung initiiert werden.  
  
 Die Authentifizierung erfolgt über die Security Support Provider (SSPI)-Channel-Anbieters. Der Client erhält die Gelegenheit zur Validierung des Serverzertifikats durch Angabe steuern eine <xref:System.Net.Security.RemoteCertificateValidationCallback> delegate beim Erstellen einer <xref:System.Net.Security.SslStream>. Der Server kann auch steuern Überprüfung durch Angabe einer <xref:System.Net.Security.RemoteCertificateValidationCallback> delegieren. Die Methode, die der Delegat verweist umfasst der Remoteanbieter Zertifikat und ggf. aufgetretenen Fehlern SSPI, die bei der Überprüfung des Zertifikats. Beachten Sie, dass der Server über einen Delegaten an, der Delegat-Methode so aufgerufen wird, unabhängig davon, ob der Server die Clientauthentifizierung angefordert. Wenn der Server nicht die Clientauthentifizierung angefordert hat, empfängt Delegatmethode des Servers ein null-Zertifikat und ein leeres Array vom Zertifikatfehler.  
  
 Wenn der Server die Clientauthentifizierung erforderlich ist, muss der Client eine oder mehrere Zertifikate für die Authentifizierung angeben. Wenn der Client mehr als ein Zertifikat verfügt, kann der Client Bereitstellen einer <xref:System.Net.Security.LocalCertificateSelectionCallback> Delegat, der das richtige Zertifikat für den Server auswählen. Die Zertifikate des Clients müssen in der aktuellen Zertifikatspeicher des Benutzers "My" befinden. Die Clientauthentifizierung über Zertifikate wird nicht unterstützt, für die <xref:System.Security.Authentication.SslProtocols.Ssl2> -Protokoll (SSL-Version 2).  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und die <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 Wenn der Authentifizierungsprozess, auch bekannt als SSL-Handshake, erfolgreich ist, wird die Identität des Servers (und optional den Client) hergestellt und die <xref:System.Net.Security.SslStream> kann von Client und Server für den Austausch von Nachrichten verwendet werden. Vor dem Senden oder Empfangen von Informationen, Client und Server sollte überprüfen Sie die Sicherheitsdienste und gebotenen Ebenen der <xref:System.Net.Security.SslStream> zu bestimmen, ob die Anforderungen für die Integrität und Vertraulichkeit Protokoll, Algorithmen und Stärken ausgewählt zu erfüllen. Wenn die aktuellen Einstellungen nicht ausreichen, sollte der Stream geschlossen werden. Sehen Sie sich die Sicherheitsdienste gebotenen der <xref:System.Net.Security.SslStream> mithilfe der <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften. Die folgende Tabelle zeigt die Elemente, die die kryptografischen zurückgegeben, für die Authentifizierung, Verschlüsselung und Signierung von Daten verwendet.  
  
|Element|Member|  
|-------------|-------------|  
|Das Sicherheitsprotokoll verwendet, um den Server und optional den Client zu authentifizieren.|Die <xref:System.Net.Security.SslStream.SslProtocol%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.SslProtocols> Enumeration.|  
|Der Algorithmus für den Schlüsselaustausch.|Die <xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.ExchangeAlgorithmType> Enumeration.|  
|Algorithmus für die Integrität.|Die <xref:System.Net.Security.SslStream.HashAlgorithm%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.HashAlgorithmType> Enumeration.|  
|Algorithmus für die Vertraulichkeit.|Die <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> Eigenschaft und den zugehörigen <xref:System.Security.Authentication.CipherAlgorithmType> Enumeration.|  
|Die Stärken der ausgewählten Algorithmen.|Die <xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>, <xref:System.Net.Security.SslStream.HashStrength%2A>, und <xref:System.Net.Security.SslStream.CipherStrength%2A> Eigenschaften.|  
  
 Nach einer erfolgreichen Authentifizierung können Sie Daten mithilfe von synchronen senden <xref:System.Net.Security.SslStream.Write%2A> oder asynchrone <xref:System.Net.Security.SslStream.BeginWrite%2A> Methoden. Möglicherweise erhalten Sie Daten mithilfe von synchronen <xref:System.Net.Security.SslStream.Read%2A> oder asynchrone <xref:System.Net.Security.SslStream.BeginRead%2A> Methoden.  
  
 Wenn Sie angegeben haben, um die <xref:System.Net.Security.SslStream.%23ctor%2A> , dass der zugrunde liegende Stream geöffnet bleiben werden sollte, Sie sind verantwortlich für Stream schließen, wenn Sie fertig sind verwenden.  
  
> [!NOTE]
>  Wenn die Anwendung erstellt wird, die die <xref:System.Net.Security.SslStream> -Objekt mit den Anmeldeinformationen eines Standardbenutzers ausgeführt wird, die Anwendung wird nicht in der Lage, Zugriff auf die Zertifikate im Speicher lokalen Computers installiert werden, es sei denn, die Berechtigung wurde dem Benutzer explizit erteilt.  
  
 <xref:System.Net.Security.SslStream> setzt voraus, dass ein Timeout sowie alle anderen <xref:System.IO.IOException> bei einer ausgelöst wird, vom inneren Datenstrom wird als schwerwiegend behandelt durch den Aufrufer. Wiederverwenden von einem <xref:System.Net.Security.SslStream> -Instanz nach ein Timeout Garbage zurückgegeben wird. Eine Anwendung sollte <xref:System.IO.Stream.Close%2A> die <xref:System.Net.Security.SslStream> und löst eine Ausnahme in diesen Fällen.  
  
 .NET Framework 4.6 umfasst eine neue Sicherheitsfunktion, die unsichere Verschlüsselungssammlungen und Hashalgorithmen für Verbindungen blockiert. Anwendungen verwenden TLS/SSL über APIs wie z. B. "HttpClient", HttpWebRequest-Anforderung, FTPClient, SmtpClient, SslStream usw. und .NET Framework 4.6 abzielt erhalten die sicherere Verhalten in der Standardeinstellung.  
  
 Möglicherweise möchten Entwickler dieses Verhalten abzuwählen, um die Interoperabilität mit ihrer vorhandenen SSL3-Diensten oder TLS mit RC4-Dienste zu verwalten. [In diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie Ihren Code ändern, damit das neue Verhalten deaktiviert ist.  
  
 Die .NET Framework-4.7 fügt neue Überladungen für die Methoden, die SslStreams zu, die die TLS-Protokollversion, die als Systemstandard im definierte verwenden authentifizieren, sondern geben Sie eine TLS-Version nicht [SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx). Verwenden Sie diese Methoden in Ihrer app als eine Möglichkeit, die Standardwerte später als TLS Version best-Practice-Änderungen im Laufe der Zeit ändern können ohne die Notwendigkeit zum Erstellen und bereitzustellen, die app.

 Siehe auch [Transport Layer Security (TLS) bewährte Methoden mit .NET Framework](~/docs/framework/network-programming/tls.md).
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer <xref:System.Net.Sockets.TcpListener> , verwendet die <xref:System.Net.Security.SslStream> Klasse für die Kommunikation mit Clients.  
  
 [!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
 [!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer <xref:System.Net.Sockets.TcpClient> , verwendet die <xref:System.Net.Security.SslStream> Klasse für die Kommunikation mit einem Server.  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Security.NegotiateStream" />
    <altmember cref="T:System.Net.Security.AuthenticatedStream" />
    <altmember cref="T:System.IO.IOException" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.SslStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass die <xref:System.Net.Security.SslStream> schließt den Stream, den Sie angeben, verwenden die <xref:System.Net.Security.SslStream.%23ctor%2A> Konstruktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.SslStream" />-Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> kann nicht gelesen werden.  -"oder" - <paramref name="innerStream" /> ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  -"oder" - <paramref name="innerStream" /> gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" /> und streamen Closure-Verhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.SslStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> kann nicht gelesen werden.  -"oder" - <paramref name="innerStream" /> ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  -"oder" - <paramref name="innerStream" /> gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <param name="userCertificateValidationCallback">Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> verantwortlich für die Überprüfung des Zertifikats, das von der Remoteseite bereitgestellten Delegaten.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />, Streamen Closure-Verhalten und ein Zertifikat Überprüfung Delegaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.SslStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
 Die `userCertificateValidationCallback` des Delegaten `certificateErrors` Argument enthält alle Windows-Fehlercodes, die vom Kanal Security Support Provider Interface (SSPI) zurückgegeben. Der Rückgabewert der Methode aufgerufen, indem die `userCertificateValidationCallback` Delegaten bestimmt, ob die Authentifizierung erfolgreich ist.  
  
 Das Sicherheitsprotokoll und Kryptografiealgorithmen sind bereits ausgewählt, wenn die `userCertificateValidationCallback` des Delegaten-Methode aufgerufen wird. Sie können die Methode verwenden, um festzustellen, ob die ausgewählten kryptografische Algorithmen und die Vorteile für Ihre Anwendung ausreichen. Wenn nicht, der Methodenrückgabewert `false` um zu verhindern, dass die <xref:System.Net.Security.SslStream> erstellt werden.  
  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung nach Möglichkeit wiederverwendet. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element des <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden), oder versucht, eine anonyme Sitzung wiederzuverwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ist leer.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Security.SslStream> und den Clientteil der Authentifizierung initiiert.  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> kann nicht gelesen werden.  -"oder" - <paramref name="innerStream" /> ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  -"oder" - <paramref name="innerStream" /> gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback, userCertificateSelectionCallback As LocalCertificateSelectionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <param name="userCertificateValidationCallback">Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> verantwortlich für die Überprüfung des Zertifikats, das von der Remoteseite bereitgestellten Delegaten.</param>
        <param name="userCertificateSelectionCallback">Ein <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> Delegaten verantwortlich für die Auswahl des Zertifikats für die Authentifizierung verwendet.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />, Streamen Closure-Verhalten, Zertifikat Überprüfung Delegaten und Zertifikat Auswahl Delegaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.SslStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
 Die `userCertificateValidationCallback` des Delegaten `certificateErrors` Argument enthält alle Windows-Fehlercodes, die vom Kanal Security Support Provider Interface (SSPI) zurückgegeben. Der Rückgabewert der Methode aufgerufen, indem die `userCertificateValidationCallback` Delegaten bestimmt, ob die Authentifizierung erfolgreich ist.  
  
 Das Sicherheitsprotokoll und Kryptografiealgorithmen sind bereits ausgewählt, wenn die `userCertificateValidationCallback` des Delegaten-Methode aufgerufen wird. Sie können die Methode verwenden, um festzustellen, ob die ausgewählten kryptografische Algorithmen und die Vorteile für Ihre Anwendung ausreichen. Wenn nicht, der Methodenrückgabewert `false` um zu verhindern, dass die <xref:System.Net.Security.SslStream> erstellt werden.  
  
 Die `userCertificateSelectionCallback` Delegat ist hilfreich, wenn Ihre Anwendung verfügt über mehrere Zertifikate und ein Zertifikat muss dynamisch auswählen. Zertifikate im Speicher "MY" werden an die Methode wird aufgerufen, durch den Delegaten übergeben.  
  
 Wenn ein Wert in der Konfigurationsdatei für Encryptionpolicy, nicht angegeben ist die <xref:System.Net.Security.EncryptionPolicy> standardmäßig <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> für die <xref:System.Net.Security.SslStream> -Instanz, die erstellt wird.  
  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die Verschlüsselungsrichtlinie, um festgelegt ist <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung nach Möglichkeit wiederverwendet. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element der P:System.Net.HttpWebRequest.ClientCertificates (sofern vorhanden) oder versucht, eine anonyme Sitzung wiederzuverwenden, wenn P:System.Net.HttpWebRequest.ClientCertificates ist leer.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.SslStream> Klasse.  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> kann nicht gelesen werden.  -"oder" - <paramref name="innerStream" /> ist nicht beschreibbar.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  -"oder" - <paramref name="innerStream" /> gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback, System::Net::Security::EncryptionPolicy encryptionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten.</param>
        <param name="leaveInnerStreamOpen">Ein boolescher Wert, der das Verhalten der Schließung des angibt der <see cref="T:System.IO.Stream" /> Objekt, das verwendet wird, indem die <see cref="T:System.Net.Security.SslStream" /> für das Senden und Empfangen von Daten. Dieser Parameter gibt an, ob die inneren Datenstroms freigehalten wird.</param>
        <param name="userCertificateValidationCallback">Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> verantwortlich für die Überprüfung des Zertifikats, das von der Remoteseite bereitgestellten Delegaten.</param>
        <param name="userCertificateSelectionCallback">Ein <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> Delegaten verantwortlich für die Auswahl des Zertifikats für die Authentifizierung verwendet.</param>
        <param name="encryptionPolicy">Der zu verwendende <see cref="T:System.Net.Security.EncryptionPolicy" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Security.SslStream" /> -Klasse mit dem angegebenen <see cref="T:System.IO.Stream" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung von Null-Verschlüsselung ist erforderlich, wenn die `encryptionPolicy` Parametersatz auf <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> kann nicht gelesen werden.  -"oder" - <paramref name="innerStream" /> ist nicht beschreibbar.  -"oder" - <paramref name="encryptionPolicy" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  -"oder" - <paramref name="innerStream" /> gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Die Clientseite der ein Client / Server-Verbindung zu authentifizieren.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <summary>Wird von Clients zur Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Bei der Authentifizierung werden keine Clientzertifikate verwendet. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene Zertifikatsammlung und das SSL-Standardprotokoll des Systems.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene zertifikatauflistung und die SSL-Protokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Die Clientseite der ein Client / Server-Verbindung als asynchronen Vorgang zu authentifizieren.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <summary>Wird von Clients zur asynchronen Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Bei der Authentifizierung werden keine Clientzertifikate verwendet. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::Security::SslClientAuthenticationOptions ^ sslClientAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslClientAuthenticationOptions" Type="System.Net.Security.SslClientAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslClientAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur asynchronen Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene Zertifikatsammlung und das SSL-Standardprotokoll des Systems.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Clients zur asynchronen Authentifizierung des Servers und optional des Clients in einer Client-Server-Verbindung verwendet. Der Authentifizierungsprozess verwendet die angegebene zertifikatauflistung und die SSL-Protokoll.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird vom Server zur Authentifizierung des Servers und optional den Client in einem Client / Server-Verbindung aufgerufen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das Zertifikat zur Authentifizierung des Servers verwendet.</param>
        <summary>Wird vom Server zur Authentifizierung des Servers und optional den Client in eine Client / Server-Verbindung mit dem angegebenen Zertifikat aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der Client ist nicht erforderlich, um ein Zertifikat für die Authentifizierung bereitzustellen.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Clientauthentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client-Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Standardsicherheitsprotokolls des Systems zu authentifizieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Clientauthentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client/Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls zu authentifizieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> ist kein gültiger <see cref="T:System.Security.Authentication.SslProtocols" />-Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Clientauthentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird vom Server zur Authentifizierung des Servers und optional den Client in einem Client / Server-Verbindung als asynchronen Vorgang aufgerufen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das Zertifikat zur Authentifizierung des Servers verwendet.</param>
        <summary>Wird vom Server zur Authentifizierung des Servers und optional den Client in eine Client / Server-Verbindung mit dem angegebenen Zertifikat als asynchronen Vorgang aufgerufen.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Diese Methode authentifiziert sich mit <xref:System.Security.Authentication.SslProtocols.Default>. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der Client ist nicht erforderlich, um ein Zertifikat für die Authentifizierung bereitzustellen.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Clientauthentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::Security::SslServerAuthenticationOptions ^ sslServerAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslServerAuthenticationOptions" Type="System.Net.Security.SslServerAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslServerAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client/Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls als asynchronen Vorgang zu authentifizieren.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <summary>Wird von Servern aufgerufen, um den Server und optional den Client in einer Client/Server-Verbindung mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls als asynchronen Vorgang zu authentifizieren.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen Vorgang zum Authentifizieren von der Clientseite der ein Client / Server-Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Zum Blockieren während des Wartens auf der Authentifizierung abzuschließen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird von Clients beginnen einen asynchronen Vorgang zum Authentifizieren des Servers und optional dem Client aufgerufen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Bei der Authentifizierung werden keine Clientzertifikate verwendet. Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft.  
  
 Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird von Clients aufgerufen, um einen asynchronen Vorgang zur Authentifizierung des Servers und optional des Clients mithilfe der angegebenen Zertifikate und des Standardsicherheitsprotokolls des Systems zu beginnen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Der Name des Servers, der diesen <see cref="T:System.Net.Security.SslStream" /> freigibt.</param>
        <param name="clientCertificates">Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den Clientzertifikaten.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird von Clients beginnen einen asynchronen Vorgang zum Authentifizieren des Servers und optional den Client mithilfe der angegebenen Zertifikate und Sicherheitsprotokoll aufgerufen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Der angegebene Wert für `targetHost` muss dem Namen auf das Zertifikat des Servers entsprechen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
> [!NOTE]
>  Clientzertifikate werden im SSL-Protokoll Version 2 nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> ist kein gültiger <see cref="T:System.Security.Authentication.SslProtocols" />-Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die Serverseite der Authentifizieren einer Client / Server-Verbindung zu behandeln.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Zum Blockieren während des Wartens auf der Authentifizierung abzuschließen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird vom Server um einen asynchronen Vorgang zum Authentifizieren des Clients zu starten und optional die Server in einem Client / Server-Verbindung aufgerufen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Die Zertifikatsperrliste wird während der Authentifizierung nicht überprüft. Der Client ist nicht erforderlich, um ein Zertifikat für die Authentifizierung bereitzustellen.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Clientauthentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird von Servern aufgerufen, um einen asynchronen Vorgang zur Authentifizierung des Servers und optional des Clients mithilfe der angegebenen Zertifikate, Anforderungen und des Standardsicherheitsprotokolls des Systems zu beginnen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Das zum Authentifizieren des Servers verwendete X509Certificate.</param>
        <param name="clientCertificateRequired">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob der Client nach einem Zertifikat für die Authentifizierung gefragt wird. Beachten Sie, dass dies nur eine Anforderung ist – wenn kein Zertifikat bereitgestellt wird, akzeptiert der Server weiterhin die Verbindungsanforderung.</param>
        <param name="enabledSslProtocols">Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</param>
        <param name="checkCertificateRevocation">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob die Zertifikatssperrliste während der Authentifizierung überprüft wird.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird von Servern aufgerufen, um einen asynchronen Vorgang zur Authentifizierung des Servers und optional des Clients mithilfe der angegebenen Zertifikate, Anforderungen und des Sicherheitsprotokolls zu beginnen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn Sie erhalten eine <xref:System.Security.Authentication.AuthenticationException>, gibt diese <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> ist kein gültiger <see cref="T:System.Security.Authentication.SslProtocols" />-Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  - oder - Server-Authentifizierung, die mit diesem <see cref="T:System.Net.Security.SslStream" /> zuvor versucht wurde.  -oder-Authentifizierung wird bereits ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />-Methode wird unter Windows 95, Windows 98 bzw. Windows Millennium nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, die Bytes empfängt, aus dem Stream lesen.</param>
        <param name="offset">Der nullbasierte Speicherort in <c>buffer</c>, ab dem die aus diesem Stream gelesenen Daten gespeichert werden.</param>
        <param name="count">Die maximale Anzahl von Bytes, die aus dem Datenstrom gelesen werden soll.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" /> Delegat, der auf die Methode verweist, die beim Abschluss des Lesevorgangs aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen über den Lesevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Startet einen asynchronen Lesevorgang, der Daten aus dem Stream liest und speichert ihn im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Verschlüsselung und Signierung aktiviert sind, wird der Lesevorgang liest die Daten aus den zugrunde liegenden Stream, überprüft die Integrität der Daten und/oder entschlüsselt. Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.SslStream.EndRead%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.SslStream.Read%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.SslStream> Klasse mehrere gleichzeitige Lesevorgänge nicht unterstützt.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Lesevorgang ab.  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
  
 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)]  
  
 Die folgende Methode wird aufgerufen, wenn nach des Lesevorgangs Abschluss.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; die Länge von <paramref name="buffer" />.  -"oder" - <paramref name="offset" /> + Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.  -"oder" - Verschlüsselung wird verwendet, aber die Daten konnten nicht entschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die in den Stream zu schreibenden Bytes angibt.</param>
        <param name="offset">Der nullbasierte Speicherort in <c>buffer</c>, ab dem das Lesen der in den Stream zu schreibenden Bytes beginnen soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" />-Wert, der die Anzahl der aus <c>buffer</c> zu lesenden Bytes angibt.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" /> Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Schreibvorgang abgeschlossen ist.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zu den Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang, der schreibt <see cref="T:System.Byte" />s aus dem angegebenen Puffer in den Stream.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode.  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; die Länge von <paramref name="buffer" />.  -"oder" - <paramref name="offset" /> + Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream gelesen werden kann.</summary>
        <value>
          <see langword="true" /> Wenn Authentifizierung aufgetreten ist und der zugrunde liegende Stream gelesen wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.CanRead%2A> auf den zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream durchsucht werden.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Versuchen Sie nicht die Position des festzulegenden der <xref:System.Net.Security.SslStream> Objekt oder die zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.CanSeek" />
        <altmember cref="P:System.Net.Security.SslStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream Timeouts unterstützt.</summary>
        <value>
          <see langword="true" /> Wenn der zugrunde liegende Stream Timeouts unterstützt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.CanTimeout%2A> auf den zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob der zugrunde liegende Stream geschrieben werden kann.</summary>
        <value>
          <see langword="true" /> Wenn die Authentifizierung erfolgt ist, und der zugrunde liegende Stream beschreibbar ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.CanWrite%2A> auf den zugrunde liegenden Stream.  
  
 Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.SslStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CheckCertRevocationStatus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CheckCertRevocationStatus { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CheckCertRevocationStatus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die Zertifikatsperrliste, während der Überprüfung des Zertifikats überprüft wird.</summary>
        <value>
          <see langword="true" />, wenn die Zertifikatsperrliste überprüft wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zertifikatsperrliste enthält Zertifikate, die vom Aussteller gesperrt wurden. Überprüfen die Liste negativ wirkt sich auf die Leistung jedoch erhöht die anwendungssicherheit.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherAlgorithm As CipherAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::CipherAlgorithmType CipherAlgorithm { System::Security::Authentication::CipherAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, den Bulk-Verschlüsselungsalgorithmus verwendet, die von diesem identifiziert <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Ein <see cref="T:System.Security.Authentication.CipherAlgorithmType" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wert <xref:System.Security.Authentication.CipherAlgorithmType.Null> ist erforderlich, damit die <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> Eigenschaft bei der <xref:System.Net.Security.EncryptionPolicy.NoEncryption> Enumerationswert dient zum Erstellen einer <xref:System.Net.Security.SslStream> Instanz.  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)] und [!INCLUDE[winxp](~/includes/winxp-md.md)] unterstützen nicht die <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wert. Auch wenn die <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wert dient zum Erstellen der <xref:System.Net.Security.SslStream> -Instanz, die <xref:System.Net.Security.EncryptionPolicy> -Eigenschaft <xref:System.Security.Authentication.CipherAlgorithmType.None>. Die <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wert wird nur zurückgegeben, unter Windows Vista und höher.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /> Eigenschaft wurde zugegriffen, vor dem Fehler beim Abschluss den Authentifizierungsprozess abgebrochen oder im Authentifizierungsprozess sorgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CipherStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der die Stärke des von diesem verwendeten Verschlüsselungsalgorithmus identifiziert <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Ein <see cref="T:System.Int32" /> Wert, der die Stärke des Algorithmus in Bits angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist 0 (null), bis die Authentifizierung erfolgt.  
  
 Diese Eigenschaft gibt einen der folgenden Werte zurück:  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Security.SslStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.Net.Security.SslStream> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen nicht verwaltete Resources](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsClient(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</param>
        <summary>Beendet ein ausstehende asynchrone Server-Authentifizierung-Vorgang gestartet wird, mit einem vorherigen Aufruf von <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ausgeführt wurde, müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch einen Aufruf erstellt <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Serverauthentifizierung abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsServer(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</param>
        <summary>Beendet ein ausstehende asynchrone Client-Authentifizierung-Vorgang gestartet wird, mit einem vorherigen Aufruf von <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ausgeführt wurde, müssen Sie überprüfen, die <xref:System.Net.Security.SslStream.IsEncrypted%2A> und <xref:System.Net.Security.SslStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.SslStream>. Überprüfen Sie die <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException>, und dies <xref:System.Net.Security.SslStream> ist nicht mehr funktionsfähig. Sie sollten dieses Objekt schließen und entfernen alle Verweise darauf, damit sie vom Garbage Collector erfasst werden kann.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch einen Aufruf erstellt <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Bei der Authentifizierung ist ein Fehler aufgetreten, und dieses Objekt wurde in einem unbrauchbaren Zustand hinterlassen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Clientauthentifizierung abgeschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndRead(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Beendet ein asynchroner Lesevorgang, mit einem vorherigen Aufruf von gestartet <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Anzahl der Bytes zu lesen, aus dem zugrunde liegenden Stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.SslStream.Read%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass das Beenden eines asynchronen Lesevorgang.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndWrite(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> durch einen Aufruf zurückgegebene Instanz <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Beendet ein asynchronen Schreibvorgang, mit einem vorherigen Aufruf von gestartet <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Eine Anwendung kann nicht auf diese Methode aufrufen, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.SslStream.Write%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Schreibvorgang beendet.  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass alle gepufferten Daten an das zugrunde liegende Gerät geschrieben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.Flush%2A> auf den zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode.  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashAlgorithm As HashAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::HashAlgorithmType HashAlgorithm { System::Security::Authentication::HashAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Algorithmus zum Generieren von Nachrichtenauthentifizierungscodes (MACs) an.</summary>
        <value>Ein <see cref="T:System.Security.Authentication.HashAlgorithmType" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachrichtenauthentifizierungsalgorithmen generieren nachrichtenhashes und Signaturen zum Erkennen von Manipulationen und Fälschung von Nachrichten verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /> Eigenschaft wurde zugegriffen, vor dem Fehler beim Abschluss den Authentifizierungsprozess abgebrochen oder im Authentifizierungsprozess sorgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der die Stärke des Hashalgorithmus, der von dieser Instanz verwendeten identifiziert.</summary>
        <value>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Stärke der <see cref="T:System.Security.Authentication.HashAlgorithmType" /> -Algorithmus in Bits. Gültige Werte sind 128 oder 160.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist 0 (null), bis die Authentifizierung erfolgt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die Authentifizierung erfolgreich war.</summary>
        <value>
          <see langword="true" /> Wenn eine erfolgreicher Authentifizierung erfolgt ist andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Authentifizieren Sie Clients durch Aufrufen der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> Methoden. Server-Authentifizierung durch Aufrufen der <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsEncrypted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob dies <see cref="T:System.Net.Security.SslStream" /> datenverschlüsselung verwendet.</summary>
        <value>
          <see langword="true" /> Wenn die Daten vor der Übertragung über das Netzwerk verschlüsselt und entschlüsselt erreicht Wenn den Remoteendpunkt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -Verschlüsselung hilft, den Schutz der Daten, d. h. ist es hilfreich, stellen Sie sicher, dass während Daten übertragen werden, es von Dritten gelesen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsMutuallyAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob sowohl Client als auch Server authentifiziert wurden.</summary>
        <value>
          <see langword="true" /> Wenn der Server authentifiziert wurden. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gegenseitiger Authentifizierung wird vom Server angegeben, wenn der Server den Client ein Zertifikat zur Authentifizierung bereitstellen möchte.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />
        <altmember cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsServer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob dies die lokale Seite der Verbindung verwendeten <see cref="T:System.Net.Security.SslStream" /> wie der Server authentifiziert wurde.</summary>
        <value>
          <see langword="true" /> Wenn der lokale Endpunkt als die Serverseite der die authentifizierte Verbindung erfolgreich authentifiziert wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung fehlgeschlagen oder ist nicht erfolgt ist, gibt diese Eigenschaft `false`.  
  
 Rufen Sie zur Authentifizierung wie der Server die <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsSigned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Boolean" /> Wert, der angibt, ob die mit diesem Stream gesendeten Daten signiert wurde.</summary>
        <value>
          <see langword="true" /> Wenn die Daten vor der Übertragung signiert ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datensignatur hilft Ihnen bei der die Integrität der Daten zu schützen, hilft es nämlich den Empfänger zu bestimmen, ob die Daten bei der Übertragung manipuliert wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As ExchangeAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::ExchangeAlgorithmType KeyExchangeAlgorithm { System::Security::Authentication::ExchangeAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, die von diesem verwendeten Schlüsselaustauschalgorithmus <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Ein <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist <xref:System.Security.Authentication.ExchangeAlgorithmType.None> bis zur Authentifizierung.  
  
 Der Schlüsselaustauschalgorithmus schützt Informationen, die zum Generieren von gemeinsam verwendeten Schlüssel verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyExchangeStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der die Stärke des von dieser Instanz verwendeten Algorithmus für den Schlüsselaustausch identifiziert.</summary>
        <value>Ein <see cref="T:System.Int32" /> Wert, der angibt, die Stärke der <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> -Algorithmus in Bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft ist 0 (null), bis die Authentifizierung erfolgt.  
  
 In allgemeinen Szenarien ist der Wert dieser Eigenschaft eine der folgenden:  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Kryptografieeinstellungen für den angegebenen Stream.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des zugrunde liegenden Stream ab.</summary>
        <value>Ein <see cref="T:System.Int64" />.  Die Länge des zugrunde liegenden Stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.Length%2A> auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, löst diese Methode in der Regel eine Ausnahme aus. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegenden Stream ist ein <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LocalCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ LocalCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.LocalCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zertifikat zur Authentifizierung des lokalen Endpunkts ab.</summary>
        <value>Ein X509Certificate-Objekt, das für die Authentifizierung bereitgestellte Zertifikat darstellt, oder <see langword="null" /> , wenn kein Zertifikat angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das von dieser Eigenschaft zurückgegebene Zertifikat.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentifizierung fehlgeschlagen, oder es ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedApplicationProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NegotiatedApplicationProtocol As SslApplicationProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslApplicationProtocol NegotiatedApplicationProtocol { System::Net::Security::SslApplicationProtocol get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslApplicationProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die aktuelle Position in den zugrunde liegenden Stream.</summary>
        <value>Ein <see cref="T:System.Int64" />.  Die aktuelle Position in den zugrunde liegenden Stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.Position%2A> auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, löst diese Methode in der Regel eine Ausnahme aus. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Durch Festlegen dieser Eigenschaft wird nicht unterstützt.  – oder – Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegenden Stream ist ein <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Read(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes empfängt, die aus diesem Stream gelesene.</param>
        <param name="offset">Ein <see cref="T:System.Int32" />-Typ, der den nullbasierten Speicherort in <c>buffer</c> enthält, ab dem die aus diesem Stream gelesenen Daten gespeichert werden.</param>
        <param name="count">Ein <see cref="T:System.Int32" /> , die die maximale Anzahl der aus diesem Stream gelesenen Bytes enthält.</param>
        <summary>Liest Daten aus diesen Datenstrom und speichert ihn im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.Int32" /> Wert, der die Anzahl der gelesenen Bytes angibt. Wenn es keine weiteren Daten ist gelesen werden, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode liest ein Maximum von `count` Bytes aus dem Stream und speichert sie in `buffer` beginnend `offset`. Sie können nicht mehrere gleichzeitige Lesevorgänge ausführen.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang asynchron auszuführen, verwenden Sie die <xref:System.Net.Security.SslStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Lesen aus einer <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; die Länge von <paramref name="buffer" />.  -"oder" - <paramref name="offset" /> + Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang. Überprüfen Sie die innere Ausnahme, falls vorhanden, um die Ursache des Fehlers zu bestimmen.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.ReadTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Zeitspanne, die ein Lesevorgang warten Daten blockiert.</summary>
        <value>Ein <see cref="T:System.Int32" /> , die die Zeitspanne, die verstreicht, bevor ein synchroner Vorgang fehl lesen angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.ReadTimeout%2A> auf den zugrunde liegenden Stream. Beim Festlegen dieser Eigenschaft die <xref:System.IO.Stream.ReadTimeout%2A> Wert auf den zugrunde liegenden Stream mit dem angegebenen Wert festgelegt ist.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.ReadTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> standardmäßig, sodass Lesevorgänge verfügen nicht über ein Timeout.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ RemoteCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.RemoteCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zertifikat, mit den Remoteendpunkt zu authentifizieren.</summary>
        <value>Ein X509Certificate-Objekt, das für die Authentifizierung bereitgestellte Zertifikat darstellt, oder <see langword="null" /> , wenn kein Zertifikat angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das von dieser Eigenschaft zurückgegebene Zertifikat.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentifizierung fehlgeschlagen, oder es ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Wert wird ignoriert.</param>
        <param name="origin">Dieser Wert wird ignoriert.</param>
        <summary>Löst eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht. Geerbt wird, aber wird nicht von der <xref:System.Net.Security.SslStream> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Unterstützt keine Suchvorgänge durch <see cref="T:System.Net.Security.SslStream" /> Objekte.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.SetLength(System.Int64)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Int64" /> Wert, der die Länge des Streams angibt.</param>
        <summary>Legt die Länge des zugrunde liegenden Streams fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType> auf den zugrunde liegenden Stream angegeben, wenn dies <xref:System.Net.Security.SslStream> erstellt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShutdownAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ ShutdownAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fährt diesen SslStream herunter.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SslProtocol As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::SslProtocols SslProtocol { System::Security::Authentication::SslProtocols get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.SslProtocol</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der das Sicherheitsprotokoll verwendet, um diese Verbindung authentifizieren angibt.</summary>
        <value>Die <see cref="T:System.Security.Authentication.SslProtocols" /> Wert, der für die Authentifizierung verwendeten Protokolls darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die unterstützten Sicherheitsprotokolle werden angegeben. wenn die <xref:System.Net.Security.SslStream> wird erstellt. Wenn kein Sicherheitsprotokoll an den Konstruktor übergeben wurde, die Instanz wird mit erstellt <xref:System.Security.Authentication.SslProtocols.Default>. Das tatsächliche Protokoll für die Authentifizierung aktiviert ist, basierend auf den vom Client und Server unterstützten Protokolle.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Sicherheitseigenschaften des angegebenen Datenstroms.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.TransportContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Net.TransportContext" /> für die Authentifizierung mit erweitertem Schutz verwendet.</summary>
        <value>Die <see cref="T:System.Net.TransportContext" /> Objekt, das für den erweiterten Schutz verwendet Kanalbindungstoken (CBT) enthält.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten in diesen Datenstrom.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes in den Stream geschrieben bereitstellt.</param>
        <summary>Schreibt die angegebenen Daten zu diesem Datenstrom.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, während der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, während der Vorgang abgeschlossen ist, verwenden die <xref:System.Net.Security.SslStream.BeginWrite%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.SslStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Schreiben in eine authentifizierte <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" /> Array, das die Bytes in den Stream geschrieben bereitstellt.</param>
        <param name="offset">Ein <see cref="T:System.Int32" />-Typ, der den nullbasierten Speicherort in <c>buffer</c> enthält, ab dem das Lesen der in den Stream zu schreibenden Bytes beginnen soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" />-Typ, der die Anzahl der aus <c>buffer</c> zu lesenden Bytes enthält.</param>
        <summary>Schreiben Sie die angegebene Anzahl von <see cref="T:System.Byte" />s in den zugrunde liegenden Stream unter Verwendung des angegebenen Puffers und Offset.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, während der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, während der Vorgang abgeschlossen abgeschlossen ist, verwenden Sie die <xref:System.Net.Security.SslStream.BeginWrite%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Aufruf der Authentifizierung der <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, oder <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.SslStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; die Länge von <paramref name="buffer" />.  -"oder" - <paramref name="offset" /> + Count &gt; die Länge des <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
        <exception cref="T:System.NotSupportedException">Es ist bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Authentifizierung ist nicht aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.WriteTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Zeitspanne, die Ausführung eines Schreibvorgangs auf Daten zu warten, blockiert.</summary>
        <value>Ein <see cref="T:System.Int32" /> , die die Zeitspanne, die verstreicht, bevor Sie ein synchronen Schreibvorgang fehlschlägt angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen <xref:System.IO.Stream.WriteTimeout%2A> auf den zugrunde liegenden Stream. Für Mengenoperationen, den angegebene Wert fest, der <xref:System.IO.Stream.WriteTimeout%2A> Wert auf den zugrunde liegenden Stream.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.WriteTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> standardmäßig, sodass Schreibvorgänge nicht zu einem Timeout verfügen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>