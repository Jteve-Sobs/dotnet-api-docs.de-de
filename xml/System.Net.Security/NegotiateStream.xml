<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d525bc672bac1f9e8322fe3609ac7a7bfff4ee84" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56389367" /></Metadata><TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type NegotiateStream = class&#xA;    inherit AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Stream bereit, der mit dem Sicherheitsprotokoll Negotiate den Client und optional den Server für die Kommunikation zwischen Client und Server authentifiziert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Net.Security.NegotiateStream> Klasse, für die Authentifizierung und Sicherung von Informationen zwischen einem Client und einem Server übertragen. Mithilfe von <xref:System.Net.Security.NegotiateStream>, können Sie Folgendes tun.  
  
-   Senden Sie die Anmeldeinformationen des Clients an den Server für den Identitätswechsel oder Delegierung.  
  
-   Fordern Sie Server-Authentifizierung.  
  
-   Verschlüsselt und/oder signiert Sie Daten vor der Übertragung.  
  
 Authentifizierung muss vor der Übermittlung von Daten ausgeführt werden. Clients fordern, Authentifizierung, die mit den synchronen <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methoden, die blockiert, bis die Authentifizierung abgeschlossen ist, oder die asynchrone <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> -Methoden, die während des Wartens auf der Authentifizierung beendet nicht blockieren. Server anfordern, Authentifizierung, die mit den synchronen <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden. Der Client und optional dem Server wird mit dem Sicherheitsprotokoll Negotiate authentifiziert. Auf Windows 95-und Windows 98-Systemen ist Windows NT LAN Manager (NTLM) das Protokoll für die Authentifizierung verwendet. Auf anderen Plattformen wird das Kerberos wird Protokoll für die Authentifizierung verwendet, wenn sowohl Client als auch Server unterstützt. Andernfalls wird NTLM verwendet. Eine ausführliche Beschreibung dieser Protokolle finden Sie unter der Plattform-SDK-Dokumentation auf MSDN an msdn.microsoft.com/library/. Die <xref:System.Net.Security.NegotiateStream> Klasse führt die Authentifizierung mit der Security Support Provider Interface (SSPI).  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> von Eigenschaften, um zu bestimmen, welche Sicherheitsdienste verwendet werden die <xref:System.Net.Security.NegotiateStream> um Ihre Daten während der Übertragung zu schützen. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist. Erhalten Sie Informationen über die remote-Client oder Server mit der <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> Eigenschaft.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Senden von Daten, die mit den synchronen <xref:System.Net.Security.NegotiateStream.Write%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> Methoden. Empfangen von Daten, die mit den synchronen <xref:System.Net.Security.NegotiateStream.Read%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Methoden. Wenn Sicherheitsdienste wie Verschlüsselung oder Signierung aktiviert sind, werden diese automatisch angewendet auf Ihre Daten durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Die <xref:System.Net.Security.NegotiateStream> überträgt Daten mithilfe eines Datenstroms, die Sie, beim Erstellen angeben der <xref:System.Net.Security.NegotiateStream>. Wenn Sie diese zugrunde liegenden Stream bereitstellen, haben Sie die Option zur Angabe, ob durch Schließen der <xref:System.Net.Security.NegotiateStream> auch die zugrunde liegende Stream geschlossen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Clientseite einer Client-/ Serververbindung, die verwendet die <xref:System.Net.Security.NegotiateStream>. Der Client authentifiziert und sendet eine Nachricht asynchron an den Server.  
  
 [!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
 [!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, die serverbasierten Aspekte von eine Client / Server-Verbindung, verwendet der <xref:System.Net.Security.NegotiateStream> zum Authentifizieren des Clients und Lesen einer Nachricht vom Client gesendet werden.  
  
 [!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
 [!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Änderungen an der NTLM-Authentifizierung für "HttpWebRequest" in Version 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.NegotiateStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie den Konstruktor <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29>, um zu verhindern, dass der von Ihnen bereitgestellte Stream durch <xref:System.Net.Security.NegotiateStream> geschlossen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" />-Objekt, das von <see cref="T:System.Net.Security.NegotiateStream" /> zum Senden und Empfangen von Daten verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.NegotiateStream" />-Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream * bool -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" />-Objekt, das von <see cref="T:System.Net.Security.NegotiateStream" /> zum Senden und Empfangen von Daten verwendet wird.</param>
        <param name="leaveInnerStreamOpen"><see langword="true" />, um anzugeben, dass das Schließen dieses <see cref="T:System.Net.Security.NegotiateStream" /> keine Auswirkungen auf <paramref name="innerStream" /> hat. <see langword="false" />, um anzugeben, dass durch Schließen dieses <see cref="T:System.Net.Security.NegotiateStream" /> auch <paramref name="innerStream" /> geschlossen wird.</param>
        <summary>Verwendet den angegebenen <see cref="T:System.Net.Security.NegotiateStream" /> und das Schlussverhalten des Streams zum Initialisieren einer neuen Instanz der <see cref="T:System.IO.Stream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Angeben von `true` für die `leaveStreamOpen` Parameter schließen die <xref:System.Net.Security.NegotiateStream> hat keine Auswirkungen auf die `innerStream` streamen, müssen Sie explizit schließen `innerStream` nicht mehr benötigte.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.NegotiateStream> Klasse.  
  
 [!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
 [!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : unit -&gt; unit&#xA;override this.AuthenticateAsClient : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Client die <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen und die Channelbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter abgerufen werden würde, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft für das zugeordnete <xref:System.Net.Security.SslStream>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und Authentifizierungsoptionen verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">"<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist NULL.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, Authentifizierungsoptionen und die Channelbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter abgerufen werden würde, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft für das zugeordnete <xref:System.Net.Security.SslStream>.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">"<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Client die <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen und die Channelbindung verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter abgerufen werden würde, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft für das zugeordnete <xref:System.Net.Security.SslStream>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und Authentifizierungsoptionen verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">"<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist NULL.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, Authentifizierungsoptionen und die Channelbindung verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter abgerufen werden würde, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft für das zugeordnete <xref:System.Net.Security.SslStream>.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">"<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Behandelt die Serverseite einer Authentifizierung für eine Client-/Serververbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden blockiert, während die Authentifizierung ausgeführt wird. Um die Anwendung blockiert, während des Wartens auf der Authentifizierung abgeschlossen zu verhindern, verwenden Sie die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : unit -&gt; unit&#xA;override this.AuthenticateAsServer : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsServer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode wird blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit" Usage="negotiateStream.AuthenticateAsServer policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess wird die angegebene erweiterte Schutzrichtlinie verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode wird blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Serveridentität.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen und die angegebenen Authentifizierungsoptionen verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode wird blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen, Authentifizierungsoptionen und die erweiterte Schutzrichtlinie verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `policy` Parameter `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode wird blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Behandelt die Serverseite für eine Authentifizierung einer Client-/Serververbindung als eines asynchronen Vorgang.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang. Für den Authentifizierungsprozess wird die angegebene erweiterte Schutzrichtlinie verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Serveridentität.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang. Beim Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen und die angegebenen Authentifizierungsoptionen verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang. Für den Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen, Authentifizierungsoptionen und die erweiterte Schutzrichtlinie verwendet.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `policy` Parameter `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die Clientseite einer Client-/Serververbindung zu authentifizieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Um zu blockieren, bis die Authentifizierung abgeschlossen, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Client die <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. Die <xref:System.Net.Security.NegotiateStream> Klasse wird den zur gegenseitigen Authentifizierung verwendeten SPN zu erstellen.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode, um eine asynchrone Authentifizierung für den Client zu starten.  
  
 [!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
 [!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und die Channelbindung verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und Authentifizierungsoptionen verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, Authentifizierungsoptionen und die Channelbindung verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die serverseitige Authentifizierung einer Client-/Serververbindung durchzuführen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während die Authentifizierung ausgeführt wird. Beim Warten auf der Authentifizierung beendet blockieren, verwenden Sie die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (policy, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess wird die angegebene erweiterte Schutzrichtlinie verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) wird für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen und die angegebenen Authentifizierungsoptionen verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen, Authentifizierungsoptionen und die erweiterte Schutzrichtlinie verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter, um die Anforderung Sicherheitsdienste für Daten, die mit dem authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Sie müssen überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die `policy` Parameter `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierung-Vorgang muss abgeschlossen werden, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
- oder - 
Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die Bytes empfängt, die aus dem Stream gelesen werden.</param>
        <param name="offset">Der nullbasierte Speicherort im <paramref name="buffer" />, ab dem die aus diesem Stream gelesenen Daten gespeichert werden.</param>
        <param name="count">Die maximale Anzahl an Bytes, die aus dem Stream gelesen werden sollen.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Lesevorgang beendet ist.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Lesevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Startet einen asynchronen Lesevorgang, der Daten aus dem Stream liest und im angegebenen Array speichert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, wird der Lesevorgang liest die Daten aus den zugrunde liegenden Stream, überprüft die Integrität der Daten und entschlüsselt. Wenn keine Sicherheitsdienste wie Verschlüsselung von Daten oder zum Signieren verwendet werden, beginnt diese Methode einen asynchronen Lesevorgang im zugrunde liegenden Stream.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndRead%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.NegotiateStream> -Klasse gleichzeitig mehrere Lesevorgänge nicht unterstützt. Wenn Sie versuchen, einen Lesevorgang gestartet werden, während eine andere lesen Vorgang wird bereits ausgeführt, für den gleichen Stream, einen <xref:System.NotSupportedException> Ausnahme ausgelöst.  
  
 Diese Methode kann nicht aufgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen asynchronen Lesevorgang ab. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.NegotiateStream> Klasse.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.  
  
- oder - 
Die Verschlüsselung wird verwendet, die Daten konnten jedoch nicht entschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es wird bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die Bytes bereitstellt, die in den Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Speicherort in <paramref name="buffer" />, ab dem das Lesen der in den Stream zu schreibenden Bytes begonnen werden soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" />-Wert, der die Anzahl der vom <paramref name="buffer" /> zu lesenden Bytes angibt.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Schreibvorgang beendet wurde.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="asyncCallback" />-Delegaten übergeben.</param>
        <summary>Startet einen asynchronen Schreibvorgang, der <see cref="T:System.Byte" /> vom angegebenen Puffer in den Stream schreibt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, diese Methode liest die Daten aus dem Puffer, verschlüsselt, signiert oder verschlüsselt und signiert es und überträgt sie mithilfe der zugrunde liegenden Stream. Wenn keine Sicherheitsdienste wie Verschlüsselung von Daten oder zum Signieren verwendet werden, beginnt diese Methode einen asynchronen Schreibvorgang auf den zugrunde liegenden Stream.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndWrite%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.NegotiateStream> -Klasse unterstützt nicht mehrere gleichzeitige Schreibvorgänge. Wenn Sie versuchen, einen Schreibvorgang gestartet werden, während ein anderer Write-Vorgang bereits, für den gleichen Stream ausgeführt wird, einen <xref:System.NotSupportedException> Ausnahme ausgelöst.  
  
 Diese Methode kann nicht aufgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen asynchronen Schreibvorgang ab.  
  
 [!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
 [!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
  
 Die folgende Methode wird aufgerufen, wenn der Vorgang abgeschlossen ist.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 Die Summe von <paramref name="offset" /> und count ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.  
  
- oder - 
Die Verschlüsselung wird verwendet, die Daten konnten jedoch nicht verschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es wird bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der zugrunde liegende Stream gelesen werden kann.</summary>
        <value><see langword="true" />, wenn die Authentifizierung erfolgt ist und der zugrunde liegende Stream lesbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es sich bei erfolgreicher Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.CanRead%2A> Eigenschaft im zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der zugrunde liegende Stream durchsucht werden kann.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten nicht versuchen, die Position des festzulegenden der <xref:System.Net.Security.NegotiateStream> Objekt oder die zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der zugrunde liegende Stream Timeouts unterstützt.</summary>
        <value><see langword="true" />, wenn der zugrunde liegende Stream Timeouts unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.CanTimeout%2A> Eigenschaft im zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob im zugrunde liegenden Stream geschrieben werden kann.</summary>
        <value><see langword="true" />, wenn die Authentifizierung erfolgt ist und im zugrunde liegende Stream geschrieben werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es sich bei erfolgreicher Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.CanWrite%2A> Eigenschaft im zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="negotiateStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Security.NegotiateStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter true ist, gibt diese Methode alle Ressourcen frei, die für verwaltete Objekte, die dieses <xref:System.Net.Security.NegotiateStream> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die zuvor von einem früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="negotiateStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> zurückgegeben wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Clientauthentifizierungsvorgang, der mit einem Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ist, müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> erstellt.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Clientauthentifizierung vorhanden, die beendet werden muss.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> zurückgegeben wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Clientauthentifizierungsvorgang, der mit einem Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften fest, welche Sicherheitsdienste von verwendet werden, um die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung fehlschlägt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Um diesen Vorgang synchron auszuführen, verwenden die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> erstellt.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Authentifizierung vorhanden, die beendet werden muss.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="negotiateStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> zurückgegeben wird.</param>
        <summary>Beendet einen asynchronen Lesevorgang, der mit einem Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> gestartet wurde.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der die Anzahl von Bytes angibt, die aus dem zugrunde liegenden Stream gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Diese Methode kann nicht aufgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass das Beenden eines asynchronen Lesevorgang. Ein Beispiel zur Veranschaulichung der Vorgang wird gestartet, finden Sie unter <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">asyncResult wurde nicht durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist kein ausstehender Lesevorgang vorhanden, der beendet werden muss.

- oder -

Es ist keine Authentifizierung erfolgt.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="negotiateStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> zurückgegeben wird.</param>
        <summary>Beendet einen asynchronen Schreibvorgang, der mit einem Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Diese Methode kann nicht aufgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang synchron auszuführen, verwenden die <xref:System.Net.Security.NegotiateStream.Write%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Methode, die aufgerufen wird, um den asynchronen Schreibvorgang abgeschlossen wird. Ein Beispiel zur Veranschaulichung der Vorgang wird gestartet, finden Sie unter <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">asyncResult wurde nicht durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist kein ausstehender Schreibvorgang vorhanden, der beendet werden muss.

- oder -

Es ist keine Authentifizierung erfolgt.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="negotiateStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Veranlasst das Schreiben aller gepufferten Daten in das zugrunde liegende Gerät.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.Flush%2A> im zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, leeren den Stream.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie der Server die Clientanmeldeinformationen verwenden kann.</summary>
        <value>Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen erfolgreich authentifizieren, bevor diese Methode aufgerufen. Clients geben die Identitätswechselebene an, wenn sie die Authentifizierung anfordern, durch Aufrufen einer der der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Methoden. Wenn Sie eine ohne Angabe Authentifizierung einer <xref:System.Security.Principal.TokenImpersonationLevel> , <xref:System.Security.Principal.TokenImpersonationLevel.Identification> wird verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bei der Authentifizierung ist ein Fehler aufgetreten, oder es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die Authentifizierung erfolgreich war.</summary>
        <value><see langword="true" />, wenn die Authentifizierung erfolgreich war, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Authentifizieren von Clients durch Aufrufen der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Methoden. Server authentifizieren, durch den Aufruf der <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob dieser <see cref="T:System.Net.Security.NegotiateStream" /> verschlüsselte Daten verwendet.</summary>
        <value><see langword="true" />, wenn Daten vor der Netzwerkübertragung verschlüsselt und am Remoteendpunkt entschlüsselt werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschlüsselung ist hilfreich, den Schutz der Daten. Insbesondere kann sichergestellt werden, während Daten während der Übertragung werden es von Drittanbietern gelesen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob sowohl der Server als auch der Client authentifiziert wurden.</summary>
        <value><see langword="true" />, wenn der Server authentifiziert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gegenseitiger Authentifizierung wird vom Client angegeben werden, wenn der Client den Server für die Anmeldeinformationen für die Authentifizierung benötigt. Standardmäßig fordern die Clients gegenseitigen Authentifizierung.  
  
 Das Aushandlungsprotokoll wählt NTLM oder Kerberos, abhängig von die Sicherheitsprotokolle, die vom Client und Server unterstützt. NTLM ist die gegenseitigen Authentifizierung nicht unterstützt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die lokale, von diesem <see cref="T:System.Net.Security.NegotiateStream" /> verwendete Seite der Verbindung als Server authentifiziert wurde.</summary>
        <value><see langword="true" />, wenn der lokale Endpunkt erfolgreich als Serverseite der authentifizierten Verbindung authentifiziert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung ist fehlgeschlagen oder ist nicht erfolgt ist, gibt diese Eigenschaft `false`.  
  
 Rufen Sie zur Authentifizierung wie der Server die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die mit diesem Stream gesendeten Daten signiert sind.</summary>
        <value><see langword="true" />, wenn die Daten vor der Übertragung signiert werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Signieren von Daten hilft, um die Integrität der Daten zu schützen; Insbesondere wird dadurch den Empfänger feststellen kann, ob die Daten bei der Übertragung manipuliert wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des zugrunde liegenden Streams ab.</summary>
        <value>Ein <see cref="T:System.Int64" />, der die Länge des zugrunde liegenden Streams angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.Length%2A> Eigenschaft im zugrunde liegenden Stream. Wenn Sie der zugrunde liegenden Datenstrom nicht suchbar ist, wird diese Eigenschaft in der Regel eine Ausnahme ausgelöst. Die Run-Time-Typ, der den zugrunde liegenden Stream bestimmt die Run-Time-Typ der Ausnahme, die ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegende Stream ein <see cref="T:System.Net.Sockets.NetworkStream" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position im zugrunde liegenden Stream ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int64" />, der die aktuelle Position im zugrunde liegenden Stream angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.Position%2A> Eigenschaft im zugrunde liegenden Stream. Wenn Sie der zugrunde liegenden Datenstrom nicht suchbar ist, wird diese Eigenschaft in der Regel eine Ausnahme ausgelöst. Die Run-Time-Typ, der den zugrunde liegenden Stream bestimmt die Run-Time-Typ der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Festlegen dieser Eigenschaft wird nicht unterstützt.  
  
- oder - 
Das Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegende Stream ein <see cref="T:System.Net.Sockets.NetworkStream" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="negotiateStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die Bytes empfängt, die aus dem Stream gelesen werden.</param>
        <param name="offset">Ein <see cref="T:System.Int32" />, der den nullbasierten Speicherort im <paramref name="buffer" /> enthält, ab dem die aus diesem Stream gelesenen Daten gespeichert werden.</param>
        <param name="count">Ein <see cref="T:System.Int32" />, der die maximale Anzahl der aus dem Stream gelesenen Bytes enthält.</param>
        <summary>Liest Daten aus diesem Stream und speichert sie im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der die Anzahl von Bytes angibt, die aus dem zugrunde liegenden Stream gelesen werden. Gibt 0 (null) zurück, wenn keine weiteren zu lesenden Daten vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode liest maximal `count` Bytes aus dem aktuellen stream und speichert diese im `buffer` beginnend bei `offset`.  
  
 Diese Methode kann nicht aufgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang asynchron auszuführen, verwenden die <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Lesen aus einer <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
        <exception cref="T:System.NotSupportedException">Es wird gerade ein <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />-Vorgang ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Lesevorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, der die Zeitspanne angibt, nach deren Ablauf ein Lesevorgang fehlschlägt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.ReadTimeout%2A> Eigenschaft im zugrunde liegenden Stream. Beim Festlegen dieser Eigenschaft die <xref:System.IO.Stream.ReadTimeout%2A> Wert im zugrunde liegenden Stream mit dem angegebenen Wert festgelegt ist.  
  
 Wenn der zugrunde liegende Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> in Millisekunden angegeben und nastaven NA hodnotu <xref:System.Threading.Timeout.Infinite> standardmäßig, damit Lesevorgänge Vorgänge werden nicht automatisch gelöscht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen zur Identität der Remoteseite ab, für die dieser authentifizierte Stream freigegeben ist.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IIdentity" />-Objekt, das die Identität des Remoteendpunkts beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vom Client zugegriffen wird, gibt diese Eigenschaft eine <xref:System.Security.Principal.GenericIdentity> , enthält der Name (SPN) des Servers und das verwendete Authentifizierungsprotokoll. Wenn durch den Server zugegriffen wird, gibt diese Eigenschaft eine <xref:System.Security.Principal.WindowsIdentity> , der den Client beschreibt. Wenn die <xref:System.Security.Principal.WindowsIdentity> ist nicht verfügbar ist, Client-Informationen wird zurückgegeben, mit dem Server in einem <xref:System.Security.Principal.GenericIdentity>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bei der Authentifizierung ist ein Fehler aufgetreten, oder es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="negotiateStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Wert wird ignoriert.</param>
        <param name="origin">Dieser Wert wird ignoriert.</param>
        <summary>Löst <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht auf. Es wird geerbt, jedoch wird nicht von <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Security.NegotiateStream" /> unterstützt keine Suchvorgänge.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="negotiateStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Int64" />-Wert, der die Länge des Streams angibt.</param>
        <summary>Legt die Länge des zugrunde liegenden Streams fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="negotiateStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die in den Stream geschriebenen Bytes bereitstellt.</param>
        <param name="offset">Ein <see cref="T:System.Int32" />, der den nullbasierten Speicherort im <paramref name="buffer" /> enthält, ab dem das Lesen der in den Stream zu schreibenden Bytes begonnen werden soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" />, der die Anzahl der aus dem <paramref name="buffer" /> gelesenen Bytes enthält.</param>
        <summary>Schreiben Sie die angegebene Anzahl von <see cref="T:System.Byte" /> mit dem angegebenen Puffer und dem angegebenen Offset in den zugrunde liegenden Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, diese Methode liest die Daten aus dem Puffer, verschlüsselt, signiert oder verschlüsselt und signiert es und überträgt sie mithilfe der zugrunde liegenden Stream. Wenn keine Sicherheitsdienste wie Verschlüsselung von Daten oder zum Signieren verwendet werden, diese Methode ruft <xref:System.IO.Stream.Write%2A> im zugrunde liegenden Stream.  
  
 Diese Methode wird blockiert, wenn der Schreibvorgang abgeschlossen wird. Um zu verhindern, blockiert, während der Vorgang abgeschlossen ist, verwenden Sie die <xref:System.Net.Security.NegotiateStream.Write%2A> Methode.  
  
 Diese Methode kann nicht aufgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.NegotiateStream> -Klasse unterstützt nicht mehrere gleichzeitige Schreibvorgänge. Wenn Sie versuchen, einen Schreibvorgang gestartet werden, während ein anderer Write-Vorgang bereits, für den gleichen Stream ausgeführt wird, einen <xref:System.NotSupportedException> Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Schreiben in eine <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
- oder - 
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder - 
 Die Summe von <paramref name="offset" /> und count ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.  
  
- oder - 
Die Verschlüsselung wird verwendet, die Daten konnten jedoch nicht verschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es wird bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Schreibvorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, der die Zeitspanne angibt, nach deren Ablauf ein Schreibvorgang fehlschlägt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch den Aufruf zurückgegebenen der <xref:System.IO.Stream.WriteTimeout%2A> Eigenschaft im zugrunde liegenden Stream. Für Set-Vorgänge den angegebene Wert fest, die <xref:System.IO.Stream.WriteTimeout%2A> Wert im zugrunde liegenden Stream.  
  
 Wenn der zugrunde liegende Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> in Millisekunden angegeben und nastaven NA hodnotu <xref:System.Threading.Timeout.Infinite> standardmäßig, sodass Schreibvorgänge Vorgänge werden nicht automatisch gelöscht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Wert dieser Eigenschaft angezeigt.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>