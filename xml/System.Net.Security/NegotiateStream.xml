<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c14dd401696189bb315395ed828de5f1c0c89ba3" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461134" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Stream bereit, der mit dem Sicherheitsprotokoll Negotiate den Client und optional den Server für die Kommunikation zwischen Client und Server authentifiziert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Net.Security.NegotiateStream> Klasse zur Authentifizierung und zum Schutz von Informationen zwischen einem Client und einem Server übertragen. Mit <xref:System.Net.Security.NegotiateStream>, können Sie wie folgt vorgehen.  
  
-   Senden Sie die Anmeldeinformationen des Clients an den Server für den Identitätswechsel oder Delegierung.  
  
-   Fordern Sie Server-Authentifizierung.  
  
-   Verschlüsseln und/oder Signieren von Daten vor der Übertragung.  
  
 Authentifizierung muss vor der Übermittlung von Daten ausgeführt werden. Clients die Authentifizierung mithilfe von synchronen anfordern <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> -Methoden, die blockiert werden, bis die Authentifizierung abgeschlossen wurde, oder den asynchronen <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> -Methoden, die während des Wartens auf das Beenden der Authentifizierung nicht blockieren. Server anfordern Authentifizierung mithilfe von synchronen <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden. Der Client und optional den Server wird mithilfe des Negotiate-Sicherheitsprotokolls authentifiziert. Auf Windows 95-und Windows 98-Systemen ist Windows NT LAN Manager (NTLM) das Protokoll für die Authentifizierung verwendet. Auf anderen Plattformen wird das Kerberos wird Protokoll für die Authentifizierung verwendet, wenn sowohl Client als auch Server unterstützen. Andernfalls wird NTLM verwendet. Eine ausführliche Beschreibung dieser Protokolle finden Sie unter der Platform SDK-Dokumentation auf MSDN zur msdn.microsoft.com/library/. Die <xref:System.Net.Security.NegotiateStream> -Klasse führt die Authentifizierung über die Security Support Provider Interface (SSPI).  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> von Eigenschaften, um zu bestimmen, welche Sicherheitsdienste verwendet werden die <xref:System.Net.Security.NegotiateStream> auf Ihre Daten während der Übertragung zu schützen. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist. Sie erhalten Informationen über die remote-Client oder Server mit der <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> Eigenschaft.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Senden von Daten mit den synchronen <xref:System.Net.Security.NegotiateStream.Write%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> Methoden. Empfangen von Daten, die mit der synchronen <xref:System.Net.Security.NegotiateStream.Read%2A> oder asynchrone <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Methoden. Wenn Sicherheitsdienste, z. B. Verschlüsselung oder Signierung aktiviert sind, werden diese automatisch angewendet auf Ihre Daten durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Die <xref:System.Net.Security.NegotiateStream> überträgt Daten mithilfe eines Datenstroms, die Sie angeben, für die Erstellung der <xref:System.Net.Security.NegotiateStream>. Wenn Sie diese zugrunde liegenden Stream bereitstellen, haben Sie die Option zur Angabe, ob das Schließen der <xref:System.Net.Security.NegotiateStream> schließt auch die zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Clientseite eine Client / Server-Verbindung, verwendet die <xref:System.Net.Security.NegotiateStream>. Der Client authentifiziert und sendet eine Nachricht asynchron an den Server.  
  
 [!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
 [!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, das serverseitige eine Client / Server-Verbindung, verwendet die <xref:System.Net.Security.NegotiateStream> zum Authentifizieren des Clients und Lesen einer Nachricht vom Client gesendet.  
  
 [!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
 [!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.NegotiateStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass die <xref:System.Net.Security.NegotiateStream> schließt den Stream, den Sie angeben, verwenden die <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> Konstruktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" />-Objekt, das von <see cref="T:System.Net.Security.NegotiateStream" /> zum Senden und Empfangen von Daten verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Security.NegotiateStream" />-Klasse mit dem angegebenen <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Ein <see cref="T:System.IO.Stream" />-Objekt, das von <see cref="T:System.Net.Security.NegotiateStream" /> zum Senden und Empfangen von Daten verwendet wird.</param>
        <param name="leaveInnerStreamOpen">
          <see langword="true" />, um anzugeben, dass das Schließen dieses <see cref="T:System.Net.Security.NegotiateStream" /> keine Auswirkungen auf <c>innerstream</c> hat. <see langword="false" />, um anzugeben, dass durch Schließen dieses <see cref="T:System.Net.Security.NegotiateStream" /> auch <c>innerStream</c> geschlossen wird.</param>
        <summary>Verwendet den angegebenen <see cref="T:System.Net.Security.NegotiateStream" /> und das Schlussverhalten des Streams zum Initialisieren einer neuen Instanz der <see cref="T:System.IO.Stream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie bei `true` für die `leaveStreamOpen` -Parameter schließen die <xref:System.Net.Security.NegotiateStream> hat keine Auswirkungen auf die `innerStream` streamen; müssen Sie explizit schließen `innerStream` Wenn Sie ihn nicht mehr benötigen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Aufrufen dieses Konstruktors. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.NegotiateStream> Klasse.  
  
 [!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
 [!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="innerStream" /> ist gleich <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Clients <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen und die Channelbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und Authentifizierungsoptionen verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          "<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist NULL.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, Authentifizierungsoptionen und die Channelbindung verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          "<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Clients <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Clientanmeldeinformationen und die Channelbindung verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, und die gegenseitige Authentifizierung wird angefordert. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und Authentifizierungsoptionen verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          "<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist NULL.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Clients zum Authentifizieren des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindung als asynchroner Vorgang aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, Authentifizierungsoptionen und die Channelbindung verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> zum erweiterten Schutz, der an diese Methode in der `binding` Parameter würde abgerufen werden, von einer Anwendung aus <xref:System.Net.Security.SslStream.TransportContext%2A> Eigenschaft auf dem zugeordneten <xref:System.Net.Security.SslStream>.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          "<paramref name="allowedImpersonationLevel" />" ist kein gültiger Wert.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Behandelt die Serverseite einer Authentifizierung für eine Client-/Serververbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden wird blockiert, während die Authentifizierung ausgeführt wird. Um die Anwendung blockiert, während des Wartens auf das Beenden der Authentifizierung zu verhindern, verwenden Sie die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess wird die angegebene erweiterte Schutzrichtlinie verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Serveridentität.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen und die angegebenen Authentifizierungsoptionen verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird bei einer Client-/Serververbindung von Servern zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen, Authentifizierungsoptionen und die erweiterte Schutzrichtlinie verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Diese Methode blockiert, bis der Vorgang abgeschlossen ist. Um zu verhindern, blockiert, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Behandelt die Serverseite für eine Authentifizierung einer Client-/Serververbindung als eines asynchronen Vorgang.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang. Für den Authentifizierungsprozess wird die angegebene erweiterte Schutzrichtlinie verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Serveridentität.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang. Beim Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen und die angegebenen Authentifizierungsoptionen verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <summary>Wird von Servern zur Authentifizierung des Clients und optional auch des Servers aufgerufen, bei einer Client-/Serververbindungen als asynchroner Vorgang. Für den Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen, Authentifizierungsoptionen und die erweiterte Schutzrichtlinie verwendet.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task" /> zurück.  
  
 Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können den Authentifizierungsversuch mithilfe dieses Objekt wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die Clientseite einer Client-/Serververbindung zu authentifizieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während der Authentifizierung ausgeführt wird. Zum Blockieren während des Wartens auf der Authentifizierung abzuschließen, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet der Clients <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, und die Sicherheitsstufe wird <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. Die <xref:System.Net.Security.NegotiateStream> -Klasse erstellen, wird den SPN für die gegenseitige Authentifizierung verwendet.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode um eine asynchrone Authentifizierung für den Client zu starten.  
  
 [!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
 [!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und die Channelbindung verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Anmeldeinformationen und Authentifizierungsoptionen verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="binding">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />.</param>
        <param name="targetName">Der SPN, der den zu authentifizierenden Server eindeutig identifiziert.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="allowedImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindung von Clients zum Starten eines asynchronen Vorgangs zum Authentifizieren des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Anmeldeinformationen, Authentifizierungsoptionen und die Channelbindung verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="targetName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Server verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Client zu wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet einen asynchronen Vorgang, um die serverseitige Authentifizierung einer Client-/Serververbindung durchzuführen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen dieser Methode werden nicht blockiert, während die Authentifizierung ausgeführt wird. Blockieren während des Wartens auf der Authentifizierung abzuschließen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess wird die angegebene erweiterte Schutzrichtlinie verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Authentifizierung verwendet des Serverzertifikat <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Keine Dienstprinzipalnamen (SPN) für den Server angegeben. Die Identitätswechselebene <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, wird die Sicherheitsstufe <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Beim Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen und die angegebenen Authentifizierungsoptionen verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Verwenden der expliziten <see cref="T:System.Net.NetworkCredential" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">Die <see cref="T:System.Net.NetworkCredential" /> zum Feststellen der Clientidentität.</param>
        <param name="policy">Das für erweiterten Schutz verwendete <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />.</param>
        <param name="requiredProtectionLevel">Einer der <see cref="T:System.Net.Security.ProtectionLevel" />-Werte, der die Sicherheitsdienste für den Stream angibt.</param>
        <param name="requiredImpersonationLevel">Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte, der angibt, wie der Server mit den Clientanmeldeinformationen auf Ressourcen zugreifen kann.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss der Authentifizierung aufgerufen werden soll.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Wird bei einer Client-/Serververbindungen von Servern zum Starten eines asynchronen Vorgangs zur Authentifizierung des Clients und optional auch des Servers aufgerufen. Für den Authentifizierungsprozess werden die angegebenen Serveranmeldeinformationen, Authentifizierungsoptionen und die erweiterte Schutzrichtlinie verwendet. Diese Methode wird nicht blockiert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `requiredProtectionLevel` Parameter Sicherheitsdienste für Daten, die mit den authentifizierten Stream übertragen. Um die Daten verschlüsselt und signiert haben, geben Sie z. B. die <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> Wert. Eine erfolgreiche Authentifizierung garantiert nicht, dass die angeforderte <xref:System.Net.Security.ProtectionLevel> erteilt wurde. Müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>.  
  
 Wenn die `policy` Parameter ist `null`, und klicken Sie dann eine erweiterte Schutzrichtlinie verwendet wird, wird <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Überladungen der Methode.  
  
 Der asynchrone Authentifizierungsvorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> und <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> für die erweiterte im <paramref name="policy" />-Parameter übergebene Schutzrichtlinie sind beide <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> muss <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> oder <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /> sein.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Die Authentifizierung ist bereits erfolgt.  
  
 \- oder –  
  
 Dieser Stream wurde zuvor für einen Authentifizierungsversuch als Client verwendet. Sie können den Stream nicht verwenden, um den Authentifizierungsversuch als Server zu wiederholen.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 und Windows 98 werden nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der <paramref name="policy" />-Parameter wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform festgelegt, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die Bytes empfängt, die aus dem Stream gelesen werden.</param>
        <param name="offset">Der nullbasierte Speicherort in <c>buffer</c>, ab dem die aus diesem Stream gelesenen Daten gespeichert werden.</param>
        <param name="count">Die maximale Anzahl an Bytes, die aus dem Stream gelesen werden sollen.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Lesevorgang beendet ist.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Lesevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Startet einen asynchronen Lesevorgang, der Daten aus dem Stream liest und im angegebenen Array speichert.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, wird der Lesevorgang liest die Daten aus den zugrunde liegenden Stream, überprüft die Integrität der Daten und wird vom Client entschlüsselt. Wenn keine Sicherheitsdienste, z. B. Verschlüsselung oder Signierung verwendet werden, wird diese Methode einen asynchronen Lesevorgang im zugrunde liegenden Stream gestartet.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndRead%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.NegotiateStream> Klasse mehrere gleichzeitige Lesevorgänge nicht unterstützt. Wenn Sie versuchen, einen Lesevorgang gestartet werden, während eine andere Vorgang bereits ausgeführt wird, für den gleichen Stream lesen eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Lesevorgang ab. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Net.Security.NegotiateStream> Klasse.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 \- oder –  
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 \- oder –  
  
 Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.  
  
 \- oder –  
  
 Die Verschlüsselung wird verwendet, die Daten konnten jedoch nicht entschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es wird bereits ein Lesevorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die Bytes bereitstellt, die in den Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Speicherort in <c>buffer</c>, ab dem das Lesen der in den Stream zu schreibenden Bytes beginnen soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" />-Wert, der die Anzahl der aus <c>buffer</c> zu lesenden Bytes angibt.</param>
        <param name="asyncCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die aufgerufen wird, wenn der Schreibvorgang beendet wurde.</param>
        <param name="asyncState">Ein benutzerdefiniertes Objekt, das Informationen zum Schreibvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <c>asyncCallback</c>-Delegaten übergeben.</param>
        <summary>Startet einen asynchronen Schreibvorgang, der <see cref="T:System.Byte" /> vom angegebenen Puffer in den Stream schreibt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, diese Methode liest die Daten aus dem Puffer, verschlüsselt, signiert oder verschlüsselt und signiert und überträgt ihn mit dem zugrunde liegenden Stream. Wenn keine Sicherheitsdienste, z. B. Verschlüsselung oder Signierung verwendet werden, wird diese Methode einen asynchronen Schreibvorgang auf den zugrunde liegenden Stream gestartet.  
  
 Diese Methode ist asynchron und wird nicht blockiert, während der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Der asynchrone Lesevorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Security.NegotiateStream.EndWrite%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren. Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Die <xref:System.Net.Security.NegotiateStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt. Wenn Sie versuchen, einen Schreibvorgang gestartet werden, während ein anderer Schreibvorgang für den gleichen Stream bereits ausgeführt wird eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen asynchronen Schreibvorgang ab.  
  
 [!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
 [!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
  
 Die folgende Methode wird aufgerufen, wenn der Vorgang abgeschlossen ist.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />  
  
 \- oder –  
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 \- oder –  
  
 Die Summe von <paramref name="offset" /> und count ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.  
  
 \- oder –  
  
 Die Verschlüsselung wird verwendet, die Daten konnten jedoch nicht verschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es wird bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der zugrunde liegende Stream gelesen werden kann.</summary>
        <value>
          <see langword="true" />, wenn die Authentifizierung erfolgt ist und der zugrunde liegende Stream lesbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Rückgabewert von Aufrufen der <xref:System.IO.Stream.CanRead%2A> Eigenschaft auf den zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der zugrunde liegende Stream durchsucht werden kann.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten nicht versuchen, die Position der Satz der <xref:System.Net.Security.NegotiateStream> Objekt oder die zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der zugrunde liegende Stream Timeouts unterstützt.</summary>
        <value>
          <see langword="true" />, wenn der zugrunde liegende Stream Timeouts unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.CanTimeout%2A> Eigenschaft auf den zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob im zugrunde liegenden Stream geschrieben werden kann.</summary>
        <value>
          <see langword="true" />, wenn die Authentifizierung erfolgt ist und im zugrunde liegende Stream geschrieben werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine erfolgreiche Authentifizierung aufgetreten ist, gibt diese Eigenschaft den Rückgabewert von Aufrufen der <xref:System.IO.Stream.CanWrite%2A> Eigenschaft auf den zugrunde liegenden Stream. Der zugrunde liegenden Stream wird angegeben, bei der Erstellung einer Instanz von der <xref:System.Net.Security.NegotiateStream> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Net.Security.NegotiateStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.Net.Security.NegotiateStream> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> zurückgegeben wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Clientauthentifizierungsvorgang, der mit einem Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist. Wenn die Authentifizierung erfolgreich ausgeführt wurde, müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Um diesen Vorgang synchron auszuführen, gehen die <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> erstellt.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Clientauthentifizierung vorhanden, die beendet werden muss.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> zurückgegeben wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Clientauthentifizierungsvorgang, der mit einem Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Bei erfolgreicher Authentifizierung müssen Sie überprüfen, die <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> und <xref:System.Net.Security.NegotiateStream.IsSigned%2A> Eigenschaften zu bestimmen, welche Sicherheitsdienste verwendet werden, durch die <xref:System.Net.Security.NegotiateStream>. Überprüfen Sie die <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Eigenschaft, um zu bestimmen, ob die gegenseitige Authentifizierung erfolgt ist.  
  
 Wenn die Authentifizierung ein Fehler auftritt, erhalten Sie eine <xref:System.Security.Authentication.AuthenticationException> oder ein <xref:System.Security.Authentication.InvalidCredentialException>. In diesem Fall können Sie die Authentifizierung mit anderen Anmeldeinformationen wiederholen.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> erstellt.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Fehler bei der Authentifizierung. Sie können die Authentifizierung mithilfe dieses Objekts wiederholen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine ausstehende Authentifizierung vorhanden, die beendet werden muss.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> zurückgegeben wird.</param>
        <summary>Beendet einen asynchronen Lesevorgang, der mit einem Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> gestartet wurde.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der die Anzahl von Bytes angibt, die aus dem zugrunde liegenden Stream gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.Read%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass das Beenden eines asynchronen Lesevorgang. Ein Beispiel für den Vorgang zu starten, finden Sie unter <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">asyncResult wurde nicht durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Eine <see cref="T:System.IAsyncResult" />-Instanz, die durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> zurückgegeben wird.</param>
        <summary>Beendet einen asynchronen Schreibvorgang, der mit einem Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> gestartet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.Write%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Methode, die aufgerufen wird, um den asynchronen Schreibvorgang abgeschlossen wird. Ein Beispiel für den Vorgang zu starten, finden Sie unter <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">asyncResult wurde nicht durch einen Aufruf von <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Veranlasst das Schreiben aller gepufferten Daten in das zugrunde liegende Gerät.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.IO.Stream.Flush%2A> auf den zugrunde liegenden Stream.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der Stream.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie der Server die Clientanmeldeinformationen verwenden kann.</summary>
        <value>Einer der <see cref="T:System.Security.Principal.TokenImpersonationLevel" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen eine erfolgreiche Authentifizierung vor dem Aufrufen dieser Methode. Clients geben die Identitätswechselebene beim Anrufen von einer der Authentifizierung anfordern der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Methoden. Wenn Sie eine ohne Angabe Authentifizierung einer <xref:System.Security.Principal.TokenImpersonationLevel> , <xref:System.Security.Principal.TokenImpersonationLevel.Identification> wird verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bei der Authentifizierung ist ein Fehler aufgetreten, oder es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die Authentifizierung erfolgreich war.</summary>
        <value>
          <see langword="true" />, wenn die Authentifizierung erfolgreich war, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Authentifizieren Sie Clients durch Aufrufen der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Methoden. Server-Authentifizierung durch Aufrufen der <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob dieser <see cref="T:System.Net.Security.NegotiateStream" /> verschlüsselte Daten verwendet.</summary>
        <value>
          <see langword="true" />, wenn Daten vor der Netzwerkübertragung verschlüsselt und am Remoteendpunkt entschlüsselt werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschlüsselung trägt zum Schutz von Daten auf des Datenschutzes; Es wird nämlich sichergestellt, dass während Daten während der Übertragung werden sie von Drittanbietern gelesen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob sowohl der Server als auch der Client authentifiziert wurden.</summary>
        <value>
          <see langword="true" />, wenn der Server authentifiziert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gegenseitiger Authentifizierung wird vom Client angegeben, wenn der Client den Server für die Anmeldeinformationen für die Authentifizierung wünscht. Standardmäßig fordern die Clients gegenseitigen Authentifizierung.  
  
 Das Aushandlungsprotokoll wählt NTLM oder Kerberos je nach der vom Client und Server unterstützten Sicherheitsprotokolle an. NTLM unterstützt keine gegenseitigen Authentifizierung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die lokale, von diesem <see cref="T:System.Net.Security.NegotiateStream" /> verwendete Seite der Verbindung als Server authentifiziert wurde.</summary>
        <value>
          <see langword="true" />, wenn der lokale Endpunkt erfolgreich als Serverseite der authentifizierten Verbindung authentifiziert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Authentifizierung fehlgeschlagen oder ist nicht erfolgt ist, gibt diese Eigenschaft `false`.  
  
 Rufen Sie zur Authentifizierung wie der Server die <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die mit diesem Stream gesendeten Daten signiert sind.</summary>
        <value>
          <see langword="true" />, wenn die Daten vor der Übertragung signiert werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Signieren von Daten schützt die Integrität der Daten; nämlich leichter den Empfänger zu bestimmen, ob die Daten bei der Übertragung manipuliert wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des zugrunde liegenden Streams ab.</summary>
        <value>Ein <see cref="T:System.Int64" />, der die Länge des zugrunde liegenden Streams angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.Length%2A> Eigenschaft auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, wird diese Eigenschaft in der Regel eine Ausnahme ausgelöst. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegende Stream ein <see cref="T:System.Net.Sockets.NetworkStream" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position im zugrunde liegenden Stream ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int64" />, der die aktuelle Position im zugrunde liegenden Stream angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.Position%2A> Eigenschaft auf den zugrunde liegenden Stream. Wenn der zugrunde liegenden Datenstrom nicht suchbar ist, wird diese Eigenschaft in der Regel eine Ausnahme ausgelöst. Der Laufzeittyp des zugrunde liegenden Streams bestimmt den Laufzeittyp der Ausnahme, die ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Festlegen dieser Eigenschaft wird nicht unterstützt.  
  
 \- oder –  
  
 Das Abrufen des Werts dieser Eigenschaft wird nicht unterstützt, wenn der zugrunde liegende Stream ein <see cref="T:System.Net.Sockets.NetworkStream" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die Bytes empfängt, die aus dem Stream gelesen werden.</param>
        <param name="offset">Ein <see cref="T:System.Int32" />, der den nullbasierten Speicherort in <c>buffer</c> enthält, ab dem die aus diesem Stream gelesenen Daten gespeichert werden.</param>
        <param name="count">Ein <see cref="T:System.Int32" />, der die maximale Anzahl der aus dem Stream gelesenen Bytes enthält.</param>
        <summary>Liest Daten aus diesem Stream und speichert sie im angegebenen Array.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der die Anzahl von Bytes angibt, die aus dem zugrunde liegenden Stream gelesen werden. Gibt 0 (null) zurück, wenn keine weiteren zu lesenden Daten vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode liest ein Maximum von `count` Bytes aus dem aktuellen stream und speichert sie in `buffer` beginnend `offset`.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Um diesen Vorgang asynchron auszuführen, verwenden Sie die <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Lesen aus einer <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Fehler beim Lesevorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
        <exception cref="T:System.NotSupportedException">Es wird gerade ein <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />-Vorgang ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Lesevorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, der die Zeitspanne angibt, nach deren Ablauf ein Lesevorgang fehlschlägt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.ReadTimeout%2A> Eigenschaft auf den zugrunde liegenden Stream. Beim Festlegen dieser Eigenschaft die <xref:System.IO.Stream.ReadTimeout%2A> Wert auf den zugrunde liegenden Stream mit dem angegebenen Wert festgelegt ist.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> , damit Lesevorgänge Vorgänge Timeoutgrenze nicht standardmäßig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen zur Identität der Remoteseite ab, für die dieser authentifizierte Stream freigegeben ist.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IIdentity" />-Objekt, das die Identität des Remoteendpunkts beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn vom Client zugegriffen wird, gibt diese Eigenschaft eine <xref:System.Security.Principal.GenericIdentity> , enthält der Name (SPN) des Servers und das Authentifizierungsprotokoll verwendet. Wenn durch den Server zugegriffen wird, gibt diese Eigenschaft eine <xref:System.Security.Principal.WindowsIdentity> , die den Client beschreibt. Wenn die <xref:System.Security.Principal.WindowsIdentity> ist nicht verfügbar ist, wird Clientinformationen zurückgegeben, mit dem Server in einem <xref:System.Security.Principal.GenericIdentity>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bei der Authentifizierung ist ein Fehler aufgetreten, oder es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Dieser Wert wird ignoriert.</param>
        <param name="origin">Dieser Wert wird ignoriert.</param>
        <summary>Löst <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht auf. Geerbt wird, aber wird nicht von <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Security.NegotiateStream" /> unterstützt keine Suchvorgänge.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Int64" />-Wert, der die Länge des Streams angibt.</param>
        <summary>Legt die Länge des zugrunde liegenden Streams fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein <see cref="T:System.Byte" />-Array, das die in den Stream geschriebenen Bytes bereitstellt.</param>
        <param name="offset">Ein <see cref="T:System.Int32" />, der den nullbasierten Speicherort in <c>buffer</c> enthält, ab dem das Lesen der in den Stream zu schreibenden Bytes beginnen soll.</param>
        <param name="count">Ein <see cref="T:System.Int32" />, der die Anzahl der aus <c>buffer</c> zu lesenden Bytes enthält.</param>
        <summary>Schreiben Sie die angegebene Anzahl von <see cref="T:System.Byte" /> mit dem angegebenen Puffer und dem angegebenen Offset in den zugrunde liegenden Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Verschlüsselung, Signierung oder Verschlüsselung und Signatur aktiviert sind, diese Methode liest die Daten aus dem Puffer, verschlüsselt, signiert oder verschlüsselt und signiert und überträgt ihn mit dem zugrunde liegenden Stream. Diese Methode wird aufgerufen, wenn keine Sicherheitsdienste, z. B. Verschlüsselung oder Signierung verwendet werden, <xref:System.IO.Stream.Write%2A> auf den zugrunde liegenden Stream.  
  
 Diese Methode blockiert, während der Schreibvorgang abgeschlossen wird. Um zu verhindern, blockiert, während der Vorgang abgeschlossen ist, verwenden die <xref:System.Net.Security.NegotiateStream.Write%2A> Methode.  
  
 Diese Methode kann nicht abgerufen werden, bis Sie erfolgreich authentifiziert wurden. Rufen Sie zur Authentifizierung eines der <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, oder <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Methoden.  
  
 Die <xref:System.Net.Security.NegotiateStream> Klasse mehrere gleichzeitige Schreibvorgänge nicht unterstützt. Wenn Sie versuchen, einen Schreibvorgang gestartet werden, während ein anderer Schreibvorgang für den gleichen Stream bereits ausgeführt wird eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Schreiben in eine <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />  
  
 \- oder –  
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 \- oder –  
  
 Die Summe von <paramref name="offset" /> und count ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Schreibvorgang.  
  
 \- oder –  
  
 Die Verschlüsselung wird verwendet, die Daten konnten jedoch nicht verschlüsselt werden.</exception>
        <exception cref="T:System.NotSupportedException">Es wird bereits ein Schreibvorgang ausgeführt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Authentifizierung erfolgt.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitspanne ab, in der ein Schreibvorgang während des Wartens auf Daten blockiert wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, der die Zeitspanne angibt, nach deren Ablauf ein Schreibvorgang fehlschlägt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Rückgabewert von Aufrufen der <xref:System.IO.Stream.WriteTimeout%2A> Eigenschaft auf den zugrunde liegenden Stream. Für Mengenoperationen, den angegebene Wert fest, der <xref:System.IO.Stream.WriteTimeout%2A> Wert auf den zugrunde liegenden Stream.  
  
 Wenn der zugrunde liegenden Stream ist ein <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> in Millisekunden und ist auf festgelegt <xref:System.Threading.Timeout.Infinite> so schreiben, der Vorgänge Timeoutgrenze nicht standardmäßig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Wert dieser Eigenschaft.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>