### <a name="change-in-behavior-for-taskwaitall-methods-with-time-out-arguments"></a><span data-ttu-id="e0a84-101">Änderung des Verhaltens für Task.WaitAll-Methoden mit Timeout-Argumenten</span><span class="sxs-lookup"><span data-stu-id="e0a84-101">Change in behavior for Task.WaitAll methods with time-out arguments</span></span>

|   |   |
|---|---|
|<span data-ttu-id="e0a84-102">Details</span><span class="sxs-lookup"><span data-stu-id="e0a84-102">Details</span></span>|<span data-ttu-id="e0a84-103">Das Task.WaitAll-Verhalten wurde in .NET 4.5 konsistenter gestaltet. In .NET Framework 4 haben diese Methoden sich unterschiedlich verhalten.</span><span class="sxs-lookup"><span data-stu-id="e0a84-103">Task.WaitAll behavior was made more consistent in .NET 4.5.In the .NET Framework 4, these methods behaved inconsistently.</span></span> <span data-ttu-id="e0a84-104">Wenn vor dem abgelaufenen Timeoutintervall eine oder mehrere Aufgaben vor dem Methodenaufruf abgeschlossen oder abgebrochen wurden, löste die Methode eine <xref:System.AggregateException?displayProperty=name>-Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e0a84-104">When the time-out expired, if one or more tasks were completed or canceled before the method call, the method threw an <xref:System.AggregateException?displayProperty=name> exception.</span></span> <span data-ttu-id="e0a84-105">Wenn vor dem abgelaufenen Timeoutintervall keine Aufgaben vor dem Methodenaufruf abgeschlossen oder abgebrochen wurden, aber eine oder mehrere Aufgaben nach dem Methodenaufruf in diesen Zustand eingetreten waren, gab die Methode „false“ zurück.</span><span class="sxs-lookup"><span data-stu-id="e0a84-105">When the time-out expired, if no tasks were completed or canceled before the method call, but one or more tasks entered these states after the method call, the method returned false.</span></span><br/><br/><span data-ttu-id="e0a84-106">In .NET Framework 4.5 geben diese Methodenüberladungen jetzt FALSE zurück, falls noch Aufgaben ausgeführt werden, wenn das Timeoutintervall abläuft, und sie lösen nur dann eine <xref:System.AggregateException?displayProperty=name>-Ausnahme aus, wenn eine Eingabeaufgabe abgebrochen wurde (unabhängig davon, ob dies vor oder nach dem Aufruf der Methode erfolgt ist) und keine anderen Aufgaben mehr ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e0a84-106">In the .NET Framework 4.5, these method overloads now return false if any tasks are still running when the time-out interval expired, and they throw an <xref:System.AggregateException?displayProperty=name> exception only if an input task was cancelled (regardless of whether it was before or after the method call) and no other tasks are still running.</span></span>|
|<span data-ttu-id="e0a84-107">Vorschlag</span><span class="sxs-lookup"><span data-stu-id="e0a84-107">Suggestion</span></span>|<span data-ttu-id="e0a84-108">Wenn eine <xref:System.AggregateException?displayProperty=name> als Mittel zum Erkennen einer Aufgabe abgefangen wurde, die vor dem WaitAll-Aufruf abgebrochen wurde, sollte dieser Code stattdessen dieselbe Erkennung über die IsCanceled-Eigenschaft durchführen (Beispiel: .Any(t =&gt; t.IsCanceled)), da .NET 4.6 nur in dem Fall eine Ausnahme auslöst, wenn alle erwarteten Aufgaben vor dem Timeout abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="e0a84-108">If an <xref:System.AggregateException?displayProperty=name> was being caught as a means of detecting a task that was cancelled prior to the WaitAll call being invoked, that code should instead do the same detection via the IsCanceled property (for example: .Any(t =&gt; t.IsCanceled)) since .NET 4.6 will only throw in that case if all awaited tasks are completed prior to the timeout.</span></span>|
|<span data-ttu-id="e0a84-109">Bereich</span><span class="sxs-lookup"><span data-stu-id="e0a84-109">Scope</span></span>|<span data-ttu-id="e0a84-110">Gering</span><span class="sxs-lookup"><span data-stu-id="e0a84-110">Minor</span></span>|
|<span data-ttu-id="e0a84-111">Version</span><span class="sxs-lookup"><span data-stu-id="e0a84-111">Version</span></span>|<span data-ttu-id="e0a84-112">4.5</span><span class="sxs-lookup"><span data-stu-id="e0a84-112">4.5</span></span>|
|<span data-ttu-id="e0a84-113">Typ</span><span class="sxs-lookup"><span data-stu-id="e0a84-113">Type</span></span>|<span data-ttu-id="e0a84-114">Laufzeit</span><span class="sxs-lookup"><span data-stu-id="e0a84-114">Runtime</span></span>|
|<span data-ttu-id="e0a84-115">Betroffene APIs</span><span class="sxs-lookup"><span data-stu-id="e0a84-115">Affected APIs</span></span>|<ul><li><xref:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)?displayProperty=nameWithType></li></ul>|

